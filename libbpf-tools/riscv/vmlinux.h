#ifndef __VMLINUX_H__
#define __VMLINUX_H__

#ifndef BPF_NO_PRESERVE_ACCESS_INDEX
#pragma clang attribute push (__attribute__((preserve_access_index)), apply_to = record)
#endif

typedef signed char __s8;

typedef unsigned char __u8;

typedef short unsigned int __u16;

typedef int __s32;

typedef unsigned int __u32;

typedef long long int __s64;

typedef long long unsigned int __u64;

typedef __s8 s8;

typedef __u8 u8;

typedef __u16 u16;

typedef __s32 s32;

typedef __u32 u32;

typedef __s64 s64;

typedef __u64 u64;

enum {
	false = 0,
	true = 1,
};

typedef long int __kernel_long_t;

typedef long unsigned int __kernel_ulong_t;

typedef int __kernel_pid_t;

typedef unsigned int __kernel_uid32_t;

typedef unsigned int __kernel_gid32_t;

typedef __kernel_ulong_t __kernel_size_t;

typedef __kernel_long_t __kernel_ssize_t;

typedef long long int __kernel_loff_t;

typedef long long int __kernel_time64_t;

typedef __kernel_long_t __kernel_clock_t;

typedef int __kernel_timer_t;

typedef int __kernel_clockid_t;

typedef __u32 __le32;

typedef unsigned int __poll_t;

typedef u32 __kernel_dev_t;

typedef __kernel_dev_t dev_t;

typedef short unsigned int umode_t;

typedef __kernel_pid_t pid_t;

typedef __kernel_clockid_t clockid_t;

typedef _Bool bool;

typedef __kernel_uid32_t uid_t;

typedef __kernel_gid32_t gid_t;

typedef __kernel_loff_t loff_t;

typedef __kernel_size_t size_t;

typedef __kernel_ssize_t ssize_t;

typedef s32 int32_t;

typedef u32 uint32_t;

typedef u64 sector_t;

typedef u64 blkcnt_t;

typedef unsigned int gfp_t;

typedef unsigned int fmode_t;

typedef u64 phys_addr_t;

typedef struct {
	int counter;
} atomic_t;

typedef struct {
	s64 counter;
} atomic64_t;

struct list_head {
	struct list_head *next;
	struct list_head *prev;
};

struct hlist_node;

struct hlist_head {
	struct hlist_node *first;
};

struct hlist_node {
	struct hlist_node *next;
	struct hlist_node **pprev;
};

struct callback_head {
	struct callback_head *next;
	void (*func)(struct callback_head *);
};

struct kernel_symbol {
	long unsigned int value;
	const char *name;
	const char *namespace;
};

struct __riscv_d_ext_state {
	__u64 f[32];
	__u32 fcsr;
};

struct __riscv_v_state {
	__int128 unsigned v[32];
	long unsigned int vstart;
	long unsigned int vxsat;
	long unsigned int vxrm;
	long unsigned int vl;
	long unsigned int vtype;
	long: 64;
};

struct pt_regs {
	long unsigned int epc;
	long unsigned int ra;
	long unsigned int sp;
	long unsigned int gp;
	long unsigned int tp;
	long unsigned int t0;
	long unsigned int t1;
	long unsigned int t2;
	long unsigned int s0;
	long unsigned int s1;
	long unsigned int a0;
	long unsigned int a1;
	long unsigned int a2;
	long unsigned int a3;
	long unsigned int a4;
	long unsigned int a5;
	long unsigned int a6;
	long unsigned int a7;
	long unsigned int s2;
	long unsigned int s3;
	long unsigned int s4;
	long unsigned int s5;
	long unsigned int s6;
	long unsigned int s7;
	long unsigned int s8;
	long unsigned int s9;
	long unsigned int s10;
	long unsigned int s11;
	long unsigned int t3;
	long unsigned int t4;
	long unsigned int t5;
	long unsigned int t6;
	long unsigned int status;
	long unsigned int badaddr;
	long unsigned int cause;
	long unsigned int orig_a0;
};

struct thread_struct {
	long unsigned int ra;
	long unsigned int sp;
	long unsigned int s[12];
	struct __riscv_d_ext_state fstate;
	long unsigned int bad_cause;
	struct __riscv_v_state vstate;
};

typedef int (*initcall_t)();

typedef initcall_t initcall_entry_t;

struct lock_class_key {};

struct fs_context;

struct fs_parameter_spec;

struct dentry;

struct super_block;

struct module;

struct file_system_type {
	const char *name;
	int fs_flags;
	int (*init_fs_context)(struct fs_context *);
	const struct fs_parameter_spec *parameters;
	struct dentry * (*mount)(struct file_system_type *, int, const char *, void *);
	void (*kill_sb)(struct super_block *);
	struct module *owner;
	struct file_system_type *next;
	struct hlist_head fs_supers;
	struct lock_class_key s_lock_key;
	struct lock_class_key s_umount_key;
	struct lock_class_key s_vfs_rename_key;
	struct lock_class_key s_writers_key[3];
	struct lock_class_key i_lock_key;
	struct lock_class_key i_mutex_key;
	struct lock_class_key i_mutex_dir_key;
};

struct obs_kernel_param {
	const char *str;
	int (*setup_func)(char *);
	int early;
};

typedef atomic_t arch_spinlock_t;

struct qrwlock {
	union {
		atomic_t cnts;
		struct {
			u8 wlocked;
			u8 __lstate[3];
		};
	};
	arch_spinlock_t wait_lock;
};

typedef struct qrwlock arch_rwlock_t;

struct lockdep_map {};

struct raw_spinlock {
	arch_spinlock_t raw_lock;
};

typedef struct raw_spinlock raw_spinlock_t;

struct spinlock {
	union {
		struct raw_spinlock rlock;
	};
};

typedef struct spinlock spinlock_t;

typedef struct {
	arch_rwlock_t raw_lock;
} rwlock_t;

struct ratelimit_state {
	raw_spinlock_t lock;
	int interval;
	int burst;
	int printed;
	int missed;
	long unsigned int begin;
	long unsigned int flags;
};

struct _ddebug {
	const char *modname;
	const char *function;
	const char *filename;
	const char *format;
	unsigned int lineno: 18;
	unsigned int flags: 8;
};

typedef void *fl_owner_t;

struct file;

struct kiocb;

struct iov_iter;

struct dir_context;

struct poll_table_struct;

struct vm_area_struct;

struct inode;

struct file_lock;

struct page;

struct pipe_inode_info;

struct seq_file;

struct file_operations {
	struct module *owner;
	loff_t (*llseek)(struct file *, loff_t, int);
	ssize_t (*read)(struct file *, char *, size_t, loff_t *);
	ssize_t (*write)(struct file *, const char *, size_t, loff_t *);
	ssize_t (*read_iter)(struct kiocb *, struct iov_iter *);
	ssize_t (*write_iter)(struct kiocb *, struct iov_iter *);
	int (*iopoll)(struct kiocb *, bool);
	int (*iterate)(struct file *, struct dir_context *);
	int (*iterate_shared)(struct file *, struct dir_context *);
	__poll_t (*poll)(struct file *, struct poll_table_struct *);
	long int (*unlocked_ioctl)(struct file *, unsigned int, long unsigned int);
	long int (*compat_ioctl)(struct file *, unsigned int, long unsigned int);
	int (*mmap)(struct file *, struct vm_area_struct *);
	long unsigned int mmap_supported_flags;
	int (*open)(struct inode *, struct file *);
	int (*flush)(struct file *, fl_owner_t);
	int (*release)(struct inode *, struct file *);
	int (*fsync)(struct file *, loff_t, loff_t, int);
	int (*fasync)(int, struct file *, int);
	int (*lock)(struct file *, int, struct file_lock *);
	ssize_t (*sendpage)(struct file *, struct page *, int, size_t, loff_t *, int);
	long unsigned int (*get_unmapped_area)(struct file *, long unsigned int, long unsigned int, long unsigned int, long unsigned int);
	int (*check_flags)(int);
	int (*flock)(struct file *, int, struct file_lock *);
	ssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t, unsigned int);
	ssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int);
	int (*setlease)(struct file *, long int, struct file_lock **, void **);
	long int (*fallocate)(struct file *, int, loff_t, loff_t);
	void (*show_fdinfo)(struct seq_file *, struct file *);
	ssize_t (*copy_file_range)(struct file *, loff_t, struct file *, loff_t, size_t, unsigned int);
	loff_t (*remap_file_range)(struct file *, loff_t, struct file *, loff_t, loff_t, unsigned int);
	int (*fadvise)(struct file *, loff_t, loff_t, int);
};

enum system_states {
	SYSTEM_BOOTING = 0,
	SYSTEM_SCHEDULING = 1,
	SYSTEM_RUNNING = 2,
	SYSTEM_HALT = 3,
	SYSTEM_POWER_OFF = 4,
	SYSTEM_RESTART = 5,
	SYSTEM_SUSPEND = 6,
};

typedef __s64 time64_t;

struct __kernel_timespec {
	__kernel_time64_t tv_sec;
	long long int tv_nsec;
};

struct timespec64 {
	time64_t tv_sec;
	long int tv_nsec;
};

typedef s32 old_time32_t;

struct old_timespec32 {
	old_time32_t tv_sec;
	s32 tv_nsec;
};

struct uid_gid_extent {
	u32 first;
	u32 lower_first;
	u32 count;
};

struct uid_gid_map {
	u32 nr_extents;
	union {
		struct uid_gid_extent extent[5];
		struct {
			struct uid_gid_extent *forward;
			struct uid_gid_extent *reverse;
		};
	};
};

typedef struct {
	uid_t val;
} kuid_t;

typedef struct {
	gid_t val;
} kgid_t;

typedef atomic64_t atomic_long_t;

struct proc_ns_operations;

struct ns_common {
	atomic_long_t stashed;
	const struct proc_ns_operations *ops;
	unsigned int inum;
};

struct optimistic_spin_queue {
	atomic_t tail;
};

struct rw_semaphore {
	atomic_long_t count;
	atomic_long_t owner;
	struct optimistic_spin_queue osq;
	raw_spinlock_t wait_lock;
	struct list_head wait_list;
};

struct work_struct;

typedef void (*work_func_t)(struct work_struct *);

struct work_struct {
	atomic_long_t data;
	struct list_head entry;
	work_func_t func;
};

struct ctl_table;

struct completion;

struct ctl_table_root;

struct ctl_table_set;

struct ctl_dir;

struct ctl_node;

struct ctl_table_header {
	union {
		struct {
			struct ctl_table *ctl_table;
			int used;
			int count;
			int nreg;
		};
		struct callback_head rcu;
	};
	struct completion *unregistering;
	struct ctl_table *ctl_table_arg;
	struct ctl_table_root *root;
	struct ctl_table_set *set;
	struct ctl_dir *parent;
	struct ctl_node *node;
	struct hlist_head inodes;
};

struct rb_node;

struct rb_root {
	struct rb_node *rb_node;
};

struct ctl_dir {
	struct ctl_table_header header;
	struct rb_root root;
};

struct ctl_table_set {
	int (*is_seen)(struct ctl_table_set *);
	struct ctl_dir dir;
};

struct key;

struct ucounts;

struct user_namespace {
	struct uid_gid_map uid_map;
	struct uid_gid_map gid_map;
	struct uid_gid_map projid_map;
	atomic_t count;
	struct user_namespace *parent;
	int level;
	kuid_t owner;
	kgid_t group;
	struct ns_common ns;
	long unsigned int flags;
	bool parent_could_setfcap;
	struct list_head keyring_name_list;
	struct key *user_keyring_register;
	struct rw_semaphore keyring_sem;
	struct work_struct work;
	struct ctl_table_set set;
	struct ctl_table_header *sysctls;
	struct ucounts *ucounts;
	int ucount_max[10];
};

struct kstat {
	u32 result_mask;
	umode_t mode;
	unsigned int nlink;
	uint32_t blksize;
	u64 attributes;
	u64 attributes_mask;
	u64 ino;
	dev_t dev;
	dev_t rdev;
	kuid_t uid;
	kgid_t gid;
	loff_t size;
	struct timespec64 atime;
	struct timespec64 mtime;
	struct timespec64 ctime;
	struct timespec64 btime;
	u64 blocks;
	u64 mnt_id;
};

enum timespec_type {
	TT_NONE = 0,
	TT_NATIVE = 1,
	TT_COMPAT = 2,
};

struct pollfd {
	int fd;
	short int events;
	short int revents;
};

struct restart_block {
	long int (*fn)(struct restart_block *);
	union {
		struct {
			u32 *uaddr;
			u32 val;
			u32 flags;
			u32 bitset;
			u64 time;
			u32 *uaddr2;
		} futex;
		struct {
			clockid_t clockid;
			enum timespec_type type;
			union {
				struct __kernel_timespec *rmtp;
				struct old_timespec32 *compat_rmtp;
			};
			u64 expires;
		} nanosleep;
		struct {
			struct pollfd *ufds;
			int nfds;
			int has_timeout;
			long unsigned int tv_sec;
			long unsigned int tv_nsec;
		} poll;
	};
};

struct thread_info {
	long unsigned int flags;
	int preempt_count;
	long int kernel_sp;
	long int user_sp;
	int cpu;
};

struct refcount_struct {
	atomic_t refs;
};

typedef struct refcount_struct refcount_t;

struct llist_node {
	struct llist_node *next;
};

struct __call_single_node {
	struct llist_node llist;
	union {
		unsigned int u_flags;
		atomic_t a_flags;
	};
	u16 src;
	u16 dst;
};

struct load_weight {
	long unsigned int weight;
	u32 inv_weight;
};

struct rb_node {
	long unsigned int __rb_parent_color;
	struct rb_node *rb_right;
	struct rb_node *rb_left;
};

struct sched_statistics {};

struct util_est {
	unsigned int enqueued;
	unsigned int ewma;
};

struct sched_avg {
	u64 last_update_time;
	u64 load_sum;
	u64 runnable_sum;
	u32 util_sum;
	u32 period_contrib;
	long unsigned int load_avg;
	long unsigned int runnable_avg;
	long unsigned int util_avg;
	struct util_est util_est;
};

struct sched_entity {
	struct load_weight load;
	struct rb_node run_node;
	struct list_head group_node;
	unsigned int on_rq;
	u64 exec_start;
	u64 sum_exec_runtime;
	u64 vruntime;
	u64 prev_sum_exec_runtime;
	u64 nr_migrations;
	struct sched_statistics statistics;
	long: 64;
	long: 64;
	long: 64;
	struct sched_avg avg;
};

struct sched_rt_entity {
	struct list_head run_list;
	long unsigned int timeout;
	long unsigned int watchdog_stamp;
	unsigned int time_slice;
	short unsigned int on_rq;
	short unsigned int on_list;
	struct sched_rt_entity *back;
};

typedef s64 ktime_t;

struct timerqueue_node {
	struct rb_node node;
	ktime_t expires;
};

enum hrtimer_restart {
	HRTIMER_NORESTART = 0,
	HRTIMER_RESTART = 1,
};

struct hrtimer_clock_base;

struct hrtimer {
	struct timerqueue_node node;
	ktime_t _softexpires;
	enum hrtimer_restart (*function)(struct hrtimer *);
	struct hrtimer_clock_base *base;
	u8 state;
	u8 is_rel;
	u8 is_soft;
	u8 is_hard;
};

struct sched_dl_entity {
	struct rb_node rb_node;
	u64 dl_runtime;
	u64 dl_deadline;
	u64 dl_period;
	u64 dl_bw;
	u64 dl_density;
	s64 runtime;
	u64 deadline;
	unsigned int flags;
	unsigned int dl_throttled: 1;
	unsigned int dl_yielded: 1;
	unsigned int dl_non_contending: 1;
	unsigned int dl_overrun: 1;
	struct hrtimer dl_timer;
	struct hrtimer inactive_timer;
	struct sched_dl_entity *pi_se;
};

struct cpumask {
	long unsigned int bits[1];
};

typedef struct cpumask cpumask_t;

union rcu_special {
	struct {
		u8 blocked;
		u8 need_qs;
		u8 exp_hint;
		u8 need_mb;
	} b;
	u32 s;
};

struct sched_info {};

struct plist_node {
	int prio;
	struct list_head prio_list;
	struct list_head node_list;
};

struct vmacache {
	u64 seqnum;
	struct vm_area_struct *vmas[4];
};

struct task_rss_stat {
	int events;
	int count[4];
};

struct prev_cputime {
	u64 utime;
	u64 stime;
	raw_spinlock_t lock;
};

struct rb_root_cached {
	struct rb_root rb_root;
	struct rb_node *rb_leftmost;
};

struct timerqueue_head {
	struct rb_root_cached rb_root;
};

struct posix_cputimer_base {
	u64 nextevt;
	struct timerqueue_head tqhead;
};

struct posix_cputimers {
	struct posix_cputimer_base bases[3];
	unsigned int timers_active;
	unsigned int expiry_active;
};

struct sem_undo_list;

struct sysv_sem {
	struct sem_undo_list *undo_list;
};

struct sysv_shm {
	struct list_head shm_clist;
};

typedef struct {
	long unsigned int sig[1];
} sigset_t;

struct sigpending {
	struct list_head list;
	sigset_t signal;
};

struct seccomp_filter;

struct seccomp {
	int mode;
	atomic_t filter_count;
	struct seccomp_filter *filter;
};

struct wake_q_node {
	struct wake_q_node *next;
};

struct task_io_accounting {};

struct mutex {
	atomic_long_t owner;
	spinlock_t wait_lock;
	struct optimistic_spin_queue osq;
	struct list_head wait_list;
};

struct tlbflush_unmap_batch {};

struct page_frag {
	struct page *page;
	__u32 offset;
	__u32 size;
};

struct sched_class;

struct rcu_node;

struct mm_struct;

struct pid;

struct cred;

struct nameidata;

struct fs_struct;

struct files_struct;

struct io_uring_task;

struct nsproxy;

struct signal_struct;

struct sighand_struct;

struct rt_mutex_waiter;

struct bio_list;

struct blk_plug;

struct reclaim_state;

struct backing_dev_info;

struct io_context;

struct capture_control;

struct kernel_siginfo;

typedef struct kernel_siginfo kernel_siginfo_t;

struct css_set;

struct robust_list_head;

struct futex_pi_state;

struct perf_event_context;

struct ftrace_ret_stack;

struct uprobe_task;

struct task_struct {
	struct thread_info thread_info;
	volatile long int state;
	void *stack;
	refcount_t usage;
	unsigned int flags;
	unsigned int ptrace;
	int on_cpu;
	struct __call_single_node wake_entry;
	unsigned int cpu;
	unsigned int wakee_flips;
	long unsigned int wakee_flip_decay_ts;
	struct task_struct *last_wakee;
	int recent_used_cpu;
	int wake_cpu;
	int on_rq;
	int prio;
	int static_prio;
	int normal_prio;
	unsigned int rt_priority;
	const struct sched_class *sched_class;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct sched_entity se;
	struct sched_rt_entity rt;
	struct sched_dl_entity dl;
	struct list_head percpu_kthread_node;
	struct hlist_head preempt_notifiers;
	unsigned int policy;
	int nr_cpus_allowed;
	const cpumask_t *cpus_ptr;
	cpumask_t cpus_mask;
	int rcu_read_lock_nesting;
	union rcu_special rcu_read_unlock_special;
	struct list_head rcu_node_entry;
	struct rcu_node *rcu_blocked_node;
	long unsigned int rcu_tasks_nvcsw;
	u8 rcu_tasks_holdout;
	u8 rcu_tasks_idx;
	int rcu_tasks_idle_cpu;
	struct list_head rcu_tasks_holdout_list;
	int trc_reader_nesting;
	int trc_ipi_to_cpu;
	union rcu_special trc_reader_special;
	bool trc_reader_checked;
	struct list_head trc_holdout_list;
	struct sched_info sched_info;
	struct list_head tasks;
	struct plist_node pushable_tasks;
	struct rb_node pushable_dl_tasks;
	struct mm_struct *mm;
	struct mm_struct *active_mm;
	struct vmacache vmacache;
	struct task_rss_stat rss_stat;
	int exit_state;
	int exit_code;
	int exit_signal;
	int pdeath_signal;
	long unsigned int jobctl;
	unsigned int personality;
	unsigned int sched_reset_on_fork: 1;
	unsigned int sched_contributes_to_load: 1;
	unsigned int sched_migrated: 1;
	int: 29;
	unsigned int sched_remote_wakeup: 1;
	unsigned int in_execve: 1;
	unsigned int in_iowait: 1;
	unsigned int brk_randomized: 1;
	unsigned int no_cgroup_migration: 1;
	unsigned int frozen: 1;
	long unsigned int atomic_flags;
	struct restart_block restart_block;
	pid_t pid;
	pid_t tgid;
	long unsigned int stack_canary;
	struct task_struct *real_parent;
	struct task_struct *parent;
	struct list_head children;
	struct list_head sibling;
	struct task_struct *group_leader;
	struct list_head ptraced;
	struct list_head ptrace_entry;
	struct pid *thread_pid;
	struct hlist_node pid_links[4];
	struct list_head thread_group;
	struct list_head thread_node;
	struct completion *vfork_done;
	int *set_child_tid;
	int *clear_child_tid;
	u64 utime;
	u64 stime;
	u64 gtime;
	struct prev_cputime prev_cputime;
	long unsigned int nvcsw;
	long unsigned int nivcsw;
	u64 start_time;
	u64 start_boottime;
	long unsigned int min_flt;
	long unsigned int maj_flt;
	struct posix_cputimers posix_cputimers;
	const struct cred *ptracer_cred;
	const struct cred *real_cred;
	const struct cred *cred;
	struct key *cached_requested_key;
	char comm[16];
	struct nameidata *nameidata;
	struct sysv_sem sysvsem;
	struct sysv_shm sysvshm;
	long unsigned int last_switch_count;
	long unsigned int last_switch_time;
	struct fs_struct *fs;
	struct files_struct *files;
	struct io_uring_task *io_uring;
	struct nsproxy *nsproxy;
	struct signal_struct *signal;
	struct sighand_struct *sighand;
	sigset_t blocked;
	sigset_t real_blocked;
	sigset_t saved_sigmask;
	struct sigpending pending;
	long unsigned int sas_ss_sp;
	size_t sas_ss_size;
	unsigned int sas_ss_flags;
	struct callback_head *task_works;
	struct seccomp seccomp;
	u64 parent_exec_id;
	u64 self_exec_id;
	spinlock_t alloc_lock;
	raw_spinlock_t pi_lock;
	struct wake_q_node wake_q;
	int wake_q_count;
	struct rb_root_cached pi_waiters;
	struct task_struct *pi_top_task;
	struct rt_mutex_waiter *pi_blocked_on;
	int non_block_count;
	void *journal_info;
	struct bio_list *bio_list;
	struct blk_plug *plug;
	struct reclaim_state *reclaim_state;
	struct backing_dev_info *backing_dev_info;
	struct io_context *io_context;
	struct capture_control *capture_control;
	long unsigned int ptrace_message;
	kernel_siginfo_t *last_siginfo;
	struct task_io_accounting ioac;
	struct css_set *cgroups;
	struct list_head cg_list;
	struct robust_list_head *robust_list;
	struct list_head pi_state_list;
	struct futex_pi_state *pi_state_cache;
	struct mutex futex_exit_mutex;
	unsigned int futex_state;
	struct perf_event_context *perf_event_ctxp[2];
	struct mutex perf_event_mutex;
	struct list_head perf_event_list;
	long unsigned int preempt_disable_ip;
	struct tlbflush_unmap_batch tlb_ubc;
	union {
		refcount_t rcu_users;
		struct callback_head rcu;
	};
	struct pipe_inode_info *splice_pipe;
	struct page_frag task_frag;
	int nr_dirtied;
	int nr_dirtied_pause;
	long unsigned int dirty_paused_when;
	u64 timer_slack_ns;
	u64 default_timer_slack_ns;
	int curr_ret_stack;
	int curr_ret_depth;
	struct ftrace_ret_stack *ret_stack;
	long long unsigned int ftrace_timestamp;
	atomic_t trace_overrun;
	atomic_t tracing_graph_pause;
	long unsigned int trace;
	long unsigned int trace_recursion;
	struct uprobe_task *utask;
	long unsigned int task_state_change;
	int pagefault_disabled;
	struct task_struct *oom_reaper_list;
	refcount_t stack_refcount;
	long: 32;
	long: 64;
	struct thread_struct thread;
};

typedef struct {
	long unsigned int pgd;
} pgd_t;

typedef struct {
	long unsigned int pte;
} pte_t;

typedef struct {
	long unsigned int pgprot;
} pgprot_t;

typedef struct page *pgtable_t;

struct address_space;

struct kmem_cache;

struct dev_pagemap;

struct page {
	long unsigned int flags;
	union {
		struct {
			struct list_head lru;
			struct address_space *mapping;
			long unsigned int index;
			long unsigned int private;
		};
		struct {
			long unsigned int dma_addr[2];
		};
		struct {
			union {
				struct list_head slab_list;
				struct {
					struct page *next;
					int pages;
					int pobjects;
				};
			};
			struct kmem_cache *slab_cache;
			void *freelist;
			union {
				void *s_mem;
				long unsigned int counters;
				struct {
					unsigned int inuse: 16;
					unsigned int objects: 15;
					unsigned int frozen: 1;
				};
			};
		};
		struct {
			long unsigned int compound_head;
			unsigned char compound_dtor;
			unsigned char compound_order;
			atomic_t compound_mapcount;
			unsigned int compound_nr;
		};
		struct {
			long unsigned int _compound_pad_1;
			atomic_t hpage_pinned_refcount;
			struct list_head deferred_list;
		};
		struct {
			long unsigned int _pt_pad_1;
			pgtable_t pmd_huge_pte;
			long unsigned int _pt_pad_2;
			union {
				struct mm_struct *pt_mm;
				atomic_t pt_frag_refcount;
			};
			spinlock_t ptl;
		};
		struct {
			struct dev_pagemap *pgmap;
			void *zone_device_data;
		};
		struct callback_head callback_head;
	};
	union {
		atomic_t _mapcount;
		unsigned int page_type;
		unsigned int active;
		int units;
	};
	atomic_t _refcount;
};

typedef struct cpumask cpumask_var_t[1];

typedef void (*smp_call_func_t)(void *);

struct __call_single_data {
	union {
		struct __call_single_node node;
		struct {
			struct llist_node llist;
			unsigned int flags;
			u16 src;
			u16 dst;
		};
	};
	smp_call_func_t func;
	void *info;
};

struct wait_queue_entry;

typedef int (*wait_queue_func_t)(struct wait_queue_entry *, unsigned int, int, void *);

struct wait_queue_entry {
	unsigned int flags;
	void *private;
	wait_queue_func_t func;
	struct list_head entry;
};

typedef struct wait_queue_entry wait_queue_entry_t;

struct wait_queue_head {
	spinlock_t lock;
	struct list_head head;
};

typedef struct wait_queue_head wait_queue_head_t;

struct seqcount {
	unsigned int sequence;
};

typedef struct seqcount seqcount_t;

struct seqcount_raw_spinlock {
	seqcount_t seqcount;
};

typedef struct seqcount_raw_spinlock seqcount_raw_spinlock_t;

struct seqcount_spinlock {
	seqcount_t seqcount;
};

typedef struct seqcount_spinlock seqcount_spinlock_t;

typedef struct {
	seqcount_spinlock_t seqcount;
	spinlock_t lock;
} seqlock_t;

typedef struct {
	long unsigned int bits[1];
} nodemask_t;

enum node_states {
	N_POSSIBLE = 0,
	N_ONLINE = 1,
	N_NORMAL_MEMORY = 2,
	N_HIGH_MEMORY = 2,
	N_MEMORY = 3,
	N_CPU = 4,
	N_GENERIC_INITIATOR = 5,
	NR_NODE_STATES = 6,
};

struct vm_userfaultfd_ctx {};

struct anon_vma;

struct vm_operations_struct;

struct vm_area_struct {
	long unsigned int vm_start;
	long unsigned int vm_end;
	struct vm_area_struct *vm_next;
	struct vm_area_struct *vm_prev;
	struct rb_node vm_rb;
	long unsigned int rb_subtree_gap;
	struct mm_struct *vm_mm;
	pgprot_t vm_page_prot;
	long unsigned int vm_flags;
	union {
		struct {
			struct rb_node rb;
			long unsigned int rb_subtree_last;
		} shared;
		const char *anon_name;
	};
	struct list_head anon_vma_chain;
	struct anon_vma *anon_vma;
	const struct vm_operations_struct *vm_ops;
	long unsigned int vm_pgoff;
	struct file *vm_file;
	void *vm_private_data;
	atomic_long_t swap_readahead_info;
	struct vm_userfaultfd_ctx vm_userfaultfd_ctx;
};

struct mm_rss_stat {
	atomic_long_t count[4];
};

struct swait_queue_head {
	raw_spinlock_t lock;
	struct list_head task_list;
};

struct completion {
	unsigned int done;
	struct swait_queue_head wait;
};

typedef struct {
	void *vdso;
	atomic64_t asid;
	void *vdso_info;
	cpumask_t icache_stale_mask;
} mm_context_t;

struct xol_area;

struct uprobes_state {
	struct xol_area *xol_area;
};

struct linux_binfmt;

struct core_state;

struct kioctx_table;

struct mmu_notifier_subscriptions;

struct mm_struct {
	struct {
		struct vm_area_struct *mmap;
		struct rb_root mm_rb;
		u64 vmacache_seqnum;
		long unsigned int (*get_unmapped_area)(struct file *, long unsigned int, long unsigned int, long unsigned int, long unsigned int);
		long unsigned int mmap_base;
		long unsigned int mmap_legacy_base;
		long unsigned int task_size;
		long unsigned int highest_vm_end;
		pgd_t *pgd;
		atomic_t membarrier_state;
		atomic_t mm_users;
		atomic_t mm_count;
		atomic_t has_pinned;
		atomic_long_t pgtables_bytes;
		int map_count;
		spinlock_t page_table_lock;
		struct rw_semaphore mmap_lock;
		struct list_head mmlist;
		long unsigned int hiwater_rss;
		long unsigned int hiwater_vm;
		long unsigned int total_vm;
		long unsigned int locked_vm;
		atomic64_t pinned_vm;
		long unsigned int data_vm;
		long unsigned int exec_vm;
		long unsigned int stack_vm;
		long unsigned int def_flags;
		seqcount_t write_protect_seq;
		spinlock_t arg_lock;
		long unsigned int start_code;
		long unsigned int end_code;
		long unsigned int start_data;
		long unsigned int end_data;
		long unsigned int start_brk;
		long unsigned int brk;
		long unsigned int start_stack;
		long unsigned int arg_start;
		long unsigned int arg_end;
		long unsigned int env_start;
		long unsigned int env_end;
		long unsigned int saved_auxv[56];
		struct mm_rss_stat rss_stat;
		struct linux_binfmt *binfmt;
		mm_context_t context;
		long unsigned int flags;
		struct core_state *core_state;
		spinlock_t ioctx_lock;
		struct kioctx_table *ioctx_table;
		struct user_namespace *user_ns;
		struct file *exe_file;
		struct mmu_notifier_subscriptions *notifier_subscriptions;
		atomic_t tlb_flush_pending;
		struct uprobes_state uprobes_state;
		atomic_long_t hugetlb_usage;
		struct work_struct async_put_work;
		u32 pasid;
	};
	long unsigned int cpu_bitmap[0];
};

struct arch_uprobe_task {
	long unsigned int saved_cause;
};

enum uprobe_task_state {
	UTASK_RUNNING = 0,
	UTASK_SSTEP = 1,
	UTASK_SSTEP_ACK = 2,
	UTASK_SSTEP_TRAPPED = 3,
};

struct uprobe;

struct return_instance;

struct uprobe_task {
	enum uprobe_task_state state;
	union {
		struct {
			struct arch_uprobe_task autask;
			long unsigned int vaddr;
		};
		struct {
			struct callback_head dup_xol_work;
			long unsigned int dup_xol_addr;
		};
	};
	struct uprobe *active_uprobe;
	long unsigned int xol_vaddr;
	struct return_instance *return_instances;
	unsigned int depth;
};

struct return_instance {
	struct uprobe *uprobe;
	long unsigned int func;
	long unsigned int stack;
	long unsigned int orig_ret_vaddr;
	bool chained;
	struct return_instance *next;
};

struct timer_list {
	struct hlist_node entry;
	long unsigned int expires;
	void (*function)(struct timer_list *);
	u32 flags;
};

struct workqueue_struct;

struct delayed_work {
	struct work_struct work;
	struct timer_list timer;
	struct workqueue_struct *wq;
	int cpu;
};

struct rcu_work {
	struct work_struct work;
	struct callback_head rcu;
	struct workqueue_struct *wq;
};

struct xarray {
	spinlock_t xa_lock;
	gfp_t xa_flags;
	void *xa_head;
};

typedef u32 errseq_t;

struct address_space_operations;

struct address_space {
	struct inode *host;
	struct xarray i_pages;
	gfp_t gfp_mask;
	atomic_t i_mmap_writable;
	struct rb_root_cached i_mmap;
	struct rw_semaphore i_mmap_rwsem;
	long unsigned int nrpages;
	long unsigned int nrexceptional;
	long unsigned int writeback_index;
	const struct address_space_operations *a_ops;
	long unsigned int flags;
	errseq_t wb_err;
	spinlock_t private_lock;
	struct list_head private_list;
	void *private_data;
};

struct vmem_altmap {
	const long unsigned int base_pfn;
	const long unsigned int end_pfn;
	const long unsigned int reserve;
	long unsigned int free;
	long unsigned int align;
	long unsigned int alloc;
};

struct percpu_ref_data;

struct percpu_ref {
	long unsigned int percpu_count_ptr;
	struct percpu_ref_data *data;
};

enum memory_type {
	MEMORY_DEVICE_PRIVATE = 1,
	MEMORY_DEVICE_FS_DAX = 2,
	MEMORY_DEVICE_GENERIC = 3,
	MEMORY_DEVICE_PCI_P2PDMA = 4,
};

struct range {
	u64 start;
	u64 end;
};

struct dev_pagemap_ops;

struct dev_pagemap {
	struct vmem_altmap altmap;
	struct percpu_ref *ref;
	struct percpu_ref internal_ref;
	struct completion done;
	enum memory_type type;
	unsigned int flags;
	const struct dev_pagemap_ops *ops;
	void *owner;
	int nr_range;
	union {
		struct range range;
		struct range ranges[0];
	};
};

struct vfsmount;

struct path {
	struct vfsmount *mnt;
	struct dentry *dentry;
};

enum rw_hint {
	WRITE_LIFE_NOT_SET = 0,
	WRITE_LIFE_NONE = 1,
	WRITE_LIFE_SHORT = 2,
	WRITE_LIFE_MEDIUM = 3,
	WRITE_LIFE_LONG = 4,
	WRITE_LIFE_EXTREME = 5,
};

enum pid_type {
	PIDTYPE_PID = 0,
	PIDTYPE_TGID = 1,
	PIDTYPE_PGID = 2,
	PIDTYPE_SID = 3,
	PIDTYPE_MAX = 4,
};

struct fown_struct {
	rwlock_t lock;
	struct pid *pid;
	enum pid_type pid_type;
	kuid_t uid;
	kuid_t euid;
	int signum;
};

struct file_ra_state {
	long unsigned int start;
	unsigned int size;
	unsigned int async_size;
	unsigned int ra_pages;
	unsigned int mmap_miss;
	loff_t prev_pos;
};

struct file {
	union {
		struct llist_node fu_llist;
		struct callback_head fu_rcuhead;
	} f_u;
	struct path f_path;
	struct inode *f_inode;
	const struct file_operations *f_op;
	spinlock_t f_lock;
	enum rw_hint f_write_hint;
	atomic_long_t f_count;
	unsigned int f_flags;
	fmode_t f_mode;
	struct mutex f_pos_lock;
	loff_t f_pos;
	struct fown_struct f_owner;
	const struct cred *f_cred;
	struct file_ra_state f_ra;
	u64 f_version;
	void *private_data;
	struct list_head f_ep_links;
	struct list_head f_tfile_llink;
	struct address_space *f_mapping;
	errseq_t f_wb_err;
	errseq_t f_sb_err;
};

struct anon_vma {
	struct anon_vma *root;
	struct rw_semaphore rwsem;
	atomic_t refcount;
	unsigned int degree;
	struct anon_vma *parent;
	struct rb_root_cached rb_root;
};

typedef unsigned int vm_fault_t;

enum page_entry_size {
	PE_SIZE_PTE = 0,
	PE_SIZE_PMD = 1,
	PE_SIZE_PUD = 2,
};

struct vm_fault;

struct vm_operations_struct {
	void (*open)(struct vm_area_struct *);
	void (*close)(struct vm_area_struct *);
	int (*split)(struct vm_area_struct *, long unsigned int);
	int (*mremap)(struct vm_area_struct *);
	vm_fault_t (*fault)(struct vm_fault *);
	vm_fault_t (*huge_fault)(struct vm_fault *, enum page_entry_size);
	vm_fault_t (*map_pages)(struct vm_fault *, long unsigned int, long unsigned int);
	long unsigned int (*pagesize)(struct vm_area_struct *);
	vm_fault_t (*page_mkwrite)(struct vm_fault *);
	vm_fault_t (*pfn_mkwrite)(struct vm_fault *);
	int (*access)(struct vm_area_struct *, long unsigned int, void *, int, int);
	const char * (*name)(struct vm_area_struct *);
	struct page * (*find_special_page)(struct vm_area_struct *, long unsigned int);
};

struct core_thread {
	struct task_struct *task;
	struct core_thread *next;
};

struct core_state {
	atomic_t nr_threads;
	struct core_thread dumper;
	struct completion startup;
};

struct linux_binprm;

struct coredump_params;

struct linux_binfmt {
	struct list_head lh;
	struct module *module;
	int (*load_binary)(struct linux_binprm *);
	int (*load_shlib)(struct file *);
	int (*core_dump)(struct coredump_params *);
	long unsigned int min_coredump;
};

typedef struct {
	long unsigned int pmd;
} pmd_t;

typedef struct {
	pgd_t pgd;
} p4d_t;

typedef struct {
	p4d_t p4d;
} pud_t;

struct vm_fault {
	const struct {
		struct vm_area_struct *vma;
		gfp_t gfp_mask;
		long unsigned int pgoff;
		long unsigned int address;
	};
	unsigned int flags;
	pmd_t *pmd;
	pud_t *pud;
	pte_t orig_pte;
	struct page *cow_page;
	struct page *page;
	pte_t *pte;
	spinlock_t *ptl;
	pgtable_t prealloc_pte;
	long unsigned int vma_flags;
	pgprot_t vma_page_prot;
};

enum node_stat_item {
	NR_LRU_BASE = 0,
	NR_INACTIVE_ANON = 0,
	NR_ACTIVE_ANON = 1,
	NR_INACTIVE_FILE = 2,
	NR_ACTIVE_FILE = 3,
	NR_UNEVICTABLE = 4,
	NR_SLAB_RECLAIMABLE_B = 5,
	NR_SLAB_UNRECLAIMABLE_B = 6,
	NR_ISOLATED_ANON = 7,
	NR_ISOLATED_FILE = 8,
	WORKINGSET_NODES = 9,
	WORKINGSET_REFAULT_BASE = 10,
	WORKINGSET_REFAULT_ANON = 10,
	WORKINGSET_REFAULT_FILE = 11,
	WORKINGSET_ACTIVATE_BASE = 12,
	WORKINGSET_ACTIVATE_ANON = 12,
	WORKINGSET_ACTIVATE_FILE = 13,
	WORKINGSET_RESTORE_BASE = 14,
	WORKINGSET_RESTORE_ANON = 14,
	WORKINGSET_RESTORE_FILE = 15,
	WORKINGSET_NODERECLAIM = 16,
	NR_ANON_MAPPED = 17,
	NR_FILE_MAPPED = 18,
	NR_FILE_PAGES = 19,
	NR_FILE_DIRTY = 20,
	NR_WRITEBACK = 21,
	NR_WRITEBACK_TEMP = 22,
	NR_SHMEM = 23,
	NR_SHMEM_THPS = 24,
	NR_SHMEM_PMDMAPPED = 25,
	NR_FILE_THPS = 26,
	NR_FILE_PMDMAPPED = 27,
	NR_ANON_THPS = 28,
	NR_VMSCAN_WRITE = 29,
	NR_VMSCAN_IMMEDIATE = 30,
	NR_DIRTIED = 31,
	NR_WRITTEN = 32,
	NR_KERNEL_MISC_RECLAIMABLE = 33,
	NR_FOLL_PIN_ACQUIRED = 34,
	NR_FOLL_PIN_RELEASED = 35,
	NR_KERNEL_STACK_KB = 36,
	NR_VM_NODE_STAT_ITEMS = 37,
};

typedef unsigned int isolate_mode_t;

struct rcu_segcblist {
	struct callback_head *head;
	struct callback_head **tails[4];
	long unsigned int gp_seq[4];
	long int len;
	u8 enabled;
	u8 offloaded;
};

struct srcu_node;

struct srcu_struct;

struct srcu_data {
	long unsigned int srcu_lock_count[2];
	long unsigned int srcu_unlock_count[2];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	spinlock_t lock;
	struct rcu_segcblist srcu_cblist;
	long unsigned int srcu_gp_seq_needed;
	long unsigned int srcu_gp_seq_needed_exp;
	bool srcu_cblist_invoking;
	struct timer_list delay_work;
	struct work_struct work;
	struct callback_head srcu_barrier_head;
	struct srcu_node *mynode;
	long unsigned int grpmask;
	int cpu;
	struct srcu_struct *ssp;
	long: 64;
	long: 64;
};

struct srcu_node {
	spinlock_t lock;
	long unsigned int srcu_have_cbs[4];
	long unsigned int srcu_data_have_cbs[4];
	long unsigned int srcu_gp_seq_needed_exp;
	struct srcu_node *srcu_parent;
	int grplo;
	int grphi;
};

struct srcu_struct {
	struct srcu_node node[1];
	struct srcu_node *level[2];
	struct mutex srcu_cb_mutex;
	spinlock_t lock;
	struct mutex srcu_gp_mutex;
	unsigned int srcu_idx;
	long unsigned int srcu_gp_seq;
	long unsigned int srcu_gp_seq_needed;
	long unsigned int srcu_gp_seq_needed_exp;
	long unsigned int srcu_last_gp_end;
	struct srcu_data *sda;
	long unsigned int srcu_barrier_seq;
	struct mutex srcu_barrier_mutex;
	struct completion srcu_barrier_completion;
	atomic_t srcu_barrier_cpu_cnt;
	struct delayed_work work;
};

typedef int proc_handler(struct ctl_table *, int, void *, size_t *, loff_t *);

struct ctl_table_poll;

struct ctl_table {
	const char *procname;
	void *data;
	int maxlen;
	umode_t mode;
	struct ctl_table *child;
	proc_handler *proc_handler;
	struct ctl_table_poll *poll;
	void *extra1;
	void *extra2;
};

struct ctl_table_poll {
	atomic_t event;
	wait_queue_head_t wait;
};

struct ctl_node {
	struct rb_node node;
	struct ctl_table_header *header;
};

struct ctl_table_root {
	struct ctl_table_set default_set;
	struct ctl_table_set * (*lookup)(struct ctl_table_root *);
	void (*set_ownership)(struct ctl_table_header *, struct ctl_table *, kuid_t *, kgid_t *);
	int (*permissions)(struct ctl_table_header *, struct ctl_table *);
};

struct kernel_cap_struct {
	__u32 cap[2];
};

typedef struct kernel_cap_struct kernel_cap_t;

struct user_struct;

struct group_info;

struct cred {
	atomic_t usage;
	kuid_t uid;
	kgid_t gid;
	kuid_t suid;
	kgid_t sgid;
	kuid_t euid;
	kgid_t egid;
	kuid_t fsuid;
	kgid_t fsgid;
	unsigned int securebits;
	kernel_cap_t cap_inheritable;
	kernel_cap_t cap_permitted;
	kernel_cap_t cap_effective;
	kernel_cap_t cap_bset;
	kernel_cap_t cap_ambient;
	unsigned char jit_keyring;
	struct key *session_keyring;
	struct key *process_keyring;
	struct key *thread_keyring;
	struct key *request_key_auth;
	struct user_struct *user;
	struct user_namespace *user_ns;
	struct group_info *group_info;
	union {
		int non_rcu;
		struct callback_head rcu;
	};
};

enum umh_disable_depth {
	UMH_ENABLED = 0,
	UMH_FREEZING = 1,
	UMH_DISABLED = 2,
};

typedef __u64 Elf64_Addr;

typedef __u16 Elf64_Half;

typedef __u64 Elf64_Off;

typedef __u32 Elf64_Word;

typedef __u64 Elf64_Xword;

struct elf64_sym {
	Elf64_Word st_name;
	unsigned char st_info;
	unsigned char st_other;
	Elf64_Half st_shndx;
	Elf64_Addr st_value;
	Elf64_Xword st_size;
};

typedef struct elf64_sym Elf64_Sym;

struct elf64_shdr {
	Elf64_Word sh_name;
	Elf64_Word sh_type;
	Elf64_Xword sh_flags;
	Elf64_Addr sh_addr;
	Elf64_Off sh_offset;
	Elf64_Xword sh_size;
	Elf64_Word sh_link;
	Elf64_Word sh_info;
	Elf64_Xword sh_addralign;
	Elf64_Xword sh_entsize;
};

typedef struct elf64_shdr Elf64_Shdr;

enum refcount_saturation_type {
	REFCOUNT_ADD_NOT_ZERO_OVF = 0,
	REFCOUNT_ADD_OVF = 1,
	REFCOUNT_ADD_UAF = 2,
	REFCOUNT_SUB_UAF = 3,
	REFCOUNT_DEC_LEAK = 4,
};

struct iovec {
	void *iov_base;
	__kernel_size_t iov_len;
};

struct kvec {
	void *iov_base;
	size_t iov_len;
};

struct bio_vec {
	struct page *bv_page;
	unsigned int bv_len;
	unsigned int bv_offset;
};

struct iov_iter {
	unsigned int type;
	size_t iov_offset;
	size_t count;
	union {
		const struct iovec *iov;
		const struct kvec *kvec;
		const struct bio_vec *bvec;
		struct pipe_inode_info *pipe;
	};
	union {
		long unsigned int nr_segs;
		struct {
			unsigned int head;
			unsigned int start_head;
		};
	};
};

struct wait_page_queue;

struct kiocb {
	struct file *ki_filp;
	loff_t ki_pos;
	void (*ki_complete)(struct kiocb *, long int, long int);
	void *private;
	int ki_flags;
	u16 ki_hint;
	u16 ki_ioprio;
	union {
		unsigned int ki_cookie;
		struct wait_page_queue *ki_waitq;
	};
};

struct hlist_bl_node;

struct hlist_bl_head {
	struct hlist_bl_node *first;
};

struct hlist_bl_node {
	struct hlist_bl_node *next;
	struct hlist_bl_node **pprev;
};

struct lockref {
	union {
		struct {
			spinlock_t lock;
			int count;
		};
	};
};

struct qstr {
	union {
		struct {
			u32 hash;
			u32 len;
		};
		u64 hash_len;
	};
	const unsigned char *name;
};

struct dentry_operations;

struct dentry {
	unsigned int d_flags;
	seqcount_spinlock_t d_seq;
	struct hlist_bl_node d_hash;
	struct dentry *d_parent;
	struct qstr d_name;
	struct inode *d_inode;
	unsigned char d_iname[32];
	struct lockref d_lockref;
	const struct dentry_operations *d_op;
	struct super_block *d_sb;
	long unsigned int d_time;
	void *d_fsdata;
	union {
		struct list_head d_lru;
		wait_queue_head_t *d_wait;
	};
	struct list_head d_child;
	struct list_head d_subdirs;
	union {
		struct hlist_node d_alias;
		struct hlist_bl_node d_in_lookup_hash;
		struct callback_head d_rcu;
	} d_u;
};

struct posix_acl;

struct inode_operations;

struct file_lock_context;

struct block_device;

struct cdev;

struct fsnotify_mark_connector;

struct inode {
	umode_t i_mode;
	short unsigned int i_opflags;
	kuid_t i_uid;
	kgid_t i_gid;
	unsigned int i_flags;
	struct posix_acl *i_acl;
	struct posix_acl *i_default_acl;
	const struct inode_operations *i_op;
	struct super_block *i_sb;
	struct address_space *i_mapping;
	long unsigned int i_ino;
	union {
		const unsigned int i_nlink;
		unsigned int __i_nlink;
	};
	dev_t i_rdev;
	loff_t i_size;
	struct timespec64 i_atime;
	struct timespec64 i_mtime;
	struct timespec64 i_ctime;
	spinlock_t i_lock;
	short unsigned int i_bytes;
	u8 i_blkbits;
	u8 i_write_hint;
	blkcnt_t i_blocks;
	long unsigned int i_state;
	struct rw_semaphore i_rwsem;
	long unsigned int dirtied_when;
	long unsigned int dirtied_time_when;
	struct hlist_node i_hash;
	struct list_head i_io_list;
	struct list_head i_lru;
	struct list_head i_sb_list;
	struct list_head i_wb_list;
	union {
		struct hlist_head i_dentry;
		struct callback_head i_rcu;
	};
	atomic64_t i_version;
	atomic64_t i_sequence;
	atomic_t i_count;
	atomic_t i_dio_count;
	atomic_t i_writecount;
	atomic_t i_readcount;
	union {
		const struct file_operations *i_fop;
		void (*free_inode)(struct inode *);
	};
	struct file_lock_context *i_flctx;
	struct address_space i_data;
	struct list_head i_devices;
	union {
		struct pipe_inode_info *i_pipe;
		struct block_device *i_bdev;
		struct cdev *i_cdev;
		char *i_link;
		unsigned int i_dir_seq;
	};
	__u32 i_generation;
	__u32 i_fsnotify_mask;
	struct fsnotify_mark_connector *i_fsnotify_marks;
	void *i_private;
};

struct dentry_operations {
	int (*d_revalidate)(struct dentry *, unsigned int);
	int (*d_weak_revalidate)(struct dentry *, unsigned int);
	int (*d_hash)(const struct dentry *, struct qstr *);
	int (*d_compare)(const struct dentry *, unsigned int, const char *, const struct qstr *);
	int (*d_delete)(const struct dentry *);
	int (*d_init)(struct dentry *);
	void (*d_release)(struct dentry *);
	void (*d_prune)(struct dentry *);
	void (*d_iput)(struct dentry *, struct inode *);
	char * (*d_dname)(struct dentry *, char *, int);
	struct vfsmount * (*d_automount)(struct path *);
	int (*d_manage)(const struct path *, bool);
	struct dentry * (*d_real)(struct dentry *, const struct inode *);
	void (*d_canonical_path)(const struct path *, struct path *);
	long: 64;
	long: 64;
};

typedef long long int qsize_t;

struct quota_format_type;

struct mem_dqinfo {
	struct quota_format_type *dqi_format;
	int dqi_fmt_id;
	struct list_head dqi_dirty_list;
	long unsigned int dqi_flags;
	unsigned int dqi_bgrace;
	unsigned int dqi_igrace;
	qsize_t dqi_max_spc_limit;
	qsize_t dqi_max_ino_limit;
	void *dqi_priv;
};

struct quota_format_ops;

struct quota_info {
	unsigned int flags;
	struct rw_semaphore dqio_sem;
	struct inode *files[3];
	struct mem_dqinfo info[3];
	const struct quota_format_ops *ops[3];
};

struct rcu_sync {
	int gp_state;
	int gp_count;
	wait_queue_head_t gp_wait;
	struct callback_head cb_head;
};

struct rcuwait {
	struct task_struct *task;
};

struct percpu_rw_semaphore {
	struct rcu_sync rss;
	unsigned int *read_count;
	struct rcuwait writer;
	wait_queue_head_t waiters;
	atomic_t block;
};

struct sb_writers {
	int frozen;
	wait_queue_head_t wait_unfrozen;
	struct percpu_rw_semaphore rw_sem[3];
};

typedef struct {
	__u8 b[16];
} uuid_t;

struct shrink_control;

struct shrinker {
	long unsigned int (*count_objects)(struct shrinker *, struct shrink_control *);
	long unsigned int (*scan_objects)(struct shrinker *, struct shrink_control *);
	long int batch;
	int seeks;
	unsigned int flags;
	struct list_head list;
	atomic_long_t *nr_deferred;
};

struct list_lru_node;

struct list_lru {
	struct list_lru_node *node;
};

struct super_operations;

struct dquot_operations;

struct quotactl_ops;

struct export_operations;

struct xattr_handler;

struct mtd_info;

struct super_block {
	struct list_head s_list;
	dev_t s_dev;
	unsigned char s_blocksize_bits;
	long unsigned int s_blocksize;
	loff_t s_maxbytes;
	struct file_system_type *s_type;
	const struct super_operations *s_op;
	const struct dquot_operations *dq_op;
	const struct quotactl_ops *s_qcop;
	const struct export_operations *s_export_op;
	long unsigned int s_flags;
	long unsigned int s_iflags;
	long unsigned int s_magic;
	struct dentry *s_root;
	struct rw_semaphore s_umount;
	int s_count;
	atomic_t s_active;
	const struct xattr_handler **s_xattr;
	struct hlist_bl_head s_roots;
	struct list_head s_mounts;
	struct block_device *s_bdev;
	struct backing_dev_info *s_bdi;
	struct mtd_info *s_mtd;
	struct hlist_node s_instances;
	unsigned int s_quota_types;
	struct quota_info s_dquot;
	struct sb_writers s_writers;
	void *s_fs_info;
	u32 s_time_gran;
	time64_t s_time_min;
	time64_t s_time_max;
	__u32 s_fsnotify_mask;
	struct fsnotify_mark_connector *s_fsnotify_marks;
	char s_id[32];
	uuid_t s_uuid;
	unsigned int s_max_links;
	fmode_t s_mode;
	struct mutex s_vfs_rename_mutex;
	const char *s_subtype;
	const struct dentry_operations *s_d_op;
	int cleancache_poolid;
	struct shrinker s_shrink;
	atomic_long_t s_remove_count;
	atomic_long_t s_fsnotify_inode_refs;
	int s_readonly_remount;
	errseq_t s_wb_err;
	struct workqueue_struct *s_dio_done_wq;
	struct hlist_head s_pins;
	struct user_namespace *s_user_ns;
	struct list_lru s_dentry_lru;
	struct list_lru s_inode_lru;
	struct callback_head rcu;
	struct work_struct destroy_work;
	struct mutex s_sync_lock;
	int s_stack_depth;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	spinlock_t s_inode_list_lock;
	struct list_head s_inodes;
	spinlock_t s_inode_wblist_lock;
	struct list_head s_inodes_wb;
	long: 64;
	long: 64;
};

struct mem_cgroup;

struct shrink_control {
	gfp_t gfp_mask;
	int nid;
	long unsigned int nr_to_scan;
	long unsigned int nr_scanned;
	struct mem_cgroup *memcg;
};

struct list_lru_one {
	struct list_head list;
	long int nr_items;
};

struct list_lru_node {
	spinlock_t lock;
	struct list_lru_one lru;
	long int nr_items;
	long: 64;
	long: 64;
	long: 64;
};

struct pid_namespace;

struct upid {
	int nr;
	struct pid_namespace *ns;
};

struct kref {
	refcount_t refcount;
};

struct idr {
	struct xarray idr_rt;
	unsigned int idr_base;
	unsigned int idr_next;
};

struct pid_namespace {
	struct kref kref;
	struct idr idr;
	struct callback_head rcu;
	unsigned int pid_allocated;
	struct task_struct *child_reaper;
	struct kmem_cache *pid_cachep;
	unsigned int level;
	struct pid_namespace *parent;
	struct user_namespace *user_ns;
	struct ucounts *ucounts;
	int reboot;
	struct ns_common ns;
};

struct pid {
	refcount_t count;
	unsigned int level;
	spinlock_t lock;
	struct hlist_head tasks[4];
	struct hlist_head inodes;
	wait_queue_head_t wait_pidfd;
	struct callback_head rcu;
	struct upid numbers[1];
};

enum migrate_mode {
	MIGRATE_ASYNC = 0,
	MIGRATE_SYNC_LIGHT = 1,
	MIGRATE_SYNC = 2,
	MIGRATE_SYNC_NO_COPY = 3,
};

typedef void __signalfn_t(int);

typedef __signalfn_t *__sighandler_t;

union sigval {
	int sival_int;
	void *sival_ptr;
};

typedef union sigval sigval_t;

union __sifields {
	struct {
		__kernel_pid_t _pid;
		__kernel_uid32_t _uid;
	} _kill;
	struct {
		__kernel_timer_t _tid;
		int _overrun;
		sigval_t _sigval;
		int _sys_private;
	} _timer;
	struct {
		__kernel_pid_t _pid;
		__kernel_uid32_t _uid;
		sigval_t _sigval;
	} _rt;
	struct {
		__kernel_pid_t _pid;
		__kernel_uid32_t _uid;
		int _status;
		__kernel_clock_t _utime;
		__kernel_clock_t _stime;
	} _sigchld;
	struct {
		void *_addr;
		union {
			short int _addr_lsb;
			struct {
				char _dummy_bnd[8];
				void *_lower;
				void *_upper;
			} _addr_bnd;
			struct {
				char _dummy_pkey[8];
				__u32 _pkey;
			} _addr_pkey;
		};
	} _sigfault;
	struct {
		long int _band;
		int _fd;
	} _sigpoll;
	struct {
		void *_call_addr;
		int _syscall;
		unsigned int _arch;
	} _sigsys;
};

struct kernel_siginfo {
	struct {
		int si_signo;
		int si_errno;
		int si_code;
		union __sifields _sifields;
	};
};

struct user_struct {
	refcount_t __count;
	atomic_t processes;
	atomic_t sigpending;
	atomic_long_t epoll_watches;
	long unsigned int mq_bytes;
	long unsigned int locked_shm;
	long unsigned int unix_inflight;
	atomic_long_t pipe_bufs;
	struct hlist_node uidhash_node;
	kuid_t uid;
	atomic_long_t locked_vm;
	struct ratelimit_state ratelimit;
};

struct sigaction {
	__sighandler_t sa_handler;
	long unsigned int sa_flags;
	sigset_t sa_mask;
};

struct k_sigaction {
	struct sigaction sa;
};

struct hrtimer_cpu_base;

struct hrtimer_clock_base {
	struct hrtimer_cpu_base *cpu_base;
	unsigned int index;
	clockid_t clockid;
	seqcount_raw_spinlock_t seq;
	struct hrtimer *running;
	struct timerqueue_head active;
	ktime_t (*get_time)();
	ktime_t offset;
};

struct hrtimer_cpu_base {
	raw_spinlock_t lock;
	unsigned int cpu;
	unsigned int active_bases;
	unsigned int clock_was_set_seq;
	unsigned int hres_active: 1;
	unsigned int in_hrtirq: 1;
	unsigned int hang_detected: 1;
	unsigned int softirq_activated: 1;
	unsigned int nr_events;
	short unsigned int nr_retries;
	short unsigned int nr_hangs;
	unsigned int max_hang_time;
	ktime_t expires_next;
	struct hrtimer *next_timer;
	ktime_t softirq_expires_next;
	struct hrtimer *softirq_next_timer;
	struct hrtimer_clock_base clock_base[8];
};

struct rlimit {
	__kernel_ulong_t rlim_cur;
	__kernel_ulong_t rlim_max;
};

struct task_cputime {
	u64 stime;
	u64 utime;
	long long unsigned int sum_exec_runtime;
};

struct cpu_itimer {
	u64 expires;
	u64 incr;
};

struct task_cputime_atomic {
	atomic64_t utime;
	atomic64_t stime;
	atomic64_t sum_exec_runtime;
};

struct thread_group_cputimer {
	struct task_cputime_atomic cputime_atomic;
};

struct tty_struct;

struct signal_struct {
	refcount_t sigcnt;
	atomic_t live;
	int nr_threads;
	struct list_head thread_head;
	wait_queue_head_t wait_chldexit;
	struct task_struct *curr_target;
	struct sigpending shared_pending;
	struct hlist_head multiprocess;
	int group_exit_code;
	int notify_count;
	struct task_struct *group_exit_task;
	int group_stop_count;
	unsigned int flags;
	unsigned int is_child_subreaper: 1;
	unsigned int has_child_subreaper: 1;
	int posix_timer_id;
	struct list_head posix_timers;
	struct hrtimer real_timer;
	ktime_t it_real_incr;
	struct cpu_itimer it[2];
	struct thread_group_cputimer cputimer;
	struct posix_cputimers posix_cputimers;
	struct pid *pids[4];
	struct pid *tty_old_pgrp;
	int leader;
	struct tty_struct *tty;
	seqlock_t stats_lock;
	u64 utime;
	u64 stime;
	u64 cutime;
	u64 cstime;
	u64 gtime;
	u64 cgtime;
	struct prev_cputime prev_cputime;
	long unsigned int nvcsw;
	long unsigned int nivcsw;
	long unsigned int cnvcsw;
	long unsigned int cnivcsw;
	long unsigned int min_flt;
	long unsigned int maj_flt;
	long unsigned int cmin_flt;
	long unsigned int cmaj_flt;
	long unsigned int inblock;
	long unsigned int oublock;
	long unsigned int cinblock;
	long unsigned int coublock;
	long unsigned int maxrss;
	long unsigned int cmaxrss;
	struct task_io_accounting ioac;
	long long unsigned int sum_sched_runtime;
	struct rlimit rlim[16];
	bool oom_flag_origin;
	short int oom_score_adj;
	short int oom_score_adj_min;
	struct mm_struct *oom_mm;
	struct mutex cred_guard_mutex;
	struct rw_semaphore exec_update_lock;
};

struct rq;

struct rq_flags;

struct sched_class {
	void (*enqueue_task)(struct rq *, struct task_struct *, int);
	void (*dequeue_task)(struct rq *, struct task_struct *, int);
	void (*yield_task)(struct rq *);
	bool (*yield_to_task)(struct rq *, struct task_struct *);
	void (*check_preempt_curr)(struct rq *, struct task_struct *, int);
	struct task_struct * (*pick_next_task)(struct rq *);
	void (*put_prev_task)(struct rq *, struct task_struct *);
	void (*set_next_task)(struct rq *, struct task_struct *, bool);
	int (*balance)(struct rq *, struct task_struct *, struct rq_flags *);
	int (*select_task_rq)(struct task_struct *, int, int, int);
	void (*migrate_task_rq)(struct task_struct *, int);
	void (*task_woken)(struct rq *, struct task_struct *);
	void (*set_cpus_allowed)(struct task_struct *, const struct cpumask *);
	void (*rq_online)(struct rq *);
	void (*rq_offline)(struct rq *);
	void (*task_tick)(struct rq *, struct task_struct *, int);
	void (*task_fork)(struct task_struct *);
	void (*task_dead)(struct task_struct *);
	void (*switched_from)(struct rq *, struct task_struct *);
	void (*switched_to)(struct rq *, struct task_struct *);
	void (*prio_changed)(struct rq *, struct task_struct *, int);
	unsigned int (*get_rr_interval)(struct rq *, struct task_struct *);
	void (*update_curr)(struct rq *);
	long: 64;
};

typedef int32_t key_serial_t;

typedef uint32_t key_perm_t;

struct key_type;

struct key_tag;

struct keyring_index_key {
	long unsigned int hash;
	union {
		struct {
			u16 desc_len;
			char desc[6];
		};
		long unsigned int x;
	};
	struct key_type *type;
	struct key_tag *domain_tag;
	const char *description;
};

union key_payload {
	void *rcu_data0;
	void *data[4];
};

struct assoc_array_ptr;

struct assoc_array {
	struct assoc_array_ptr *root;
	long unsigned int nr_leaves_on_tree;
};

struct key_user;

struct key_restriction;

struct key {
	refcount_t usage;
	key_serial_t serial;
	union {
		struct list_head graveyard_link;
		struct rb_node serial_node;
	};
	struct rw_semaphore sem;
	struct key_user *user;
	void *security;
	union {
		time64_t expiry;
		time64_t revoked_at;
	};
	time64_t last_used_at;
	kuid_t uid;
	kgid_t gid;
	key_perm_t perm;
	short unsigned int quotalen;
	short unsigned int datalen;
	short int state;
	long unsigned int flags;
	union {
		struct keyring_index_key index_key;
		struct {
			long unsigned int hash;
			long unsigned int len_desc;
			struct key_type *type;
			struct key_tag *domain_tag;
			char *description;
		};
	};
	union {
		union key_payload payload;
		struct {
			struct list_head name_link;
			struct assoc_array keys;
		};
	};
	struct key_restriction *restrict_link;
};

struct uts_namespace;

struct ipc_namespace;

struct mnt_namespace;

struct net;

struct time_namespace;

struct cgroup_namespace;

struct nsproxy {
	atomic_t count;
	struct uts_namespace *uts_ns;
	struct ipc_namespace *ipc_ns;
	struct mnt_namespace *mnt_ns;
	struct pid_namespace *pid_ns_for_children;
	struct net *net_ns;
	struct time_namespace *time_ns;
	struct time_namespace *time_ns_for_children;
	struct cgroup_namespace *cgroup_ns;
};

struct sighand_struct {
	spinlock_t siglock;
	refcount_t count;
	wait_queue_head_t signalfd_wqh;
	struct k_sigaction action[64];
};

struct bio;

struct bio_list {
	struct bio *head;
	struct bio *tail;
};

struct blk_plug {
	struct list_head mq_list;
	struct list_head cb_list;
	short unsigned int rq_count;
	bool multiple_queues;
	bool nowait;
};

struct reclaim_state {
	long unsigned int reclaimed_slab;
};

struct percpu_counter {
	raw_spinlock_t lock;
	s64 count;
	struct list_head list;
	s32 *counters;
};

struct fprop_local_percpu {
	struct percpu_counter events;
	unsigned int period;
	raw_spinlock_t lock;
};

enum wb_reason {
	WB_REASON_BACKGROUND = 0,
	WB_REASON_VMSCAN = 1,
	WB_REASON_SYNC = 2,
	WB_REASON_PERIODIC = 3,
	WB_REASON_LAPTOP_TIMER = 4,
	WB_REASON_FS_FREE_SPACE = 5,
	WB_REASON_FORKER_THREAD = 6,
	WB_REASON_FOREIGN_FLUSH = 7,
	WB_REASON_MAX = 8,
};

struct bdi_writeback {
	struct backing_dev_info *bdi;
	long unsigned int state;
	long unsigned int last_old_flush;
	struct list_head b_dirty;
	struct list_head b_io;
	struct list_head b_more_io;
	struct list_head b_dirty_time;
	spinlock_t list_lock;
	struct percpu_counter stat[4];
	long unsigned int congested;
	long unsigned int bw_time_stamp;
	long unsigned int dirtied_stamp;
	long unsigned int written_stamp;
	long unsigned int write_bandwidth;
	long unsigned int avg_write_bandwidth;
	long unsigned int dirty_ratelimit;
	long unsigned int balanced_dirty_ratelimit;
	struct fprop_local_percpu completions;
	int dirty_exceeded;
	enum wb_reason start_all_reason;
	spinlock_t work_lock;
	struct list_head work_list;
	struct delayed_work dwork;
	long unsigned int dirty_sleep;
	struct list_head bdi_node;
};

struct device;

struct backing_dev_info {
	u64 id;
	struct rb_node rb_node;
	struct list_head bdi_list;
	long unsigned int ra_pages;
	long unsigned int io_pages;
	struct kref refcnt;
	unsigned int capabilities;
	unsigned int min_ratio;
	unsigned int max_ratio;
	unsigned int max_prop_frac;
	atomic_long_t tot_write_bandwidth;
	struct bdi_writeback wb;
	struct list_head wb_list;
	wait_queue_head_t wb_waitq;
	struct device *dev;
	char dev_name[64];
	struct device *owner;
	struct timer_list laptop_mode_wb_timer;
	struct dentry *debug_dir;
};

struct io_cq;

struct io_context {
	atomic_long_t refcount;
	atomic_t active_ref;
	atomic_t nr_tasks;
	spinlock_t lock;
	short unsigned int ioprio;
	struct xarray icq_tree;
	struct io_cq *icq_hint;
	struct hlist_head icq_list;
	struct work_struct release_work;
};

struct cgroup_subsys_state;

struct cgroup;

struct css_set {
	struct cgroup_subsys_state *subsys[0];
	refcount_t refcount;
	struct css_set *dom_cset;
	struct cgroup *dfl_cgrp;
	int nr_tasks;
	struct list_head tasks;
	struct list_head mg_tasks;
	struct list_head dying_tasks;
	struct list_head task_iters;
	struct list_head e_cset_node[0];
	struct list_head threaded_csets;
	struct list_head threaded_csets_node;
	struct hlist_node hlist;
	struct list_head cgrp_links;
	struct list_head mg_preload_node;
	struct list_head mg_node;
	struct cgroup *mg_src_cgrp;
	struct cgroup *mg_dst_cgrp;
	struct css_set *mg_dst_cset;
	bool dead;
	struct callback_head callback_head;
};

struct perf_event_groups {
	struct rb_root tree;
	u64 index;
};

struct pmu;

struct perf_event_context {
	struct pmu *pmu;
	raw_spinlock_t lock;
	struct mutex mutex;
	struct list_head active_ctx_list;
	struct perf_event_groups pinned_groups;
	struct perf_event_groups flexible_groups;
	struct list_head event_list;
	struct list_head pinned_active;
	struct list_head flexible_active;
	int nr_events;
	int nr_active;
	int is_active;
	int nr_stat;
	int nr_freq;
	int rotate_disable;
	int rotate_necessary;
	refcount_t refcount;
	struct task_struct *task;
	u64 time;
	u64 timestamp;
	struct perf_event_context *parent_ctx;
	u64 parent_gen;
	u64 generation;
	int pin_count;
	void *task_ctx_data;
	struct callback_head callback_head;
};

struct ftrace_ret_stack {
	long unsigned int ret;
	long unsigned int func;
	long long unsigned int calltime;
	long unsigned int fp;
	long unsigned int *retp;
};

struct exception_table_entry {
	long unsigned int insn;
	long unsigned int fixup;
};

struct cgroup_subsys;

struct cgroup_subsys_state {
	struct cgroup *cgroup;
	struct cgroup_subsys *ss;
	struct percpu_ref refcnt;
	struct list_head sibling;
	struct list_head children;
	struct list_head rstat_css_node;
	int id;
	unsigned int flags;
	u64 serial_nr;
	atomic_t online_cnt;
	struct work_struct destroy_work;
	struct rcu_work destroy_rwork;
	struct cgroup_subsys_state *parent;
};

struct kernfs_node;

struct cgroup_file {
	struct kernfs_node *kn;
	long unsigned int notified_at;
	struct timer_list notify_timer;
};

struct cgroup_base_stat {
	struct task_cputime cputime;
};

struct psi_group {};

struct cgroup_bpf {};

struct cgroup_freezer_state {
	bool freeze;
	int e_freeze;
	int nr_frozen_descendants;
	int nr_frozen_tasks;
};

struct cgroup_root;

struct cgroup_rstat_cpu;

struct cgroup {
	struct cgroup_subsys_state self;
	long unsigned int flags;
	int level;
	int max_depth;
	int nr_descendants;
	int nr_dying_descendants;
	int max_descendants;
	int nr_populated_csets;
	int nr_populated_domain_children;
	int nr_populated_threaded_children;
	int nr_threaded_children;
	struct kernfs_node *kn;
	struct cgroup_file procs_file;
	struct cgroup_file events_file;
	u16 subtree_control;
	u16 subtree_ss_mask;
	u16 old_subtree_control;
	u16 old_subtree_ss_mask;
	struct cgroup_subsys_state *subsys[0];
	struct cgroup_root *root;
	struct list_head cset_links;
	struct list_head e_csets[0];
	struct cgroup *dom_cgrp;
	struct cgroup *old_dom_cgrp;
	struct cgroup_rstat_cpu *rstat_cpu;
	struct list_head rstat_css_list;
	struct cgroup_base_stat last_bstat;
	struct cgroup_base_stat bstat;
	struct prev_cputime prev_cputime;
	struct list_head pidlists;
	struct mutex pidlist_mutex;
	wait_queue_head_t offline_waitq;
	struct work_struct release_agent_work;
	struct psi_group psi;
	struct cgroup_bpf bpf;
	atomic_t congestion_count;
	struct cgroup_freezer_state freezer;
	u64 ancestor_ids[0];
};

struct key_tag {
	struct callback_head rcu;
	refcount_t usage;
	bool removed;
};

typedef int (*request_key_actor_t)(struct key *, void *);

struct key_preparsed_payload;

struct key_match_data;

struct kernel_pkey_params;

struct kernel_pkey_query;

struct key_type {
	const char *name;
	size_t def_datalen;
	unsigned int flags;
	int (*vet_description)(const char *);
	int (*preparse)(struct key_preparsed_payload *);
	void (*free_preparse)(struct key_preparsed_payload *);
	int (*instantiate)(struct key *, struct key_preparsed_payload *);
	int (*update)(struct key *, struct key_preparsed_payload *);
	int (*match_preparse)(struct key_match_data *);
	void (*match_free)(struct key_match_data *);
	void (*revoke)(struct key *);
	void (*destroy)(struct key *);
	void (*describe)(const struct key *, struct seq_file *);
	long int (*read)(const struct key *, char *, size_t);
	request_key_actor_t request_key;
	struct key_restriction * (*lookup_restriction)(const char *);
	int (*asym_query)(const struct kernel_pkey_params *, struct kernel_pkey_query *);
	int (*asym_eds_op)(struct kernel_pkey_params *, const void *, void *);
	int (*asym_verify_signature)(struct kernel_pkey_params *, const void *, const void *);
	struct list_head link;
	struct lock_class_key lock_class;
};

typedef int (*key_restrict_link_func_t)(struct key *, const struct key_type *, const union key_payload *, struct key *);

struct key_restriction {
	key_restrict_link_func_t check;
	struct key *key;
	struct key_type *keytype;
};

struct group_info {
	atomic_t usage;
	int ngroups;
	kgid_t gid[0];
};

struct delayed_call {
	void (*fn)(void *);
	void *arg;
};

struct request_queue;

struct io_cq {
	struct request_queue *q;
	struct io_context *ioc;
	union {
		struct list_head q_node;
		struct kmem_cache *__rcu_icq_cache;
	};
	union {
		struct hlist_node ioc_node;
		struct callback_head __rcu_head;
	};
	unsigned int flags;
};

struct kset;

struct kobj_type;

struct kobject {
	const char *name;
	struct list_head entry;
	struct kobject *parent;
	struct kset *kset;
	struct kobj_type *ktype;
	struct kernfs_node *sd;
	struct kref kref;
	unsigned int state_initialized: 1;
	unsigned int state_in_sysfs: 1;
	unsigned int state_add_uevent_sent: 1;
	unsigned int state_remove_uevent_sent: 1;
	unsigned int uevent_suppress: 1;
};

enum rpm_status {
	RPM_ACTIVE = 0,
	RPM_RESUMING = 1,
	RPM_SUSPENDED = 2,
	RPM_SUSPENDING = 3,
};

struct blk_rq_stat {
	u64 mean;
	u64 min;
	u64 max;
	u32 nr_samples;
	u64 batch;
};

enum blk_zoned_model {
	BLK_ZONED_NONE = 0,
	BLK_ZONED_HA = 1,
	BLK_ZONED_HM = 2,
};

struct queue_limits {
	long unsigned int bounce_pfn;
	long unsigned int seg_boundary_mask;
	long unsigned int virt_boundary_mask;
	unsigned int max_hw_sectors;
	unsigned int max_dev_sectors;
	unsigned int chunk_sectors;
	unsigned int max_sectors;
	unsigned int max_segment_size;
	unsigned int physical_block_size;
	unsigned int logical_block_size;
	unsigned int alignment_offset;
	unsigned int io_min;
	unsigned int io_opt;
	unsigned int max_discard_sectors;
	unsigned int max_hw_discard_sectors;
	unsigned int max_write_same_sectors;
	unsigned int max_write_zeroes_sectors;
	unsigned int max_zone_append_sectors;
	unsigned int discard_granularity;
	unsigned int discard_alignment;
	short unsigned int max_segments;
	short unsigned int max_integrity_segments;
	short unsigned int max_discard_segments;
	unsigned char misaligned;
	unsigned char discard_misaligned;
	unsigned char raid_partial_stripes_expensive;
	enum blk_zoned_model zoned;
};

struct bsg_ops;

struct bsg_class_device {
	struct device *class_dev;
	int minor;
	struct request_queue *queue;
	const struct bsg_ops *ops;
};

typedef void *mempool_alloc_t(gfp_t, void *);

typedef void mempool_free_t(void *, void *);

struct mempool_s {
	spinlock_t lock;
	int min_nr;
	int curr_nr;
	void **elements;
	void *pool_data;
	mempool_alloc_t *alloc;
	mempool_free_t *free;
	wait_queue_head_t wait;
};

typedef struct mempool_s mempool_t;

struct bio_set {
	struct kmem_cache *bio_slab;
	unsigned int front_pad;
	mempool_t bio_pool;
	mempool_t bvec_pool;
	spinlock_t rescue_lock;
	struct bio_list rescue_list;
	struct work_struct rescue_work;
	struct workqueue_struct *rescue_workqueue;
};

struct request;

struct elevator_queue;

struct blk_queue_stats;

struct rq_qos;

struct blk_mq_ops;

struct blk_mq_ctx;

struct blk_mq_hw_ctx;

struct blk_stat_callback;

struct blk_flush_queue;

struct blk_mq_tag_set;

struct request_queue {
	struct request *last_merge;
	struct elevator_queue *elevator;
	struct percpu_ref q_usage_counter;
	struct blk_queue_stats *stats;
	struct rq_qos *rq_qos;
	const struct blk_mq_ops *mq_ops;
	struct blk_mq_ctx *queue_ctx;
	unsigned int queue_depth;
	struct blk_mq_hw_ctx **queue_hw_ctx;
	unsigned int nr_hw_queues;
	struct backing_dev_info *backing_dev_info;
	void *queuedata;
	long unsigned int queue_flags;
	atomic_t pm_only;
	int id;
	gfp_t bounce_gfp;
	spinlock_t queue_lock;
	struct kobject kobj;
	struct kobject *mq_kobj;
	struct device *dev;
	enum rpm_status rpm_status;
	unsigned int nr_pending;
	long unsigned int nr_requests;
	unsigned int dma_pad_mask;
	unsigned int dma_alignment;
	unsigned int rq_timeout;
	int poll_nsec;
	struct blk_stat_callback *poll_cb;
	struct blk_rq_stat poll_stat[16];
	struct timer_list timeout;
	struct work_struct timeout_work;
	atomic_t nr_active_requests_shared_sbitmap;
	struct list_head icq_list;
	struct queue_limits limits;
	unsigned int required_elevator_features;
	unsigned int sg_timeout;
	unsigned int sg_reserved_size;
	int node;
	struct mutex debugfs_mutex;
	struct blk_flush_queue *fq;
	struct list_head requeue_list;
	spinlock_t requeue_lock;
	struct delayed_work requeue_work;
	struct mutex sysfs_lock;
	struct mutex sysfs_dir_lock;
	struct list_head unused_hctx_list;
	spinlock_t unused_hctx_lock;
	int mq_freeze_depth;
	struct bsg_class_device bsg_dev;
	struct callback_head callback_head;
	wait_queue_head_t mq_freeze_wq;
	struct mutex mq_freeze_lock;
	struct blk_mq_tag_set *tag_set;
	struct list_head tag_set_list;
	struct bio_set bio_split;
	struct dentry *debugfs_dir;
	struct dentry *sched_debugfs_dir;
	struct dentry *rqos_debugfs_dir;
	bool mq_sysfs_init_done;
	size_t cmd_size;
	u64 write_hints[5];
};

struct iattr {
	unsigned int ia_valid;
	umode_t ia_mode;
	kuid_t ia_uid;
	kgid_t ia_gid;
	loff_t ia_size;
	struct timespec64 ia_atime;
	struct timespec64 ia_mtime;
	struct timespec64 ia_ctime;
	struct file *ia_file;
};

typedef __kernel_uid32_t projid_t;

typedef struct {
	projid_t val;
} kprojid_t;

enum quota_type {
	USRQUOTA = 0,
	GRPQUOTA = 1,
	PRJQUOTA = 2,
};

struct kqid {
	union {
		kuid_t uid;
		kgid_t gid;
		kprojid_t projid;
	};
	enum quota_type type;
};

struct mem_dqblk {
	qsize_t dqb_bhardlimit;
	qsize_t dqb_bsoftlimit;
	qsize_t dqb_curspace;
	qsize_t dqb_rsvspace;
	qsize_t dqb_ihardlimit;
	qsize_t dqb_isoftlimit;
	qsize_t dqb_curinodes;
	time64_t dqb_btime;
	time64_t dqb_itime;
};

struct dquot {
	struct hlist_node dq_hash;
	struct list_head dq_inuse;
	struct list_head dq_free;
	struct list_head dq_dirty;
	struct mutex dq_lock;
	spinlock_t dq_dqb_lock;
	atomic_t dq_count;
	struct super_block *dq_sb;
	struct kqid dq_id;
	loff_t dq_off;
	long unsigned int dq_flags;
	struct mem_dqblk dq_dqb;
};

struct quota_format_type {
	int qf_fmt_id;
	const struct quota_format_ops *qf_ops;
	struct module *qf_owner;
	struct quota_format_type *qf_next;
};

struct quota_format_ops {
	int (*check_quota_file)(struct super_block *, int);
	int (*read_file_info)(struct super_block *, int);
	int (*write_file_info)(struct super_block *, int);
	int (*free_file_info)(struct super_block *, int);
	int (*read_dqblk)(struct dquot *);
	int (*commit_dqblk)(struct dquot *);
	int (*release_dqblk)(struct dquot *);
	int (*get_next_id)(struct super_block *, struct kqid *);
};

struct dquot_operations {
	int (*write_dquot)(struct dquot *);
	struct dquot * (*alloc_dquot)(struct super_block *, int);
	void (*destroy_dquot)(struct dquot *);
	int (*acquire_dquot)(struct dquot *);
	int (*release_dquot)(struct dquot *);
	int (*mark_dirty)(struct dquot *);
	int (*write_info)(struct super_block *, int);
	qsize_t * (*get_reserved_space)(struct inode *);
	int (*get_projid)(struct inode *, kprojid_t *);
	int (*get_inode_usage)(struct inode *, qsize_t *);
	int (*get_next_id)(struct super_block *, struct kqid *);
};

struct qc_dqblk {
	int d_fieldmask;
	u64 d_spc_hardlimit;
	u64 d_spc_softlimit;
	u64 d_ino_hardlimit;
	u64 d_ino_softlimit;
	u64 d_space;
	u64 d_ino_count;
	s64 d_ino_timer;
	s64 d_spc_timer;
	int d_ino_warns;
	int d_spc_warns;
	u64 d_rt_spc_hardlimit;
	u64 d_rt_spc_softlimit;
	u64 d_rt_space;
	s64 d_rt_spc_timer;
	int d_rt_spc_warns;
};

struct qc_type_state {
	unsigned int flags;
	unsigned int spc_timelimit;
	unsigned int ino_timelimit;
	unsigned int rt_spc_timelimit;
	unsigned int spc_warnlimit;
	unsigned int ino_warnlimit;
	unsigned int rt_spc_warnlimit;
	long long unsigned int ino;
	blkcnt_t blocks;
	blkcnt_t nextents;
};

struct qc_state {
	unsigned int s_incoredqs;
	struct qc_type_state s_state[3];
};

struct qc_info {
	int i_fieldmask;
	unsigned int i_flags;
	unsigned int i_spc_timelimit;
	unsigned int i_ino_timelimit;
	unsigned int i_rt_spc_timelimit;
	unsigned int i_spc_warnlimit;
	unsigned int i_ino_warnlimit;
	unsigned int i_rt_spc_warnlimit;
};

struct quotactl_ops {
	int (*quota_on)(struct super_block *, int, int, const struct path *);
	int (*quota_off)(struct super_block *, int);
	int (*quota_enable)(struct super_block *, unsigned int);
	int (*quota_disable)(struct super_block *, unsigned int);
	int (*quota_sync)(struct super_block *, int);
	int (*set_info)(struct super_block *, int, struct qc_info *);
	int (*get_dqblk)(struct super_block *, struct kqid, struct qc_dqblk *);
	int (*get_nextdqblk)(struct super_block *, struct kqid *, struct qc_dqblk *);
	int (*set_dqblk)(struct super_block *, struct kqid, struct qc_dqblk *);
	int (*get_state)(struct super_block *, struct qc_state *);
	int (*rm_xquota)(struct super_block *, unsigned int);
};

enum module_state {
	MODULE_STATE_LIVE = 0,
	MODULE_STATE_COMING = 1,
	MODULE_STATE_GOING = 2,
	MODULE_STATE_UNFORMED = 3,
};

struct module_param_attrs;

struct module_kobject {
	struct kobject kobj;
	struct module *mod;
	struct kobject *drivers_dir;
	struct module_param_attrs *mp;
	struct completion *kobj_completion;
};

struct latch_tree_node {
	struct rb_node node[2];
};

struct mod_tree_node {
	struct module *mod;
	struct latch_tree_node node;
};

struct module_layout {
	void *base;
	unsigned int size;
	unsigned int text_size;
	unsigned int ro_size;
	unsigned int ro_after_init_size;
	struct mod_tree_node mtn;
};

struct mod_section {
	Elf64_Shdr *shdr;
	int num_entries;
	int max_entries;
};

struct mod_arch_specific {
	struct mod_section got;
	struct mod_section plt;
	struct mod_section got_plt;
};

struct mod_kallsyms {
	Elf64_Sym *symtab;
	unsigned int num_symtab;
	char *strtab;
	char *typetab;
};

struct module_attribute;

struct kernel_param;

struct module_sect_attrs;

struct module_notes_attrs;

struct tracepoint;

typedef struct tracepoint * const tracepoint_ptr_t;

struct bpf_raw_event_map;

struct trace_event_call;

struct trace_eval_map;

struct error_injection_entry;

struct module {
	enum module_state state;
	struct list_head list;
	char name[56];
	struct module_kobject mkobj;
	struct module_attribute *modinfo_attrs;
	const char *version;
	const char *srcversion;
	const char *scmversion;
	struct kobject *holders_dir;
	const struct kernel_symbol *syms;
	const s32 *crcs;
	unsigned int num_syms;
	struct mutex param_lock;
	struct kernel_param *kp;
	unsigned int num_kp;
	unsigned int num_gpl_syms;
	const struct kernel_symbol *gpl_syms;
	const s32 *gpl_crcs;
	bool using_gplonly_symbols;
	bool sig_ok;
	bool async_probe_requested;
	const struct kernel_symbol *gpl_future_syms;
	const s32 *gpl_future_crcs;
	unsigned int num_gpl_future_syms;
	unsigned int num_exentries;
	struct exception_table_entry *extable;
	int (*init)();
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct module_layout core_layout;
	struct module_layout init_layout;
	struct mod_arch_specific arch;
	long unsigned int taints;
	struct mod_kallsyms *kallsyms;
	struct mod_kallsyms core_kallsyms;
	struct module_sect_attrs *sect_attrs;
	struct module_notes_attrs *notes_attrs;
	char *args;
	void *percpu;
	unsigned int percpu_size;
	void *noinstr_text_start;
	unsigned int noinstr_text_size;
	unsigned int num_tracepoints;
	tracepoint_ptr_t *tracepoints_ptrs;
	unsigned int num_srcu_structs;
	struct srcu_struct **srcu_struct_ptrs;
	unsigned int num_bpf_raw_events;
	struct bpf_raw_event_map *bpf_raw_events;
	unsigned int num_trace_bprintk_fmt;
	const char **trace_bprintk_fmt_start;
	struct trace_event_call **trace_events;
	unsigned int num_trace_events;
	struct trace_eval_map **trace_evals;
	unsigned int num_trace_evals;
	unsigned int num_ftrace_callsites;
	long unsigned int *ftrace_callsites;
	void *kprobes_text_start;
	unsigned int kprobes_text_size;
	long unsigned int *kprobe_blacklist;
	unsigned int num_kprobe_blacklist;
	struct list_head source_list;
	struct list_head target_list;
	void (*exit)();
	atomic_t refcnt;
	struct error_injection_entry *ei_funcs;
	unsigned int num_ei_funcs;
	long: 32;
	long: 64;
};

struct wait_page_queue {
	struct page *page;
	int bit_nr;
	wait_queue_entry_t wait;
};

struct writeback_control;

struct readahead_control;

struct swap_info_struct;

struct address_space_operations {
	int (*writepage)(struct page *, struct writeback_control *);
	int (*readpage)(struct file *, struct page *);
	int (*writepages)(struct address_space *, struct writeback_control *);
	int (*set_page_dirty)(struct page *);
	int (*readpages)(struct file *, struct address_space *, struct list_head *, unsigned int);
	void (*readahead)(struct readahead_control *);
	int (*write_begin)(struct file *, struct address_space *, loff_t, unsigned int, unsigned int, struct page **, void **);
	int (*write_end)(struct file *, struct address_space *, loff_t, unsigned int, unsigned int, struct page *, void *);
	sector_t (*bmap)(struct address_space *, sector_t);
	void (*invalidatepage)(struct page *, unsigned int, unsigned int);
	int (*releasepage)(struct page *, gfp_t);
	void (*freepage)(struct page *);
	ssize_t (*direct_IO)(struct kiocb *, struct iov_iter *);
	int (*migratepage)(struct address_space *, struct page *, struct page *, enum migrate_mode);
	bool (*isolate_page)(struct page *, isolate_mode_t);
	void (*putback_page)(struct page *);
	int (*launder_page)(struct page *);
	int (*is_partially_uptodate)(struct page *, long unsigned int, long unsigned int);
	void (*is_dirty_writeback)(struct page *, bool *, bool *);
	int (*error_remove_page)(struct address_space *, struct page *);
	int (*swap_activate)(struct swap_info_struct *, struct file *, sector_t *);
	void (*swap_deactivate)(struct file *);
};

enum writeback_sync_modes {
	WB_SYNC_NONE = 0,
	WB_SYNC_ALL = 1,
};

struct writeback_control {
	long int nr_to_write;
	long int pages_skipped;
	loff_t range_start;
	loff_t range_end;
	enum writeback_sync_modes sync_mode;
	unsigned int for_kupdate: 1;
	unsigned int for_background: 1;
	unsigned int tagged_writepages: 1;
	unsigned int for_reclaim: 1;
	unsigned int range_cyclic: 1;
	unsigned int for_sync: 1;
	unsigned int no_cgroup_owner: 1;
	unsigned int punt_to_cgroup: 1;
};

struct readahead_control {
	struct file *file;
	struct address_space *mapping;
	long unsigned int _index;
	unsigned int _nr_pages;
	unsigned int _batch_count;
};

struct swap_cluster_info {
	spinlock_t lock;
	unsigned int data: 24;
	unsigned int flags: 8;
};

struct swap_cluster_list {
	struct swap_cluster_info head;
	struct swap_cluster_info tail;
};

struct percpu_cluster;

struct swap_info_struct {
	long unsigned int flags;
	short int prio;
	struct plist_node list;
	signed char type;
	unsigned int max;
	unsigned char *swap_map;
	struct swap_cluster_info *cluster_info;
	struct swap_cluster_list free_clusters;
	unsigned int lowest_bit;
	unsigned int highest_bit;
	unsigned int pages;
	unsigned int inuse_pages;
	unsigned int cluster_next;
	unsigned int cluster_nr;
	unsigned int *cluster_next_cpu;
	struct percpu_cluster *percpu_cluster;
	struct rb_root swap_extent_root;
	struct block_device *bdev;
	struct file *swap_file;
	unsigned int old_block_size;
	spinlock_t lock;
	spinlock_t cont_lock;
	struct work_struct discard_work;
	struct swap_cluster_list discard_clusters;
	struct plist_node avail_lists[0];
};

struct hd_struct;

struct gendisk;

struct block_device {
	dev_t bd_dev;
	int bd_openers;
	struct inode *bd_inode;
	struct super_block *bd_super;
	struct mutex bd_mutex;
	void *bd_claiming;
	void *bd_holder;
	int bd_holders;
	bool bd_write_holder;
	struct list_head bd_holder_disks;
	struct block_device *bd_contains;
	u8 bd_partno;
	struct hd_struct *bd_part;
	unsigned int bd_part_count;
	spinlock_t bd_size_lock;
	struct gendisk *bd_disk;
	struct backing_dev_info *bd_bdi;
	int bd_fsfreeze_count;
	struct mutex bd_fsfreeze_mutex;
	struct super_block *bd_fsfreeze_sb;
};

struct cdev {
	struct kobject kobj;
	struct module *owner;
	const struct file_operations *ops;
	struct list_head list;
	dev_t dev;
	unsigned int count;
};

struct fiemap_extent_info;

struct inode_operations {
	struct dentry * (*lookup)(struct inode *, struct dentry *, unsigned int);
	const char * (*get_link)(struct dentry *, struct inode *, struct delayed_call *);
	int (*permission)(struct inode *, int);
	struct posix_acl * (*get_acl)(struct inode *, int);
	int (*readlink)(struct dentry *, char *, int);
	int (*create)(struct inode *, struct dentry *, umode_t, bool);
	int (*link)(struct dentry *, struct inode *, struct dentry *);
	int (*unlink)(struct inode *, struct dentry *);
	int (*symlink)(struct inode *, struct dentry *, const char *);
	int (*mkdir)(struct inode *, struct dentry *, umode_t);
	int (*rmdir)(struct inode *, struct dentry *);
	int (*mknod)(struct inode *, struct dentry *, umode_t, dev_t);
	int (*rename)(struct inode *, struct dentry *, struct inode *, struct dentry *, unsigned int);
	int (*setattr)(struct dentry *, struct iattr *);
	int (*getattr)(const struct path *, struct kstat *, u32, unsigned int);
	ssize_t (*listxattr)(struct dentry *, char *, size_t);
	int (*fiemap)(struct inode *, struct fiemap_extent_info *, u64, u64);
	int (*update_time)(struct inode *, struct timespec64 *, int);
	int (*atomic_open)(struct inode *, struct dentry *, struct file *, unsigned int, umode_t);
	int (*tmpfile)(struct inode *, struct dentry *, umode_t);
	int (*set_acl)(struct inode *, struct posix_acl *, int);
	long: 64;
	long: 64;
	long: 64;
};

struct file_lock_context {
	spinlock_t flc_lock;
	struct list_head flc_flock;
	struct list_head flc_posix;
	struct list_head flc_lease;
};

struct file_lock_operations {
	void (*fl_copy_lock)(struct file_lock *, struct file_lock *);
	void (*fl_release_private)(struct file_lock *);
};

struct nlm_lockowner;

struct nfs_lock_info {
	u32 state;
	struct nlm_lockowner *owner;
	struct list_head list;
};

struct nfs4_lock_state;

struct nfs4_lock_info {
	struct nfs4_lock_state *owner;
};

struct fasync_struct;

struct lock_manager_operations;

struct file_lock {
	struct file_lock *fl_blocker;
	struct list_head fl_list;
	struct hlist_node fl_link;
	struct list_head fl_blocked_requests;
	struct list_head fl_blocked_member;
	fl_owner_t fl_owner;
	unsigned int fl_flags;
	unsigned char fl_type;
	unsigned int fl_pid;
	int fl_link_cpu;
	wait_queue_head_t fl_wait;
	struct file *fl_file;
	loff_t fl_start;
	loff_t fl_end;
	struct fasync_struct *fl_fasync;
	long unsigned int fl_break_time;
	long unsigned int fl_downgrade_time;
	const struct file_lock_operations *fl_ops;
	const struct lock_manager_operations *fl_lmops;
	union {
		struct nfs_lock_info nfs_fl;
		struct nfs4_lock_info nfs4_fl;
		struct {
			struct list_head link;
			int state;
			unsigned int debug_id;
		} afs;
	} fl_u;
	struct list_head android_reserved1;
};

struct lock_manager_operations {
	fl_owner_t (*lm_get_owner)(fl_owner_t);
	void (*lm_put_owner)(fl_owner_t);
	void (*lm_notify)(struct file_lock *);
	int (*lm_grant)(struct file_lock *, int);
	bool (*lm_break)(struct file_lock *);
	int (*lm_change)(struct file_lock *, int, struct list_head *);
	void (*lm_setup)(struct file_lock *, void **);
	bool (*lm_breaker_owns_lease)(struct file_lock *);
};

struct fasync_struct {
	rwlock_t fa_lock;
	int magic;
	int fa_fd;
	struct fasync_struct *fa_next;
	struct file *fa_file;
	struct callback_head fa_rcu;
};

struct kstatfs;

struct super_operations {
	struct inode * (*alloc_inode)(struct super_block *);
	void (*destroy_inode)(struct inode *);
	void (*free_inode)(struct inode *);
	void (*dirty_inode)(struct inode *, int);
	int (*write_inode)(struct inode *, struct writeback_control *);
	int (*drop_inode)(struct inode *);
	void (*evict_inode)(struct inode *);
	void (*put_super)(struct super_block *);
	int (*sync_fs)(struct super_block *, int);
	int (*freeze_super)(struct super_block *);
	int (*freeze_fs)(struct super_block *);
	int (*thaw_super)(struct super_block *);
	int (*unfreeze_fs)(struct super_block *);
	int (*statfs)(struct dentry *, struct kstatfs *);
	int (*remount_fs)(struct super_block *, int *, char *);
	void (*umount_begin)(struct super_block *);
	int (*show_options)(struct seq_file *, struct dentry *);
	int (*show_devname)(struct seq_file *, struct dentry *);
	int (*show_path)(struct seq_file *, struct dentry *);
	int (*show_stats)(struct seq_file *, struct dentry *);
	int (*bdev_try_to_free_page)(struct super_block *, struct page *, gfp_t);
	long int (*nr_cached_objects)(struct super_block *, struct shrink_control *);
	long int (*free_cached_objects)(struct super_block *, struct shrink_control *);
};

struct iomap;

struct fid;

struct export_operations {
	int (*encode_fh)(struct inode *, __u32 *, int *, struct inode *);
	struct dentry * (*fh_to_dentry)(struct super_block *, struct fid *, int, int);
	struct dentry * (*fh_to_parent)(struct super_block *, struct fid *, int, int);
	int (*get_name)(struct dentry *, char *, struct dentry *);
	struct dentry * (*get_parent)(struct dentry *);
	int (*commit_metadata)(struct inode *);
	int (*get_uuid)(struct super_block *, u8 *, u32 *, u64 *);
	int (*map_blocks)(struct inode *, loff_t, u64, struct iomap *, bool, u32 *);
	int (*commit_blocks)(struct inode *, struct iomap *, int, struct iattr *);
};

struct xattr_handler {
	const char *name;
	const char *prefix;
	int flags;
	bool (*list)(struct dentry *);
	int (*get)(const struct xattr_handler *, struct dentry *, struct inode *, const char *, void *, size_t, int);
	int (*set)(const struct xattr_handler *, struct dentry *, struct inode *, const char *, const void *, size_t, int);
};

typedef int (*filldir_t)(struct dir_context *, const char *, int, loff_t, u64, unsigned int);

struct dir_context {
	filldir_t actor;
	loff_t pos;
};

typedef void (*poll_queue_proc)(struct file *, wait_queue_head_t *, struct poll_table_struct *);

struct poll_table_struct {
	poll_queue_proc _qproc;
	__poll_t _key;
};

struct seq_operations;

struct seq_file {
	char *buf;
	size_t size;
	size_t from;
	size_t count;
	size_t pad_until;
	loff_t index;
	loff_t read_pos;
	struct mutex lock;
	const struct seq_operations *op;
	int poll_event;
	const struct file *file;
	void *private;
};

struct fc_log;

struct p_log {
	const char *prefix;
	struct fc_log *log;
};

enum fs_context_purpose {
	FS_CONTEXT_FOR_MOUNT = 0,
	FS_CONTEXT_FOR_SUBMOUNT = 1,
	FS_CONTEXT_FOR_RECONFIGURE = 2,
};

enum fs_context_phase {
	FS_CONTEXT_CREATE_PARAMS = 0,
	FS_CONTEXT_CREATING = 1,
	FS_CONTEXT_AWAITING_MOUNT = 2,
	FS_CONTEXT_AWAITING_RECONF = 3,
	FS_CONTEXT_RECONF_PARAMS = 4,
	FS_CONTEXT_RECONFIGURING = 5,
	FS_CONTEXT_FAILED = 6,
};

struct fs_context_operations;

struct fs_context {
	const struct fs_context_operations *ops;
	struct mutex uapi_mutex;
	struct file_system_type *fs_type;
	void *fs_private;
	void *sget_key;
	struct dentry *root;
	struct user_namespace *user_ns;
	struct net *net_ns;
	const struct cred *cred;
	struct p_log log;
	const char *source;
	void *security;
	void *s_fs_info;
	unsigned int sb_flags;
	unsigned int sb_flags_mask;
	unsigned int s_iflags;
	unsigned int lsm_flags;
	enum fs_context_purpose purpose: 8;
	enum fs_context_phase phase: 8;
	bool need_free: 1;
	bool global: 1;
	bool oldapi: 1;
};

struct fs_parameter;

struct fs_parse_result;

typedef int fs_param_type(struct p_log *, const struct fs_parameter_spec *, struct fs_parameter *, struct fs_parse_result *);

struct fs_parameter_spec {
	const char *name;
	fs_param_type *type;
	u8 opt;
	short unsigned int flags;
	const void *data;
};

struct audit_names;

struct filename {
	const char *name;
	const char *uptr;
	int refcnt;
	struct audit_names *aname;
	const char iname[0];
};

typedef u8 blk_status_t;

struct bvec_iter {
	sector_t bi_sector;
	unsigned int bi_size;
	unsigned int bi_idx;
	unsigned int bi_bvec_done;
};

typedef void bio_end_io_t(struct bio *);

struct bio {
	struct bio *bi_next;
	struct gendisk *bi_disk;
	unsigned int bi_opf;
	short unsigned int bi_flags;
	short unsigned int bi_ioprio;
	short unsigned int bi_write_hint;
	blk_status_t bi_status;
	u8 bi_partno;
	atomic_t __bi_remaining;
	struct bvec_iter bi_iter;
	bio_end_io_t *bi_end_io;
	void *bi_private;
	union {	};
	short unsigned int bi_vcnt;
	short unsigned int bi_max_vecs;
	atomic_t __bi_cnt;
	struct bio_vec *bi_io_vec;
	struct bio_set *bi_pool;
	struct bio_vec bi_inline_vecs[0];
};

struct static_key {
	atomic_t enabled;
};

struct static_key_false {
	struct static_key key;
};

struct kernfs_root;

struct kernfs_elem_dir {
	long unsigned int subdirs;
	struct rb_root children;
	struct kernfs_root *root;
};

struct kernfs_syscall_ops;

struct kernfs_root {
	struct kernfs_node *kn;
	unsigned int flags;
	struct idr ino_idr;
	u32 last_id_lowbits;
	u32 id_highbits;
	struct kernfs_syscall_ops *syscall_ops;
	struct list_head supers;
	wait_queue_head_t deactivate_waitq;
};

struct kernfs_elem_symlink {
	struct kernfs_node *target_kn;
};

struct kernfs_ops;

struct kernfs_open_node;

struct kernfs_elem_attr {
	const struct kernfs_ops *ops;
	struct kernfs_open_node *open;
	loff_t size;
	struct kernfs_node *notify_next;
};

struct kernfs_iattrs;

struct kernfs_node {
	atomic_t count;
	atomic_t active;
	struct kernfs_node *parent;
	const char *name;
	struct rb_node rb;
	const void *ns;
	unsigned int hash;
	union {
		struct kernfs_elem_dir dir;
		struct kernfs_elem_symlink symlink;
		struct kernfs_elem_attr attr;
	};
	void *priv;
	u64 id;
	short unsigned int flags;
	umode_t mode;
	struct kernfs_iattrs *iattr;
};

struct kernfs_open_file;

struct kernfs_ops {
	int (*open)(struct kernfs_open_file *);
	void (*release)(struct kernfs_open_file *);
	int (*seq_show)(struct seq_file *, void *);
	void * (*seq_start)(struct seq_file *, loff_t *);
	void * (*seq_next)(struct seq_file *, void *, loff_t *);
	void (*seq_stop)(struct seq_file *, void *);
	ssize_t (*read)(struct kernfs_open_file *, char *, size_t, loff_t);
	size_t atomic_write_len;
	bool prealloc;
	ssize_t (*write)(struct kernfs_open_file *, char *, size_t, loff_t);
	__poll_t (*poll)(struct kernfs_open_file *, struct poll_table_struct *);
	int (*mmap)(struct kernfs_open_file *, struct vm_area_struct *);
};

struct kernfs_syscall_ops {
	int (*show_options)(struct seq_file *, struct kernfs_root *);
	int (*mkdir)(struct kernfs_node *, const char *, umode_t);
	int (*rmdir)(struct kernfs_node *);
	int (*rename)(struct kernfs_node *, struct kernfs_node *, const char *);
	int (*show_path)(struct seq_file *, struct kernfs_node *, struct kernfs_root *);
};

struct kernfs_open_file {
	struct kernfs_node *kn;
	struct file *file;
	struct seq_file *seq_file;
	void *priv;
	struct mutex mutex;
	struct mutex prealloc_mutex;
	int event;
	struct list_head list;
	char *prealloc_buf;
	size_t atomic_write_len;
	bool mmapped: 1;
	bool released: 1;
	const struct vm_operations_struct *vm_ops;
};

enum kobj_ns_type {
	KOBJ_NS_TYPE_NONE = 0,
	KOBJ_NS_TYPE_NET = 1,
	KOBJ_NS_TYPES = 2,
};

struct sock;

struct kobj_ns_type_operations {
	enum kobj_ns_type type;
	bool (*current_may_mount)();
	void * (*grab_current_ns)();
	const void * (*netlink_ns)(struct sock *);
	const void * (*initial_ns)();
	void (*drop_ns)(void *);
};

struct attribute {
	const char *name;
	umode_t mode;
};

struct bin_attribute;

struct attribute_group {
	const char *name;
	umode_t (*is_visible)(struct kobject *, struct attribute *, int);
	umode_t (*is_bin_visible)(struct kobject *, struct bin_attribute *, int);
	struct attribute **attrs;
	struct bin_attribute **bin_attrs;
};

struct bin_attribute {
	struct attribute attr;
	size_t size;
	void *private;
	ssize_t (*read)(struct file *, struct kobject *, struct bin_attribute *, char *, loff_t, size_t);
	ssize_t (*write)(struct file *, struct kobject *, struct bin_attribute *, char *, loff_t, size_t);
	int (*mmap)(struct file *, struct kobject *, struct bin_attribute *, struct vm_area_struct *);
};

struct sysfs_ops {
	ssize_t (*show)(struct kobject *, struct attribute *, char *);
	ssize_t (*store)(struct kobject *, struct attribute *, const char *, size_t);
};

struct kset_uevent_ops;

struct kset {
	struct list_head list;
	spinlock_t list_lock;
	struct kobject kobj;
	const struct kset_uevent_ops *uevent_ops;
};

struct kobj_type {
	void (*release)(struct kobject *);
	const struct sysfs_ops *sysfs_ops;
	struct attribute **default_attrs;
	const struct attribute_group **default_groups;
	const struct kobj_ns_type_operations * (*child_ns_type)(struct kobject *);
	const void * (*namespace)(struct kobject *);
	void (*get_ownership)(struct kobject *, kuid_t *, kgid_t *);
};

struct kobj_uevent_env {
	char *argv[3];
	char *envp[64];
	int envp_idx;
	char buf[2048];
	int buflen;
};

struct kset_uevent_ops {
	int (* const filter)(struct kset *, struct kobject *);
	const char * (* const name)(struct kset *, struct kobject *);
	int (* const uevent)(struct kset *, struct kobject *, struct kobj_uevent_env *);
};

struct pm_message {
	int event;
};

typedef struct pm_message pm_message_t;

struct dev_pm_ops {
	int (*prepare)(struct device *);
	void (*complete)(struct device *);
	int (*suspend)(struct device *);
	int (*resume)(struct device *);
	int (*freeze)(struct device *);
	int (*thaw)(struct device *);
	int (*poweroff)(struct device *);
	int (*restore)(struct device *);
	int (*suspend_late)(struct device *);
	int (*resume_early)(struct device *);
	int (*freeze_late)(struct device *);
	int (*thaw_early)(struct device *);
	int (*poweroff_late)(struct device *);
	int (*restore_early)(struct device *);
	int (*suspend_noirq)(struct device *);
	int (*resume_noirq)(struct device *);
	int (*freeze_noirq)(struct device *);
	int (*thaw_noirq)(struct device *);
	int (*poweroff_noirq)(struct device *);
	int (*restore_noirq)(struct device *);
	int (*runtime_suspend)(struct device *);
	int (*runtime_resume)(struct device *);
	int (*runtime_idle)(struct device *);
};

enum dl_dev_state {
	DL_DEV_NO_DRIVER = 0,
	DL_DEV_PROBING = 1,
	DL_DEV_DRIVER_BOUND = 2,
	DL_DEV_UNBINDING = 3,
};

struct dev_links_info {
	struct list_head suppliers;
	struct list_head consumers;
	struct list_head defer_sync;
	enum dl_dev_state status;
};

enum rpm_request {
	RPM_REQ_NONE = 0,
	RPM_REQ_IDLE = 1,
	RPM_REQ_SUSPEND = 2,
	RPM_REQ_AUTOSUSPEND = 3,
	RPM_REQ_RESUME = 4,
};

struct wake_irq;

struct pm_subsys_data;

struct dev_pm_qos;

struct dev_pm_info {
	pm_message_t power_state;
	unsigned int can_wakeup: 1;
	unsigned int async_suspend: 1;
	bool in_dpm_list: 1;
	bool is_prepared: 1;
	bool is_suspended: 1;
	bool is_noirq_suspended: 1;
	bool is_late_suspended: 1;
	bool no_pm: 1;
	bool early_init: 1;
	bool direct_complete: 1;
	u32 driver_flags;
	spinlock_t lock;
	unsigned int should_wakeup: 1;
	struct hrtimer suspend_timer;
	u64 timer_expires;
	struct work_struct work;
	wait_queue_head_t wait_queue;
	struct wake_irq *wakeirq;
	atomic_t usage_count;
	atomic_t child_count;
	unsigned int disable_depth: 3;
	unsigned int idle_notification: 1;
	unsigned int request_pending: 1;
	unsigned int deferred_resume: 1;
	unsigned int needs_force_resume: 1;
	unsigned int runtime_auto: 1;
	bool ignore_children: 1;
	unsigned int no_callbacks: 1;
	unsigned int irq_safe: 1;
	unsigned int use_autosuspend: 1;
	unsigned int timer_autosuspends: 1;
	unsigned int memalloc_noio: 1;
	unsigned int links_count;
	enum rpm_request request;
	enum rpm_status runtime_status;
	int runtime_error;
	int autosuspend_delay;
	u64 last_busy;
	u64 active_time;
	u64 suspended_time;
	u64 accounting_timestamp;
	struct pm_subsys_data *subsys_data;
	void (*set_latency_tolerance)(struct device *, s32);
	struct dev_pm_qos *qos;
};

struct dev_archdata {};

struct dev_iommu;

struct device_private;

struct device_type;

struct bus_type;

struct device_driver;

struct dev_pm_domain;

struct dev_pin_info;

struct bus_dma_region;

struct device_dma_parameters;

struct dma_coherent_mem;

struct cma;

struct device_node;

struct fwnode_handle;

struct class;

struct iommu_group;

struct device {
	struct kobject kobj;
	struct device *parent;
	struct device_private *p;
	const char *init_name;
	const struct device_type *type;
	struct bus_type *bus;
	struct device_driver *driver;
	void *platform_data;
	void *driver_data;
	struct mutex mutex;
	struct dev_links_info links;
	struct dev_pm_info power;
	struct dev_pm_domain *pm_domain;
	struct dev_pin_info *pins;
	u64 *dma_mask;
	u64 coherent_dma_mask;
	u64 bus_dma_limit;
	const struct bus_dma_region *dma_range_map;
	struct device_dma_parameters *dma_parms;
	struct list_head dma_pools;
	struct dma_coherent_mem *dma_mem;
	struct cma *cma_area;
	struct dev_archdata archdata;
	struct device_node *of_node;
	struct fwnode_handle *fwnode;
	dev_t devt;
	u32 id;
	spinlock_t devres_lock;
	struct list_head devres_head;
	struct class *class;
	const struct attribute_group **groups;
	void (*release)(struct device *);
	struct iommu_group *iommu_group;
	struct dev_iommu *iommu;
	bool offline_disabled: 1;
	bool offline: 1;
	bool of_node_reused: 1;
	bool state_synced: 1;
	bool dma_coherent: 1;
};

struct pm_domain_data;

struct pm_subsys_data {
	spinlock_t lock;
	unsigned int refcount;
	struct list_head clock_list;
	struct pm_domain_data *domain_data;
};

struct dev_pm_domain {
	struct dev_pm_ops ops;
	int (*start)(struct device *);
	void (*detach)(struct device *, bool);
	int (*activate)(struct device *);
	void (*sync)(struct device *);
	void (*dismiss)(struct device *);
};

struct iommu_ops;

struct subsys_private;

struct bus_type {
	const char *name;
	const char *dev_name;
	struct device *dev_root;
	const struct attribute_group **bus_groups;
	const struct attribute_group **dev_groups;
	const struct attribute_group **drv_groups;
	int (*match)(struct device *, struct device_driver *);
	int (*uevent)(struct device *, struct kobj_uevent_env *);
	int (*probe)(struct device *);
	void (*sync_state)(struct device *);
	int (*remove)(struct device *);
	void (*shutdown)(struct device *);
	int (*online)(struct device *);
	int (*offline)(struct device *);
	int (*suspend)(struct device *, pm_message_t);
	int (*resume)(struct device *);
	int (*num_vf)(struct device *);
	int (*dma_configure)(struct device *);
	const struct dev_pm_ops *pm;
	const struct iommu_ops *iommu_ops;
	struct subsys_private *p;
	struct lock_class_key lock_key;
	bool need_parent_lock;
};

enum probe_type {
	PROBE_DEFAULT_STRATEGY = 0,
	PROBE_PREFER_ASYNCHRONOUS = 1,
	PROBE_FORCE_SYNCHRONOUS = 2,
};

struct of_device_id;

struct acpi_device_id;

struct driver_private;

struct device_driver {
	const char *name;
	struct bus_type *bus;
	struct module *owner;
	const char *mod_name;
	bool suppress_bind_attrs;
	enum probe_type probe_type;
	const struct of_device_id *of_match_table;
	const struct acpi_device_id *acpi_match_table;
	int (*probe)(struct device *);
	void (*sync_state)(struct device *);
	int (*remove)(struct device *);
	void (*shutdown)(struct device *);
	int (*suspend)(struct device *, pm_message_t);
	int (*resume)(struct device *);
	const struct attribute_group **groups;
	const struct attribute_group **dev_groups;
	const struct dev_pm_ops *pm;
	void (*coredump)(struct device *);
	struct driver_private *p;
};

struct iommu_ops {};

struct device_type {
	const char *name;
	const struct attribute_group **groups;
	int (*uevent)(struct device *, struct kobj_uevent_env *);
	char * (*devnode)(struct device *, umode_t *, kuid_t *, kgid_t *);
	void (*release)(struct device *);
	const struct dev_pm_ops *pm;
};

struct class {
	const char *name;
	struct module *owner;
	const struct attribute_group **class_groups;
	const struct attribute_group **dev_groups;
	struct kobject *dev_kobj;
	int (*dev_uevent)(struct device *, struct kobj_uevent_env *);
	char * (*devnode)(struct device *, umode_t *);
	void (*class_release)(struct class *);
	void (*dev_release)(struct device *);
	int (*shutdown_pre)(struct device *);
	const struct kobj_ns_type_operations *ns_type;
	const void * (*namespace)(struct device *);
	void (*get_ownership)(struct device *, kuid_t *, kgid_t *);
	const struct dev_pm_ops *pm;
	struct subsys_private *p;
};

struct of_device_id {
	char name[32];
	char type[32];
	char compatible[128];
	const void *data;
};

typedef long unsigned int kernel_ulong_t;

struct acpi_device_id {
	__u8 id[9];
	kernel_ulong_t driver_data;
	__u32 cls;
	__u32 cls_msk;
};

struct device_dma_parameters {
	unsigned int max_segment_size;
	unsigned int min_align_mask;
	long unsigned int segment_boundary_mask;
};

typedef u64 dma_addr_t;

struct bus_dma_region {
	phys_addr_t cpu_start;
	dma_addr_t dma_start;
	u64 size;
	u64 offset;
};

typedef u32 phandle;

struct fwnode_operations;

struct fwnode_handle {
	struct fwnode_handle *secondary;
	const struct fwnode_operations *ops;
	struct device *dev;
	struct list_head suppliers;
	struct list_head consumers;
	u8 flags;
};

struct property;

struct device_node {
	const char *name;
	phandle phandle;
	const char *full_name;
	struct fwnode_handle fwnode;
	struct property *properties;
	struct property *deadprops;
	struct device_node *parent;
	struct device_node *child;
	struct device_node *sibling;
	struct kobject kobj;
	long unsigned int _flags;
	void *data;
};

enum cpuhp_state {
	CPUHP_INVALID = 4294967295,
	CPUHP_OFFLINE = 0,
	CPUHP_CREATE_THREADS = 1,
	CPUHP_PERF_PREPARE = 2,
	CPUHP_PERF_X86_PREPARE = 3,
	CPUHP_PERF_X86_AMD_UNCORE_PREP = 4,
	CPUHP_PERF_POWER = 5,
	CPUHP_PERF_SUPERH = 6,
	CPUHP_X86_HPET_DEAD = 7,
	CPUHP_X86_APB_DEAD = 8,
	CPUHP_X86_MCE_DEAD = 9,
	CPUHP_VIRT_NET_DEAD = 10,
	CPUHP_SLUB_DEAD = 11,
	CPUHP_DEBUG_OBJ_DEAD = 12,
	CPUHP_MM_WRITEBACK_DEAD = 13,
	CPUHP_MM_VMSTAT_DEAD = 14,
	CPUHP_SOFTIRQ_DEAD = 15,
	CPUHP_NET_MVNETA_DEAD = 16,
	CPUHP_CPUIDLE_DEAD = 17,
	CPUHP_ARM64_FPSIMD_DEAD = 18,
	CPUHP_ARM_OMAP_WAKE_DEAD = 19,
	CPUHP_IRQ_POLL_DEAD = 20,
	CPUHP_BLOCK_SOFTIRQ_DEAD = 21,
	CPUHP_ACPI_CPUDRV_DEAD = 22,
	CPUHP_S390_PFAULT_DEAD = 23,
	CPUHP_BLK_MQ_DEAD = 24,
	CPUHP_FS_BUFF_DEAD = 25,
	CPUHP_PRINTK_DEAD = 26,
	CPUHP_MM_MEMCQ_DEAD = 27,
	CPUHP_PERCPU_CNT_DEAD = 28,
	CPUHP_RADIX_DEAD = 29,
	CPUHP_PAGE_ALLOC_DEAD = 30,
	CPUHP_NET_DEV_DEAD = 31,
	CPUHP_PCI_XGENE_DEAD = 32,
	CPUHP_IOMMU_INTEL_DEAD = 33,
	CPUHP_LUSTRE_CFS_DEAD = 34,
	CPUHP_AP_ARM_CACHE_B15_RAC_DEAD = 35,
	CPUHP_PADATA_DEAD = 36,
	CPUHP_WORKQUEUE_PREP = 37,
	CPUHP_POWER_NUMA_PREPARE = 38,
	CPUHP_HRTIMERS_PREPARE = 39,
	CPUHP_PROFILE_PREPARE = 40,
	CPUHP_X2APIC_PREPARE = 41,
	CPUHP_SMPCFD_PREPARE = 42,
	CPUHP_RELAY_PREPARE = 43,
	CPUHP_SLAB_PREPARE = 44,
	CPUHP_MD_RAID5_PREPARE = 45,
	CPUHP_RCUTREE_PREP = 46,
	CPUHP_CPUIDLE_COUPLED_PREPARE = 47,
	CPUHP_POWERPC_PMAC_PREPARE = 48,
	CPUHP_POWERPC_MMU_CTX_PREPARE = 49,
	CPUHP_XEN_PREPARE = 50,
	CPUHP_XEN_EVTCHN_PREPARE = 51,
	CPUHP_ARM_SHMOBILE_SCU_PREPARE = 52,
	CPUHP_SH_SH3X_PREPARE = 53,
	CPUHP_NET_FLOW_PREPARE = 54,
	CPUHP_TOPOLOGY_PREPARE = 55,
	CPUHP_NET_IUCV_PREPARE = 56,
	CPUHP_ARM_BL_PREPARE = 57,
	CPUHP_TRACE_RB_PREPARE = 58,
	CPUHP_MM_ZS_PREPARE = 59,
	CPUHP_MM_ZSWP_MEM_PREPARE = 60,
	CPUHP_MM_ZSWP_POOL_PREPARE = 61,
	CPUHP_KVM_PPC_BOOK3S_PREPARE = 62,
	CPUHP_ZCOMP_PREPARE = 63,
	CPUHP_TIMERS_PREPARE = 64,
	CPUHP_MIPS_SOC_PREPARE = 65,
	CPUHP_BP_PREPARE_DYN = 66,
	CPUHP_BP_PREPARE_DYN_END = 86,
	CPUHP_BRINGUP_CPU = 87,
	CPUHP_AP_IDLE_DEAD = 88,
	CPUHP_AP_OFFLINE = 89,
	CPUHP_AP_SCHED_STARTING = 90,
	CPUHP_AP_RCUTREE_DYING = 91,
	CPUHP_AP_CPU_PM_STARTING = 92,
	CPUHP_AP_IRQ_GIC_STARTING = 93,
	CPUHP_AP_IRQ_HIP04_STARTING = 94,
	CPUHP_AP_IRQ_ARMADA_XP_STARTING = 95,
	CPUHP_AP_IRQ_BCM2836_STARTING = 96,
	CPUHP_AP_IRQ_MIPS_GIC_STARTING = 97,
	CPUHP_AP_IRQ_RISCV_STARTING = 98,
	CPUHP_AP_IRQ_SIFIVE_PLIC_STARTING = 99,
	CPUHP_AP_ARM_MVEBU_COHERENCY = 100,
	CPUHP_AP_MICROCODE_LOADER = 101,
	CPUHP_AP_PERF_X86_AMD_UNCORE_STARTING = 102,
	CPUHP_AP_PERF_X86_STARTING = 103,
	CPUHP_AP_PERF_X86_AMD_IBS_STARTING = 104,
	CPUHP_AP_PERF_X86_CQM_STARTING = 105,
	CPUHP_AP_PERF_X86_CSTATE_STARTING = 106,
	CPUHP_AP_PERF_XTENSA_STARTING = 107,
	CPUHP_AP_MIPS_OP_LOONGSON3_STARTING = 108,
	CPUHP_AP_ARM_SDEI_STARTING = 109,
	CPUHP_AP_ARM_VFP_STARTING = 110,
	CPUHP_AP_ARM64_DEBUG_MONITORS_STARTING = 111,
	CPUHP_AP_PERF_ARM_HW_BREAKPOINT_STARTING = 112,
	CPUHP_AP_PERF_ARM_ACPI_STARTING = 113,
	CPUHP_AP_PERF_ARM_STARTING = 114,
	CPUHP_AP_ARM_L2X0_STARTING = 115,
	CPUHP_AP_EXYNOS4_MCT_TIMER_STARTING = 116,
	CPUHP_AP_ARM_ARCH_TIMER_STARTING = 117,
	CPUHP_AP_ARM_GLOBAL_TIMER_STARTING = 118,
	CPUHP_AP_JCORE_TIMER_STARTING = 119,
	CPUHP_AP_ARM_TWD_STARTING = 120,
	CPUHP_AP_QCOM_TIMER_STARTING = 121,
	CPUHP_AP_TEGRA_TIMER_STARTING = 122,
	CPUHP_AP_ARMADA_TIMER_STARTING = 123,
	CPUHP_AP_MARCO_TIMER_STARTING = 124,
	CPUHP_AP_MIPS_GIC_TIMER_STARTING = 125,
	CPUHP_AP_ARC_TIMER_STARTING = 126,
	CPUHP_AP_RISCV_TIMER_STARTING = 127,
	CPUHP_AP_CLINT_TIMER_STARTING = 128,
	CPUHP_AP_CSKY_TIMER_STARTING = 129,
	CPUHP_AP_TI_GP_TIMER_STARTING = 130,
	CPUHP_AP_HYPERV_TIMER_STARTING = 131,
	CPUHP_AP_KVM_STARTING = 132,
	CPUHP_AP_KVM_ARM_VGIC_INIT_STARTING = 133,
	CPUHP_AP_KVM_ARM_VGIC_STARTING = 134,
	CPUHP_AP_KVM_ARM_TIMER_STARTING = 135,
	CPUHP_AP_DUMMY_TIMER_STARTING = 136,
	CPUHP_AP_ARM_XEN_STARTING = 137,
	CPUHP_AP_ARM_CORESIGHT_STARTING = 138,
	CPUHP_AP_ARM_CORESIGHT_CTI_STARTING = 139,
	CPUHP_AP_ARM64_ISNDEP_STARTING = 140,
	CPUHP_AP_SMPCFD_DYING = 141,
	CPUHP_AP_X86_TBOOT_DYING = 142,
	CPUHP_AP_ARM_CACHE_B15_RAC_DYING = 143,
	CPUHP_AP_ONLINE = 144,
	CPUHP_TEARDOWN_CPU = 145,
	CPUHP_AP_ONLINE_IDLE = 146,
	CPUHP_AP_SMPBOOT_THREADS = 147,
	CPUHP_AP_X86_VDSO_VMA_ONLINE = 148,
	CPUHP_AP_IRQ_AFFINITY_ONLINE = 149,
	CPUHP_AP_BLK_MQ_ONLINE = 150,
	CPUHP_AP_ARM_MVEBU_SYNC_CLOCKS = 151,
	CPUHP_AP_X86_INTEL_EPB_ONLINE = 152,
	CPUHP_AP_PERF_ONLINE = 153,
	CPUHP_AP_PERF_X86_ONLINE = 154,
	CPUHP_AP_PERF_X86_UNCORE_ONLINE = 155,
	CPUHP_AP_PERF_X86_AMD_UNCORE_ONLINE = 156,
	CPUHP_AP_PERF_X86_AMD_POWER_ONLINE = 157,
	CPUHP_AP_PERF_X86_RAPL_ONLINE = 158,
	CPUHP_AP_PERF_X86_CQM_ONLINE = 159,
	CPUHP_AP_PERF_X86_CSTATE_ONLINE = 160,
	CPUHP_AP_PERF_S390_CF_ONLINE = 161,
	CPUHP_AP_PERF_S390_SF_ONLINE = 162,
	CPUHP_AP_PERF_ARM_CCI_ONLINE = 163,
	CPUHP_AP_PERF_ARM_CCN_ONLINE = 164,
	CPUHP_AP_PERF_ARM_HISI_DDRC_ONLINE = 165,
	CPUHP_AP_PERF_ARM_HISI_HHA_ONLINE = 166,
	CPUHP_AP_PERF_ARM_HISI_L3_ONLINE = 167,
	CPUHP_AP_PERF_ARM_L2X0_ONLINE = 168,
	CPUHP_AP_PERF_ARM_QCOM_L2_ONLINE = 169,
	CPUHP_AP_PERF_ARM_QCOM_L3_ONLINE = 170,
	CPUHP_AP_PERF_ARM_APM_XGENE_ONLINE = 171,
	CPUHP_AP_PERF_ARM_CAVIUM_TX2_UNCORE_ONLINE = 172,
	CPUHP_AP_PERF_POWERPC_NEST_IMC_ONLINE = 173,
	CPUHP_AP_PERF_POWERPC_CORE_IMC_ONLINE = 174,
	CPUHP_AP_PERF_POWERPC_THREAD_IMC_ONLINE = 175,
	CPUHP_AP_PERF_POWERPC_TRACE_IMC_ONLINE = 176,
	CPUHP_AP_PERF_POWERPC_HV_24x7_ONLINE = 177,
	CPUHP_AP_PERF_POWERPC_HV_GPCI_ONLINE = 178,
	CPUHP_AP_PERF_CSKY_ONLINE = 179,
	CPUHP_AP_WATCHDOG_ONLINE = 180,
	CPUHP_AP_WORKQUEUE_ONLINE = 181,
	CPUHP_AP_RCUTREE_ONLINE = 182,
	CPUHP_AP_BASE_CACHEINFO_ONLINE = 183,
	CPUHP_AP_ONLINE_DYN = 184,
	CPUHP_AP_ONLINE_DYN_END = 214,
	CPUHP_AP_X86_HPET_ONLINE = 215,
	CPUHP_AP_X86_KVM_CLK_ONLINE = 216,
	CPUHP_AP_DTPM_CPU_ONLINE = 217,
	CPUHP_AP_ACTIVE = 218,
	CPUHP_ANDROID_RESERVED_1 = 219,
	CPUHP_ANDROID_RESERVED_2 = 220,
	CPUHP_ANDROID_RESERVED_3 = 221,
	CPUHP_ANDROID_RESERVED_4 = 222,
	CPUHP_ONLINE = 223,
};

struct kernel_param_ops {
	unsigned int flags;
	int (*set)(const char *, const struct kernel_param *);
	int (*get)(char *, const struct kernel_param *);
	void (*free)(void *);
};

struct kparam_string;

struct kparam_array;

struct kernel_param {
	const char *name;
	struct module *mod;
	const struct kernel_param_ops *ops;
	const u16 perm;
	s8 level;
	u8 flags;
	union {
		void *arg;
		const struct kparam_string *str;
		const struct kparam_array *arr;
	};
};

struct kparam_string {
	unsigned int maxlen;
	char *string;
};

struct kparam_array {
	unsigned int max;
	unsigned int elemsize;
	unsigned int *num;
	const struct kernel_param_ops *ops;
	void *elem;
};

struct error_injection_entry {
	long unsigned int addr;
	int etype;
};

struct tracepoint_func {
	void *func;
	void *data;
	int prio;
};

struct static_call_key;

struct tracepoint {
	const char *name;
	struct static_key key;
	struct static_call_key *static_call_key;
	void *static_call_tramp;
	void *iterator;
	int (*regfunc)();
	void (*unregfunc)();
	struct tracepoint_func *funcs;
};

struct static_call_key {
	void *func;
};

struct bpf_raw_event_map {
	struct tracepoint *tp;
	void *bpf_func;
	u32 num_args;
	u32 writable_size;
	long: 64;
};

struct module_attribute {
	struct attribute attr;
	ssize_t (*show)(struct module_attribute *, struct module_kobject *, char *);
	ssize_t (*store)(struct module_attribute *, struct module_kobject *, const char *, size_t);
	void (*setup)(struct module *, const char *);
	int (*test)(struct module *);
	void (*free)(struct module *);
};

struct trace_event_functions;

struct trace_event {
	struct hlist_node node;
	struct list_head list;
	int type;
	struct trace_event_functions *funcs;
};

struct trace_event_class;

struct event_filter;

struct bpf_prog_array;

struct perf_event;

struct trace_event_call {
	struct list_head list;
	struct trace_event_class *class;
	union {
		char *name;
		struct tracepoint *tp;
	};
	struct trace_event event;
	char *print_fmt;
	struct event_filter *filter;
	void *mod;
	void *data;
	int flags;
	int perf_refcount;
	struct hlist_head *perf_events;
	struct bpf_prog_array *prog_array;
	int (*perf_perm)(struct trace_event_call *, struct perf_event *);
};

struct trace_eval_map {
	const char *system;
	const char *eval_string;
	long unsigned int eval_value;
};

struct linux_binprm {
	struct vm_area_struct *vma;
	long unsigned int vma_pages;
	struct mm_struct *mm;
	long unsigned int p;
	long unsigned int argmin;
	unsigned int have_execfd: 1;
	unsigned int execfd_creds: 1;
	unsigned int secureexec: 1;
	unsigned int point_of_no_return: 1;
	struct file *executable;
	struct file *interpreter;
	struct file *file;
	struct cred *cred;
	int unsafe;
	unsigned int per_clear;
	int argc;
	int envc;
	const char *filename;
	const char *interp;
	const char *fdpath;
	unsigned int interp_flags;
	int execfd;
	long unsigned int loader;
	long unsigned int exec;
	struct rlimit rlim_stack;
	char buf[256];
};

struct coredump_params {
	const kernel_siginfo_t *siginfo;
	struct pt_regs *regs;
	struct file *file;
	long unsigned int limit;
	long unsigned int mm_flags;
	loff_t written;
	loff_t pos;
};

typedef void percpu_ref_func_t(struct percpu_ref *);

struct percpu_ref_data {
	atomic_long_t count;
	percpu_ref_func_t *release;
	percpu_ref_func_t *confirm_switch;
	bool force_atomic: 1;
	bool allow_reinit: 1;
	struct callback_head rcu;
	struct percpu_ref *ref;
};

struct dev_pagemap_ops {
	void (*page_free)(struct page *);
	void (*kill)(struct dev_pagemap *);
	void (*cleanup)(struct dev_pagemap *);
	vm_fault_t (*migrate_to_ram)(struct vm_fault *);
};

struct seq_operations {
	void * (*start)(struct seq_file *, loff_t *);
	void (*stop)(struct seq_file *, void *);
	void * (*next)(struct seq_file *, void *, loff_t *);
	int (*show)(struct seq_file *, void *);
};

struct ring_buffer_event {
	u32 type_len: 5;
	u32 time_delta: 27;
	u32 array[0];
};

struct seq_buf {
	char *buffer;
	size_t size;
	size_t len;
	loff_t readpos;
};

struct trace_seq {
	char buffer[4096];
	struct seq_buf seq;
	int full;
};

struct fwnode_reference_args;

struct fwnode_endpoint;

struct fwnode_operations {
	struct fwnode_handle * (*get)(struct fwnode_handle *);
	void (*put)(struct fwnode_handle *);
	bool (*device_is_available)(const struct fwnode_handle *);
	const void * (*device_get_match_data)(const struct fwnode_handle *, const struct device *);
	bool (*property_present)(const struct fwnode_handle *, const char *);
	int (*property_read_int_array)(const struct fwnode_handle *, const char *, unsigned int, void *, size_t);
	int (*property_read_string_array)(const struct fwnode_handle *, const char *, const char **, size_t);
	const char * (*get_name)(const struct fwnode_handle *);
	const char * (*get_name_prefix)(const struct fwnode_handle *);
	struct fwnode_handle * (*get_parent)(const struct fwnode_handle *);
	struct fwnode_handle * (*get_next_child_node)(const struct fwnode_handle *, struct fwnode_handle *);
	struct fwnode_handle * (*get_named_child_node)(const struct fwnode_handle *, const char *);
	int (*get_reference_args)(const struct fwnode_handle *, const char *, const char *, unsigned int, unsigned int, struct fwnode_reference_args *);
	struct fwnode_handle * (*graph_get_next_endpoint)(const struct fwnode_handle *, struct fwnode_handle *);
	struct fwnode_handle * (*graph_get_remote_endpoint)(const struct fwnode_handle *);
	struct fwnode_handle * (*graph_get_port_parent)(struct fwnode_handle *);
	int (*graph_parse_endpoint)(const struct fwnode_handle *, struct fwnode_endpoint *);
	int (*add_links)(struct fwnode_handle *);
};

struct fwnode_endpoint {
	unsigned int port;
	unsigned int id;
	const struct fwnode_handle *local_fwnode;
};

struct fwnode_reference_args {
	struct fwnode_handle *fwnode;
	unsigned int nargs;
	u64 args[8];
};

enum kmalloc_cache_type {
	KMALLOC_NORMAL = 0,
	KMALLOC_RECLAIM = 1,
	NR_KMALLOC_TYPES = 2,
};

enum perf_sw_ids {
	PERF_COUNT_SW_CPU_CLOCK = 0,
	PERF_COUNT_SW_TASK_CLOCK = 1,
	PERF_COUNT_SW_PAGE_FAULTS = 2,
	PERF_COUNT_SW_CONTEXT_SWITCHES = 3,
	PERF_COUNT_SW_CPU_MIGRATIONS = 4,
	PERF_COUNT_SW_PAGE_FAULTS_MIN = 5,
	PERF_COUNT_SW_PAGE_FAULTS_MAJ = 6,
	PERF_COUNT_SW_ALIGNMENT_FAULTS = 7,
	PERF_COUNT_SW_EMULATION_FAULTS = 8,
	PERF_COUNT_SW_DUMMY = 9,
	PERF_COUNT_SW_BPF_OUTPUT = 10,
	PERF_COUNT_SW_MAX = 11,
};

struct perf_event_attr {
	__u32 type;
	__u32 size;
	__u64 config;
	union {
		__u64 sample_period;
		__u64 sample_freq;
	};
	__u64 sample_type;
	__u64 read_format;
	__u64 disabled: 1;
	__u64 inherit: 1;
	__u64 pinned: 1;
	__u64 exclusive: 1;
	__u64 exclude_user: 1;
	__u64 exclude_kernel: 1;
	__u64 exclude_hv: 1;
	__u64 exclude_idle: 1;
	__u64 mmap: 1;
	__u64 comm: 1;
	__u64 freq: 1;
	__u64 inherit_stat: 1;
	__u64 enable_on_exec: 1;
	__u64 task: 1;
	__u64 watermark: 1;
	__u64 precise_ip: 2;
	__u64 mmap_data: 1;
	__u64 sample_id_all: 1;
	__u64 exclude_host: 1;
	__u64 exclude_guest: 1;
	__u64 exclude_callchain_kernel: 1;
	__u64 exclude_callchain_user: 1;
	__u64 mmap2: 1;
	__u64 comm_exec: 1;
	__u64 use_clockid: 1;
	__u64 context_switch: 1;
	__u64 write_backward: 1;
	__u64 namespaces: 1;
	__u64 ksymbol: 1;
	__u64 bpf_event: 1;
	__u64 aux_output: 1;
	__u64 cgroup: 1;
	__u64 text_poke: 1;
	__u64 __reserved_1: 30;
	union {
		__u32 wakeup_events;
		__u32 wakeup_watermark;
	};
	__u32 bp_type;
	union {
		__u64 bp_addr;
		__u64 kprobe_func;
		__u64 uprobe_path;
		__u64 config1;
	};
	union {
		__u64 bp_len;
		__u64 kprobe_addr;
		__u64 probe_offset;
		__u64 config2;
	};
	__u64 branch_sample_type;
	__u64 sample_regs_user;
	__u32 sample_stack_user;
	__s32 clockid;
	__u64 sample_regs_intr;
	__u32 aux_watermark;
	__u16 sample_max_stack;
	__u16 __reserved_2;
	__u32 aux_sample_size;
	__u32 __reserved_3;
};

union perf_mem_data_src {
	__u64 val;
	struct {
		__u64 mem_op: 5;
		__u64 mem_lvl: 14;
		__u64 mem_snoop: 5;
		__u64 mem_lock: 2;
		__u64 mem_dtlb: 7;
		__u64 mem_lvl_num: 4;
		__u64 mem_remote: 1;
		__u64 mem_snoopx: 2;
		__u64 mem_rsvd: 24;
	};
};

struct perf_branch_entry {
	__u64 from;
	__u64 to;
	__u64 mispred: 1;
	__u64 predicted: 1;
	__u64 in_tx: 1;
	__u64 abort: 1;
	__u64 cycles: 16;
	__u64 type: 4;
	__u64 reserved: 40;
};

struct new_utsname {
	char sysname[65];
	char nodename[65];
	char release[65];
	char version[65];
	char machine[65];
	char domainname[65];
};

struct uts_namespace {
	struct kref kref;
	struct new_utsname name;
	struct user_namespace *user_ns;
	struct ucounts *ucounts;
	struct ns_common ns;
};

struct cgroup_namespace {
	refcount_t count;
	struct ns_common ns;
	struct user_namespace *user_ns;
	struct ucounts *ucounts;
	struct css_set *root_cset;
};

struct nsset {
	unsigned int flags;
	struct nsproxy *nsproxy;
	struct fs_struct *fs;
	const struct cred *cred;
};

struct proc_ns_operations {
	const char *name;
	const char *real_ns_name;
	int type;
	struct ns_common * (*get)(struct task_struct *);
	void (*put)(struct ns_common *);
	int (*install)(struct nsset *, struct ns_common *);
	struct user_namespace * (*owner)(struct ns_common *);
	struct ns_common * (*get_parent)(struct ns_common *);
};

struct ucounts {
	struct hlist_node node;
	struct user_namespace *ns;
	kuid_t uid;
	int count;
	atomic_t ucount[10];
};

typedef struct {
	atomic_long_t a;
} local_t;

typedef struct {
	local_t a;
} local64_t;

struct ftrace_ops;

typedef void (*ftrace_func_t)(long unsigned int, long unsigned int, struct ftrace_ops *, struct pt_regs *);

struct ftrace_hash;

struct ftrace_ops_hash {
	struct ftrace_hash *notrace_hash;
	struct ftrace_hash *filter_hash;
	struct mutex regex_lock;
};

struct ftrace_ops {
	ftrace_func_t func;
	struct ftrace_ops *next;
	long unsigned int flags;
	void *private;
	ftrace_func_t saved_func;
	struct ftrace_ops_hash local_hash;
	struct ftrace_ops_hash *func_hash;
	struct ftrace_ops_hash old_hash;
	long unsigned int trampoline;
	long unsigned int trampoline_size;
	struct list_head list;
};

struct irq_work {
	union {
		struct __call_single_node node;
		struct {
			struct llist_node llnode;
			atomic_t flags;
		};
	};
	void (*func)(struct irq_work *);
};

struct perf_regs {
	__u64 abi;
	struct pt_regs *regs;
};

struct u64_stats_sync {};

enum perf_event_state {
	PERF_EVENT_STATE_DEAD = 4294967292,
	PERF_EVENT_STATE_EXIT = 4294967293,
	PERF_EVENT_STATE_ERROR = 4294967294,
	PERF_EVENT_STATE_OFF = 4294967295,
	PERF_EVENT_STATE_INACTIVE = 0,
	PERF_EVENT_STATE_ACTIVE = 1,
};

struct hw_perf_event_extra {
	u64 config;
	unsigned int reg;
	int alloc;
	int idx;
};

struct hw_perf_event {
	union {
		struct {
			u64 config;
			u64 last_tag;
			long unsigned int config_base;
			long unsigned int event_base;
			int event_base_rdpmc;
			int idx;
			int last_cpu;
			int flags;
			struct hw_perf_event_extra extra_reg;
			struct hw_perf_event_extra branch_reg;
		};
		struct {
			struct hrtimer hrtimer;
		};
		struct {
			struct list_head tp_list;
		};
		struct {
			u64 pwr_acc;
			u64 ptsc;
		};
		struct {
			u8 iommu_bank;
			u8 iommu_cntr;
			u16 padding;
			u64 conf;
			u64 conf1;
		};
	};
	struct task_struct *target;
	void *addr_filters;
	long unsigned int addr_filters_gen;
	int state;
	local64_t prev_count;
	u64 sample_period;
	union {
		struct {
			u64 last_period;
			local64_t period_left;
		};
		struct {
			u64 saved_metric;
			u64 saved_slots;
		};
	};
	u64 interrupts_seq;
	u64 interrupts;
	u64 freq_time_stamp;
	u64 freq_count_stamp;
};

struct perf_addr_filters_head {
	struct list_head list;
	raw_spinlock_t lock;
	unsigned int nr_file_filters;
};

struct perf_sample_data;

typedef void (*perf_overflow_handler_t)(struct perf_event *, struct perf_sample_data *, struct pt_regs *);

struct perf_buffer;

struct perf_addr_filter_range;

struct bpf_prog;

struct perf_event {
	struct list_head event_entry;
	struct list_head sibling_list;
	struct list_head active_list;
	struct rb_node group_node;
	u64 group_index;
	struct list_head migrate_entry;
	struct hlist_node hlist_entry;
	struct list_head active_entry;
	int nr_siblings;
	int event_caps;
	int group_caps;
	struct perf_event *group_leader;
	struct pmu *pmu;
	void *pmu_private;
	enum perf_event_state state;
	unsigned int attach_state;
	local64_t count;
	atomic64_t child_count;
	u64 total_time_enabled;
	u64 total_time_running;
	u64 tstamp;
	u64 shadow_ctx_time;
	struct perf_event_attr attr;
	u16 header_size;
	u16 id_header_size;
	u16 read_size;
	struct hw_perf_event hw;
	struct perf_event_context *ctx;
	atomic_long_t refcount;
	atomic64_t child_total_time_enabled;
	atomic64_t child_total_time_running;
	struct mutex child_mutex;
	struct list_head child_list;
	struct perf_event *parent;
	int oncpu;
	int cpu;
	struct list_head owner_entry;
	struct task_struct *owner;
	struct mutex mmap_mutex;
	atomic_t mmap_count;
	struct perf_buffer *rb;
	struct list_head rb_entry;
	long unsigned int rcu_batches;
	int rcu_pending;
	wait_queue_head_t waitq;
	struct fasync_struct *fasync;
	int pending_wakeup;
	int pending_kill;
	int pending_disable;
	struct irq_work pending;
	atomic_t event_limit;
	struct perf_addr_filters_head addr_filters;
	struct perf_addr_filter_range *addr_filter_ranges;
	long unsigned int addr_filters_gen;
	struct perf_event *aux_event;
	void (*destroy)(struct perf_event *);
	struct callback_head callback_head;
	struct pid_namespace *ns;
	u64 id;
	u64 (*clock)();
	perf_overflow_handler_t overflow_handler;
	void *overflow_handler_context;
	perf_overflow_handler_t orig_overflow_handler;
	struct bpf_prog *prog;
	struct trace_event_call *tp_event;
	struct event_filter *filter;
	struct ftrace_ops ftrace_ops;
	struct list_head sb_list;
};

struct bpf_cgroup_storage;

struct bpf_prog_array_item {
	struct bpf_prog *prog;
	struct bpf_cgroup_storage *cgroup_storage[2];
};

struct bpf_prog_array {
	struct callback_head rcu;
	struct bpf_prog_array_item items[0];
};

struct cgroup_taskset;

struct cftype;

struct cgroup_subsys {
	struct cgroup_subsys_state * (*css_alloc)(struct cgroup_subsys_state *);
	int (*css_online)(struct cgroup_subsys_state *);
	void (*css_offline)(struct cgroup_subsys_state *);
	void (*css_released)(struct cgroup_subsys_state *);
	void (*css_free)(struct cgroup_subsys_state *);
	void (*css_reset)(struct cgroup_subsys_state *);
	void (*css_rstat_flush)(struct cgroup_subsys_state *, int);
	int (*css_extra_stat_show)(struct seq_file *, struct cgroup_subsys_state *);
	int (*can_attach)(struct cgroup_taskset *);
	void (*cancel_attach)(struct cgroup_taskset *);
	void (*attach)(struct cgroup_taskset *);
	void (*post_attach)();
	int (*can_fork)(struct task_struct *, struct css_set *);
	void (*cancel_fork)(struct task_struct *, struct css_set *);
	void (*fork)(struct task_struct *);
	void (*exit)(struct task_struct *);
	void (*release)(struct task_struct *);
	void (*bind)(struct cgroup_subsys_state *);
	bool early_init: 1;
	bool implicit_on_dfl: 1;
	bool threaded: 1;
	bool broken_hierarchy: 1;
	bool warned_broken_hierarchy: 1;
	int id;
	const char *name;
	const char *legacy_name;
	struct cgroup_root *root;
	struct idr css_idr;
	struct list_head cfts;
	struct cftype *dfl_cftypes;
	struct cftype *legacy_cftypes;
	unsigned int depends_on;
};

struct cgroup_rstat_cpu {
	struct u64_stats_sync bsync;
	struct cgroup_base_stat bstat;
	struct cgroup_base_stat last_bstat;
	struct cgroup *updated_children;
	struct cgroup *updated_next;
};

struct cgroup_root {
	struct kernfs_root *kf_root;
	unsigned int subsys_mask;
	int hierarchy_id;
	struct cgroup cgrp;
	u64 cgrp_ancestor_id_storage;
	atomic_t nr_cgrps;
	struct list_head root_list;
	unsigned int flags;
	char release_agent_path[4096];
	char name[64];
};

struct cftype {
	char name[64];
	long unsigned int private;
	size_t max_write_len;
	unsigned int flags;
	unsigned int file_offset;
	struct cgroup_subsys *ss;
	struct list_head node;
	struct kernfs_ops *kf_ops;
	int (*open)(struct kernfs_open_file *);
	void (*release)(struct kernfs_open_file *);
	u64 (*read_u64)(struct cgroup_subsys_state *, struct cftype *);
	s64 (*read_s64)(struct cgroup_subsys_state *, struct cftype *);
	int (*seq_show)(struct seq_file *, void *);
	void * (*seq_start)(struct seq_file *, loff_t *);
	void * (*seq_next)(struct seq_file *, void *, loff_t *);
	void (*seq_stop)(struct seq_file *, void *);
	int (*write_u64)(struct cgroup_subsys_state *, struct cftype *, u64);
	int (*write_s64)(struct cgroup_subsys_state *, struct cftype *, s64);
	ssize_t (*write)(struct kernfs_open_file *, char *, size_t, loff_t);
	__poll_t (*poll)(struct kernfs_open_file *, struct poll_table_struct *);
};

struct perf_callchain_entry {
	__u64 nr;
	__u64 ip[0];
};

typedef long unsigned int (*perf_copy_f)(void *, const void *, long unsigned int, long unsigned int);

struct perf_raw_frag {
	union {
		struct perf_raw_frag *next;
		long unsigned int pad;
	};
	perf_copy_f copy;
	void *data;
	u32 size;
} __attribute__((packed));

struct perf_raw_record {
	struct perf_raw_frag frag;
	u32 size;
};

struct perf_branch_stack {
	__u64 nr;
	__u64 hw_idx;
	struct perf_branch_entry entries[0];
};

struct perf_cpu_context;

struct perf_output_handle;

struct pmu {
	struct list_head entry;
	struct module *module;
	struct device *dev;
	const struct attribute_group **attr_groups;
	const struct attribute_group **attr_update;
	const char *name;
	int type;
	int capabilities;
	int *pmu_disable_count;
	struct perf_cpu_context *pmu_cpu_context;
	atomic_t exclusive_cnt;
	int task_ctx_nr;
	int hrtimer_interval_ms;
	unsigned int nr_addr_filters;
	void (*pmu_enable)(struct pmu *);
	void (*pmu_disable)(struct pmu *);
	int (*event_init)(struct perf_event *);
	void (*event_mapped)(struct perf_event *, struct mm_struct *);
	void (*event_unmapped)(struct perf_event *, struct mm_struct *);
	int (*add)(struct perf_event *, int);
	void (*del)(struct perf_event *, int);
	void (*start)(struct perf_event *, int);
	void (*stop)(struct perf_event *, int);
	void (*read)(struct perf_event *);
	void (*start_txn)(struct pmu *, unsigned int);
	int (*commit_txn)(struct pmu *);
	void (*cancel_txn)(struct pmu *);
	int (*event_idx)(struct perf_event *);
	void (*sched_task)(struct perf_event_context *, bool);
	struct kmem_cache *task_ctx_cache;
	void (*swap_task_ctx)(struct perf_event_context *, struct perf_event_context *);
	void * (*setup_aux)(struct perf_event *, void **, int, bool);
	void (*free_aux)(void *);
	long int (*snapshot_aux)(struct perf_event *, struct perf_output_handle *, long unsigned int);
	int (*addr_filters_validate)(struct list_head *);
	void (*addr_filters_sync)(struct perf_event *);
	int (*aux_output_match)(struct perf_event *);
	int (*filter_match)(struct perf_event *);
	int (*check_period)(struct perf_event *, u64);
};

struct perf_cpu_context {
	struct perf_event_context ctx;
	struct perf_event_context *task_ctx;
	int active_oncpu;
	int exclusive;
	raw_spinlock_t hrtimer_lock;
	struct hrtimer hrtimer;
	ktime_t hrtimer_interval;
	unsigned int hrtimer_active;
	struct list_head sched_cb_entry;
	int sched_cb_usage;
	int online;
	int heap_size;
	struct perf_event **heap;
	struct perf_event *heap_default[2];
};

struct perf_output_handle {
	struct perf_event *event;
	struct perf_buffer *rb;
	long unsigned int wakeup;
	long unsigned int size;
	u64 aux_flags;
	union {
		void *addr;
		long unsigned int head;
	};
	int page;
};

struct perf_addr_filter_range {
	long unsigned int start;
	long unsigned int size;
};

struct perf_sample_data {
	u64 addr;
	struct perf_raw_record *raw;
	struct perf_branch_stack *br_stack;
	u64 period;
	u64 weight;
	u64 txn;
	union perf_mem_data_src data_src;
	u64 type;
	u64 ip;
	struct {
		u32 pid;
		u32 tid;
	} tid_entry;
	u64 time;
	u64 id;
	u64 stream_id;
	struct {
		u32 cpu;
		u32 reserved;
	} cpu_entry;
	struct perf_callchain_entry *callchain;
	u64 aux_size;
	struct perf_regs regs_user;
	struct perf_regs regs_intr;
	u64 stack_user_size;
	u64 phys_addr;
	u64 cgroup;
	long: 64;
};

struct trace_entry {
	short unsigned int type;
	unsigned char flags;
	unsigned char preempt_count;
	int pid;
};

struct trace_array;

struct tracer;

struct array_buffer;

struct ring_buffer_iter;

struct trace_iterator {
	struct trace_array *tr;
	struct tracer *trace;
	struct array_buffer *array_buffer;
	void *private;
	int cpu_file;
	struct mutex mutex;
	struct ring_buffer_iter **buffer_iter;
	long unsigned int iter_flags;
	void *temp;
	unsigned int temp_size;
	struct trace_seq tmp_seq;
	cpumask_var_t started;
	bool snapshot;
	struct trace_seq seq;
	struct trace_entry *ent;
	long unsigned int lost_events;
	int leftover;
	int ent_size;
	int cpu;
	u64 ts;
	loff_t pos;
	long int idx;
};

enum print_line_t {
	TRACE_TYPE_PARTIAL_LINE = 0,
	TRACE_TYPE_HANDLED = 1,
	TRACE_TYPE_UNHANDLED = 2,
	TRACE_TYPE_NO_CONSUME = 3,
};

typedef enum print_line_t (*trace_print_func)(struct trace_iterator *, int, struct trace_event *);

struct trace_event_functions {
	trace_print_func trace;
	trace_print_func raw;
	trace_print_func hex;
	trace_print_func binary;
};

enum trace_reg {
	TRACE_REG_REGISTER = 0,
	TRACE_REG_UNREGISTER = 1,
	TRACE_REG_PERF_REGISTER = 2,
	TRACE_REG_PERF_UNREGISTER = 3,
	TRACE_REG_PERF_OPEN = 4,
	TRACE_REG_PERF_CLOSE = 5,
	TRACE_REG_PERF_ADD = 6,
	TRACE_REG_PERF_DEL = 7,
};

struct trace_event_fields {
	const char *type;
	union {
		struct {
			const char *name;
			const int size;
			const int align;
			const int is_signed;
			const int filter_type;
		};
		int (*define_fields)(struct trace_event_call *);
	};
};

struct trace_event_class {
	const char *system;
	void *probe;
	void *perf_probe;
	int (*reg)(struct trace_event_call *, enum trace_reg, void *);
	struct trace_event_fields *fields_array;
	struct list_head * (*get_fields)(struct trace_event_call *);
	struct list_head fields;
	int (*raw_init)(struct trace_event_call *);
};

struct trace_buffer;

struct trace_event_file;

struct trace_event_buffer {
	struct trace_buffer *buffer;
	struct ring_buffer_event *event;
	struct trace_event_file *trace_file;
	void *entry;
	long unsigned int flags;
	int pc;
	struct pt_regs *regs;
};

struct trace_subsystem_dir;

struct trace_event_file {
	struct list_head list;
	struct trace_event_call *event_call;
	struct event_filter *filter;
	struct dentry *dir;
	struct trace_array *tr;
	struct trace_subsystem_dir *system;
	struct list_head triggers;
	long unsigned int flags;
	atomic_t sm_ref;
	atomic_t tm_ref;
};

enum {
	TRACE_EVENT_FL_FILTERED_BIT = 0,
	TRACE_EVENT_FL_CAP_ANY_BIT = 1,
	TRACE_EVENT_FL_NO_SET_FILTER_BIT = 2,
	TRACE_EVENT_FL_IGNORE_ENABLE_BIT = 3,
	TRACE_EVENT_FL_TRACEPOINT_BIT = 4,
	TRACE_EVENT_FL_KPROBE_BIT = 5,
	TRACE_EVENT_FL_UPROBE_BIT = 6,
};

enum {
	TRACE_EVENT_FL_FILTERED = 1,
	TRACE_EVENT_FL_CAP_ANY = 2,
	TRACE_EVENT_FL_NO_SET_FILTER = 4,
	TRACE_EVENT_FL_IGNORE_ENABLE = 8,
	TRACE_EVENT_FL_TRACEPOINT = 16,
	TRACE_EVENT_FL_KPROBE = 32,
	TRACE_EVENT_FL_UPROBE = 64,
};

enum {
	EVENT_FILE_FL_ENABLED_BIT = 0,
	EVENT_FILE_FL_RECORDED_CMD_BIT = 1,
	EVENT_FILE_FL_RECORDED_TGID_BIT = 2,
	EVENT_FILE_FL_FILTERED_BIT = 3,
	EVENT_FILE_FL_NO_SET_FILTER_BIT = 4,
	EVENT_FILE_FL_SOFT_MODE_BIT = 5,
	EVENT_FILE_FL_SOFT_DISABLED_BIT = 6,
	EVENT_FILE_FL_TRIGGER_MODE_BIT = 7,
	EVENT_FILE_FL_TRIGGER_COND_BIT = 8,
	EVENT_FILE_FL_PID_FILTER_BIT = 9,
	EVENT_FILE_FL_WAS_ENABLED_BIT = 10,
};

enum {
	EVENT_FILE_FL_ENABLED = 1,
	EVENT_FILE_FL_RECORDED_CMD = 2,
	EVENT_FILE_FL_RECORDED_TGID = 4,
	EVENT_FILE_FL_FILTERED = 8,
	EVENT_FILE_FL_NO_SET_FILTER = 16,
	EVENT_FILE_FL_SOFT_MODE = 32,
	EVENT_FILE_FL_SOFT_DISABLED = 64,
	EVENT_FILE_FL_TRIGGER_MODE = 128,
	EVENT_FILE_FL_TRIGGER_COND = 256,
	EVENT_FILE_FL_PID_FILTER = 512,
	EVENT_FILE_FL_WAS_ENABLED = 1024,
};

enum {
	FILTER_OTHER = 0,
	FILTER_STATIC_STRING = 1,
	FILTER_DYN_STRING = 2,
	FILTER_PTR_STRING = 3,
	FILTER_TRACE_FN = 4,
	FILTER_COMM = 5,
	FILTER_CPU = 6,
};

struct property {
	char *name;
	int length;
	void *value;
	struct property *next;
	struct bin_attribute attr;
};

enum wb_stat_item {
	WB_RECLAIMABLE = 0,
	WB_WRITEBACK = 1,
	WB_DIRTIED = 2,
	WB_WRITTEN = 3,
	NR_WB_STAT_ITEMS = 4,
};

struct disk_stats;

struct partition_meta_info;

struct hd_struct {
	sector_t start_sect;
	sector_t nr_sects;
	long unsigned int stamp;
	struct disk_stats *dkstats;
	struct percpu_ref ref;
	struct device __dev;
	struct kobject *holder_dir;
	int policy;
	int partno;
	struct partition_meta_info *info;
	struct rcu_work rcu_work;
};

struct disk_part_tbl;

struct block_device_operations;

struct timer_rand_state;

struct disk_events;

struct badblocks;

struct gendisk {
	int major;
	int first_minor;
	int minors;
	char disk_name[32];
	short unsigned int events;
	short unsigned int event_flags;
	struct disk_part_tbl *part_tbl;
	struct hd_struct part0;
	const struct block_device_operations *fops;
	struct request_queue *queue;
	void *private_data;
	int flags;
	long unsigned int state;
	struct rw_semaphore lookup_sem;
	struct kobject *slave_dir;
	struct timer_rand_state *random;
	atomic_t sync_io;
	struct disk_events *ev;
	int node_id;
	struct badblocks *bb;
	struct lockdep_map lockdep_map;
};

typedef __u32 blk_mq_req_flags_t;

typedef unsigned int blk_qc_t;

struct partition_meta_info {
	char uuid[37];
	u8 volname[64];
};

struct disk_part_tbl {
	struct callback_head callback_head;
	int len;
	struct hd_struct *last_lookup;
	struct hd_struct *part[0];
};

struct blk_zone;

typedef int (*report_zones_cb)(struct blk_zone *, unsigned int, void *);

struct hd_geometry;

struct pr_ops;

struct block_device_operations {
	blk_qc_t (*submit_bio)(struct bio *);
	int (*open)(struct block_device *, fmode_t);
	void (*release)(struct gendisk *, fmode_t);
	int (*rw_page)(struct block_device *, sector_t, struct page *, unsigned int);
	int (*ioctl)(struct block_device *, fmode_t, unsigned int, long unsigned int);
	int (*compat_ioctl)(struct block_device *, fmode_t, unsigned int, long unsigned int);
	unsigned int (*check_events)(struct gendisk *, unsigned int);
	void (*unlock_native_capacity)(struct gendisk *);
	int (*revalidate_disk)(struct gendisk *);
	int (*getgeo)(struct block_device *, struct hd_geometry *);
	void (*swap_slot_free_notify)(struct block_device *, long unsigned int);
	int (*report_zones)(struct gendisk *, sector_t, unsigned int, report_zones_cb, void *);
	char * (*devnode)(struct gendisk *, umode_t *);
	struct module *owner;
	const struct pr_ops *pr_ops;
};

struct sg_io_v4 {
	__s32 guard;
	__u32 protocol;
	__u32 subprotocol;
	__u32 request_len;
	__u64 request;
	__u64 request_tag;
	__u32 request_attr;
	__u32 request_priority;
	__u32 request_extra;
	__u32 max_response_len;
	__u64 response;
	__u32 dout_iovec_count;
	__u32 dout_xfer_len;
	__u32 din_iovec_count;
	__u32 din_xfer_len;
	__u64 dout_xferp;
	__u64 din_xferp;
	__u32 timeout;
	__u32 flags;
	__u64 usr_ptr;
	__u32 spare_in;
	__u32 driver_status;
	__u32 transport_status;
	__u32 device_status;
	__u32 retry_delay;
	__u32 info;
	__u32 duration;
	__u32 response_len;
	__s32 din_resid;
	__s32 dout_resid;
	__u64 generated_tag;
	__u32 spare_out;
	__u32 padding;
};

struct bsg_ops {
	int (*check_proto)(struct sg_io_v4 *);
	int (*fill_hdr)(struct request *, struct sg_io_v4 *, fmode_t);
	int (*complete_rq)(struct request *, struct sg_io_v4 *);
	void (*free_rq)(struct request *);
};

typedef __u32 req_flags_t;

typedef void rq_end_io_fn(struct request *, blk_status_t);

enum mq_rq_state {
	MQ_RQ_IDLE = 0,
	MQ_RQ_IN_FLIGHT = 1,
	MQ_RQ_COMPLETE = 2,
};

struct request {
	struct request_queue *q;
	struct blk_mq_ctx *mq_ctx;
	struct blk_mq_hw_ctx *mq_hctx;
	unsigned int cmd_flags;
	req_flags_t rq_flags;
	int tag;
	int internal_tag;
	unsigned int __data_len;
	sector_t __sector;
	struct bio *bio;
	struct bio *biotail;
	struct list_head queuelist;
	union {
		struct hlist_node hash;
		struct list_head ipi_list;
	};
	union {
		struct rb_node rb_node;
		struct bio_vec special_vec;
		void *completion_data;
		int error_count;
	};
	union {
		struct {
			struct io_cq *icq;
			void *priv[2];
		} elv;
		struct {
			unsigned int seq;
			struct list_head list;
			rq_end_io_fn *saved_end_io;
		} flush;
	};
	struct gendisk *rq_disk;
	struct hd_struct *part;
	u64 start_time_ns;
	u64 io_start_time_ns;
	short unsigned int stats_sectors;
	short unsigned int nr_phys_segments;
	short unsigned int write_hint;
	short unsigned int ioprio;
	enum mq_rq_state state;
	refcount_t ref;
	unsigned int timeout;
	long unsigned int deadline;
	union {
		struct __call_single_data csd;
		u64 fifo_time;
	};
	rq_end_io_fn *end_io;
	void *end_io_data;
};

struct blk_zone {
	__u64 start;
	__u64 len;
	__u64 wp;
	__u8 type;
	__u8 cond;
	__u8 non_seq;
	__u8 reset;
	__u8 resv[4];
	__u64 capacity;
	__u8 reserved[24];
};

struct sbitmap_word;

struct sbitmap {
	unsigned int depth;
	unsigned int shift;
	unsigned int map_nr;
	struct sbitmap_word *map;
};

struct blk_mq_tags;

struct blk_mq_hw_ctx {
	struct {
		spinlock_t lock;
		struct list_head dispatch;
		long unsigned int state;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
	};
	struct delayed_work run_work;
	cpumask_var_t cpumask;
	int next_cpu;
	int next_cpu_batch;
	long unsigned int flags;
	void *sched_data;
	struct request_queue *queue;
	struct blk_flush_queue *fq;
	void *driver_data;
	struct sbitmap ctx_map;
	struct blk_mq_ctx *dispatch_from;
	unsigned int dispatch_busy;
	short unsigned int type;
	short unsigned int nr_ctx;
	struct blk_mq_ctx **ctxs;
	spinlock_t dispatch_wait_lock;
	wait_queue_entry_t dispatch_wait;
	atomic_t wait_index;
	struct blk_mq_tags *tags;
	struct blk_mq_tags *sched_tags;
	long unsigned int queued;
	long unsigned int run;
	long unsigned int dispatched[7];
	unsigned int numa_node;
	unsigned int queue_num;
	atomic_t nr_active;
	struct hlist_node cpuhp_online;
	struct hlist_node cpuhp_dead;
	struct kobject kobj;
	long unsigned int poll_considered;
	long unsigned int poll_invoked;
	long unsigned int poll_success;
	struct dentry *debugfs_dir;
	struct dentry *sched_debugfs_dir;
	struct list_head hctx_list;
	struct srcu_struct srcu[0];
	long: 64;
};

enum elv_merge {
	ELEVATOR_NO_MERGE = 0,
	ELEVATOR_FRONT_MERGE = 1,
	ELEVATOR_BACK_MERGE = 2,
	ELEVATOR_DISCARD_MERGE = 3,
};

struct elevator_type;

struct blk_mq_alloc_data;

struct elevator_mq_ops {
	int (*init_sched)(struct request_queue *, struct elevator_type *);
	void (*exit_sched)(struct elevator_queue *);
	int (*init_hctx)(struct blk_mq_hw_ctx *, unsigned int);
	void (*exit_hctx)(struct blk_mq_hw_ctx *, unsigned int);
	void (*depth_updated)(struct blk_mq_hw_ctx *);
	bool (*allow_merge)(struct request_queue *, struct request *, struct bio *);
	bool (*bio_merge)(struct request_queue *, struct bio *, unsigned int);
	int (*request_merge)(struct request_queue *, struct request **, struct bio *);
	void (*request_merged)(struct request_queue *, struct request *, enum elv_merge);
	void (*requests_merged)(struct request_queue *, struct request *, struct request *);
	void (*limit_depth)(unsigned int, struct blk_mq_alloc_data *);
	void (*prepare_request)(struct request *);
	void (*finish_request)(struct request *);
	void (*insert_requests)(struct blk_mq_hw_ctx *, struct list_head *, bool);
	struct request * (*dispatch_request)(struct blk_mq_hw_ctx *);
	bool (*has_work)(struct blk_mq_hw_ctx *);
	void (*completed_request)(struct request *, u64);
	void (*requeue_request)(struct request *);
	struct request * (*former_request)(struct request_queue *, struct request *);
	struct request * (*next_request)(struct request_queue *, struct request *);
	void (*init_icq)(struct io_cq *);
	void (*exit_icq)(struct io_cq *);
};

struct elv_fs_entry;

struct blk_mq_debugfs_attr;

struct elevator_type {
	struct kmem_cache *icq_cache;
	struct elevator_mq_ops ops;
	size_t icq_size;
	size_t icq_align;
	struct elv_fs_entry *elevator_attrs;
	const char *elevator_name;
	const char *elevator_alias;
	const unsigned int elevator_features;
	struct module *elevator_owner;
	const struct blk_mq_debugfs_attr *queue_debugfs_attrs;
	const struct blk_mq_debugfs_attr *hctx_debugfs_attrs;
	char icq_cache_name[22];
	struct list_head list;
};

struct elevator_queue {
	struct elevator_type *type;
	void *elevator_data;
	struct kobject kobj;
	struct mutex sysfs_lock;
	unsigned int registered: 1;
	struct hlist_head hash[64];
};

struct elv_fs_entry {
	struct attribute attr;
	ssize_t (*show)(struct elevator_queue *, char *);
	ssize_t (*store)(struct elevator_queue *, const char *, size_t);
};

struct blk_mq_debugfs_attr {
	const char *name;
	umode_t mode;
	int (*show)(void *, struct seq_file *);
	ssize_t (*write)(void *, const char *, size_t, loff_t *);
	const struct seq_operations *seq_ops;
};

enum blk_eh_timer_return {
	BLK_EH_DONE = 0,
	BLK_EH_RESET_TIMER = 1,
};

struct blk_mq_queue_data;

struct blk_mq_ops {
	blk_status_t (*queue_rq)(struct blk_mq_hw_ctx *, const struct blk_mq_queue_data *);
	void (*commit_rqs)(struct blk_mq_hw_ctx *);
	bool (*get_budget)(struct request_queue *);
	void (*put_budget)(struct request_queue *);
	enum blk_eh_timer_return (*timeout)(struct request *, bool);
	int (*poll)(struct blk_mq_hw_ctx *);
	void (*complete)(struct request *);
	int (*init_hctx)(struct blk_mq_hw_ctx *, void *, unsigned int);
	void (*exit_hctx)(struct blk_mq_hw_ctx *, unsigned int);
	int (*init_request)(struct blk_mq_tag_set *, struct request *, unsigned int, unsigned int);
	void (*exit_request)(struct blk_mq_tag_set *, struct request *, unsigned int);
	void (*initialize_rq_fn)(struct request *);
	void (*cleanup_rq)(struct request *);
	bool (*busy)(struct request_queue *);
	int (*map_queues)(struct blk_mq_tag_set *);
	void (*show_rq)(struct seq_file *, struct request *);
};

struct blk_mq_queue_map {
	unsigned int *mq_map;
	unsigned int nr_queues;
	unsigned int queue_offset;
};

struct sbq_wait_state;

struct sbitmap_queue {
	struct sbitmap sb;
	unsigned int *alloc_hint;
	unsigned int wake_batch;
	atomic_t wake_index;
	struct sbq_wait_state *ws;
	atomic_t ws_active;
	bool round_robin;
	unsigned int min_shallow_depth;
};

struct blk_mq_tag_set {
	struct blk_mq_queue_map map[3];
	unsigned int nr_maps;
	const struct blk_mq_ops *ops;
	unsigned int nr_hw_queues;
	unsigned int queue_depth;
	unsigned int reserved_tags;
	unsigned int cmd_size;
	int numa_node;
	unsigned int timeout;
	unsigned int flags;
	void *driver_data;
	atomic_t active_queues_shared_sbitmap;
	struct sbitmap_queue __bitmap_tags;
	struct sbitmap_queue __breserved_tags;
	struct blk_mq_tags **tags;
	struct mutex tag_list_lock;
	struct list_head tag_list;
};

enum pr_type {
	PR_WRITE_EXCLUSIVE = 1,
	PR_EXCLUSIVE_ACCESS = 2,
	PR_WRITE_EXCLUSIVE_REG_ONLY = 3,
	PR_EXCLUSIVE_ACCESS_REG_ONLY = 4,
	PR_WRITE_EXCLUSIVE_ALL_REGS = 5,
	PR_EXCLUSIVE_ACCESS_ALL_REGS = 6,
};

struct pr_ops {
	int (*pr_register)(struct block_device *, u64, u64, u32);
	int (*pr_reserve)(struct block_device *, u64, enum pr_type, u32);
	int (*pr_release)(struct block_device *, u64, enum pr_type);
	int (*pr_preempt)(struct block_device *, u64, u64, enum pr_type, bool);
	int (*pr_clear)(struct block_device *, u64);
};

struct sbitmap_word {
	long unsigned int depth;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long unsigned int word;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long unsigned int cleared;
	spinlock_t swap_lock;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct sbq_wait_state {
	atomic_t wait_cnt;
	wait_queue_head_t wait;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

enum hctx_type {
	HCTX_TYPE_DEFAULT = 0,
	HCTX_TYPE_READ = 1,
	HCTX_TYPE_POLL = 2,
	HCTX_MAX_TYPES = 3,
};

struct blk_mq_queue_data {
	struct request *rq;
	bool last;
};

struct percpu_cluster {
	struct swap_cluster_info index;
	unsigned int next;
};

enum fs_value_type {
	fs_value_is_undefined = 0,
	fs_value_is_flag = 1,
	fs_value_is_string = 2,
	fs_value_is_blob = 3,
	fs_value_is_filename = 4,
	fs_value_is_file = 5,
};

struct fs_parameter {
	const char *key;
	enum fs_value_type type: 8;
	union {
		char *string;
		void *blob;
		struct filename *name;
		struct file *file;
	};
	size_t size;
	int dirfd;
};

struct fc_log {
	refcount_t usage;
	u8 head;
	u8 tail;
	u8 need_free;
	struct module *owner;
	char *buffer[8];
};

struct fs_context_operations {
	void (*free)(struct fs_context *);
	int (*dup)(struct fs_context *, struct fs_context *);
	int (*parse_param)(struct fs_context *, struct fs_parameter *);
	int (*parse_monolithic)(struct fs_context *, void *);
	int (*get_tree)(struct fs_context *);
	int (*reconfigure)(struct fs_context *);
};

struct fs_parse_result {
	bool negated;
	union {
		bool boolean;
		int int_32;
		unsigned int uint_32;
		u64 uint_64;
	};
};

struct trace_event_raw_initcall_level {
	struct trace_entry ent;
	u32 __data_loc_level;
	char __data[0];
};

struct trace_event_raw_initcall_start {
	struct trace_entry ent;
	initcall_t func;
	char __data[0];
};

struct trace_event_raw_initcall_finish {
	struct trace_entry ent;
	initcall_t func;
	int ret;
	char __data[0];
};

struct trace_event_data_offsets_initcall_level {
	u32 level;
};

struct trace_event_data_offsets_initcall_start {};

struct trace_event_data_offsets_initcall_finish {};

typedef void (*btf_trace_initcall_level)(void *, const char *);

typedef void (*btf_trace_initcall_start)(void *, initcall_t);

typedef void (*btf_trace_initcall_finish)(void *, initcall_t, int);

struct blacklist_entry {
	struct list_head next;
	char *buf;
};

typedef __u32 Elf32_Word;

struct elf32_note {
	Elf32_Word n_namesz;
	Elf32_Word n_descsz;
	Elf32_Word n_type;
};

enum pcpu_fc {
	PCPU_FC_AUTO = 0,
	PCPU_FC_EMBED = 1,
	PCPU_FC_PAGE = 2,
	PCPU_FC_NR = 3,
};

enum hrtimer_base_type {
	HRTIMER_BASE_MONOTONIC = 0,
	HRTIMER_BASE_REALTIME = 1,
	HRTIMER_BASE_BOOTTIME = 2,
	HRTIMER_BASE_TAI = 3,
	HRTIMER_BASE_MONOTONIC_SOFT = 4,
	HRTIMER_BASE_REALTIME_SOFT = 5,
	HRTIMER_BASE_BOOTTIME_SOFT = 6,
	HRTIMER_BASE_TAI_SOFT = 7,
	HRTIMER_MAX_CLOCK_BASES = 8,
};

enum {
	MM_FILEPAGES = 0,
	MM_ANONPAGES = 1,
	MM_SWAPENTS = 2,
	MM_SHMEMPAGES = 3,
	NR_MM_COUNTERS = 4,
};

enum rseq_cs_flags_bit {
	RSEQ_CS_FLAG_NO_RESTART_ON_PREEMPT_BIT = 0,
	RSEQ_CS_FLAG_NO_RESTART_ON_SIGNAL_BIT = 1,
	RSEQ_CS_FLAG_NO_RESTART_ON_MIGRATE_BIT = 2,
};

enum perf_event_task_context {
	perf_invalid_context = 4294967295,
	perf_hw_context = 0,
	perf_sw_context = 1,
	perf_nr_task_contexts = 2,
};

enum {
	PROC_ROOT_INO = 1,
	PROC_IPC_INIT_INO = 4026531839,
	PROC_UTS_INIT_INO = 4026531838,
	PROC_USER_INIT_INO = 4026531837,
	PROC_PID_INIT_INO = 4026531836,
	PROC_CGROUP_INIT_INO = 4026531835,
	PROC_TIME_INIT_INO = 4026531834,
};

typedef short int __s16;

typedef __s16 s16;

typedef __u16 __be16;

typedef __u32 __be32;

typedef __u32 __wsum;

typedef unsigned int slab_flags_t;

struct llist_head {
	struct llist_node *first;
};

struct notifier_block;

typedef int (*notifier_fn_t)(struct notifier_block *, long unsigned int, void *);

struct notifier_block {
	notifier_fn_t notifier_call;
	struct notifier_block *next;
	int priority;
};

struct blocking_notifier_head {
	struct rw_semaphore rwsem;
	struct notifier_block *head;
};

struct raw_notifier_head {
	struct notifier_block *head;
};

struct rhash_head {
	struct rhash_head *next;
};

struct rhashtable;

struct rhashtable_compare_arg {
	struct rhashtable *ht;
	const void *key;
};

typedef u32 (*rht_hashfn_t)(const void *, u32, u32);

typedef u32 (*rht_obj_hashfn_t)(const void *, u32, u32);

typedef int (*rht_obj_cmpfn_t)(struct rhashtable_compare_arg *, const void *);

struct rhashtable_params {
	u16 nelem_hint;
	u16 key_len;
	u16 key_offset;
	u16 head_offset;
	unsigned int max_size;
	u16 min_size;
	bool automatic_shrinking;
	rht_hashfn_t hashfn;
	rht_obj_hashfn_t obj_hashfn;
	rht_obj_cmpfn_t obj_cmpfn;
};

struct bucket_table;

struct rhashtable {
	struct bucket_table *tbl;
	unsigned int key_len;
	unsigned int max_elems;
	struct rhashtable_params p;
	bool rhlist;
	struct work_struct run_work;
	struct mutex mutex;
	spinlock_t lock;
	atomic_t nelems;
};

struct pipe_buffer;

struct pipe_inode_info {
	struct mutex mutex;
	wait_queue_head_t rd_wait;
	wait_queue_head_t wr_wait;
	unsigned int head;
	unsigned int tail;
	unsigned int max_usage;
	unsigned int ring_size;
	unsigned int nr_accounted;
	unsigned int readers;
	unsigned int writers;
	unsigned int files;
	unsigned int r_counter;
	unsigned int w_counter;
	struct page *tmp_page;
	struct fasync_struct *fasync_readers;
	struct fasync_struct *fasync_writers;
	struct pipe_buffer *bufs;
	struct user_struct *user;
};

typedef short unsigned int __kernel_sa_family_t;

typedef __kernel_sa_family_t sa_family_t;

struct sockaddr {
	sa_family_t sa_family;
	char sa_data[14];
};

struct msghdr {
	void *msg_name;
	int msg_namelen;
	struct iov_iter msg_iter;
	union {
		void *msg_control;
		void *msg_control_user;
	};
	bool msg_control_is_user: 1;
	__kernel_size_t msg_controllen;
	unsigned int msg_flags;
	struct kiocb *msg_iocb;
};

typedef struct {
	unsigned int clock_rate;
	unsigned int clock_type;
	short unsigned int loopback;
} sync_serial_settings;

typedef struct {
	unsigned int clock_rate;
	unsigned int clock_type;
	short unsigned int loopback;
	unsigned int slot_map;
} te1_settings;

typedef struct {
	short unsigned int encoding;
	short unsigned int parity;
} raw_hdlc_proto;

typedef struct {
	unsigned int t391;
	unsigned int t392;
	unsigned int n391;
	unsigned int n392;
	unsigned int n393;
	short unsigned int lmi;
	short unsigned int dce;
} fr_proto;

typedef struct {
	unsigned int dlci;
} fr_proto_pvc;

typedef struct {
	unsigned int dlci;
	char master[16];
} fr_proto_pvc_info;

typedef struct {
	unsigned int interval;
	unsigned int timeout;
} cisco_proto;

typedef struct {
	short unsigned int dce;
	unsigned int modulo;
	unsigned int window;
	unsigned int t1;
	unsigned int t2;
	unsigned int n2;
} x25_hdlc_proto;

struct ifmap {
	long unsigned int mem_start;
	long unsigned int mem_end;
	short unsigned int base_addr;
	unsigned char irq;
	unsigned char dma;
	unsigned char port;
};

struct if_settings {
	unsigned int type;
	unsigned int size;
	union {
		raw_hdlc_proto *raw_hdlc;
		cisco_proto *cisco;
		fr_proto *fr;
		fr_proto_pvc *fr_pvc;
		fr_proto_pvc_info *fr_pvc_info;
		x25_hdlc_proto *x25;
		sync_serial_settings *sync;
		te1_settings *te1;
	} ifs_ifsu;
};

struct ifreq {
	union {
		char ifrn_name[16];
	} ifr_ifrn;
	union {
		struct sockaddr ifru_addr;
		struct sockaddr ifru_dstaddr;
		struct sockaddr ifru_broadaddr;
		struct sockaddr ifru_netmask;
		struct sockaddr ifru_hwaddr;
		short int ifru_flags;
		int ifru_ivalue;
		int ifru_mtu;
		struct ifmap ifru_map;
		char ifru_slave[16];
		char ifru_newname[16];
		void *ifru_data;
		struct if_settings ifru_settings;
	} ifr_ifru;
};

struct vfsmount {
	struct dentry *mnt_root;
	struct super_block *mnt_sb;
	int mnt_flags;
};

struct fs_struct {
	int users;
	spinlock_t lock;
	seqcount_spinlock_t seq;
	int umask;
	int in_exec;
	struct path root;
	struct path pwd;
};

struct ld_semaphore {
	atomic_long_t count;
	raw_spinlock_t wait_lock;
	unsigned int wait_readers;
	struct list_head read_wait;
	struct list_head write_wait;
};

typedef unsigned int tcflag_t;

typedef unsigned char cc_t;

typedef unsigned int speed_t;

struct ktermios {
	tcflag_t c_iflag;
	tcflag_t c_oflag;
	tcflag_t c_cflag;
	tcflag_t c_lflag;
	cc_t c_line;
	cc_t c_cc[19];
	speed_t c_ispeed;
	speed_t c_ospeed;
};

struct winsize {
	short unsigned int ws_row;
	short unsigned int ws_col;
	short unsigned int ws_xpixel;
	short unsigned int ws_ypixel;
};

struct tty_driver;

struct tty_operations;

struct tty_ldisc;

struct termiox;

struct tty_port;

struct tty_struct {
	int magic;
	struct kref kref;
	struct device *dev;
	struct tty_driver *driver;
	const struct tty_operations *ops;
	int index;
	struct ld_semaphore ldisc_sem;
	struct tty_ldisc *ldisc;
	struct mutex atomic_write_lock;
	struct mutex legacy_mutex;
	struct mutex throttle_mutex;
	struct rw_semaphore termios_rwsem;
	struct mutex winsize_mutex;
	spinlock_t ctrl_lock;
	spinlock_t flow_lock;
	struct ktermios termios;
	struct ktermios termios_locked;
	struct termiox *termiox;
	char name[64];
	struct pid *pgrp;
	struct pid *session;
	long unsigned int flags;
	int count;
	struct winsize winsize;
	long unsigned int stopped: 1;
	long unsigned int flow_stopped: 1;
	int: 30;
	long unsigned int unused: 62;
	int hw_stopped;
	long unsigned int ctrl_status: 8;
	long unsigned int packet: 1;
	int: 23;
	long unsigned int unused_ctrl: 55;
	unsigned int receive_room;
	int flow_change;
	struct tty_struct *link;
	struct fasync_struct *fasync;
	wait_queue_head_t write_wait;
	wait_queue_head_t read_wait;
	struct work_struct hangup_work;
	void *disc_data;
	void *driver_data;
	spinlock_t files_lock;
	struct list_head tty_files;
	int closing;
	unsigned char *write_buf;
	int write_cnt;
	struct work_struct SAK_work;
	struct tty_port *port;
};

typedef struct {
	size_t written;
	size_t count;
	union {
		char *buf;
		void *data;
	} arg;
	int error;
} read_descriptor_t;

struct posix_acl_entry {
	short int e_tag;
	short unsigned int e_perm;
	union {
		kuid_t e_uid;
		kgid_t e_gid;
	};
};

struct posix_acl {
	refcount_t a_refcount;
	struct callback_head a_rcu;
	unsigned int a_count;
	struct posix_acl_entry a_entries[0];
};

typedef __u64 __addrpair;

typedef __u32 __portpair;

typedef struct {
	struct net *net;
} possible_net_t;

struct in6_addr {
	union {
		__u8 u6_addr8[16];
		__be16 u6_addr16[8];
		__be32 u6_addr32[4];
	} in6_u;
};

struct hlist_nulls_node {
	struct hlist_nulls_node *next;
	struct hlist_nulls_node **pprev;
};

struct proto;

struct inet_timewait_death_row;

struct sock_common {
	union {
		__addrpair skc_addrpair;
		struct {
			__be32 skc_daddr;
			__be32 skc_rcv_saddr;
		};
	};
	union {
		unsigned int skc_hash;
		__u16 skc_u16hashes[2];
	};
	union {
		__portpair skc_portpair;
		struct {
			__be16 skc_dport;
			__u16 skc_num;
		};
	};
	short unsigned int skc_family;
	volatile unsigned char skc_state;
	unsigned char skc_reuse: 4;
	unsigned char skc_reuseport: 1;
	unsigned char skc_ipv6only: 1;
	unsigned char skc_net_refcnt: 1;
	int skc_bound_dev_if;
	union {
		struct hlist_node skc_bind_node;
		struct hlist_node skc_portaddr_node;
	};
	struct proto *skc_prot;
	possible_net_t skc_net;
	struct in6_addr skc_v6_daddr;
	struct in6_addr skc_v6_rcv_saddr;
	atomic64_t skc_cookie;
	union {
		long unsigned int skc_flags;
		struct sock *skc_listener;
		struct inet_timewait_death_row *skc_tw_dr;
	};
	int skc_dontcopy_begin[0];
	union {
		struct hlist_node skc_node;
		struct hlist_nulls_node skc_nulls_node;
	};
	short unsigned int skc_tx_queue_mapping;
	short unsigned int skc_rx_queue_mapping;
	union {
		int skc_incoming_cpu;
		u32 skc_rcv_wnd;
		u32 skc_tw_rcv_nxt;
	};
	refcount_t skc_refcnt;
	int skc_dontcopy_end[0];
	union {
		u32 skc_rxhash;
		u32 skc_window_clamp;
		u32 skc_tw_snd_nxt;
	};
};

typedef struct {
	spinlock_t slock;
	int owned;
	wait_queue_head_t wq;
} socket_lock_t;

struct sk_buff;

struct sk_buff_head {
	struct sk_buff *next;
	struct sk_buff *prev;
	__u32 qlen;
	spinlock_t lock;
};

typedef u64 netdev_features_t;

struct sock_cgroup_data {};

struct sk_filter;

struct socket_wq;

struct dst_entry;

struct socket;

struct sock_reuseport;

struct bpf_local_storage;

struct sock {
	struct sock_common __sk_common;
	socket_lock_t sk_lock;
	atomic_t sk_drops;
	int sk_rcvlowat;
	struct sk_buff_head sk_error_queue;
	struct sk_buff *sk_rx_skb_cache;
	struct sk_buff_head sk_receive_queue;
	struct {
		atomic_t rmem_alloc;
		int len;
		struct sk_buff *head;
		struct sk_buff *tail;
	} sk_backlog;
	int sk_forward_alloc;
	unsigned int sk_ll_usec;
	unsigned int sk_napi_id;
	int sk_rcvbuf;
	struct sk_filter *sk_filter;
	union {
		struct socket_wq *sk_wq;
		struct socket_wq *sk_wq_raw;
	};
	struct dst_entry *sk_rx_dst;
	struct dst_entry *sk_dst_cache;
	atomic_t sk_omem_alloc;
	int sk_sndbuf;
	int sk_wmem_queued;
	refcount_t sk_wmem_alloc;
	long unsigned int sk_tsq_flags;
	union {
		struct sk_buff *sk_send_head;
		struct rb_root tcp_rtx_queue;
	};
	struct sk_buff *sk_tx_skb_cache;
	struct sk_buff_head sk_write_queue;
	__s32 sk_peek_off;
	int sk_write_pending;
	__u32 sk_dst_pending_confirm;
	u32 sk_pacing_status;
	long int sk_sndtimeo;
	struct timer_list sk_timer;
	__u32 sk_priority;
	__u32 sk_mark;
	long unsigned int sk_pacing_rate;
	long unsigned int sk_max_pacing_rate;
	struct page_frag sk_frag;
	netdev_features_t sk_route_caps;
	netdev_features_t sk_route_nocaps;
	netdev_features_t sk_route_forced_caps;
	int sk_gso_type;
	unsigned int sk_gso_max_size;
	gfp_t sk_allocation;
	__u32 sk_txhash;
	u8 sk_padding: 1;
	u8 sk_kern_sock: 1;
	u8 sk_no_check_tx: 1;
	u8 sk_no_check_rx: 1;
	u8 sk_userlocks: 4;
	u8 sk_pacing_shift;
	u16 sk_type;
	u16 sk_protocol;
	u16 sk_gso_max_segs;
	long unsigned int sk_lingertime;
	struct proto *sk_prot_creator;
	rwlock_t sk_callback_lock;
	int sk_err;
	int sk_err_soft;
	u32 sk_ack_backlog;
	u32 sk_max_ack_backlog;
	kuid_t sk_uid;
	struct pid *sk_peer_pid;
	const struct cred *sk_peer_cred;
	long int sk_rcvtimeo;
	ktime_t sk_stamp;
	u16 sk_tsflags;
	u8 sk_shutdown;
	u32 sk_tskey;
	atomic_t sk_zckey;
	u8 sk_clockid;
	u8 sk_txtime_deadline_mode: 1;
	u8 sk_txtime_report_errors: 1;
	u8 sk_txtime_unused: 6;
	struct socket *sk_socket;
	void *sk_user_data;
	struct sock_cgroup_data sk_cgrp_data;
	struct mem_cgroup *sk_memcg;
	void (*sk_state_change)(struct sock *);
	void (*sk_data_ready)(struct sock *);
	void (*sk_write_space)(struct sock *);
	void (*sk_error_report)(struct sock *);
	int (*sk_backlog_rcv)(struct sock *, struct sk_buff *);
	void (*sk_destruct)(struct sock *);
	struct sock_reuseport *sk_reuseport_cb;
	struct bpf_local_storage *sk_bpf_storage;
	struct callback_head sk_rcu;
	union {
		spinlock_t sk_peer_lock;
		struct {
			u64 android_kabi_reserved1;
		};
		union {		};
	};
};

struct termiox {
	__u16 x_hflag;
	__u16 x_cflag;
	__u16 x_rflag[5];
	__u16 x_sflag;
};

struct serial_icounter_struct;

struct serial_struct;

struct tty_operations {
	struct tty_struct * (*lookup)(struct tty_driver *, struct file *, int);
	int (*install)(struct tty_driver *, struct tty_struct *);
	void (*remove)(struct tty_driver *, struct tty_struct *);
	int (*open)(struct tty_struct *, struct file *);
	void (*close)(struct tty_struct *, struct file *);
	void (*shutdown)(struct tty_struct *);
	void (*cleanup)(struct tty_struct *);
	int (*write)(struct tty_struct *, const unsigned char *, int);
	int (*put_char)(struct tty_struct *, unsigned char);
	void (*flush_chars)(struct tty_struct *);
	int (*write_room)(struct tty_struct *);
	int (*chars_in_buffer)(struct tty_struct *);
	int (*ioctl)(struct tty_struct *, unsigned int, long unsigned int);
	long int (*compat_ioctl)(struct tty_struct *, unsigned int, long unsigned int);
	void (*set_termios)(struct tty_struct *, struct ktermios *);
	void (*throttle)(struct tty_struct *);
	void (*unthrottle)(struct tty_struct *);
	void (*stop)(struct tty_struct *);
	void (*start)(struct tty_struct *);
	void (*hangup)(struct tty_struct *);
	int (*break_ctl)(struct tty_struct *, int);
	void (*flush_buffer)(struct tty_struct *);
	void (*set_ldisc)(struct tty_struct *);
	void (*wait_until_sent)(struct tty_struct *, int);
	void (*send_xchar)(struct tty_struct *, char);
	int (*tiocmget)(struct tty_struct *);
	int (*tiocmset)(struct tty_struct *, unsigned int, unsigned int);
	int (*resize)(struct tty_struct *, struct winsize *);
	int (*set_termiox)(struct tty_struct *, struct termiox *);
	int (*get_icount)(struct tty_struct *, struct serial_icounter_struct *);
	int (*get_serial)(struct tty_struct *, struct serial_struct *);
	int (*set_serial)(struct tty_struct *, struct serial_struct *);
	void (*show_fdinfo)(struct tty_struct *, struct seq_file *);
	int (*proc_show)(struct seq_file *, void *);
};

struct proc_dir_entry;

struct tty_driver {
	int magic;
	struct kref kref;
	struct cdev **cdevs;
	struct module *owner;
	const char *driver_name;
	const char *name;
	int name_base;
	int major;
	int minor_start;
	unsigned int num;
	short int type;
	short int subtype;
	struct ktermios init_termios;
	long unsigned int flags;
	struct proc_dir_entry *proc_entry;
	struct tty_driver *other;
	struct tty_struct **ttys;
	struct tty_port **ports;
	struct ktermios **termios;
	void *driver_state;
	const struct tty_operations *ops;
	struct list_head tty_drivers;
};

struct tty_buffer {
	union {
		struct tty_buffer *next;
		struct llist_node free;
	};
	int used;
	int size;
	int commit;
	int read;
	int flags;
	long unsigned int data[0];
};

struct tty_bufhead {
	struct tty_buffer *head;
	struct work_struct work;
	struct mutex lock;
	atomic_t priority;
	struct tty_buffer sentinel;
	struct llist_head free;
	atomic_t mem_used;
	int mem_limit;
	struct tty_buffer *tail;
};

struct tty_port_operations;

struct tty_port_client_operations;

struct tty_port {
	struct tty_bufhead buf;
	struct tty_struct *tty;
	struct tty_struct *itty;
	const struct tty_port_operations *ops;
	const struct tty_port_client_operations *client_ops;
	spinlock_t lock;
	int blocked_open;
	int count;
	wait_queue_head_t open_wait;
	wait_queue_head_t delta_msr_wait;
	long unsigned int flags;
	long unsigned int iflags;
	unsigned char console: 1;
	unsigned char low_latency: 1;
	struct mutex mutex;
	struct mutex buf_mutex;
	unsigned char *xmit_buf;
	unsigned int close_delay;
	unsigned int closing_wait;
	int drain_delay;
	struct kref kref;
	void *client_data;
};

struct tty_ldisc_ops {
	int magic;
	char *name;
	int num;
	int flags;
	int (*open)(struct tty_struct *);
	void (*close)(struct tty_struct *);
	void (*flush_buffer)(struct tty_struct *);
	ssize_t (*read)(struct tty_struct *, struct file *, unsigned char *, size_t, void **, long unsigned int);
	ssize_t (*write)(struct tty_struct *, struct file *, const unsigned char *, size_t);
	int (*ioctl)(struct tty_struct *, struct file *, unsigned int, long unsigned int);
	int (*compat_ioctl)(struct tty_struct *, struct file *, unsigned int, long unsigned int);
	void (*set_termios)(struct tty_struct *, struct ktermios *);
	__poll_t (*poll)(struct tty_struct *, struct file *, struct poll_table_struct *);
	int (*hangup)(struct tty_struct *);
	void (*receive_buf)(struct tty_struct *, const unsigned char *, char *, int);
	void (*write_wakeup)(struct tty_struct *);
	void (*dcd_change)(struct tty_struct *, unsigned int);
	int (*receive_buf2)(struct tty_struct *, const unsigned char *, char *, int);
	struct module *owner;
	int refcount;
};

struct tty_ldisc {
	struct tty_ldisc_ops *ops;
	struct tty_struct *tty;
};

struct tty_port_operations {
	int (*carrier_raised)(struct tty_port *);
	void (*dtr_rts)(struct tty_port *, int);
	void (*shutdown)(struct tty_port *);
	int (*activate)(struct tty_port *, struct tty_struct *);
	void (*destruct)(struct tty_port *);
};

struct tty_port_client_operations {
	int (*receive_buf)(struct tty_port *, const unsigned char *, const unsigned char *, size_t);
	void (*write_wakeup)(struct tty_port *);
};

struct prot_inuse;

struct netns_core {
	struct ctl_table_header *sysctl_hdr;
	int sysctl_somaxconn;
	int *sock_inuse;
	struct prot_inuse *prot_inuse;
};

struct tcp_mib;

struct ipstats_mib;

struct linux_mib;

struct udp_mib;

struct icmp_mib;

struct icmpmsg_mib;

struct icmpv6_mib;

struct icmpv6msg_mib;

struct netns_mib {
	struct tcp_mib *tcp_statistics;
	struct ipstats_mib *ip_statistics;
	struct linux_mib *net_statistics;
	struct udp_mib *udp_statistics;
	struct udp_mib *udplite_statistics;
	struct icmp_mib *icmp_statistics;
	struct icmpmsg_mib *icmpmsg_statistics;
	struct proc_dir_entry *proc_net_devsnmp6;
	struct udp_mib *udp_stats_in6;
	struct udp_mib *udplite_stats_in6;
	struct ipstats_mib *ipv6_statistics;
	struct icmpv6_mib *icmpv6_statistics;
	struct icmpv6msg_mib *icmpv6msg_statistics;
};

struct netns_packet {
	struct mutex sklist_lock;
	struct hlist_head sklist;
};

struct netns_unix {
	int sysctl_max_dgram_qlen;
	struct ctl_table_header *ctl;
};

struct netns_nexthop {
	struct rb_root rb_root;
	struct hlist_head *devhash;
	unsigned int seq;
	u32 last_id_allocated;
	struct blocking_notifier_head notifier_chain;
};

struct local_ports {
	seqlock_t lock;
	int range[2];
	bool warned;
};

struct inet_hashinfo;

struct inet_timewait_death_row {
	atomic_t tw_count;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct inet_hashinfo *hashinfo;
	int sysctl_max_tw_buckets;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct ping_group_range {
	seqlock_t lock;
	kgid_t range[2];
};

typedef struct {
	u64 key[2];
} siphash_key_t;

struct ipv4_devconf;

struct ip_ra_chain;

struct inet_peer_base;

struct fqdir;

struct tcp_congestion_ops;

struct tcp_fastopen_context;

struct fib_notifier_ops;

struct netns_ipv4 {
	struct ctl_table_header *forw_hdr;
	struct ctl_table_header *frags_hdr;
	struct ctl_table_header *ipv4_hdr;
	struct ctl_table_header *route_hdr;
	struct ctl_table_header *xfrm4_hdr;
	struct ipv4_devconf *devconf_all;
	struct ipv4_devconf *devconf_dflt;
	struct ip_ra_chain *ra_chain;
	struct mutex ra_mutex;
	bool fib_has_custom_local_routes;
	struct hlist_head *fib_table_hash;
	bool fib_offload_disabled;
	struct sock *fibnl;
	struct sock **icmp_sk;
	struct sock *mc_autojoin_sk;
	struct inet_peer_base *peers;
	struct sock **tcp_sk;
	struct fqdir *fqdir;
	int sysctl_icmp_echo_ignore_all;
	int sysctl_icmp_echo_ignore_broadcasts;
	int sysctl_icmp_ignore_bogus_error_responses;
	int sysctl_icmp_ratelimit;
	int sysctl_icmp_ratemask;
	int sysctl_icmp_errors_use_inbound_ifaddr;
	struct local_ports ip_local_ports;
	int sysctl_tcp_ecn;
	int sysctl_tcp_ecn_fallback;
	int sysctl_ip_default_ttl;
	int sysctl_ip_no_pmtu_disc;
	int sysctl_ip_fwd_use_pmtu;
	int sysctl_ip_fwd_update_priority;
	int sysctl_ip_nonlocal_bind;
	int sysctl_ip_autobind_reuse;
	int sysctl_ip_dynaddr;
	int sysctl_ip_early_demux;
	int sysctl_tcp_early_demux;
	int sysctl_udp_early_demux;
	int sysctl_nexthop_compat_mode;
	int sysctl_fwmark_reflect;
	int sysctl_tcp_fwmark_accept;
	int sysctl_tcp_mtu_probing;
	int sysctl_tcp_mtu_probe_floor;
	int sysctl_tcp_base_mss;
	int sysctl_tcp_min_snd_mss;
	int sysctl_tcp_probe_threshold;
	u32 sysctl_tcp_probe_interval;
	int sysctl_tcp_keepalive_time;
	int sysctl_tcp_keepalive_probes;
	int sysctl_tcp_keepalive_intvl;
	int sysctl_tcp_syn_retries;
	int sysctl_tcp_synack_retries;
	int sysctl_tcp_syncookies;
	int sysctl_tcp_reordering;
	int sysctl_tcp_retries1;
	int sysctl_tcp_retries2;
	int sysctl_tcp_orphan_retries;
	int sysctl_tcp_fin_timeout;
	unsigned int sysctl_tcp_notsent_lowat;
	int sysctl_tcp_tw_reuse;
	int sysctl_tcp_sack;
	int sysctl_tcp_window_scaling;
	int sysctl_tcp_timestamps;
	int sysctl_tcp_early_retrans;
	int sysctl_tcp_recovery;
	int sysctl_tcp_thin_linear_timeouts;
	int sysctl_tcp_slow_start_after_idle;
	int sysctl_tcp_retrans_collapse;
	int sysctl_tcp_stdurg;
	int sysctl_tcp_rfc1337;
	int sysctl_tcp_abort_on_overflow;
	int sysctl_tcp_fack;
	int sysctl_tcp_max_reordering;
	int sysctl_tcp_dsack;
	int sysctl_tcp_app_win;
	int sysctl_tcp_adv_win_scale;
	int sysctl_tcp_frto;
	int sysctl_tcp_nometrics_save;
	int sysctl_tcp_no_ssthresh_metrics_save;
	int sysctl_tcp_moderate_rcvbuf;
	int sysctl_tcp_tso_win_divisor;
	int sysctl_tcp_workaround_signed_windows;
	int sysctl_tcp_limit_output_bytes;
	int sysctl_tcp_challenge_ack_limit;
	int sysctl_tcp_min_tso_segs;
	int sysctl_tcp_min_rtt_wlen;
	int sysctl_tcp_autocorking;
	int sysctl_tcp_invalid_ratelimit;
	int sysctl_tcp_pacing_ss_ratio;
	int sysctl_tcp_pacing_ca_ratio;
	int sysctl_tcp_wmem[3];
	int sysctl_tcp_rmem[3];
	int sysctl_tcp_comp_sack_nr;
	long unsigned int sysctl_tcp_comp_sack_delay_ns;
	long unsigned int sysctl_tcp_comp_sack_slack_ns;
	struct inet_timewait_death_row tcp_death_row;
	int sysctl_max_syn_backlog;
	int sysctl_tcp_fastopen;
	const struct tcp_congestion_ops *tcp_congestion_control;
	struct tcp_fastopen_context *tcp_fastopen_ctx;
	spinlock_t tcp_fastopen_ctx_lock;
	unsigned int sysctl_tcp_fastopen_blackhole_timeout;
	atomic_t tfo_active_disable_times;
	long unsigned int tfo_active_disable_stamp;
	int sysctl_tcp_reflect_tos;
	int sysctl_udp_wmem_min;
	int sysctl_udp_rmem_min;
	int sysctl_igmp_max_memberships;
	int sysctl_igmp_max_msf;
	int sysctl_igmp_llm_reports;
	int sysctl_igmp_qrv;
	struct ping_group_range ping_group_range;
	atomic_t dev_addr_genid;
	long unsigned int *sysctl_local_reserved_ports;
	long unsigned int *sysctl_local_unbindable_ports;
	int sysctl_ip_prot_sock;
	struct fib_notifier_ops *notifier_ops;
	unsigned int fib_seq;
	struct fib_notifier_ops *ipmr_notifier_ops;
	unsigned int ipmr_seq;
	atomic_t rt_genid;
	siphash_key_t ip_id_key;
	long: 64;
	long: 64;
	long: 64;
};

struct netns_sysctl_ipv6 {
	struct ctl_table_header *hdr;
	struct ctl_table_header *route_hdr;
	struct ctl_table_header *icmp_hdr;
	struct ctl_table_header *frags_hdr;
	struct ctl_table_header *xfrm6_hdr;
	int bindv6only;
	int flush_delay;
	int ip6_rt_max_size;
	int ip6_rt_gc_min_interval;
	int ip6_rt_gc_timeout;
	int ip6_rt_gc_interval;
	int ip6_rt_gc_elasticity;
	int ip6_rt_mtu_expires;
	int ip6_rt_min_advmss;
	int multipath_hash_policy;
	int flowlabel_consistency;
	int auto_flowlabels;
	int icmpv6_time;
	int icmpv6_echo_ignore_all;
	int icmpv6_echo_ignore_multicast;
	int icmpv6_echo_ignore_anycast;
	long unsigned int icmpv6_ratemask[4];
	long unsigned int *icmpv6_ratemask_ptr;
	int anycast_src_echo_reply;
	int ip_nonlocal_bind;
	int fwmark_reflect;
	int idgen_retries;
	int idgen_delay;
	int flowlabel_state_ranges;
	int flowlabel_reflect;
	int max_dst_opts_cnt;
	int max_hbh_opts_cnt;
	int max_dst_opts_len;
	int max_hbh_opts_len;
	int seg6_flowlabel;
	bool skip_notify_on_dev_down;
};

struct net_device;

struct neighbour;

struct dst_ops {
	short unsigned int family;
	unsigned int gc_thresh;
	int (*gc)(struct dst_ops *);
	struct dst_entry * (*check)(struct dst_entry *, __u32);
	unsigned int (*default_advmss)(const struct dst_entry *);
	unsigned int (*mtu)(const struct dst_entry *);
	u32 * (*cow_metrics)(struct dst_entry *, long unsigned int);
	void (*destroy)(struct dst_entry *);
	void (*ifdown)(struct dst_entry *, struct net_device *, int);
	struct dst_entry * (*negative_advice)(struct dst_entry *);
	void (*link_failure)(struct sk_buff *);
	void (*update_pmtu)(struct dst_entry *, struct sock *, struct sk_buff *, u32, bool);
	void (*redirect)(struct dst_entry *, struct sock *, struct sk_buff *);
	int (*local_out)(struct net *, struct sock *, struct sk_buff *);
	struct neighbour * (*neigh_lookup)(const struct dst_entry *, struct sk_buff *, const void *);
	void (*confirm_neigh)(const struct dst_entry *, const void *);
	struct kmem_cache *kmem_cachep;
	struct percpu_counter pcpuc_entries;
	long: 64;
	long: 64;
	long: 64;
};

struct ipv6_devconf;

struct fib6_info;

struct rt6_info;

struct rt6_statistics;

struct fib6_table;

struct seg6_pernet_data;

struct netns_ipv6 {
	struct netns_sysctl_ipv6 sysctl;
	struct ipv6_devconf *devconf_all;
	struct ipv6_devconf *devconf_dflt;
	struct inet_peer_base *peers;
	struct fqdir *fqdir;
	struct fib6_info *fib6_null_entry;
	struct rt6_info *ip6_null_entry;
	struct rt6_statistics *rt6_stats;
	struct timer_list ip6_fib_timer;
	struct hlist_head *fib_table_hash;
	struct fib6_table *fib6_main_tbl;
	struct list_head fib6_walkers;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct dst_ops ip6_dst_ops;
	rwlock_t fib6_walker_lock;
	spinlock_t fib6_gc_lock;
	unsigned int ip6_rt_gc_expire;
	long unsigned int ip6_rt_last_gc;
	struct sock **icmp_sk;
	struct sock *ndisc_sk;
	struct sock *tcp_sk;
	struct sock *igmp_sk;
	struct sock *mc_autojoin_sk;
	atomic_t dev_addr_genid;
	atomic_t fib6_sernum;
	struct seg6_pernet_data *seg6_data;
	struct fib_notifier_ops *notifier_ops;
	struct fib_notifier_ops *ip6mr_notifier_ops;
	unsigned int ipmr_seq;
	struct {
		struct hlist_head head;
		spinlock_t lock;
		u32 seq;
	} ip6addrlbl_table;
	long: 64;
};

struct netns_bpf {
	struct bpf_prog_array *run_array[2];
	struct bpf_prog *progs[2];
	struct list_head links[2];
};

struct uevent_sock;

struct net_generic;

struct net {
	refcount_t passive;
	refcount_t count;
	spinlock_t rules_mod_lock;
	unsigned int dev_unreg_count;
	unsigned int dev_base_seq;
	int ifindex;
	spinlock_t nsid_lock;
	atomic_t fnhe_genid;
	struct list_head list;
	struct list_head exit_list;
	struct llist_node cleanup_list;
	struct key_tag *key_domain;
	struct user_namespace *user_ns;
	struct ucounts *ucounts;
	struct idr netns_ids;
	struct ns_common ns;
	struct list_head dev_base_head;
	struct proc_dir_entry *proc_net;
	struct proc_dir_entry *proc_net_stat;
	struct ctl_table_set sysctls;
	struct sock *rtnl;
	struct sock *genl_sock;
	struct uevent_sock *uevent_sock;
	struct hlist_head *dev_name_head;
	struct hlist_head *dev_index_head;
	struct raw_notifier_head netdev_chain;
	u32 hash_mix;
	struct net_device *loopback_dev;
	struct list_head rules_ops;
	struct netns_core core;
	struct netns_mib mib;
	struct netns_packet packet;
	struct netns_unix unx;
	struct netns_nexthop nexthop;
	long: 64;
	long: 64;
	long: 64;
	struct netns_ipv4 ipv4;
	struct netns_ipv6 ipv6;
	struct net_generic *gen;
	struct netns_bpf bpf;
	atomic64_t net_cookie;
	struct sock *diag_nlsk;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

typedef struct {
	local64_t v;
} u64_stats_t;

struct bpf_insn {
	__u8 code;
	__u8 dst_reg: 4;
	__u8 src_reg: 4;
	__s16 off;
	__s32 imm;
};

enum bpf_map_type {
	BPF_MAP_TYPE_UNSPEC = 0,
	BPF_MAP_TYPE_HASH = 1,
	BPF_MAP_TYPE_ARRAY = 2,
	BPF_MAP_TYPE_PROG_ARRAY = 3,
	BPF_MAP_TYPE_PERF_EVENT_ARRAY = 4,
	BPF_MAP_TYPE_PERCPU_HASH = 5,
	BPF_MAP_TYPE_PERCPU_ARRAY = 6,
	BPF_MAP_TYPE_STACK_TRACE = 7,
	BPF_MAP_TYPE_CGROUP_ARRAY = 8,
	BPF_MAP_TYPE_LRU_HASH = 9,
	BPF_MAP_TYPE_LRU_PERCPU_HASH = 10,
	BPF_MAP_TYPE_LPM_TRIE = 11,
	BPF_MAP_TYPE_ARRAY_OF_MAPS = 12,
	BPF_MAP_TYPE_HASH_OF_MAPS = 13,
	BPF_MAP_TYPE_DEVMAP = 14,
	BPF_MAP_TYPE_SOCKMAP = 15,
	BPF_MAP_TYPE_CPUMAP = 16,
	BPF_MAP_TYPE_XSKMAP = 17,
	BPF_MAP_TYPE_SOCKHASH = 18,
	BPF_MAP_TYPE_CGROUP_STORAGE = 19,
	BPF_MAP_TYPE_REUSEPORT_SOCKARRAY = 20,
	BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE = 21,
	BPF_MAP_TYPE_QUEUE = 22,
	BPF_MAP_TYPE_STACK = 23,
	BPF_MAP_TYPE_SK_STORAGE = 24,
	BPF_MAP_TYPE_DEVMAP_HASH = 25,
	BPF_MAP_TYPE_STRUCT_OPS = 26,
	BPF_MAP_TYPE_RINGBUF = 27,
	BPF_MAP_TYPE_INODE_STORAGE = 28,
};

enum bpf_prog_type {
	BPF_PROG_TYPE_UNSPEC = 0,
	BPF_PROG_TYPE_SOCKET_FILTER = 1,
	BPF_PROG_TYPE_KPROBE = 2,
	BPF_PROG_TYPE_SCHED_CLS = 3,
	BPF_PROG_TYPE_SCHED_ACT = 4,
	BPF_PROG_TYPE_TRACEPOINT = 5,
	BPF_PROG_TYPE_XDP = 6,
	BPF_PROG_TYPE_PERF_EVENT = 7,
	BPF_PROG_TYPE_CGROUP_SKB = 8,
	BPF_PROG_TYPE_CGROUP_SOCK = 9,
	BPF_PROG_TYPE_LWT_IN = 10,
	BPF_PROG_TYPE_LWT_OUT = 11,
	BPF_PROG_TYPE_LWT_XMIT = 12,
	BPF_PROG_TYPE_SOCK_OPS = 13,
	BPF_PROG_TYPE_SK_SKB = 14,
	BPF_PROG_TYPE_CGROUP_DEVICE = 15,
	BPF_PROG_TYPE_SK_MSG = 16,
	BPF_PROG_TYPE_RAW_TRACEPOINT = 17,
	BPF_PROG_TYPE_CGROUP_SOCK_ADDR = 18,
	BPF_PROG_TYPE_LWT_SEG6LOCAL = 19,
	BPF_PROG_TYPE_LIRC_MODE2 = 20,
	BPF_PROG_TYPE_SK_REUSEPORT = 21,
	BPF_PROG_TYPE_FLOW_DISSECTOR = 22,
	BPF_PROG_TYPE_CGROUP_SYSCTL = 23,
	BPF_PROG_TYPE_RAW_TRACEPOINT_WRITABLE = 24,
	BPF_PROG_TYPE_CGROUP_SOCKOPT = 25,
	BPF_PROG_TYPE_TRACING = 26,
	BPF_PROG_TYPE_STRUCT_OPS = 27,
	BPF_PROG_TYPE_EXT = 28,
	BPF_PROG_TYPE_LSM = 29,
	BPF_PROG_TYPE_SK_LOOKUP = 30,
};

enum bpf_attach_type {
	BPF_CGROUP_INET_INGRESS = 0,
	BPF_CGROUP_INET_EGRESS = 1,
	BPF_CGROUP_INET_SOCK_CREATE = 2,
	BPF_CGROUP_SOCK_OPS = 3,
	BPF_SK_SKB_STREAM_PARSER = 4,
	BPF_SK_SKB_STREAM_VERDICT = 5,
	BPF_CGROUP_DEVICE = 6,
	BPF_SK_MSG_VERDICT = 7,
	BPF_CGROUP_INET4_BIND = 8,
	BPF_CGROUP_INET6_BIND = 9,
	BPF_CGROUP_INET4_CONNECT = 10,
	BPF_CGROUP_INET6_CONNECT = 11,
	BPF_CGROUP_INET4_POST_BIND = 12,
	BPF_CGROUP_INET6_POST_BIND = 13,
	BPF_CGROUP_UDP4_SENDMSG = 14,
	BPF_CGROUP_UDP6_SENDMSG = 15,
	BPF_LIRC_MODE2 = 16,
	BPF_FLOW_DISSECTOR = 17,
	BPF_CGROUP_SYSCTL = 18,
	BPF_CGROUP_UDP4_RECVMSG = 19,
	BPF_CGROUP_UDP6_RECVMSG = 20,
	BPF_CGROUP_GETSOCKOPT = 21,
	BPF_CGROUP_SETSOCKOPT = 22,
	BPF_TRACE_RAW_TP = 23,
	BPF_TRACE_FENTRY = 24,
	BPF_TRACE_FEXIT = 25,
	BPF_MODIFY_RETURN = 26,
	BPF_LSM_MAC = 27,
	BPF_TRACE_ITER = 28,
	BPF_CGROUP_INET4_GETPEERNAME = 29,
	BPF_CGROUP_INET6_GETPEERNAME = 30,
	BPF_CGROUP_INET4_GETSOCKNAME = 31,
	BPF_CGROUP_INET6_GETSOCKNAME = 32,
	BPF_XDP_DEVMAP = 33,
	BPF_CGROUP_INET_SOCK_RELEASE = 34,
	BPF_XDP_CPUMAP = 35,
	BPF_SK_LOOKUP = 36,
	BPF_XDP = 37,
	__MAX_BPF_ATTACH_TYPE = 38,
};

union bpf_attr {
	struct {
		__u32 map_type;
		__u32 key_size;
		__u32 value_size;
		__u32 max_entries;
		__u32 map_flags;
		__u32 inner_map_fd;
		__u32 numa_node;
		char map_name[16];
		__u32 map_ifindex;
		__u32 btf_fd;
		__u32 btf_key_type_id;
		__u32 btf_value_type_id;
		__u32 btf_vmlinux_value_type_id;
	};
	struct {
		__u32 map_fd;
		__u64 key;
		union {
			__u64 value;
			__u64 next_key;
		};
		__u64 flags;
	};
	struct {
		__u64 in_batch;
		__u64 out_batch;
		__u64 keys;
		__u64 values;
		__u32 count;
		__u32 map_fd;
		__u64 elem_flags;
		__u64 flags;
	} batch;
	struct {
		__u32 prog_type;
		__u32 insn_cnt;
		__u64 insns;
		__u64 license;
		__u32 log_level;
		__u32 log_size;
		__u64 log_buf;
		__u32 kern_version;
		__u32 prog_flags;
		char prog_name[16];
		__u32 prog_ifindex;
		__u32 expected_attach_type;
		__u32 prog_btf_fd;
		__u32 func_info_rec_size;
		__u64 func_info;
		__u32 func_info_cnt;
		__u32 line_info_rec_size;
		__u64 line_info;
		__u32 line_info_cnt;
		__u32 attach_btf_id;
		__u32 attach_prog_fd;
	};
	struct {
		__u64 pathname;
		__u32 bpf_fd;
		__u32 file_flags;
	};
	struct {
		__u32 target_fd;
		__u32 attach_bpf_fd;
		__u32 attach_type;
		__u32 attach_flags;
		__u32 replace_bpf_fd;
	};
	struct {
		__u32 prog_fd;
		__u32 retval;
		__u32 data_size_in;
		__u32 data_size_out;
		__u64 data_in;
		__u64 data_out;
		__u32 repeat;
		__u32 duration;
		__u32 ctx_size_in;
		__u32 ctx_size_out;
		__u64 ctx_in;
		__u64 ctx_out;
		__u32 flags;
		__u32 cpu;
	} test;
	struct {
		union {
			__u32 start_id;
			__u32 prog_id;
			__u32 map_id;
			__u32 btf_id;
			__u32 link_id;
		};
		__u32 next_id;
		__u32 open_flags;
	};
	struct {
		__u32 bpf_fd;
		__u32 info_len;
		__u64 info;
	} info;
	struct {
		__u32 target_fd;
		__u32 attach_type;
		__u32 query_flags;
		__u32 attach_flags;
		__u64 prog_ids;
		__u32 prog_cnt;
	} query;
	struct {
		__u64 name;
		__u32 prog_fd;
	} raw_tracepoint;
	struct {
		__u64 btf;
		__u64 btf_log_buf;
		__u32 btf_size;
		__u32 btf_log_size;
		__u32 btf_log_level;
	};
	struct {
		__u32 pid;
		__u32 fd;
		__u32 flags;
		__u32 buf_len;
		__u64 buf;
		__u32 prog_id;
		__u32 fd_type;
		__u64 probe_offset;
		__u64 probe_addr;
	} task_fd_query;
	struct {
		__u32 prog_fd;
		union {
			__u32 target_fd;
			__u32 target_ifindex;
		};
		__u32 attach_type;
		__u32 flags;
		union {
			__u32 target_btf_id;
			struct {
				__u64 iter_info;
				__u32 iter_info_len;
			};
		};
	} link_create;
	struct {
		__u32 link_fd;
		__u32 new_prog_fd;
		__u32 flags;
		__u32 old_prog_fd;
	} link_update;
	struct {
		__u32 link_fd;
	} link_detach;
	struct {
		__u32 type;
	} enable_stats;
	struct {
		__u32 link_fd;
		__u32 flags;
	} iter_create;
	struct {
		__u32 prog_fd;
		__u32 map_fd;
		__u32 flags;
	} prog_bind_map;
};

struct bpf_func_info {
	__u32 insn_off;
	__u32 type_id;
};

struct bpf_line_info {
	__u32 insn_off;
	__u32 file_name_off;
	__u32 line_off;
	__u32 line_col;
};

struct bpf_iter_aux_info;

typedef int (*bpf_iter_init_seq_priv_t)(void *, struct bpf_iter_aux_info *);

struct bpf_map;

struct bpf_iter_aux_info {
	struct bpf_map *map;
};

typedef void (*bpf_iter_fini_seq_priv_t)(void *);

struct bpf_iter_seq_info {
	const struct seq_operations *seq_ops;
	bpf_iter_init_seq_priv_t init_seq_private;
	bpf_iter_fini_seq_priv_t fini_seq_private;
	u32 seq_priv_size;
};

struct btf;

struct btf_type;

struct bpf_prog_aux;

struct bpf_local_storage_map;

struct bpf_map_ops {
	int (*map_alloc_check)(union bpf_attr *);
	struct bpf_map * (*map_alloc)(union bpf_attr *);
	void (*map_release)(struct bpf_map *, struct file *);
	void (*map_free)(struct bpf_map *);
	int (*map_get_next_key)(struct bpf_map *, void *, void *);
	void (*map_release_uref)(struct bpf_map *);
	void * (*map_lookup_elem_sys_only)(struct bpf_map *, void *);
	int (*map_lookup_batch)(struct bpf_map *, const union bpf_attr *, union bpf_attr *);
	int (*map_lookup_and_delete_batch)(struct bpf_map *, const union bpf_attr *, union bpf_attr *);
	int (*map_update_batch)(struct bpf_map *, const union bpf_attr *, union bpf_attr *);
	int (*map_delete_batch)(struct bpf_map *, const union bpf_attr *, union bpf_attr *);
	void * (*map_lookup_elem)(struct bpf_map *, void *);
	int (*map_update_elem)(struct bpf_map *, void *, void *, u64);
	int (*map_delete_elem)(struct bpf_map *, void *);
	int (*map_push_elem)(struct bpf_map *, void *, u64);
	int (*map_pop_elem)(struct bpf_map *, void *);
	int (*map_peek_elem)(struct bpf_map *, void *);
	void * (*map_fd_get_ptr)(struct bpf_map *, struct file *, int);
	void (*map_fd_put_ptr)(void *);
	int (*map_gen_lookup)(struct bpf_map *, struct bpf_insn *);
	u32 (*map_fd_sys_lookup_elem)(void *);
	void (*map_seq_show_elem)(struct bpf_map *, void *, struct seq_file *);
	int (*map_check_btf)(const struct bpf_map *, const struct btf *, const struct btf_type *, const struct btf_type *);
	int (*map_poke_track)(struct bpf_map *, struct bpf_prog_aux *);
	void (*map_poke_untrack)(struct bpf_map *, struct bpf_prog_aux *);
	void (*map_poke_run)(struct bpf_map *, u32, struct bpf_prog *, struct bpf_prog *);
	int (*map_direct_value_addr)(const struct bpf_map *, u64 *, u32);
	int (*map_direct_value_meta)(const struct bpf_map *, u64, u32 *);
	int (*map_mmap)(struct bpf_map *, struct vm_area_struct *);
	__poll_t (*map_poll)(struct bpf_map *, struct file *, struct poll_table_struct *);
	int (*map_local_storage_charge)(struct bpf_local_storage_map *, void *, u32);
	void (*map_local_storage_uncharge)(struct bpf_local_storage_map *, void *, u32);
	struct bpf_local_storage ** (*map_owner_storage_ptr)(void *);
	bool (*map_meta_equal)(const struct bpf_map *, const struct bpf_map *);
	const char * const map_btf_name;
	int *map_btf_id;
	const struct bpf_iter_seq_info *iter_seq_info;
};

struct bpf_map_memory {
	u32 pages;
	struct user_struct *user;
};

struct bpf_map {
	const struct bpf_map_ops *ops;
	struct bpf_map *inner_map_meta;
	enum bpf_map_type map_type;
	u32 key_size;
	u32 value_size;
	u32 max_entries;
	u32 map_flags;
	int spin_lock_off;
	u32 id;
	int numa_node;
	u32 btf_key_type_id;
	u32 btf_value_type_id;
	struct btf *btf;
	struct bpf_map_memory memory;
	char name[16];
	u32 btf_vmlinux_value_type_id;
	bool bypass_spec_v1;
	bool frozen;
	long: 16;
	long: 64;
	long: 64;
	long: 64;
	atomic64_t refcnt;
	atomic64_t usercnt;
	struct work_struct work;
	struct mutex freeze_mutex;
	atomic64_t writecnt;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct btf_header {
	__u16 magic;
	__u8 version;
	__u8 flags;
	__u32 hdr_len;
	__u32 type_off;
	__u32 type_len;
	__u32 str_off;
	__u32 str_len;
};

struct btf {
	void *data;
	struct btf_type **types;
	u32 *resolved_ids;
	u32 *resolved_sizes;
	const char *strings;
	void *nohdr_data;
	struct btf_header hdr;
	u32 nr_types;
	u32 types_size;
	u32 data_size;
	refcount_t refcnt;
	u32 id;
	struct callback_head rcu;
};

struct btf_type {
	__u32 name_off;
	__u32 info;
	union {
		__u32 size;
		__u32 type;
	};
};

struct bpf_ksym {
	long unsigned int start;
	long unsigned int end;
	char name[128];
	struct list_head lnode;
	struct latch_tree_node tnode;
	bool prog;
};

struct bpf_ctx_arg_aux;

struct bpf_trampoline;

struct bpf_jit_poke_descriptor;

struct bpf_prog_ops;

struct bpf_prog_offload;

struct bpf_func_info_aux;

struct bpf_prog_stats;

struct bpf_prog_aux {
	atomic64_t refcnt;
	u32 used_map_cnt;
	u32 max_ctx_offset;
	u32 max_pkt_offset;
	u32 max_tp_access;
	u32 stack_depth;
	u32 id;
	u32 func_cnt;
	u32 func_idx;
	u32 attach_btf_id;
	u32 ctx_arg_info_size;
	u32 max_rdonly_access;
	u32 max_rdwr_access;
	const struct bpf_ctx_arg_aux *ctx_arg_info;
	struct mutex dst_mutex;
	struct bpf_prog *dst_prog;
	struct bpf_trampoline *dst_trampoline;
	enum bpf_prog_type saved_dst_prog_type;
	enum bpf_attach_type saved_dst_attach_type;
	bool verifier_zext;
	bool offload_requested;
	bool attach_btf_trace;
	bool func_proto_unreliable;
	bool sleepable;
	bool tail_call_reachable;
	struct hlist_node tramp_hlist;
	const struct btf_type *attach_func_proto;
	const char *attach_func_name;
	struct bpf_prog **func;
	void *jit_data;
	struct bpf_jit_poke_descriptor *poke_tab;
	u32 size_poke_tab;
	struct bpf_ksym ksym;
	const struct bpf_prog_ops *ops;
	struct bpf_map **used_maps;
	struct mutex used_maps_mutex;
	struct bpf_prog *prog;
	struct user_struct *user;
	u64 load_time;
	struct bpf_map *cgroup_storage[2];
	char name[16];
	struct bpf_prog_offload *offload;
	struct btf *btf;
	struct bpf_func_info *func_info;
	struct bpf_func_info_aux *func_info_aux;
	struct bpf_line_info *linfo;
	void **jited_linfo;
	u32 func_info_cnt;
	u32 nr_linfo;
	u32 linfo_idx;
	u32 num_exentries;
	struct exception_table_entry *extable;
	struct bpf_prog_stats *stats;
	union {
		struct work_struct work;
		struct callback_head rcu;
	};
};

struct sock_filter {
	__u16 code;
	__u8 jt;
	__u8 jf;
	__u32 k;
};

struct sock_fprog_kern;

struct bpf_prog {
	u16 pages;
	u16 jited: 1;
	u16 jit_requested: 1;
	u16 gpl_compatible: 1;
	u16 cb_access: 1;
	u16 dst_needed: 1;
	u16 blinded: 1;
	u16 is_func: 1;
	u16 kprobe_override: 1;
	u16 has_callchain_buf: 1;
	u16 enforce_expected_attach_type: 1;
	u16 call_get_stack: 1;
	enum bpf_prog_type type;
	enum bpf_attach_type expected_attach_type;
	u32 len;
	u32 jited_len;
	u8 tag[8];
	struct bpf_prog_aux *aux;
	struct sock_fprog_kern *orig_prog;
	unsigned int (*bpf_func)(const void *, const struct bpf_insn *);
	struct sock_filter insns[0];
	struct bpf_insn insnsi[0];
};

struct bpf_offloaded_map;

struct bpf_map_dev_ops {
	int (*map_get_next_key)(struct bpf_offloaded_map *, void *, void *);
	int (*map_lookup_elem)(struct bpf_offloaded_map *, void *, void *);
	int (*map_update_elem)(struct bpf_offloaded_map *, void *, void *, u64);
	int (*map_delete_elem)(struct bpf_offloaded_map *, void *);
};

struct bpf_offloaded_map {
	struct bpf_map map;
	struct net_device *netdev;
	const struct bpf_map_dev_ops *dev_ops;
	void *dev_priv;
	struct list_head offloads;
	long: 64;
	long: 64;
	long: 64;
};

struct net_device_stats {
	long unsigned int rx_packets;
	long unsigned int tx_packets;
	long unsigned int rx_bytes;
	long unsigned int tx_bytes;
	long unsigned int rx_errors;
	long unsigned int tx_errors;
	long unsigned int rx_dropped;
	long unsigned int tx_dropped;
	long unsigned int multicast;
	long unsigned int collisions;
	long unsigned int rx_length_errors;
	long unsigned int rx_over_errors;
	long unsigned int rx_crc_errors;
	long unsigned int rx_frame_errors;
	long unsigned int rx_fifo_errors;
	long unsigned int rx_missed_errors;
	long unsigned int tx_aborted_errors;
	long unsigned int tx_carrier_errors;
	long unsigned int tx_fifo_errors;
	long unsigned int tx_heartbeat_errors;
	long unsigned int tx_window_errors;
	long unsigned int rx_compressed;
	long unsigned int tx_compressed;
};

struct netdev_hw_addr_list {
	struct list_head list;
	int count;
};

enum rx_handler_result {
	RX_HANDLER_CONSUMED = 0,
	RX_HANDLER_ANOTHER = 1,
	RX_HANDLER_EXACT = 2,
	RX_HANDLER_PASS = 3,
};

typedef enum rx_handler_result rx_handler_result_t;

typedef rx_handler_result_t rx_handler_func_t(struct sk_buff **);

enum netdev_ml_priv_type {
	ML_PRIV_NONE = 0,
	ML_PRIV_CAN = 1,
};

struct pcpu_dstats;

struct netdev_tc_txq {
	u16 count;
	u16 offset;
};

struct sfp_bus;

struct udp_tunnel_nic;

struct bpf_xdp_link;

struct bpf_xdp_entity {
	struct bpf_prog *prog;
	struct bpf_xdp_link *link;
};

struct netdev_name_node;

struct dev_ifalias;

struct net_device_ops;

struct ethtool_ops;

struct ndisc_ops;

struct header_ops;

struct in_device;

struct inet6_dev;

struct wireless_dev;

struct wpan_dev;

struct netdev_rx_queue;

struct netdev_queue;

struct cpu_rmap;

struct Qdisc;

struct xdp_dev_bulk_queue;

struct xps_dev_maps;

struct pcpu_lstats;

struct pcpu_sw_netstats;

struct rtnl_link_ops;

struct phy_device;

struct udp_tunnel_nic_info;

struct net_device {
	char name[16];
	struct netdev_name_node *name_node;
	struct dev_ifalias *ifalias;
	long unsigned int mem_end;
	long unsigned int mem_start;
	long unsigned int base_addr;
	int irq;
	long unsigned int state;
	struct list_head dev_list;
	struct list_head napi_list;
	struct list_head unreg_list;
	struct list_head close_list;
	struct list_head ptype_all;
	struct list_head ptype_specific;
	struct {
		struct list_head upper;
		struct list_head lower;
	} adj_list;
	netdev_features_t features;
	netdev_features_t hw_features;
	netdev_features_t wanted_features;
	netdev_features_t vlan_features;
	netdev_features_t hw_enc_features;
	netdev_features_t mpls_features;
	netdev_features_t gso_partial_features;
	int ifindex;
	int group;
	struct net_device_stats stats;
	atomic_long_t rx_dropped;
	atomic_long_t tx_dropped;
	atomic_long_t rx_nohandler;
	atomic_t carrier_up_count;
	atomic_t carrier_down_count;
	const struct net_device_ops *netdev_ops;
	const struct ethtool_ops *ethtool_ops;
	const struct ndisc_ops *ndisc_ops;
	const struct header_ops *header_ops;
	unsigned int flags;
	unsigned int priv_flags;
	short unsigned int gflags;
	short unsigned int padded;
	unsigned char operstate;
	unsigned char link_mode;
	unsigned char if_port;
	unsigned char dma;
	unsigned int mtu;
	unsigned int min_mtu;
	unsigned int max_mtu;
	short unsigned int type;
	short unsigned int hard_header_len;
	unsigned char min_header_len;
	unsigned char name_assign_type;
	short unsigned int needed_headroom;
	short unsigned int needed_tailroom;
	unsigned char perm_addr[32];
	unsigned char addr_assign_type;
	unsigned char addr_len;
	unsigned char upper_level;
	unsigned char lower_level;
	short unsigned int neigh_priv_len;
	short unsigned int dev_id;
	short unsigned int dev_port;
	spinlock_t addr_list_lock;
	struct netdev_hw_addr_list uc;
	struct netdev_hw_addr_list mc;
	struct netdev_hw_addr_list dev_addrs;
	struct kset *queues_kset;
	unsigned int promiscuity;
	unsigned int allmulti;
	bool uc_promisc;
	struct in_device *ip_ptr;
	struct inet6_dev *ip6_ptr;
	struct wireless_dev *ieee80211_ptr;
	struct wpan_dev *ieee802154_ptr;
	unsigned char *dev_addr;
	struct netdev_rx_queue *_rx;
	unsigned int num_rx_queues;
	unsigned int real_num_rx_queues;
	struct bpf_prog *xdp_prog;
	long unsigned int gro_flush_timeout;
	int napi_defer_hard_irqs;
	rx_handler_func_t *rx_handler;
	void *rx_handler_data;
	struct netdev_queue *ingress_queue;
	unsigned char broadcast[32];
	struct cpu_rmap *rx_cpu_rmap;
	struct hlist_node index_hlist;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct netdev_queue *_tx;
	unsigned int num_tx_queues;
	unsigned int real_num_tx_queues;
	struct Qdisc *qdisc;
	unsigned int tx_queue_len;
	spinlock_t tx_global_lock;
	struct xdp_dev_bulk_queue *xdp_bulkq;
	struct xps_dev_maps *xps_cpus_map;
	struct xps_dev_maps *xps_rxqs_map;
	struct timer_list watchdog_timer;
	int watchdog_timeo;
	u32 proto_down_reason;
	struct list_head todo_list;
	int *pcpu_refcnt;
	struct list_head link_watch_list;
	enum {
		NETREG_UNINITIALIZED = 0,
		NETREG_REGISTERED = 1,
		NETREG_UNREGISTERING = 2,
		NETREG_UNREGISTERED = 3,
		NETREG_RELEASED = 4,
		NETREG_DUMMY = 5,
	} reg_state: 8;
	bool dismantle;
	enum {
		RTNL_LINK_INITIALIZED = 0,
		RTNL_LINK_INITIALIZING = 1,
	} rtnl_link_state: 16;
	bool needs_free_netdev;
	void (*priv_destructor)(struct net_device *);
	possible_net_t nd_net;
	void *ml_priv;
	enum netdev_ml_priv_type ml_priv_type;
	union {
		struct pcpu_lstats *lstats;
		struct pcpu_sw_netstats *tstats;
		struct pcpu_dstats *dstats;
	};
	struct device dev;
	const struct attribute_group *sysfs_groups[4];
	const struct attribute_group *sysfs_rx_queue_group;
	const struct rtnl_link_ops *rtnl_link_ops;
	unsigned int gso_max_size;
	u16 gso_max_segs;
	s16 num_tc;
	struct netdev_tc_txq tc_to_txq[16];
	u8 prio_tc_map[16];
	struct phy_device *phydev;
	struct sfp_bus *sfp_bus;
	struct lock_class_key *qdisc_tx_busylock;
	struct lock_class_key *qdisc_running_key;
	bool proto_down;
	unsigned int wol_enabled: 1;
	struct list_head net_notifier_list;
	const struct udp_tunnel_nic_info *udp_tunnel_nic_info;
	struct udp_tunnel_nic *udp_tunnel_nic;
	struct bpf_xdp_entity xdp_state[3];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

enum bpf_reg_type {
	NOT_INIT = 0,
	SCALAR_VALUE = 1,
	PTR_TO_CTX = 2,
	CONST_PTR_TO_MAP = 3,
	PTR_TO_MAP_VALUE = 4,
	PTR_TO_MAP_VALUE_OR_NULL = 5,
	PTR_TO_STACK = 6,
	PTR_TO_PACKET_META = 7,
	PTR_TO_PACKET = 8,
	PTR_TO_PACKET_END = 9,
	PTR_TO_FLOW_KEYS = 10,
	PTR_TO_SOCKET = 11,
	PTR_TO_SOCKET_OR_NULL = 12,
	PTR_TO_SOCK_COMMON = 13,
	PTR_TO_SOCK_COMMON_OR_NULL = 14,
	PTR_TO_TCP_SOCK = 15,
	PTR_TO_TCP_SOCK_OR_NULL = 16,
	PTR_TO_TP_BUFFER = 17,
	PTR_TO_XDP_SOCK = 18,
	PTR_TO_BTF_ID = 19,
	PTR_TO_BTF_ID_OR_NULL = 20,
	PTR_TO_MEM = 21,
	PTR_TO_MEM_OR_NULL = 22,
	PTR_TO_RDONLY_BUF = 23,
	PTR_TO_RDONLY_BUF_OR_NULL = 24,
	PTR_TO_RDWR_BUF = 25,
	PTR_TO_RDWR_BUF_OR_NULL = 26,
	PTR_TO_PERCPU_BTF_ID = 27,
};

struct bpf_prog_ops {
	int (*test_run)(struct bpf_prog *, const union bpf_attr *, union bpf_attr *);
};

struct bpf_offload_dev;

struct bpf_prog_offload {
	struct bpf_prog *prog;
	struct net_device *netdev;
	struct bpf_offload_dev *offdev;
	void *dev_priv;
	struct list_head offloads;
	bool dev_state;
	bool opt_failed;
	void *jited_image;
	u32 jited_len;
};

struct bpf_prog_stats {
	u64 cnt;
	u64 nsecs;
	struct u64_stats_sync syncp;
};

struct btf_func_model {
	u8 ret_size;
	u8 nr_args;
	u8 arg_size[12];
};

struct bpf_tramp_image {
	void *image;
	struct bpf_ksym ksym;
	struct percpu_ref pcref;
	void *ip_after_call;
	void *ip_epilogue;
	union {
		struct callback_head rcu;
		struct work_struct work;
	};
};

struct bpf_trampoline {
	struct hlist_node hlist;
	struct mutex mutex;
	refcount_t refcnt;
	u64 key;
	struct {
		struct btf_func_model model;
		void *addr;
		bool ftrace_managed;
	} func;
	struct bpf_prog *extension_prog;
	struct hlist_head progs_hlist[3];
	int progs_cnt[3];
	struct bpf_tramp_image *cur_image;
	u64 selector;
};

struct bpf_func_info_aux {
	u16 linkage;
	bool unreliable;
};

struct bpf_jit_poke_descriptor {
	void *tailcall_target;
	void *tailcall_bypass;
	void *bypass_addr;
	union {
		struct {
			struct bpf_map *map;
			u32 key;
		} tail_call;
	};
	bool tailcall_target_stable;
	u8 adj_off;
	u16 reason;
	u32 insn_idx;
};

struct bpf_ctx_arg_aux {
	u32 offset;
	enum bpf_reg_type reg_type;
	u32 btf_id;
};

typedef unsigned int sk_buff_data_t;

struct sk_buff {
	union {
		struct {
			struct sk_buff *next;
			struct sk_buff *prev;
			union {
				struct net_device *dev;
				long unsigned int dev_scratch;
			};
		};
		struct rb_node rbnode;
		struct list_head list;
	};
	union {
		struct sock *sk;
		int ip_defrag_offset;
	};
	union {
		ktime_t tstamp;
		u64 skb_mstamp_ns;
	};
	char cb[48];
	union {
		struct {
			long unsigned int _skb_refdst;
			void (*destructor)(struct sk_buff *);
		};
		struct list_head tcp_tsorted_anchor;
	};
	unsigned int len;
	unsigned int data_len;
	__u16 mac_len;
	__u16 hdr_len;
	__u16 queue_mapping;
	__u8 __cloned_offset[0];
	__u8 cloned: 1;
	__u8 nohdr: 1;
	__u8 fclone: 2;
	__u8 peeked: 1;
	__u8 head_frag: 1;
	__u8 pfmemalloc: 1;
	__u32 headers_start[0];
	__u8 __pkt_type_offset[0];
	__u8 pkt_type: 3;
	__u8 ignore_df: 1;
	__u8 nf_trace: 1;
	__u8 ip_summed: 2;
	__u8 ooo_okay: 1;
	__u8 l4_hash: 1;
	__u8 sw_hash: 1;
	__u8 wifi_acked_valid: 1;
	__u8 wifi_acked: 1;
	__u8 no_fcs: 1;
	__u8 encapsulation: 1;
	__u8 encap_hdr_csum: 1;
	__u8 csum_valid: 1;
	__u8 __pkt_vlan_present_offset[0];
	__u8 vlan_present: 1;
	__u8 csum_complete_sw: 1;
	__u8 csum_level: 2;
	__u8 csum_not_inet: 1;
	__u8 dst_pending_confirm: 1;
	__u8 ndisc_nodetype: 2;
	__u8 ipvs_property: 1;
	__u8 inner_protocol_type: 1;
	__u8 remcsum_offload: 1;
	union {
		__wsum csum;
		struct {
			__u16 csum_start;
			__u16 csum_offset;
		};
	};
	__u32 priority;
	int skb_iif;
	__u32 hash;
	__be16 vlan_proto;
	__u16 vlan_tci;
	union {
		unsigned int napi_id;
		unsigned int sender_cpu;
	};
	union {
		__u32 mark;
		__u32 reserved_tailroom;
	};
	union {
		__be16 inner_protocol;
		__u8 inner_ipproto;
	};
	__u16 inner_transport_header;
	__u16 inner_network_header;
	__u16 inner_mac_header;
	__be16 protocol;
	__u16 transport_header;
	__u16 network_header;
	__u16 mac_header;
	__u32 headers_end[0];
	sk_buff_data_t tail;
	sk_buff_data_t end;
	unsigned char *head;
	unsigned char *data;
	unsigned int truesize;
	refcount_t users;
};

enum {
	Root_NFS = 255,
	Root_CIFS = 254,
	Root_RAM0 = 1048576,
	Root_RAM1 = 1048577,
	Root_FD0 = 2097152,
	Root_HDA1 = 3145729,
	Root_HDA2 = 3145730,
	Root_SDA1 = 8388609,
	Root_SDA2 = 8388610,
	Root_HDC1 = 23068673,
	Root_SR0 = 11534336,
};

struct ethhdr {
	unsigned char h_dest[6];
	unsigned char h_source[6];
	__be16 h_proto;
};

struct ipstats_mib {
	u64 mibs[37];
	struct u64_stats_sync syncp;
};

struct icmp_mib {
	long unsigned int mibs[28];
};

struct icmpmsg_mib {
	atomic_long_t mibs[512];
};

struct icmpv6_mib {
	long unsigned int mibs[6];
};

struct icmpv6_mib_device {
	atomic_long_t mibs[6];
};

struct icmpv6msg_mib {
	atomic_long_t mibs[512];
};

struct icmpv6msg_mib_device {
	atomic_long_t mibs[512];
};

struct tcp_mib {
	long unsigned int mibs[16];
};

struct udp_mib {
	long unsigned int mibs[9];
};

struct linux_mib {
	long unsigned int mibs[124];
};

struct inet_frags;

struct fqdir {
	long int high_thresh;
	long int low_thresh;
	int timeout;
	int max_dist;
	struct inet_frags *f;
	struct net *net;
	bool dead;
	long: 56;
	long: 64;
	long: 64;
	struct rhashtable rhashtable;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	atomic_long_t mem;
	struct work_struct destroy_work;
	long: 64;
	long: 64;
	long: 64;
};

struct inet_frag_queue;

struct inet_frags {
	unsigned int qsize;
	void (*constructor)(struct inet_frag_queue *, const void *);
	void (*destructor)(struct inet_frag_queue *);
	void (*frag_expire)(struct timer_list *);
	struct kmem_cache *frags_cachep;
	const char *frags_cache_name;
	struct rhashtable_params rhash_params;
	refcount_t refcnt;
	struct completion completion;
};

struct frag_v4_compare_key {
	__be32 saddr;
	__be32 daddr;
	u32 user;
	u32 vif;
	__be16 id;
	u16 protocol;
};

struct frag_v6_compare_key {
	struct in6_addr saddr;
	struct in6_addr daddr;
	u32 user;
	__be32 id;
	u32 iif;
};

struct inet_frag_queue {
	struct rhash_head node;
	union {
		struct frag_v4_compare_key v4;
		struct frag_v6_compare_key v6;
	} key;
	struct timer_list timer;
	spinlock_t lock;
	refcount_t refcnt;
	struct rb_root rb_fragments;
	struct sk_buff *fragments_tail;
	struct sk_buff *last_run_head;
	ktime_t stamp;
	int len;
	int meat;
	__u8 flags;
	u16 max_size;
	struct fqdir *fqdir;
	struct callback_head rcu;
};

enum tcp_ca_event {
	CA_EVENT_TX_START = 0,
	CA_EVENT_CWND_RESTART = 1,
	CA_EVENT_COMPLETE_CWR = 2,
	CA_EVENT_LOSS = 3,
	CA_EVENT_ECN_NO_CE = 4,
	CA_EVENT_ECN_IS_CE = 5,
};

struct ack_sample;

struct rate_sample;

union tcp_cc_info;

struct tcp_congestion_ops {
	struct list_head list;
	u32 key;
	u32 flags;
	void (*init)(struct sock *);
	void (*release)(struct sock *);
	u32 (*ssthresh)(struct sock *);
	void (*cong_avoid)(struct sock *, u32, u32);
	void (*set_state)(struct sock *, u8);
	void (*cwnd_event)(struct sock *, enum tcp_ca_event);
	void (*in_ack_event)(struct sock *, u32);
	u32 (*undo_cwnd)(struct sock *);
	void (*pkts_acked)(struct sock *, const struct ack_sample *);
	u32 (*min_tso_segs)(struct sock *);
	u32 (*sndbuf_expand)(struct sock *);
	void (*cong_control)(struct sock *, const struct rate_sample *);
	size_t (*get_info)(struct sock *, u32, int *, union tcp_cc_info *);
	char name[16];
	struct module *owner;
};

struct netlink_ext_ack;

struct fib_notifier_ops {
	int family;
	struct list_head list;
	unsigned int (*fib_seq_read)(struct net *);
	int (*fib_dump)(struct net *, struct notifier_block *, struct netlink_ext_ack *);
	struct module *owner;
	struct callback_head rcu;
};

struct lwtunnel_state;

struct dst_entry {
	struct net_device *dev;
	struct dst_ops *ops;
	long unsigned int _metrics;
	long unsigned int expires;
	void *__pad1;
	int (*input)(struct sk_buff *);
	int (*output)(struct net *, struct sock *, struct sk_buff *);
	short unsigned int flags;
	short int obsolete;
	short unsigned int header_len;
	short unsigned int trailer_len;
	atomic_t __refcnt;
	int __use;
	long unsigned int lastuse;
	struct lwtunnel_state *lwtstate;
	struct callback_head callback_head;
	short int error;
	short int __pad;
	__u32 tclassid;
};

struct hh_cache {
	unsigned int hh_len;
	seqlock_t hh_lock;
	long unsigned int hh_data[12];
};

struct neigh_table;

struct neigh_parms;

struct neigh_ops;

struct neighbour {
	struct neighbour *next;
	struct neigh_table *tbl;
	struct neigh_parms *parms;
	long unsigned int confirmed;
	long unsigned int updated;
	rwlock_t lock;
	refcount_t refcnt;
	unsigned int arp_queue_len_bytes;
	struct sk_buff_head arp_queue;
	struct timer_list timer;
	long unsigned int used;
	atomic_t probes;
	__u8 flags;
	__u8 nud_state;
	__u8 type;
	__u8 dead;
	u8 protocol;
	seqlock_t ha_lock;
	int: 32;
	unsigned char ha[32];
	struct hh_cache hh;
	int (*output)(struct neighbour *, struct sk_buff *);
	const struct neigh_ops *ops;
	struct list_head gc_list;
	struct callback_head rcu;
	struct net_device *dev;
	u8 primary_key[0];
};

struct ipv6_stable_secret {
	bool initialized;
	struct in6_addr secret;
};

struct ipv6_devconf {
	__s32 forwarding;
	__s32 hop_limit;
	__s32 mtu6;
	__s32 accept_ra;
	__s32 accept_redirects;
	__s32 autoconf;
	__s32 dad_transmits;
	__s32 rtr_solicits;
	__s32 rtr_solicit_interval;
	__s32 rtr_solicit_max_interval;
	__s32 rtr_solicit_delay;
	__s32 force_mld_version;
	__s32 mldv1_unsolicited_report_interval;
	__s32 mldv2_unsolicited_report_interval;
	__s32 use_tempaddr;
	__s32 temp_valid_lft;
	__s32 temp_prefered_lft;
	__s32 regen_max_retry;
	__s32 max_desync_factor;
	__s32 max_addresses;
	__s32 accept_ra_defrtr;
	__s32 accept_ra_min_hop_limit;
	__s32 accept_ra_pinfo;
	__s32 ignore_routes_with_linkdown;
	__s32 accept_ra_rt_table;
	__s32 proxy_ndp;
	__s32 accept_source_route;
	__s32 accept_ra_from_local;
	__s32 disable_ipv6;
	__s32 drop_unicast_in_l2_multicast;
	__s32 accept_dad;
	__s32 force_tllao;
	__s32 ndisc_notify;
	__s32 suppress_frag_ndisc;
	__s32 accept_ra_mtu;
	__s32 drop_unsolicited_na;
	struct ipv6_stable_secret stable_secret;
	__s32 use_oif_addrs_only;
	__s32 keep_addr_on_down;
	__s32 seg6_enabled;
	__u32 enhanced_dad;
	__u32 addr_gen_mode;
	__s32 disable_policy;
	__s32 ndisc_tclass;
	__s32 rpl_seg_enabled;
	struct ctl_table_header *sysctl_header;
};

typedef struct {
	union {
		void *kernel;
		void *user;
	};
	bool is_kernel: 1;
} sockptr_t;

typedef enum {
	SS_FREE = 0,
	SS_UNCONNECTED = 1,
	SS_CONNECTING = 2,
	SS_CONNECTED = 3,
	SS_DISCONNECTING = 4,
} socket_state;

struct socket_wq {
	wait_queue_head_t wait;
	struct fasync_struct *fasync_list;
	long unsigned int flags;
	struct callback_head rcu;
	long: 64;
};

struct proto_ops;

struct socket {
	socket_state state;
	short int type;
	long unsigned int flags;
	struct file *file;
	struct sock *sk;
	const struct proto_ops *ops;
	long: 64;
	long: 64;
	long: 64;
	struct socket_wq wq;
};

typedef int (*sk_read_actor_t)(read_descriptor_t *, struct sk_buff *, unsigned int, size_t);

struct proto_ops {
	int family;
	unsigned int flags;
	struct module *owner;
	int (*release)(struct socket *);
	int (*bind)(struct socket *, struct sockaddr *, int);
	int (*connect)(struct socket *, struct sockaddr *, int, int);
	int (*socketpair)(struct socket *, struct socket *);
	int (*accept)(struct socket *, struct socket *, int, bool);
	int (*getname)(struct socket *, struct sockaddr *, int);
	__poll_t (*poll)(struct file *, struct socket *, struct poll_table_struct *);
	int (*ioctl)(struct socket *, unsigned int, long unsigned int);
	int (*gettstamp)(struct socket *, void *, bool, bool);
	int (*listen)(struct socket *, int);
	int (*shutdown)(struct socket *, int);
	int (*setsockopt)(struct socket *, int, int, sockptr_t, unsigned int);
	int (*getsockopt)(struct socket *, int, int, char *, int *);
	void (*show_fdinfo)(struct seq_file *, struct socket *);
	int (*sendmsg)(struct socket *, struct msghdr *, size_t);
	int (*recvmsg)(struct socket *, struct msghdr *, size_t, int);
	int (*mmap)(struct file *, struct socket *, struct vm_area_struct *);
	ssize_t (*sendpage)(struct socket *, struct page *, int, size_t, int);
	ssize_t (*splice_read)(struct socket *, loff_t *, struct pipe_inode_info *, size_t, unsigned int);
	int (*set_peek_off)(struct sock *, int);
	int (*peek_len)(struct socket *);
	int (*read_sock)(struct sock *, read_descriptor_t *, sk_read_actor_t);
	int (*sendpage_locked)(struct sock *, struct page *, int, size_t, int);
	int (*sendmsg_locked)(struct sock *, struct msghdr *, size_t);
	int (*set_rcvlowat)(struct sock *, int);
};

struct pipe_buf_operations;

struct pipe_buffer {
	struct page *page;
	unsigned int offset;
	unsigned int len;
	const struct pipe_buf_operations *ops;
	unsigned int flags;
	long unsigned int private;
};

struct pipe_buf_operations {
	int (*confirm)(struct pipe_inode_info *, struct pipe_buffer *);
	void (*release)(struct pipe_inode_info *, struct pipe_buffer *);
	bool (*try_steal)(struct pipe_inode_info *, struct pipe_buffer *);
	bool (*get)(struct pipe_inode_info *, struct pipe_buffer *);
};

struct dql {
	unsigned int num_queued;
	unsigned int adj_limit;
	unsigned int last_obj_cnt;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	unsigned int limit;
	unsigned int num_completed;
	unsigned int prev_ovlimit;
	unsigned int prev_num_queued;
	unsigned int prev_last_obj_cnt;
	unsigned int lowest_slack;
	long unsigned int slack_start_time;
	unsigned int max_limit;
	unsigned int min_limit;
	unsigned int slack_hold_time;
	long: 32;
	long: 64;
	long: 64;
};

struct ethtool_drvinfo {
	__u32 cmd;
	char driver[32];
	char version[32];
	char fw_version[32];
	char bus_info[32];
	char erom_version[32];
	char reserved2[12];
	__u32 n_priv_flags;
	__u32 n_stats;
	__u32 testinfo_len;
	__u32 eedump_len;
	__u32 regdump_len;
};

struct ethtool_wolinfo {
	__u32 cmd;
	__u32 supported;
	__u32 wolopts;
	__u8 sopass[6];
};

struct ethtool_tunable {
	__u32 cmd;
	__u32 id;
	__u32 type_id;
	__u32 len;
	void *data[0];
};

struct ethtool_regs {
	__u32 cmd;
	__u32 version;
	__u32 len;
	__u8 data[0];
};

struct ethtool_eeprom {
	__u32 cmd;
	__u32 magic;
	__u32 offset;
	__u32 len;
	__u8 data[0];
};

struct ethtool_eee {
	__u32 cmd;
	__u32 supported;
	__u32 advertised;
	__u32 lp_advertised;
	__u32 eee_active;
	__u32 eee_enabled;
	__u32 tx_lpi_enabled;
	__u32 tx_lpi_timer;
	__u32 reserved[2];
};

struct ethtool_modinfo {
	__u32 cmd;
	__u32 type;
	__u32 eeprom_len;
	__u32 reserved[8];
};

struct ethtool_coalesce {
	__u32 cmd;
	__u32 rx_coalesce_usecs;
	__u32 rx_max_coalesced_frames;
	__u32 rx_coalesce_usecs_irq;
	__u32 rx_max_coalesced_frames_irq;
	__u32 tx_coalesce_usecs;
	__u32 tx_max_coalesced_frames;
	__u32 tx_coalesce_usecs_irq;
	__u32 tx_max_coalesced_frames_irq;
	__u32 stats_block_coalesce_usecs;
	__u32 use_adaptive_rx_coalesce;
	__u32 use_adaptive_tx_coalesce;
	__u32 pkt_rate_low;
	__u32 rx_coalesce_usecs_low;
	__u32 rx_max_coalesced_frames_low;
	__u32 tx_coalesce_usecs_low;
	__u32 tx_max_coalesced_frames_low;
	__u32 pkt_rate_high;
	__u32 rx_coalesce_usecs_high;
	__u32 rx_max_coalesced_frames_high;
	__u32 tx_coalesce_usecs_high;
	__u32 tx_max_coalesced_frames_high;
	__u32 rate_sample_interval;
};

struct ethtool_ringparam {
	__u32 cmd;
	__u32 rx_max_pending;
	__u32 rx_mini_max_pending;
	__u32 rx_jumbo_max_pending;
	__u32 tx_max_pending;
	__u32 rx_pending;
	__u32 rx_mini_pending;
	__u32 rx_jumbo_pending;
	__u32 tx_pending;
};

struct ethtool_channels {
	__u32 cmd;
	__u32 max_rx;
	__u32 max_tx;
	__u32 max_other;
	__u32 max_combined;
	__u32 rx_count;
	__u32 tx_count;
	__u32 other_count;
	__u32 combined_count;
};

struct ethtool_pauseparam {
	__u32 cmd;
	__u32 autoneg;
	__u32 rx_pause;
	__u32 tx_pause;
};

enum ethtool_link_ext_state {
	ETHTOOL_LINK_EXT_STATE_AUTONEG = 0,
	ETHTOOL_LINK_EXT_STATE_LINK_TRAINING_FAILURE = 1,
	ETHTOOL_LINK_EXT_STATE_LINK_LOGICAL_MISMATCH = 2,
	ETHTOOL_LINK_EXT_STATE_BAD_SIGNAL_INTEGRITY = 3,
	ETHTOOL_LINK_EXT_STATE_NO_CABLE = 4,
	ETHTOOL_LINK_EXT_STATE_CABLE_ISSUE = 5,
	ETHTOOL_LINK_EXT_STATE_EEPROM_ISSUE = 6,
	ETHTOOL_LINK_EXT_STATE_CALIBRATION_FAILURE = 7,
	ETHTOOL_LINK_EXT_STATE_POWER_BUDGET_EXCEEDED = 8,
	ETHTOOL_LINK_EXT_STATE_OVERHEAT = 9,
};

enum ethtool_link_ext_substate_autoneg {
	ETHTOOL_LINK_EXT_SUBSTATE_AN_NO_PARTNER_DETECTED = 1,
	ETHTOOL_LINK_EXT_SUBSTATE_AN_ACK_NOT_RECEIVED = 2,
	ETHTOOL_LINK_EXT_SUBSTATE_AN_NEXT_PAGE_EXCHANGE_FAILED = 3,
	ETHTOOL_LINK_EXT_SUBSTATE_AN_NO_PARTNER_DETECTED_FORCE_MODE = 4,
	ETHTOOL_LINK_EXT_SUBSTATE_AN_FEC_MISMATCH_DURING_OVERRIDE = 5,
	ETHTOOL_LINK_EXT_SUBSTATE_AN_NO_HCD = 6,
};

enum ethtool_link_ext_substate_link_training {
	ETHTOOL_LINK_EXT_SUBSTATE_LT_KR_FRAME_LOCK_NOT_ACQUIRED = 1,
	ETHTOOL_LINK_EXT_SUBSTATE_LT_KR_LINK_INHIBIT_TIMEOUT = 2,
	ETHTOOL_LINK_EXT_SUBSTATE_LT_KR_LINK_PARTNER_DID_NOT_SET_RECEIVER_READY = 3,
	ETHTOOL_LINK_EXT_SUBSTATE_LT_REMOTE_FAULT = 4,
};

enum ethtool_link_ext_substate_link_logical_mismatch {
	ETHTOOL_LINK_EXT_SUBSTATE_LLM_PCS_DID_NOT_ACQUIRE_BLOCK_LOCK = 1,
	ETHTOOL_LINK_EXT_SUBSTATE_LLM_PCS_DID_NOT_ACQUIRE_AM_LOCK = 2,
	ETHTOOL_LINK_EXT_SUBSTATE_LLM_PCS_DID_NOT_GET_ALIGN_STATUS = 3,
	ETHTOOL_LINK_EXT_SUBSTATE_LLM_FC_FEC_IS_NOT_LOCKED = 4,
	ETHTOOL_LINK_EXT_SUBSTATE_LLM_RS_FEC_IS_NOT_LOCKED = 5,
};

enum ethtool_link_ext_substate_bad_signal_integrity {
	ETHTOOL_LINK_EXT_SUBSTATE_BSI_LARGE_NUMBER_OF_PHYSICAL_ERRORS = 1,
	ETHTOOL_LINK_EXT_SUBSTATE_BSI_UNSUPPORTED_RATE = 2,
};

enum ethtool_link_ext_substate_cable_issue {
	ETHTOOL_LINK_EXT_SUBSTATE_CI_UNSUPPORTED_CABLE = 1,
	ETHTOOL_LINK_EXT_SUBSTATE_CI_CABLE_TEST_FAILURE = 2,
};

struct ethtool_test {
	__u32 cmd;
	__u32 flags;
	__u32 reserved;
	__u32 len;
	__u64 data[0];
};

struct ethtool_stats {
	__u32 cmd;
	__u32 n_stats;
	__u64 data[0];
};

struct ethtool_tcpip4_spec {
	__be32 ip4src;
	__be32 ip4dst;
	__be16 psrc;
	__be16 pdst;
	__u8 tos;
};

struct ethtool_ah_espip4_spec {
	__be32 ip4src;
	__be32 ip4dst;
	__be32 spi;
	__u8 tos;
};

struct ethtool_usrip4_spec {
	__be32 ip4src;
	__be32 ip4dst;
	__be32 l4_4_bytes;
	__u8 tos;
	__u8 ip_ver;
	__u8 proto;
};

struct ethtool_tcpip6_spec {
	__be32 ip6src[4];
	__be32 ip6dst[4];
	__be16 psrc;
	__be16 pdst;
	__u8 tclass;
};

struct ethtool_ah_espip6_spec {
	__be32 ip6src[4];
	__be32 ip6dst[4];
	__be32 spi;
	__u8 tclass;
};

struct ethtool_usrip6_spec {
	__be32 ip6src[4];
	__be32 ip6dst[4];
	__be32 l4_4_bytes;
	__u8 tclass;
	__u8 l4_proto;
};

union ethtool_flow_union {
	struct ethtool_tcpip4_spec tcp_ip4_spec;
	struct ethtool_tcpip4_spec udp_ip4_spec;
	struct ethtool_tcpip4_spec sctp_ip4_spec;
	struct ethtool_ah_espip4_spec ah_ip4_spec;
	struct ethtool_ah_espip4_spec esp_ip4_spec;
	struct ethtool_usrip4_spec usr_ip4_spec;
	struct ethtool_tcpip6_spec tcp_ip6_spec;
	struct ethtool_tcpip6_spec udp_ip6_spec;
	struct ethtool_tcpip6_spec sctp_ip6_spec;
	struct ethtool_ah_espip6_spec ah_ip6_spec;
	struct ethtool_ah_espip6_spec esp_ip6_spec;
	struct ethtool_usrip6_spec usr_ip6_spec;
	struct ethhdr ether_spec;
	__u8 hdata[52];
};

struct ethtool_flow_ext {
	__u8 padding[2];
	unsigned char h_dest[6];
	__be16 vlan_etype;
	__be16 vlan_tci;
	__be32 data[2];
};

struct ethtool_rx_flow_spec {
	__u32 flow_type;
	union ethtool_flow_union h_u;
	struct ethtool_flow_ext h_ext;
	union ethtool_flow_union m_u;
	struct ethtool_flow_ext m_ext;
	__u64 ring_cookie;
	__u32 location;
};

struct ethtool_rxnfc {
	__u32 cmd;
	__u32 flow_type;
	__u64 data;
	struct ethtool_rx_flow_spec fs;
	union {
		__u32 rule_cnt;
		__u32 rss_context;
	};
	__u32 rule_locs[0];
};

struct ethtool_flash {
	__u32 cmd;
	__u32 region;
	char data[128];
};

struct ethtool_dump {
	__u32 cmd;
	__u32 version;
	__u32 flag;
	__u32 len;
	__u8 data[0];
};

struct ethtool_ts_info {
	__u32 cmd;
	__u32 so_timestamping;
	__s32 phc_index;
	__u32 tx_types;
	__u32 tx_reserved[3];
	__u32 rx_filters;
	__u32 rx_reserved[3];
};

struct ethtool_fecparam {
	__u32 cmd;
	__u32 active_fec;
	__u32 fec;
	__u32 reserved;
};

struct ethtool_link_settings {
	__u32 cmd;
	__u32 speed;
	__u8 duplex;
	__u8 port;
	__u8 phy_address;
	__u8 autoneg;
	__u8 mdio_support;
	__u8 eth_tp_mdix;
	__u8 eth_tp_mdix_ctrl;
	__s8 link_mode_masks_nwords;
	__u8 transceiver;
	__u8 master_slave_cfg;
	__u8 master_slave_state;
	__u8 reserved1[1];
	__u32 reserved[7];
	__u32 link_mode_masks[0];
};

enum ethtool_phys_id_state {
	ETHTOOL_ID_INACTIVE = 0,
	ETHTOOL_ID_ACTIVE = 1,
	ETHTOOL_ID_ON = 2,
	ETHTOOL_ID_OFF = 3,
};

struct ethtool_link_ext_state_info {
	enum ethtool_link_ext_state link_ext_state;
	union {
		enum ethtool_link_ext_substate_autoneg autoneg;
		enum ethtool_link_ext_substate_link_training link_training;
		enum ethtool_link_ext_substate_link_logical_mismatch link_logical_mismatch;
		enum ethtool_link_ext_substate_bad_signal_integrity bad_signal_integrity;
		enum ethtool_link_ext_substate_cable_issue cable_issue;
		u8 __link_ext_substate;
	};
};

struct ethtool_link_ksettings {
	struct ethtool_link_settings base;
	struct {
		long unsigned int supported[2];
		long unsigned int advertising[2];
		long unsigned int lp_advertising[2];
	} link_modes;
};

struct ethtool_pause_stats {
	u64 tx_pause_frames;
	u64 rx_pause_frames;
};

struct ethtool_ops {
	u32 supported_coalesce_params;
	void (*get_drvinfo)(struct net_device *, struct ethtool_drvinfo *);
	int (*get_regs_len)(struct net_device *);
	void (*get_regs)(struct net_device *, struct ethtool_regs *, void *);
	void (*get_wol)(struct net_device *, struct ethtool_wolinfo *);
	int (*set_wol)(struct net_device *, struct ethtool_wolinfo *);
	u32 (*get_msglevel)(struct net_device *);
	void (*set_msglevel)(struct net_device *, u32);
	int (*nway_reset)(struct net_device *);
	u32 (*get_link)(struct net_device *);
	int (*get_link_ext_state)(struct net_device *, struct ethtool_link_ext_state_info *);
	int (*get_eeprom_len)(struct net_device *);
	int (*get_eeprom)(struct net_device *, struct ethtool_eeprom *, u8 *);
	int (*set_eeprom)(struct net_device *, struct ethtool_eeprom *, u8 *);
	int (*get_coalesce)(struct net_device *, struct ethtool_coalesce *);
	int (*set_coalesce)(struct net_device *, struct ethtool_coalesce *);
	void (*get_ringparam)(struct net_device *, struct ethtool_ringparam *);
	int (*set_ringparam)(struct net_device *, struct ethtool_ringparam *);
	void (*get_pause_stats)(struct net_device *, struct ethtool_pause_stats *);
	void (*get_pauseparam)(struct net_device *, struct ethtool_pauseparam *);
	int (*set_pauseparam)(struct net_device *, struct ethtool_pauseparam *);
	void (*self_test)(struct net_device *, struct ethtool_test *, u64 *);
	void (*get_strings)(struct net_device *, u32, u8 *);
	int (*set_phys_id)(struct net_device *, enum ethtool_phys_id_state);
	void (*get_ethtool_stats)(struct net_device *, struct ethtool_stats *, u64 *);
	int (*begin)(struct net_device *);
	void (*complete)(struct net_device *);
	u32 (*get_priv_flags)(struct net_device *);
	int (*set_priv_flags)(struct net_device *, u32);
	int (*get_sset_count)(struct net_device *, int);
	int (*get_rxnfc)(struct net_device *, struct ethtool_rxnfc *, u32 *);
	int (*set_rxnfc)(struct net_device *, struct ethtool_rxnfc *);
	int (*flash_device)(struct net_device *, struct ethtool_flash *);
	int (*reset)(struct net_device *, u32 *);
	u32 (*get_rxfh_key_size)(struct net_device *);
	u32 (*get_rxfh_indir_size)(struct net_device *);
	int (*get_rxfh)(struct net_device *, u32 *, u8 *, u8 *);
	int (*set_rxfh)(struct net_device *, const u32 *, const u8 *, const u8);
	int (*get_rxfh_context)(struct net_device *, u32 *, u8 *, u8 *, u32);
	int (*set_rxfh_context)(struct net_device *, const u32 *, const u8 *, const u8, u32 *, bool);
	void (*get_channels)(struct net_device *, struct ethtool_channels *);
	int (*set_channels)(struct net_device *, struct ethtool_channels *);
	int (*get_dump_flag)(struct net_device *, struct ethtool_dump *);
	int (*get_dump_data)(struct net_device *, struct ethtool_dump *, void *);
	int (*set_dump)(struct net_device *, struct ethtool_dump *);
	int (*get_ts_info)(struct net_device *, struct ethtool_ts_info *);
	int (*get_module_info)(struct net_device *, struct ethtool_modinfo *);
	int (*get_module_eeprom)(struct net_device *, struct ethtool_eeprom *, u8 *);
	int (*get_eee)(struct net_device *, struct ethtool_eee *);
	int (*set_eee)(struct net_device *, struct ethtool_eee *);
	int (*get_tunable)(struct net_device *, const struct ethtool_tunable *, void *);
	int (*set_tunable)(struct net_device *, const struct ethtool_tunable *, const void *);
	int (*get_per_queue_coalesce)(struct net_device *, u32, struct ethtool_coalesce *);
	int (*set_per_queue_coalesce)(struct net_device *, u32, struct ethtool_coalesce *);
	int (*get_link_ksettings)(struct net_device *, struct ethtool_link_ksettings *);
	int (*set_link_ksettings)(struct net_device *, const struct ethtool_link_ksettings *);
	int (*get_fecparam)(struct net_device *, struct ethtool_fecparam *);
	int (*set_fecparam)(struct net_device *, struct ethtool_fecparam *);
	void (*get_ethtool_phy_stats)(struct net_device *, struct ethtool_stats *, u64 *);
	int (*get_phy_tunable)(struct net_device *, const struct ethtool_tunable *, void *);
	int (*set_phy_tunable)(struct net_device *, const struct ethtool_tunable *, const void *);
};

struct nlattr;

struct nla_policy;

struct netlink_ext_ack {
	const char *_msg;
	const struct nlattr *bad_attr;
	const struct nla_policy *policy;
	u8 cookie[20];
	u8 cookie_len;
};

struct xdp_mem_info {
	u32 type;
	u32 id;
};

struct xdp_rxq_info {
	struct net_device *dev;
	u32 queue_index;
	u32 reg_state;
	struct xdp_mem_info mem;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct xdp_frame {
	void *data;
	u16 len;
	u16 headroom;
	u32 metasize: 8;
	u32 frame_sz: 24;
	struct xdp_mem_info mem;
	struct net_device *dev_rx;
};

struct nlmsghdr {
	__u32 nlmsg_len;
	__u16 nlmsg_type;
	__u16 nlmsg_flags;
	__u32 nlmsg_seq;
	__u32 nlmsg_pid;
};

struct nlattr {
	__u16 nla_len;
	__u16 nla_type;
};

struct netlink_range_validation;

struct netlink_range_validation_signed;

struct nla_policy {
	u8 type;
	u8 validation_type;
	u16 len;
	union {
		const u32 bitfield32_valid;
		const u32 mask;
		const char *reject_message;
		const struct nla_policy *nested_policy;
		struct netlink_range_validation *range;
		struct netlink_range_validation_signed *range_signed;
		struct {
			s16 min;
			s16 max;
		};
		int (*validate)(const struct nlattr *, struct netlink_ext_ack *);
		u16 strict_start_type;
	};
};

struct netlink_callback {
	struct sk_buff *skb;
	const struct nlmsghdr *nlh;
	int (*dump)(struct sk_buff *, struct netlink_callback *);
	int (*done)(struct netlink_callback *);
	void *data;
	struct module *module;
	struct netlink_ext_ack *extack;
	u16 family;
	u16 answer_flags;
	u32 min_dump_alloc;
	unsigned int prev_seq;
	unsigned int seq;
	bool strict_check;
	union {
		u8 ctx[48];
		long int args[6];
	};
};

struct ndmsg {
	__u8 ndm_family;
	__u8 ndm_pad1;
	__u16 ndm_pad2;
	__s32 ndm_ifindex;
	__u16 ndm_state;
	__u8 ndm_flags;
	__u8 ndm_type;
};

struct rtnl_link_stats64 {
	__u64 rx_packets;
	__u64 tx_packets;
	__u64 rx_bytes;
	__u64 tx_bytes;
	__u64 rx_errors;
	__u64 tx_errors;
	__u64 rx_dropped;
	__u64 tx_dropped;
	__u64 multicast;
	__u64 collisions;
	__u64 rx_length_errors;
	__u64 rx_over_errors;
	__u64 rx_crc_errors;
	__u64 rx_frame_errors;
	__u64 rx_fifo_errors;
	__u64 rx_missed_errors;
	__u64 tx_aborted_errors;
	__u64 tx_carrier_errors;
	__u64 tx_fifo_errors;
	__u64 tx_heartbeat_errors;
	__u64 tx_window_errors;
	__u64 rx_compressed;
	__u64 tx_compressed;
	__u64 rx_nohandler;
};

struct ifla_vf_guid {
	__u32 vf;
	__u64 guid;
};

struct ifla_vf_stats {
	__u64 rx_packets;
	__u64 tx_packets;
	__u64 rx_bytes;
	__u64 tx_bytes;
	__u64 broadcast;
	__u64 multicast;
	__u64 rx_dropped;
	__u64 tx_dropped;
};

struct ifla_vf_info {
	__u32 vf;
	__u8 mac[32];
	__u32 vlan;
	__u32 qos;
	__u32 spoofchk;
	__u32 linkstate;
	__u32 min_tx_rate;
	__u32 max_tx_rate;
	__u32 rss_query_en;
	__u32 trusted;
	__be16 vlan_proto;
};

struct tc_stats {
	__u64 bytes;
	__u32 packets;
	__u32 drops;
	__u32 overlimits;
	__u32 bps;
	__u32 pps;
	__u32 qlen;
	__u32 backlog;
};

struct tc_sizespec {
	unsigned char cell_log;
	unsigned char size_log;
	short int cell_align;
	int overhead;
	unsigned int linklayer;
	unsigned int mpu;
	unsigned int mtu;
	unsigned int tsize;
};

enum netdev_tx {
	__NETDEV_TX_MIN = 2147483648,
	NETDEV_TX_OK = 0,
	NETDEV_TX_BUSY = 16,
};

typedef enum netdev_tx netdev_tx_t;

struct header_ops {
	int (*create)(struct sk_buff *, struct net_device *, short unsigned int, const void *, const void *, unsigned int);
	int (*parse)(const struct sk_buff *, unsigned char *);
	int (*cache)(const struct neighbour *, struct hh_cache *, __be16);
	void (*cache_update)(struct hh_cache *, const struct net_device *, const unsigned char *);
	bool (*validate)(const char *, unsigned int);
	__be16 (*parse_protocol)(const struct sk_buff *);
};

struct netdev_queue {
	struct net_device *dev;
	struct Qdisc *qdisc;
	struct Qdisc *qdisc_sleeping;
	struct kobject kobj;
	long unsigned int tx_maxrate;
	long unsigned int trans_timeout;
	struct net_device *sb_dev;
	long: 64;
	long: 64;
	spinlock_t _xmit_lock;
	int xmit_lock_owner;
	long unsigned int trans_start;
	long unsigned int state;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct dql dql;
};

struct qdisc_skb_head {
	struct sk_buff *head;
	struct sk_buff *tail;
	__u32 qlen;
	spinlock_t lock;
};

struct gnet_stats_basic_packed {
	__u64 bytes;
	__u64 packets;
};

struct gnet_stats_queue {
	__u32 qlen;
	__u32 backlog;
	__u32 drops;
	__u32 requeues;
	__u32 overlimits;
};

struct Qdisc_ops;

struct qdisc_size_table;

struct net_rate_estimator;

struct gnet_stats_basic_cpu;

struct Qdisc {
	int (*enqueue)(struct sk_buff *, struct Qdisc *, struct sk_buff **);
	struct sk_buff * (*dequeue)(struct Qdisc *);
	unsigned int flags;
	u32 limit;
	const struct Qdisc_ops *ops;
	struct qdisc_size_table *stab;
	struct hlist_node hash;
	u32 handle;
	u32 parent;
	struct netdev_queue *dev_queue;
	struct net_rate_estimator *rate_est;
	struct gnet_stats_basic_cpu *cpu_bstats;
	struct gnet_stats_queue *cpu_qstats;
	int pad;
	refcount_t refcnt;
	long: 64;
	long: 64;
	long: 64;
	struct sk_buff_head gso_skb;
	struct qdisc_skb_head q;
	struct gnet_stats_basic_packed bstats;
	seqcount_t running;
	struct gnet_stats_queue qstats;
	long unsigned int state;
	struct Qdisc *next_sched;
	struct sk_buff_head skb_bad_txq;
	spinlock_t busylock;
	spinlock_t seqlock;
	bool empty;
	struct callback_head rcu;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long int privdata[0];
};

struct rps_map {
	unsigned int len;
	struct callback_head rcu;
	u16 cpus[0];
};

struct rps_dev_flow {
	u16 cpu;
	u16 filter;
	unsigned int last_qtail;
};

struct rps_dev_flow_table {
	unsigned int mask;
	struct callback_head rcu;
	struct rps_dev_flow flows[0];
};

struct netdev_rx_queue {
	struct rps_map *rps_map;
	struct rps_dev_flow_table *rps_flow_table;
	struct kobject kobj;
	struct net_device *dev;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct xdp_rxq_info xdp_rxq;
};

struct xps_map {
	unsigned int len;
	unsigned int alloc_len;
	struct callback_head rcu;
	u16 queues[0];
};

struct xps_dev_maps {
	struct callback_head rcu;
	struct xps_map *attr_map[0];
};

struct netdev_phys_item_id {
	unsigned char id[32];
	unsigned char id_len;
};

enum tc_setup_type {
	TC_SETUP_QDISC_MQPRIO = 0,
	TC_SETUP_CLSU32 = 1,
	TC_SETUP_CLSFLOWER = 2,
	TC_SETUP_CLSMATCHALL = 3,
	TC_SETUP_CLSBPF = 4,
	TC_SETUP_BLOCK = 5,
	TC_SETUP_QDISC_CBS = 6,
	TC_SETUP_QDISC_RED = 7,
	TC_SETUP_QDISC_PRIO = 8,
	TC_SETUP_QDISC_MQ = 9,
	TC_SETUP_QDISC_ETF = 10,
	TC_SETUP_ROOT_QDISC = 11,
	TC_SETUP_QDISC_GRED = 12,
	TC_SETUP_QDISC_TAPRIO = 13,
	TC_SETUP_FT = 14,
	TC_SETUP_QDISC_ETS = 15,
	TC_SETUP_QDISC_TBF = 16,
	TC_SETUP_QDISC_FIFO = 17,
};

enum bpf_netdev_command {
	XDP_SETUP_PROG = 0,
	XDP_SETUP_PROG_HW = 1,
	BPF_OFFLOAD_MAP_ALLOC = 2,
	BPF_OFFLOAD_MAP_FREE = 3,
	XDP_SETUP_XSK_POOL = 4,
};

struct xsk_buff_pool;

struct netdev_bpf {
	enum bpf_netdev_command command;
	union {
		struct {
			u32 flags;
			struct bpf_prog *prog;
			struct netlink_ext_ack *extack;
		};
		struct {
			struct bpf_offloaded_map *offmap;
		};
		struct {
			struct xsk_buff_pool *pool;
			u16 queue_id;
		} xsk;
	};
};

struct dev_ifalias {
	struct callback_head rcuhead;
	char ifalias[0];
};

struct netdev_name_node {
	struct hlist_node hlist;
	struct list_head list;
	struct net_device *dev;
	const char *name;
};

struct udp_tunnel_info;

struct devlink_port;

struct ip_tunnel_parm;

struct net_device_ops {
	int (*ndo_init)(struct net_device *);
	void (*ndo_uninit)(struct net_device *);
	int (*ndo_open)(struct net_device *);
	int (*ndo_stop)(struct net_device *);
	netdev_tx_t (*ndo_start_xmit)(struct sk_buff *, struct net_device *);
	netdev_features_t (*ndo_features_check)(struct sk_buff *, struct net_device *, netdev_features_t);
	u16 (*ndo_select_queue)(struct net_device *, struct sk_buff *, struct net_device *);
	void (*ndo_change_rx_flags)(struct net_device *, int);
	void (*ndo_set_rx_mode)(struct net_device *);
	int (*ndo_set_mac_address)(struct net_device *, void *);
	int (*ndo_validate_addr)(struct net_device *);
	int (*ndo_do_ioctl)(struct net_device *, struct ifreq *, int);
	int (*ndo_set_config)(struct net_device *, struct ifmap *);
	int (*ndo_change_mtu)(struct net_device *, int);
	int (*ndo_neigh_setup)(struct net_device *, struct neigh_parms *);
	void (*ndo_tx_timeout)(struct net_device *, unsigned int);
	void (*ndo_get_stats64)(struct net_device *, struct rtnl_link_stats64 *);
	bool (*ndo_has_offload_stats)(const struct net_device *, int);
	int (*ndo_get_offload_stats)(int, const struct net_device *, void *);
	struct net_device_stats * (*ndo_get_stats)(struct net_device *);
	int (*ndo_vlan_rx_add_vid)(struct net_device *, __be16, u16);
	int (*ndo_vlan_rx_kill_vid)(struct net_device *, __be16, u16);
	int (*ndo_set_vf_mac)(struct net_device *, int, u8 *);
	int (*ndo_set_vf_vlan)(struct net_device *, int, u16, u8, __be16);
	int (*ndo_set_vf_rate)(struct net_device *, int, int, int);
	int (*ndo_set_vf_spoofchk)(struct net_device *, int, bool);
	int (*ndo_set_vf_trust)(struct net_device *, int, bool);
	int (*ndo_get_vf_config)(struct net_device *, int, struct ifla_vf_info *);
	int (*ndo_set_vf_link_state)(struct net_device *, int, int);
	int (*ndo_get_vf_stats)(struct net_device *, int, struct ifla_vf_stats *);
	int (*ndo_set_vf_port)(struct net_device *, int, struct nlattr **);
	int (*ndo_get_vf_port)(struct net_device *, int, struct sk_buff *);
	int (*ndo_get_vf_guid)(struct net_device *, int, struct ifla_vf_guid *, struct ifla_vf_guid *);
	int (*ndo_set_vf_guid)(struct net_device *, int, u64, int);
	int (*ndo_set_vf_rss_query_en)(struct net_device *, int, bool);
	int (*ndo_setup_tc)(struct net_device *, enum tc_setup_type, void *);
	int (*ndo_rx_flow_steer)(struct net_device *, const struct sk_buff *, u16, u32);
	int (*ndo_add_slave)(struct net_device *, struct net_device *, struct netlink_ext_ack *);
	int (*ndo_del_slave)(struct net_device *, struct net_device *);
	struct net_device * (*ndo_get_xmit_slave)(struct net_device *, struct sk_buff *, bool);
	netdev_features_t (*ndo_fix_features)(struct net_device *, netdev_features_t);
	int (*ndo_set_features)(struct net_device *, netdev_features_t);
	int (*ndo_neigh_construct)(struct net_device *, struct neighbour *);
	void (*ndo_neigh_destroy)(struct net_device *, struct neighbour *);
	int (*ndo_fdb_add)(struct ndmsg *, struct nlattr **, struct net_device *, const unsigned char *, u16, u16, struct netlink_ext_ack *);
	int (*ndo_fdb_del)(struct ndmsg *, struct nlattr **, struct net_device *, const unsigned char *, u16);
	int (*ndo_fdb_dump)(struct sk_buff *, struct netlink_callback *, struct net_device *, struct net_device *, int *);
	int (*ndo_fdb_get)(struct sk_buff *, struct nlattr **, struct net_device *, const unsigned char *, u16, u32, u32, struct netlink_ext_ack *);
	int (*ndo_bridge_setlink)(struct net_device *, struct nlmsghdr *, u16, struct netlink_ext_ack *);
	int (*ndo_bridge_getlink)(struct sk_buff *, u32, u32, struct net_device *, u32, int);
	int (*ndo_bridge_dellink)(struct net_device *, struct nlmsghdr *, u16);
	int (*ndo_change_carrier)(struct net_device *, bool);
	int (*ndo_get_phys_port_id)(struct net_device *, struct netdev_phys_item_id *);
	int (*ndo_get_port_parent_id)(struct net_device *, struct netdev_phys_item_id *);
	int (*ndo_get_phys_port_name)(struct net_device *, char *, size_t);
	void (*ndo_udp_tunnel_add)(struct net_device *, struct udp_tunnel_info *);
	void (*ndo_udp_tunnel_del)(struct net_device *, struct udp_tunnel_info *);
	void * (*ndo_dfwd_add_station)(struct net_device *, struct net_device *);
	void (*ndo_dfwd_del_station)(struct net_device *, void *);
	int (*ndo_set_tx_maxrate)(struct net_device *, int, u32);
	int (*ndo_get_iflink)(const struct net_device *);
	int (*ndo_change_proto_down)(struct net_device *, bool);
	int (*ndo_fill_metadata_dst)(struct net_device *, struct sk_buff *);
	void (*ndo_set_rx_headroom)(struct net_device *, int);
	int (*ndo_bpf)(struct net_device *, struct netdev_bpf *);
	int (*ndo_xdp_xmit)(struct net_device *, int, struct xdp_frame **, u32);
	int (*ndo_xsk_wakeup)(struct net_device *, u32, u32);
	struct devlink_port * (*ndo_get_devlink_port)(struct net_device *);
	int (*ndo_tunnel_ctl)(struct net_device *, struct ip_tunnel_parm *, int);
	struct net_device * (*ndo_get_peer_dev)(struct net_device *);
};

struct neigh_parms {
	possible_net_t net;
	struct net_device *dev;
	struct list_head list;
	int (*neigh_setup)(struct neighbour *);
	struct neigh_table *tbl;
	void *sysctl_table;
	int dead;
	refcount_t refcnt;
	struct callback_head callback_head;
	int reachable_time;
	int data[13];
	long unsigned int data_state[1];
};

struct pcpu_lstats {
	u64_stats_t packets;
	u64_stats_t bytes;
	struct u64_stats_sync syncp;
};

struct pcpu_sw_netstats {
	u64 rx_packets;
	u64 rx_bytes;
	u64 tx_packets;
	u64 tx_bytes;
	struct u64_stats_sync syncp;
};

struct nd_opt_hdr;

struct ndisc_options;

struct prefix_info;

struct ndisc_ops {
	int (*is_useropt)(u8);
	int (*parse_options)(const struct net_device *, struct nd_opt_hdr *, struct ndisc_options *);
	void (*update)(const struct net_device *, struct neighbour *, u32, u8, const struct ndisc_options *);
	int (*opt_addr_space)(const struct net_device *, u8, struct neighbour *, u8 *, u8 **);
	void (*fill_addr_option)(const struct net_device *, struct sk_buff *, u8, const u8 *);
	void (*prefix_rcv_add_addr)(struct net *, struct net_device *, const struct prefix_info *, struct inet6_dev *, struct in6_addr *, int, u32, bool, bool, __u32, u32, bool);
};

struct ipv6_devstat {
	struct proc_dir_entry *proc_dir_entry;
	struct ipstats_mib *ipv6;
	struct icmpv6_mib_device *icmpv6dev;
	struct icmpv6msg_mib_device *icmpv6msgdev;
};

struct ifmcaddr6;

struct ifacaddr6;

struct inet6_dev {
	struct net_device *dev;
	struct list_head addr_list;
	struct ifmcaddr6 *mc_list;
	struct ifmcaddr6 *mc_tomb;
	spinlock_t mc_lock;
	unsigned char mc_qrv;
	unsigned char mc_gq_running;
	unsigned char mc_ifc_count;
	unsigned char mc_dad_count;
	long unsigned int mc_v1_seen;
	long unsigned int mc_qi;
	long unsigned int mc_qri;
	long unsigned int mc_maxdelay;
	struct timer_list mc_gq_timer;
	struct timer_list mc_ifc_timer;
	struct timer_list mc_dad_timer;
	struct ifacaddr6 *ac_list;
	rwlock_t lock;
	refcount_t refcnt;
	__u32 if_flags;
	int dead;
	u32 desync_factor;
	struct list_head tempaddr_list;
	struct in6_addr token;
	struct neigh_parms *nd_parms;
	struct ipv6_devconf cnf;
	struct ipv6_devstat stats;
	struct timer_list rs_timer;
	__s32 rs_interval;
	__u8 rs_probes;
	long unsigned int tstamp;
	struct callback_head rcu;
};

struct rtnl_link_ops {
	struct list_head list;
	const char *kind;
	size_t priv_size;
	void (*setup)(struct net_device *);
	bool netns_refund;
	unsigned int maxtype;
	const struct nla_policy *policy;
	int (*validate)(struct nlattr **, struct nlattr **, struct netlink_ext_ack *);
	int (*newlink)(struct net *, struct net_device *, struct nlattr **, struct nlattr **, struct netlink_ext_ack *);
	int (*changelink)(struct net_device *, struct nlattr **, struct nlattr **, struct netlink_ext_ack *);
	void (*dellink)(struct net_device *, struct list_head *);
	size_t (*get_size)(const struct net_device *);
	int (*fill_info)(struct sk_buff *, const struct net_device *);
	size_t (*get_xstats_size)(const struct net_device *);
	int (*fill_xstats)(struct sk_buff *, const struct net_device *);
	unsigned int (*get_num_tx_queues)();
	unsigned int (*get_num_rx_queues)();
	unsigned int slave_maxtype;
	const struct nla_policy *slave_policy;
	int (*slave_changelink)(struct net_device *, struct net_device *, struct nlattr **, struct nlattr **, struct netlink_ext_ack *);
	size_t (*get_slave_size)(const struct net_device *, const struct net_device *);
	int (*fill_slave_info)(struct sk_buff *, const struct net_device *, const struct net_device *);
	struct net * (*get_link_net)(const struct net_device *);
	size_t (*get_linkxstats_size)(const struct net_device *, int);
	int (*fill_linkxstats)(struct sk_buff *, const struct net_device *, int *, int);
};

struct udp_tunnel_nic_table_info {
	unsigned int n_entries;
	unsigned int tunnel_types;
};

struct udp_tunnel_nic_shared;

struct udp_tunnel_nic_info {
	int (*set_port)(struct net_device *, unsigned int, unsigned int, struct udp_tunnel_info *);
	int (*unset_port)(struct net_device *, unsigned int, unsigned int, struct udp_tunnel_info *);
	int (*sync_table)(struct net_device *, unsigned int);
	struct udp_tunnel_nic_shared *shared;
	unsigned int flags;
	struct udp_tunnel_nic_table_info tables[4];
};

enum {
	RTAX_UNSPEC = 0,
	RTAX_LOCK = 1,
	RTAX_MTU = 2,
	RTAX_WINDOW = 3,
	RTAX_RTT = 4,
	RTAX_RTTVAR = 5,
	RTAX_SSTHRESH = 6,
	RTAX_CWND = 7,
	RTAX_ADVMSS = 8,
	RTAX_REORDERING = 9,
	RTAX_HOPLIMIT = 10,
	RTAX_INITCWND = 11,
	RTAX_FEATURES = 12,
	RTAX_RTO_MIN = 13,
	RTAX_INITRWND = 14,
	RTAX_QUICKACK = 15,
	RTAX_CC_ALGO = 16,
	RTAX_FASTOPEN_NO_COOKIE = 17,
	__RTAX_MAX = 18,
};

struct tcmsg {
	unsigned char tcm_family;
	unsigned char tcm__pad1;
	short unsigned int tcm__pad2;
	int tcm_ifindex;
	__u32 tcm_handle;
	__u32 tcm_parent;
	__u32 tcm_info;
};

struct gnet_stats_basic_cpu {
	struct gnet_stats_basic_packed bstats;
	struct u64_stats_sync syncp;
};

struct gnet_dump {
	spinlock_t *lock;
	struct sk_buff *skb;
	struct nlattr *tail;
	int compat_tc_stats;
	int compat_xstats;
	int padattr;
	void *xstats;
	int xstats_len;
	struct tc_stats tc_stats;
};

struct netlink_range_validation {
	u64 min;
	u64 max;
};

struct netlink_range_validation_signed {
	s64 min;
	s64 max;
};

enum flow_action_hw_stats_bit {
	FLOW_ACTION_HW_STATS_IMMEDIATE_BIT = 0,
	FLOW_ACTION_HW_STATS_DELAYED_BIT = 1,
	FLOW_ACTION_HW_STATS_DISABLED_BIT = 2,
	FLOW_ACTION_HW_STATS_NUM_BITS = 3,
};

struct flow_block {
	struct list_head cb_list;
};

typedef int flow_setup_cb_t(enum tc_setup_type, void *, void *);

struct qdisc_size_table {
	struct callback_head rcu;
	struct list_head list;
	struct tc_sizespec szopts;
	int refcnt;
	u16 data[0];
};

struct Qdisc_class_ops;

struct Qdisc_ops {
	struct Qdisc_ops *next;
	const struct Qdisc_class_ops *cl_ops;
	char id[16];
	int priv_size;
	unsigned int static_flags;
	int (*enqueue)(struct sk_buff *, struct Qdisc *, struct sk_buff **);
	struct sk_buff * (*dequeue)(struct Qdisc *);
	struct sk_buff * (*peek)(struct Qdisc *);
	int (*init)(struct Qdisc *, struct nlattr *, struct netlink_ext_ack *);
	void (*reset)(struct Qdisc *);
	void (*destroy)(struct Qdisc *);
	int (*change)(struct Qdisc *, struct nlattr *, struct netlink_ext_ack *);
	void (*attach)(struct Qdisc *);
	int (*change_tx_queue_len)(struct Qdisc *, unsigned int);
	int (*dump)(struct Qdisc *, struct sk_buff *);
	int (*dump_stats)(struct Qdisc *, struct gnet_dump *);
	void (*ingress_block_set)(struct Qdisc *, u32);
	void (*egress_block_set)(struct Qdisc *, u32);
	u32 (*ingress_block_get)(struct Qdisc *);
	u32 (*egress_block_get)(struct Qdisc *);
	struct module *owner;
};

struct qdisc_walker;

struct tcf_block;

struct Qdisc_class_ops {
	unsigned int flags;
	struct netdev_queue * (*select_queue)(struct Qdisc *, struct tcmsg *);
	int (*graft)(struct Qdisc *, long unsigned int, struct Qdisc *, struct Qdisc **, struct netlink_ext_ack *);
	struct Qdisc * (*leaf)(struct Qdisc *, long unsigned int);
	void (*qlen_notify)(struct Qdisc *, long unsigned int);
	long unsigned int (*find)(struct Qdisc *, u32);
	int (*change)(struct Qdisc *, u32, u32, struct nlattr **, long unsigned int *, struct netlink_ext_ack *);
	int (*delete)(struct Qdisc *, long unsigned int);
	void (*walk)(struct Qdisc *, struct qdisc_walker *);
	struct tcf_block * (*tcf_block)(struct Qdisc *, long unsigned int, struct netlink_ext_ack *);
	long unsigned int (*bind_tcf)(struct Qdisc *, long unsigned int, u32);
	void (*unbind_tcf)(struct Qdisc *, long unsigned int);
	int (*dump)(struct Qdisc *, long unsigned int, struct sk_buff *, struct tcmsg *);
	int (*dump_stats)(struct Qdisc *, long unsigned int, struct gnet_dump *);
};

struct tcf_chain;

struct tcf_block {
	struct mutex lock;
	struct list_head chain_list;
	u32 index;
	u32 classid;
	refcount_t refcnt;
	struct net *net;
	struct Qdisc *q;
	struct rw_semaphore cb_lock;
	struct flow_block flow_block;
	struct list_head owner_list;
	bool keep_dst;
	atomic_t offloadcnt;
	unsigned int nooffloaddevcnt;
	unsigned int lockeddevcnt;
	struct {
		struct tcf_chain *chain;
		struct list_head filter_chain_list;
	} chain0;
	struct callback_head rcu;
	struct hlist_head proto_destroy_ht[128];
	struct mutex proto_destroy_lock;
};

struct tcf_result;

struct tcf_proto_ops;

struct tcf_proto {
	struct tcf_proto *next;
	void *root;
	int (*classify)(struct sk_buff *, const struct tcf_proto *, struct tcf_result *);
	__be16 protocol;
	u32 prio;
	void *data;
	const struct tcf_proto_ops *ops;
	struct tcf_chain *chain;
	spinlock_t lock;
	bool deleting;
	refcount_t refcnt;
	struct callback_head rcu;
	struct hlist_node destroy_ht_node;
};

struct tcf_result {
	union {
		struct {
			long unsigned int class;
			u32 classid;
		};
		const struct tcf_proto *goto_tp;
		struct {
			bool ingress;
			struct gnet_stats_queue *qstats;
		};
	};
};

struct tcf_walker;

struct tcf_proto_ops {
	struct list_head head;
	char kind[16];
	int (*classify)(struct sk_buff *, const struct tcf_proto *, struct tcf_result *);
	int (*init)(struct tcf_proto *);
	void (*destroy)(struct tcf_proto *, bool, struct netlink_ext_ack *);
	void * (*get)(struct tcf_proto *, u32);
	void (*put)(struct tcf_proto *, void *);
	int (*change)(struct net *, struct sk_buff *, struct tcf_proto *, long unsigned int, u32, struct nlattr **, void **, bool, bool, struct netlink_ext_ack *);
	int (*delete)(struct tcf_proto *, void *, bool *, bool, struct netlink_ext_ack *);
	bool (*delete_empty)(struct tcf_proto *);
	void (*walk)(struct tcf_proto *, struct tcf_walker *, bool);
	int (*reoffload)(struct tcf_proto *, bool, flow_setup_cb_t *, void *, struct netlink_ext_ack *);
	void (*hw_add)(struct tcf_proto *, void *);
	void (*hw_del)(struct tcf_proto *, void *);
	void (*bind_class)(void *, u32, long unsigned int, void *, long unsigned int);
	void * (*tmplt_create)(struct net *, struct tcf_chain *, struct nlattr **, struct netlink_ext_ack *);
	void (*tmplt_destroy)(void *);
	int (*dump)(struct net *, struct tcf_proto *, void *, struct sk_buff *, struct tcmsg *, bool);
	int (*terse_dump)(struct net *, struct tcf_proto *, void *, struct sk_buff *, struct tcmsg *, bool);
	int (*tmplt_dump)(struct sk_buff *, struct net *, void *);
	struct module *owner;
	int flags;
};

struct tcf_chain {
	struct mutex filter_chain_lock;
	struct tcf_proto *filter_chain;
	struct list_head list;
	struct tcf_block *block;
	u32 index;
	unsigned int refcnt;
	unsigned int action_refcnt;
	bool explicitly_created;
	bool flushing;
	const struct tcf_proto_ops *tmplt_ops;
	void *tmplt_priv;
	struct callback_head rcu;
};

struct sock_fprog_kern {
	u16 len;
	struct sock_filter *filter;
};

struct sk_filter {
	refcount_t refcnt;
	struct callback_head rcu;
	struct bpf_prog *prog;
};

enum {
	NEIGH_VAR_MCAST_PROBES = 0,
	NEIGH_VAR_UCAST_PROBES = 1,
	NEIGH_VAR_APP_PROBES = 2,
	NEIGH_VAR_MCAST_REPROBES = 3,
	NEIGH_VAR_RETRANS_TIME = 4,
	NEIGH_VAR_BASE_REACHABLE_TIME = 5,
	NEIGH_VAR_DELAY_PROBE_TIME = 6,
	NEIGH_VAR_GC_STALETIME = 7,
	NEIGH_VAR_QUEUE_LEN_BYTES = 8,
	NEIGH_VAR_PROXY_QLEN = 9,
	NEIGH_VAR_ANYCAST_DELAY = 10,
	NEIGH_VAR_PROXY_DELAY = 11,
	NEIGH_VAR_LOCKTIME = 12,
	NEIGH_VAR_QUEUE_LEN = 13,
	NEIGH_VAR_RETRANS_TIME_MS = 14,
	NEIGH_VAR_BASE_REACHABLE_TIME_MS = 15,
	NEIGH_VAR_GC_INTERVAL = 16,
	NEIGH_VAR_GC_THRESH1 = 17,
	NEIGH_VAR_GC_THRESH2 = 18,
	NEIGH_VAR_GC_THRESH3 = 19,
	NEIGH_VAR_MAX = 20,
};

struct pneigh_entry;

struct neigh_statistics;

struct neigh_hash_table;

struct neigh_table {
	int family;
	unsigned int entry_size;
	unsigned int key_len;
	__be16 protocol;
	__u32 (*hash)(const void *, const struct net_device *, __u32 *);
	bool (*key_eq)(const struct neighbour *, const void *);
	int (*constructor)(struct neighbour *);
	int (*pconstructor)(struct pneigh_entry *);
	void (*pdestructor)(struct pneigh_entry *);
	void (*proxy_redo)(struct sk_buff *);
	int (*is_multicast)(const void *);
	bool (*allow_add)(const struct net_device *, struct netlink_ext_ack *);
	char *id;
	struct neigh_parms parms;
	struct list_head parms_list;
	int gc_interval;
	int gc_thresh1;
	int gc_thresh2;
	int gc_thresh3;
	long unsigned int last_flush;
	struct delayed_work gc_work;
	struct timer_list proxy_timer;
	struct sk_buff_head proxy_queue;
	atomic_t entries;
	atomic_t gc_entries;
	struct list_head gc_list;
	rwlock_t lock;
	long unsigned int last_rand;
	struct neigh_statistics *stats;
	struct neigh_hash_table *nht;
	struct pneigh_entry **phash_buckets;
};

struct neigh_statistics {
	long unsigned int allocs;
	long unsigned int destroys;
	long unsigned int hash_grows;
	long unsigned int res_failed;
	long unsigned int lookups;
	long unsigned int hits;
	long unsigned int rcv_probes_mcast;
	long unsigned int rcv_probes_ucast;
	long unsigned int periodic_gc_runs;
	long unsigned int forced_gc_runs;
	long unsigned int unres_discards;
	long unsigned int table_fulls;
};

struct neigh_ops {
	int family;
	void (*solicit)(struct neighbour *, struct sk_buff *);
	void (*error_report)(struct neighbour *, struct sk_buff *);
	int (*output)(struct neighbour *, struct sk_buff *);
	int (*connected_output)(struct neighbour *, struct sk_buff *);
};

struct pneigh_entry {
	struct pneigh_entry *next;
	possible_net_t net;
	struct net_device *dev;
	u8 flags;
	u8 protocol;
	u8 key[0];
};

struct neigh_hash_table {
	struct neighbour **hash_buckets;
	unsigned int hash_shift;
	__u32 hash_rnd[4];
	struct callback_head rcu;
};

enum {
	TCP_ESTABLISHED = 1,
	TCP_SYN_SENT = 2,
	TCP_SYN_RECV = 3,
	TCP_FIN_WAIT1 = 4,
	TCP_FIN_WAIT2 = 5,
	TCP_TIME_WAIT = 6,
	TCP_CLOSE = 7,
	TCP_CLOSE_WAIT = 8,
	TCP_LAST_ACK = 9,
	TCP_LISTEN = 10,
	TCP_CLOSING = 11,
	TCP_NEW_SYN_RECV = 12,
	TCP_MAX_STATES = 13,
};

struct smc_hashinfo;

struct request_sock_ops;

struct timewait_sock_ops;

struct udp_table;

struct raw_hashinfo;

struct proto {
	void (*close)(struct sock *, long int);
	int (*pre_connect)(struct sock *, struct sockaddr *, int);
	int (*connect)(struct sock *, struct sockaddr *, int);
	int (*disconnect)(struct sock *, int);
	struct sock * (*accept)(struct sock *, int, int *, bool);
	int (*ioctl)(struct sock *, int, long unsigned int);
	int (*init)(struct sock *);
	void (*destroy)(struct sock *);
	void (*shutdown)(struct sock *, int);
	int (*setsockopt)(struct sock *, int, int, sockptr_t, unsigned int);
	int (*getsockopt)(struct sock *, int, int, char *, int *);
	void (*keepalive)(struct sock *, int);
	int (*sendmsg)(struct sock *, struct msghdr *, size_t);
	int (*recvmsg)(struct sock *, struct msghdr *, size_t, int, int, int *);
	int (*sendpage)(struct sock *, struct page *, int, size_t, int);
	int (*bind)(struct sock *, struct sockaddr *, int);
	int (*bind_add)(struct sock *, struct sockaddr *, int);
	int (*backlog_rcv)(struct sock *, struct sk_buff *);
	void (*release_cb)(struct sock *);
	int (*hash)(struct sock *);
	void (*unhash)(struct sock *);
	void (*rehash)(struct sock *);
	int (*get_port)(struct sock *, short unsigned int);
	unsigned int inuse_idx;
	bool (*stream_memory_free)(const struct sock *, int);
	bool (*stream_memory_read)(const struct sock *);
	void (*enter_memory_pressure)(struct sock *);
	void (*leave_memory_pressure)(struct sock *);
	atomic_long_t *memory_allocated;
	struct percpu_counter *sockets_allocated;
	long unsigned int *memory_pressure;
	long int *sysctl_mem;
	int *sysctl_wmem;
	int *sysctl_rmem;
	u32 sysctl_wmem_offset;
	u32 sysctl_rmem_offset;
	int max_header;
	bool no_autobind;
	struct kmem_cache *slab;
	unsigned int obj_size;
	slab_flags_t slab_flags;
	unsigned int useroffset;
	unsigned int usersize;
	struct percpu_counter *orphan_count;
	struct request_sock_ops *rsk_prot;
	struct timewait_sock_ops *twsk_prot;
	union {
		struct inet_hashinfo *hashinfo;
		struct udp_table *udp_table;
		struct raw_hashinfo *raw_hash;
		struct smc_hashinfo *smc_hash;
	} h;
	struct module *owner;
	char name[32];
	struct list_head node;
	int (*diag_destroy)(struct sock *, int);
};

struct request_sock;

struct request_sock_ops {
	int family;
	unsigned int obj_size;
	struct kmem_cache *slab;
	char *slab_name;
	int (*rtx_syn_ack)(const struct sock *, struct request_sock *);
	void (*send_ack)(const struct sock *, struct sk_buff *, struct request_sock *);
	void (*send_reset)(const struct sock *, struct sk_buff *);
	void (*destructor)(struct request_sock *);
	void (*syn_ack_timeout)(const struct request_sock *);
};

struct timewait_sock_ops {
	struct kmem_cache *twsk_slab;
	char *twsk_slab_name;
	unsigned int twsk_obj_size;
	int (*twsk_unique)(struct sock *, struct sock *, void *);
	void (*twsk_destructor)(struct sock *);
};

struct saved_syn;

struct request_sock {
	struct sock_common __req_common;
	struct request_sock *dl_next;
	u16 mss;
	u8 num_retrans;
	u8 syncookie: 1;
	u8 num_timeout: 7;
	u32 ts_recent;
	struct timer_list rsk_timer;
	const struct request_sock_ops *rsk_ops;
	struct sock *sk;
	struct saved_syn *saved_syn;
	u32 secid;
	u32 peer_secid;
};

struct saved_syn {
	u32 mac_hdrlen;
	u32 network_hdrlen;
	u32 tcp_hdrlen;
	u8 data[0];
};

enum tsq_enum {
	TSQ_THROTTLED = 0,
	TSQ_QUEUED = 1,
	TCP_TSQ_DEFERRED = 2,
	TCP_WRITE_TIMER_DEFERRED = 3,
	TCP_DELACK_TIMER_DEFERRED = 4,
	TCP_MTU_REDUCED_DEFERRED = 5,
};

struct ip6_sf_list {
	struct ip6_sf_list *sf_next;
	struct in6_addr sf_addr;
	long unsigned int sf_count[2];
	unsigned char sf_gsresp;
	unsigned char sf_oldin;
	unsigned char sf_crcount;
};

struct ifmcaddr6 {
	struct in6_addr mca_addr;
	struct inet6_dev *idev;
	struct ifmcaddr6 *next;
	struct ip6_sf_list *mca_sources;
	struct ip6_sf_list *mca_tomb;
	unsigned int mca_sfmode;
	unsigned char mca_crcount;
	long unsigned int mca_sfcount[2];
	struct timer_list mca_timer;
	unsigned int mca_flags;
	int mca_users;
	refcount_t mca_refcnt;
	spinlock_t mca_lock;
	long unsigned int mca_cstamp;
	long unsigned int mca_tstamp;
};

struct ifacaddr6 {
	struct in6_addr aca_addr;
	struct fib6_info *aca_rt;
	struct ifacaddr6 *aca_next;
	struct hlist_node aca_addr_lst;
	int aca_users;
	refcount_t aca_refcnt;
	long unsigned int aca_cstamp;
	long unsigned int aca_tstamp;
	struct callback_head rcu;
};

enum {
	__ND_OPT_PREFIX_INFO_END = 0,
	ND_OPT_SOURCE_LL_ADDR = 1,
	ND_OPT_TARGET_LL_ADDR = 2,
	ND_OPT_PREFIX_INFO = 3,
	ND_OPT_REDIRECT_HDR = 4,
	ND_OPT_MTU = 5,
	ND_OPT_NONCE = 14,
	__ND_OPT_ARRAY_MAX = 15,
	ND_OPT_ROUTE_INFO = 24,
	ND_OPT_RDNSS = 25,
	ND_OPT_DNSSL = 31,
	ND_OPT_6CO = 34,
	ND_OPT_CAPTIVE_PORTAL = 37,
	ND_OPT_PREF64 = 38,
	__ND_OPT_MAX = 39,
};

struct nd_opt_hdr {
	__u8 nd_opt_type;
	__u8 nd_opt_len;
};

struct ndisc_options {
	struct nd_opt_hdr *nd_opt_array[15];
	struct nd_opt_hdr *nd_useropts;
	struct nd_opt_hdr *nd_useropts_end;
};

struct prefix_info {
	__u8 type;
	__u8 length;
	__u8 prefix_len;
	__u8 reserved: 6;
	__u8 autoconf: 1;
	__u8 onlink: 1;
	__be32 valid;
	__be32 prefered;
	__be32 reserved2;
	struct in6_addr prefix;
};

enum nfs_opnum4 {
	OP_ACCESS = 3,
	OP_CLOSE = 4,
	OP_COMMIT = 5,
	OP_CREATE = 6,
	OP_DELEGPURGE = 7,
	OP_DELEGRETURN = 8,
	OP_GETATTR = 9,
	OP_GETFH = 10,
	OP_LINK = 11,
	OP_LOCK = 12,
	OP_LOCKT = 13,
	OP_LOCKU = 14,
	OP_LOOKUP = 15,
	OP_LOOKUPP = 16,
	OP_NVERIFY = 17,
	OP_OPEN = 18,
	OP_OPENATTR = 19,
	OP_OPEN_CONFIRM = 20,
	OP_OPEN_DOWNGRADE = 21,
	OP_PUTFH = 22,
	OP_PUTPUBFH = 23,
	OP_PUTROOTFH = 24,
	OP_READ = 25,
	OP_READDIR = 26,
	OP_READLINK = 27,
	OP_REMOVE = 28,
	OP_RENAME = 29,
	OP_RENEW = 30,
	OP_RESTOREFH = 31,
	OP_SAVEFH = 32,
	OP_SECINFO = 33,
	OP_SETATTR = 34,
	OP_SETCLIENTID = 35,
	OP_SETCLIENTID_CONFIRM = 36,
	OP_VERIFY = 37,
	OP_WRITE = 38,
	OP_RELEASE_LOCKOWNER = 39,
	OP_BACKCHANNEL_CTL = 40,
	OP_BIND_CONN_TO_SESSION = 41,
	OP_EXCHANGE_ID = 42,
	OP_CREATE_SESSION = 43,
	OP_DESTROY_SESSION = 44,
	OP_FREE_STATEID = 45,
	OP_GET_DIR_DELEGATION = 46,
	OP_GETDEVICEINFO = 47,
	OP_GETDEVICELIST = 48,
	OP_LAYOUTCOMMIT = 49,
	OP_LAYOUTGET = 50,
	OP_LAYOUTRETURN = 51,
	OP_SECINFO_NO_NAME = 52,
	OP_SEQUENCE = 53,
	OP_SET_SSV = 54,
	OP_TEST_STATEID = 55,
	OP_WANT_DELEGATION = 56,
	OP_DESTROY_CLIENTID = 57,
	OP_RECLAIM_COMPLETE = 58,
	OP_ALLOCATE = 59,
	OP_COPY = 60,
	OP_COPY_NOTIFY = 61,
	OP_DEALLOCATE = 62,
	OP_IO_ADVISE = 63,
	OP_LAYOUTERROR = 64,
	OP_LAYOUTSTATS = 65,
	OP_OFFLOAD_CANCEL = 66,
	OP_OFFLOAD_STATUS = 67,
	OP_READ_PLUS = 68,
	OP_SEEK = 69,
	OP_WRITE_SAME = 70,
	OP_CLONE = 71,
	OP_GETXATTR = 72,
	OP_SETXATTR = 73,
	OP_LISTXATTRS = 74,
	OP_REMOVEXATTR = 75,
	OP_ILLEGAL = 10044,
};

enum {
	UNAME26 = 131072,
	ADDR_NO_RANDOMIZE = 262144,
	FDPIC_FUNCPTRS = 524288,
	MMAP_PAGE_ZERO = 1048576,
	ADDR_COMPAT_LAYOUT = 2097152,
	READ_IMPLIES_EXEC = 4194304,
	ADDR_LIMIT_32BIT = 8388608,
	SHORT_INODE = 16777216,
	WHOLE_SECONDS = 33554432,
	STICKY_TIMEOUTS = 67108864,
	ADDR_LIMIT_3GB = 134217728,
};

enum perf_branch_sample_type_shift {
	PERF_SAMPLE_BRANCH_USER_SHIFT = 0,
	PERF_SAMPLE_BRANCH_KERNEL_SHIFT = 1,
	PERF_SAMPLE_BRANCH_HV_SHIFT = 2,
	PERF_SAMPLE_BRANCH_ANY_SHIFT = 3,
	PERF_SAMPLE_BRANCH_ANY_CALL_SHIFT = 4,
	PERF_SAMPLE_BRANCH_ANY_RETURN_SHIFT = 5,
	PERF_SAMPLE_BRANCH_IND_CALL_SHIFT = 6,
	PERF_SAMPLE_BRANCH_ABORT_TX_SHIFT = 7,
	PERF_SAMPLE_BRANCH_IN_TX_SHIFT = 8,
	PERF_SAMPLE_BRANCH_NO_TX_SHIFT = 9,
	PERF_SAMPLE_BRANCH_COND_SHIFT = 10,
	PERF_SAMPLE_BRANCH_CALL_STACK_SHIFT = 11,
	PERF_SAMPLE_BRANCH_IND_JUMP_SHIFT = 12,
	PERF_SAMPLE_BRANCH_CALL_SHIFT = 13,
	PERF_SAMPLE_BRANCH_NO_FLAGS_SHIFT = 14,
	PERF_SAMPLE_BRANCH_NO_CYCLES_SHIFT = 15,
	PERF_SAMPLE_BRANCH_TYPE_SAVE_SHIFT = 16,
	PERF_SAMPLE_BRANCH_HW_INDEX_SHIFT = 17,
	PERF_SAMPLE_BRANCH_MAX_SHIFT = 18,
};

enum {
	TSK_TRACE_FL_TRACE_BIT = 0,
	TSK_TRACE_FL_GRAPH_BIT = 1,
};

struct uuidcmp {
	const char *uuid;
	int len;
};

struct subprocess_info {
	struct work_struct work;
	struct completion *complete;
	const char *path;
	char **argv;
	char **envp;
	int wait;
	int retval;
	int (*init)(struct subprocess_info *, struct cred *);
	void (*cleanup)(struct subprocess_info *);
	void *data;
};

typedef phys_addr_t resource_size_t;

struct resource {
	resource_size_t start;
	resource_size_t end;
	const char *name;
	long unsigned int flags;
	long unsigned int desc;
	struct resource *parent;
	struct resource *sibling;
	struct resource *child;
};

struct hash {
	int ino;
	int minor;
	int major;
	umode_t mode;
	struct hash *next;
	char name[4098];
};

struct dir_entry {
	struct list_head list;
	char *name;
	time64_t mtime;
};

enum state {
	Start = 0,
	Collect = 1,
	GotHeader = 2,
	SkipIt = 3,
	GotName = 4,
	CopyFile = 5,
	GotSymlink = 6,
	Reset = 7,
};

typedef int (*decompress_fn)(unsigned char *, long int, long int (*)(void *, long unsigned int), long int (*)(void *, long unsigned int), unsigned char *, long int *, void (*)(char *));

typedef long unsigned int cycles_t;

enum migratetype {
	MIGRATE_UNMOVABLE = 0,
	MIGRATE_MOVABLE = 1,
	MIGRATE_RECLAIMABLE = 2,
	MIGRATE_CMA = 3,
	MIGRATE_PCPTYPES = 4,
	MIGRATE_HIGHATOMIC = 4,
	MIGRATE_ISOLATE = 5,
	MIGRATE_TYPES = 6,
};

enum zone_stat_item {
	NR_FREE_PAGES = 0,
	NR_ZONE_LRU_BASE = 1,
	NR_ZONE_INACTIVE_ANON = 1,
	NR_ZONE_ACTIVE_ANON = 2,
	NR_ZONE_INACTIVE_FILE = 3,
	NR_ZONE_ACTIVE_FILE = 4,
	NR_ZONE_UNEVICTABLE = 5,
	NR_ZONE_WRITE_PENDING = 6,
	NR_MLOCK = 7,
	NR_PAGETABLE = 8,
	NR_BOUNCE = 9,
	NR_ZSPAGES = 10,
	NR_FREE_CMA_PAGES = 11,
	NR_VM_ZONE_STAT_ITEMS = 12,
};

enum lru_list {
	LRU_INACTIVE_ANON = 0,
	LRU_ACTIVE_ANON = 1,
	LRU_INACTIVE_FILE = 2,
	LRU_ACTIVE_FILE = 3,
	LRU_UNEVICTABLE = 4,
	NR_LRU_LISTS = 5,
};

enum zone_watermarks {
	WMARK_MIN = 0,
	WMARK_LOW = 1,
	WMARK_HIGH = 2,
	NR_WMARK = 3,
};

enum {
	ZONELIST_FALLBACK = 0,
	MAX_ZONELISTS = 1,
};

enum {
	DQF_ROOT_SQUASH_B = 0,
	DQF_SYS_FILE_B = 16,
	DQF_PRIVATE = 17,
};

enum {
	DQST_LOOKUPS = 0,
	DQST_DROPS = 1,
	DQST_READS = 2,
	DQST_WRITES = 3,
	DQST_CACHE_HITS = 4,
	DQST_ALLOC_DQUOTS = 5,
	DQST_FREE_DQUOTS = 6,
	DQST_SYNCS = 7,
	_DQST_DQSTAT_LAST = 8,
};

enum {
	SB_UNFROZEN = 0,
	SB_FREEZE_WRITE = 1,
	SB_FREEZE_PAGEFAULT = 2,
	SB_FREEZE_FS = 3,
	SB_FREEZE_COMPLETE = 4,
};

enum compound_dtor_id {
	NULL_COMPOUND_DTOR = 0,
	COMPOUND_PAGE_DTOR = 1,
	HUGETLB_PAGE_DTOR = 2,
	NR_COMPOUND_DTORS = 3,
};

enum vm_event_item {
	PGPGIN = 0,
	PGPGOUT = 1,
	PSWPIN = 2,
	PSWPOUT = 3,
	PGALLOC_DMA32 = 4,
	PGALLOC_NORMAL = 5,
	PGALLOC_MOVABLE = 6,
	ALLOCSTALL_DMA32 = 7,
	ALLOCSTALL_NORMAL = 8,
	ALLOCSTALL_MOVABLE = 9,
	PGSCAN_SKIP_DMA32 = 10,
	PGSCAN_SKIP_NORMAL = 11,
	PGSCAN_SKIP_MOVABLE = 12,
	PGFREE = 13,
	PGACTIVATE = 14,
	PGDEACTIVATE = 15,
	PGLAZYFREE = 16,
	PGFAULT = 17,
	PGMAJFAULT = 18,
	PGLAZYFREED = 19,
	PGREFILL = 20,
	PGREUSE = 21,
	PGSTEAL_KSWAPD = 22,
	PGSTEAL_DIRECT = 23,
	PGSCAN_KSWAPD = 24,
	PGSCAN_DIRECT = 25,
	PGSCAN_DIRECT_THROTTLE = 26,
	PGSCAN_ANON = 27,
	PGSCAN_FILE = 28,
	PGSTEAL_ANON = 29,
	PGSTEAL_FILE = 30,
	PGINODESTEAL = 31,
	SLABS_SCANNED = 32,
	KSWAPD_INODESTEAL = 33,
	KSWAPD_LOW_WMARK_HIT_QUICKLY = 34,
	KSWAPD_HIGH_WMARK_HIT_QUICKLY = 35,
	PAGEOUTRUN = 36,
	PGROTATED = 37,
	DROP_PAGECACHE = 38,
	DROP_SLAB = 39,
	OOM_KILL = 40,
	PGMIGRATE_SUCCESS = 41,
	PGMIGRATE_FAIL = 42,
	THP_MIGRATION_SUCCESS = 43,
	THP_MIGRATION_FAIL = 44,
	THP_MIGRATION_SPLIT = 45,
	COMPACTMIGRATE_SCANNED = 46,
	COMPACTFREE_SCANNED = 47,
	COMPACTISOLATED = 48,
	COMPACTSTALL = 49,
	COMPACTFAIL = 50,
	COMPACTSUCCESS = 51,
	KCOMPACTD_WAKE = 52,
	KCOMPACTD_MIGRATE_SCANNED = 53,
	KCOMPACTD_FREE_SCANNED = 54,
	HTLB_BUDDY_PGALLOC = 55,
	HTLB_BUDDY_PGALLOC_FAIL = 56,
	CMA_ALLOC_SUCCESS = 57,
	CMA_ALLOC_FAIL = 58,
	UNEVICTABLE_PGCULLED = 59,
	UNEVICTABLE_PGSCANNED = 60,
	UNEVICTABLE_PGRESCUED = 61,
	UNEVICTABLE_PGMLOCKED = 62,
	UNEVICTABLE_PGMUNLOCKED = 63,
	UNEVICTABLE_PGCLEARED = 64,
	UNEVICTABLE_PGSTRANDED = 65,
	SWAP_RA = 66,
	SWAP_RA_HIT = 67,
	NR_VM_EVENT_ITEMS = 68,
};

enum {
	__SD_BALANCE_NEWIDLE = 0,
	__SD_BALANCE_EXEC = 1,
	__SD_BALANCE_FORK = 2,
	__SD_BALANCE_WAKE = 3,
	__SD_WAKE_AFFINE = 4,
	__SD_ASYM_CPUCAPACITY = 5,
	__SD_SHARE_CPUCAPACITY = 6,
	__SD_SHARE_PKG_RESOURCES = 7,
	__SD_SERIALIZE = 8,
	__SD_ASYM_PACKING = 9,
	__SD_PREFER_SIBLING = 10,
	__SD_OVERLAP = 11,
	__SD_NUMA = 12,
	__SD_FLAG_CNT = 13,
};

enum ucount_type {
	UCOUNT_USER_NAMESPACES = 0,
	UCOUNT_PID_NAMESPACES = 1,
	UCOUNT_UTS_NAMESPACES = 2,
	UCOUNT_IPC_NAMESPACES = 3,
	UCOUNT_NET_NAMESPACES = 4,
	UCOUNT_MNT_NAMESPACES = 5,
	UCOUNT_CGROUP_NAMESPACES = 6,
	UCOUNT_TIME_NAMESPACES = 7,
	UCOUNT_INOTIFY_INSTANCES = 8,
	UCOUNT_INOTIFY_WATCHES = 9,
	UCOUNT_COUNTS = 10,
};

enum flow_dissector_key_id {
	FLOW_DISSECTOR_KEY_CONTROL = 0,
	FLOW_DISSECTOR_KEY_BASIC = 1,
	FLOW_DISSECTOR_KEY_IPV4_ADDRS = 2,
	FLOW_DISSECTOR_KEY_IPV6_ADDRS = 3,
	FLOW_DISSECTOR_KEY_PORTS = 4,
	FLOW_DISSECTOR_KEY_PORTS_RANGE = 5,
	FLOW_DISSECTOR_KEY_ICMP = 6,
	FLOW_DISSECTOR_KEY_ETH_ADDRS = 7,
	FLOW_DISSECTOR_KEY_TIPC = 8,
	FLOW_DISSECTOR_KEY_ARP = 9,
	FLOW_DISSECTOR_KEY_VLAN = 10,
	FLOW_DISSECTOR_KEY_FLOW_LABEL = 11,
	FLOW_DISSECTOR_KEY_GRE_KEYID = 12,
	FLOW_DISSECTOR_KEY_MPLS_ENTROPY = 13,
	FLOW_DISSECTOR_KEY_ENC_KEYID = 14,
	FLOW_DISSECTOR_KEY_ENC_IPV4_ADDRS = 15,
	FLOW_DISSECTOR_KEY_ENC_IPV6_ADDRS = 16,
	FLOW_DISSECTOR_KEY_ENC_CONTROL = 17,
	FLOW_DISSECTOR_KEY_ENC_PORTS = 18,
	FLOW_DISSECTOR_KEY_MPLS = 19,
	FLOW_DISSECTOR_KEY_TCP = 20,
	FLOW_DISSECTOR_KEY_IP = 21,
	FLOW_DISSECTOR_KEY_CVLAN = 22,
	FLOW_DISSECTOR_KEY_ENC_IP = 23,
	FLOW_DISSECTOR_KEY_ENC_OPTS = 24,
	FLOW_DISSECTOR_KEY_META = 25,
	FLOW_DISSECTOR_KEY_CT = 26,
	FLOW_DISSECTOR_KEY_HASH = 27,
	FLOW_DISSECTOR_KEY_MAX = 28,
};

enum {
	IPSTATS_MIB_NUM = 0,
	IPSTATS_MIB_INPKTS = 1,
	IPSTATS_MIB_INOCTETS = 2,
	IPSTATS_MIB_INDELIVERS = 3,
	IPSTATS_MIB_OUTFORWDATAGRAMS = 4,
	IPSTATS_MIB_OUTPKTS = 5,
	IPSTATS_MIB_OUTOCTETS = 6,
	IPSTATS_MIB_INHDRERRORS = 7,
	IPSTATS_MIB_INTOOBIGERRORS = 8,
	IPSTATS_MIB_INNOROUTES = 9,
	IPSTATS_MIB_INADDRERRORS = 10,
	IPSTATS_MIB_INUNKNOWNPROTOS = 11,
	IPSTATS_MIB_INTRUNCATEDPKTS = 12,
	IPSTATS_MIB_INDISCARDS = 13,
	IPSTATS_MIB_OUTDISCARDS = 14,
	IPSTATS_MIB_OUTNOROUTES = 15,
	IPSTATS_MIB_REASMTIMEOUT = 16,
	IPSTATS_MIB_REASMREQDS = 17,
	IPSTATS_MIB_REASMOKS = 18,
	IPSTATS_MIB_REASMFAILS = 19,
	IPSTATS_MIB_FRAGOKS = 20,
	IPSTATS_MIB_FRAGFAILS = 21,
	IPSTATS_MIB_FRAGCREATES = 22,
	IPSTATS_MIB_INMCASTPKTS = 23,
	IPSTATS_MIB_OUTMCASTPKTS = 24,
	IPSTATS_MIB_INBCASTPKTS = 25,
	IPSTATS_MIB_OUTBCASTPKTS = 26,
	IPSTATS_MIB_INMCASTOCTETS = 27,
	IPSTATS_MIB_OUTMCASTOCTETS = 28,
	IPSTATS_MIB_INBCASTOCTETS = 29,
	IPSTATS_MIB_OUTBCASTOCTETS = 30,
	IPSTATS_MIB_CSUMERRORS = 31,
	IPSTATS_MIB_NOECTPKTS = 32,
	IPSTATS_MIB_ECT1PKTS = 33,
	IPSTATS_MIB_ECT0PKTS = 34,
	IPSTATS_MIB_CEPKTS = 35,
	IPSTATS_MIB_REASM_OVERLAPS = 36,
	__IPSTATS_MIB_MAX = 37,
};

enum {
	ICMP_MIB_NUM = 0,
	ICMP_MIB_INMSGS = 1,
	ICMP_MIB_INERRORS = 2,
	ICMP_MIB_INDESTUNREACHS = 3,
	ICMP_MIB_INTIMEEXCDS = 4,
	ICMP_MIB_INPARMPROBS = 5,
	ICMP_MIB_INSRCQUENCHS = 6,
	ICMP_MIB_INREDIRECTS = 7,
	ICMP_MIB_INECHOS = 8,
	ICMP_MIB_INECHOREPS = 9,
	ICMP_MIB_INTIMESTAMPS = 10,
	ICMP_MIB_INTIMESTAMPREPS = 11,
	ICMP_MIB_INADDRMASKS = 12,
	ICMP_MIB_INADDRMASKREPS = 13,
	ICMP_MIB_OUTMSGS = 14,
	ICMP_MIB_OUTERRORS = 15,
	ICMP_MIB_OUTDESTUNREACHS = 16,
	ICMP_MIB_OUTTIMEEXCDS = 17,
	ICMP_MIB_OUTPARMPROBS = 18,
	ICMP_MIB_OUTSRCQUENCHS = 19,
	ICMP_MIB_OUTREDIRECTS = 20,
	ICMP_MIB_OUTECHOS = 21,
	ICMP_MIB_OUTECHOREPS = 22,
	ICMP_MIB_OUTTIMESTAMPS = 23,
	ICMP_MIB_OUTTIMESTAMPREPS = 24,
	ICMP_MIB_OUTADDRMASKS = 25,
	ICMP_MIB_OUTADDRMASKREPS = 26,
	ICMP_MIB_CSUMERRORS = 27,
	__ICMP_MIB_MAX = 28,
};

enum {
	ICMP6_MIB_NUM = 0,
	ICMP6_MIB_INMSGS = 1,
	ICMP6_MIB_INERRORS = 2,
	ICMP6_MIB_OUTMSGS = 3,
	ICMP6_MIB_OUTERRORS = 4,
	ICMP6_MIB_CSUMERRORS = 5,
	__ICMP6_MIB_MAX = 6,
};

enum {
	TCP_MIB_NUM = 0,
	TCP_MIB_RTOALGORITHM = 1,
	TCP_MIB_RTOMIN = 2,
	TCP_MIB_RTOMAX = 3,
	TCP_MIB_MAXCONN = 4,
	TCP_MIB_ACTIVEOPENS = 5,
	TCP_MIB_PASSIVEOPENS = 6,
	TCP_MIB_ATTEMPTFAILS = 7,
	TCP_MIB_ESTABRESETS = 8,
	TCP_MIB_CURRESTAB = 9,
	TCP_MIB_INSEGS = 10,
	TCP_MIB_OUTSEGS = 11,
	TCP_MIB_RETRANSSEGS = 12,
	TCP_MIB_INERRS = 13,
	TCP_MIB_OUTRSTS = 14,
	TCP_MIB_CSUMERRORS = 15,
	__TCP_MIB_MAX = 16,
};

enum {
	UDP_MIB_NUM = 0,
	UDP_MIB_INDATAGRAMS = 1,
	UDP_MIB_NOPORTS = 2,
	UDP_MIB_INERRORS = 3,
	UDP_MIB_OUTDATAGRAMS = 4,
	UDP_MIB_RCVBUFERRORS = 5,
	UDP_MIB_SNDBUFERRORS = 6,
	UDP_MIB_CSUMERRORS = 7,
	UDP_MIB_IGNOREDMULTI = 8,
	__UDP_MIB_MAX = 9,
};

enum {
	LINUX_MIB_NUM = 0,
	LINUX_MIB_SYNCOOKIESSENT = 1,
	LINUX_MIB_SYNCOOKIESRECV = 2,
	LINUX_MIB_SYNCOOKIESFAILED = 3,
	LINUX_MIB_EMBRYONICRSTS = 4,
	LINUX_MIB_PRUNECALLED = 5,
	LINUX_MIB_RCVPRUNED = 6,
	LINUX_MIB_OFOPRUNED = 7,
	LINUX_MIB_OUTOFWINDOWICMPS = 8,
	LINUX_MIB_LOCKDROPPEDICMPS = 9,
	LINUX_MIB_ARPFILTER = 10,
	LINUX_MIB_TIMEWAITED = 11,
	LINUX_MIB_TIMEWAITRECYCLED = 12,
	LINUX_MIB_TIMEWAITKILLED = 13,
	LINUX_MIB_PAWSACTIVEREJECTED = 14,
	LINUX_MIB_PAWSESTABREJECTED = 15,
	LINUX_MIB_DELAYEDACKS = 16,
	LINUX_MIB_DELAYEDACKLOCKED = 17,
	LINUX_MIB_DELAYEDACKLOST = 18,
	LINUX_MIB_LISTENOVERFLOWS = 19,
	LINUX_MIB_LISTENDROPS = 20,
	LINUX_MIB_TCPHPHITS = 21,
	LINUX_MIB_TCPPUREACKS = 22,
	LINUX_MIB_TCPHPACKS = 23,
	LINUX_MIB_TCPRENORECOVERY = 24,
	LINUX_MIB_TCPSACKRECOVERY = 25,
	LINUX_MIB_TCPSACKRENEGING = 26,
	LINUX_MIB_TCPSACKREORDER = 27,
	LINUX_MIB_TCPRENOREORDER = 28,
	LINUX_MIB_TCPTSREORDER = 29,
	LINUX_MIB_TCPFULLUNDO = 30,
	LINUX_MIB_TCPPARTIALUNDO = 31,
	LINUX_MIB_TCPDSACKUNDO = 32,
	LINUX_MIB_TCPLOSSUNDO = 33,
	LINUX_MIB_TCPLOSTRETRANSMIT = 34,
	LINUX_MIB_TCPRENOFAILURES = 35,
	LINUX_MIB_TCPSACKFAILURES = 36,
	LINUX_MIB_TCPLOSSFAILURES = 37,
	LINUX_MIB_TCPFASTRETRANS = 38,
	LINUX_MIB_TCPSLOWSTARTRETRANS = 39,
	LINUX_MIB_TCPTIMEOUTS = 40,
	LINUX_MIB_TCPLOSSPROBES = 41,
	LINUX_MIB_TCPLOSSPROBERECOVERY = 42,
	LINUX_MIB_TCPRENORECOVERYFAIL = 43,
	LINUX_MIB_TCPSACKRECOVERYFAIL = 44,
	LINUX_MIB_TCPRCVCOLLAPSED = 45,
	LINUX_MIB_TCPDSACKOLDSENT = 46,
	LINUX_MIB_TCPDSACKOFOSENT = 47,
	LINUX_MIB_TCPDSACKRECV = 48,
	LINUX_MIB_TCPDSACKOFORECV = 49,
	LINUX_MIB_TCPABORTONDATA = 50,
	LINUX_MIB_TCPABORTONCLOSE = 51,
	LINUX_MIB_TCPABORTONMEMORY = 52,
	LINUX_MIB_TCPABORTONTIMEOUT = 53,
	LINUX_MIB_TCPABORTONLINGER = 54,
	LINUX_MIB_TCPABORTFAILED = 55,
	LINUX_MIB_TCPMEMORYPRESSURES = 56,
	LINUX_MIB_TCPMEMORYPRESSURESCHRONO = 57,
	LINUX_MIB_TCPSACKDISCARD = 58,
	LINUX_MIB_TCPDSACKIGNOREDOLD = 59,
	LINUX_MIB_TCPDSACKIGNOREDNOUNDO = 60,
	LINUX_MIB_TCPSPURIOUSRTOS = 61,
	LINUX_MIB_TCPMD5NOTFOUND = 62,
	LINUX_MIB_TCPMD5UNEXPECTED = 63,
	LINUX_MIB_TCPMD5FAILURE = 64,
	LINUX_MIB_SACKSHIFTED = 65,
	LINUX_MIB_SACKMERGED = 66,
	LINUX_MIB_SACKSHIFTFALLBACK = 67,
	LINUX_MIB_TCPBACKLOGDROP = 68,
	LINUX_MIB_PFMEMALLOCDROP = 69,
	LINUX_MIB_TCPMINTTLDROP = 70,
	LINUX_MIB_TCPDEFERACCEPTDROP = 71,
	LINUX_MIB_IPRPFILTER = 72,
	LINUX_MIB_TCPTIMEWAITOVERFLOW = 73,
	LINUX_MIB_TCPREQQFULLDOCOOKIES = 74,
	LINUX_MIB_TCPREQQFULLDROP = 75,
	LINUX_MIB_TCPRETRANSFAIL = 76,
	LINUX_MIB_TCPRCVCOALESCE = 77,
	LINUX_MIB_TCPBACKLOGCOALESCE = 78,
	LINUX_MIB_TCPOFOQUEUE = 79,
	LINUX_MIB_TCPOFODROP = 80,
	LINUX_MIB_TCPOFOMERGE = 81,
	LINUX_MIB_TCPCHALLENGEACK = 82,
	LINUX_MIB_TCPSYNCHALLENGE = 83,
	LINUX_MIB_TCPFASTOPENACTIVE = 84,
	LINUX_MIB_TCPFASTOPENACTIVEFAIL = 85,
	LINUX_MIB_TCPFASTOPENPASSIVE = 86,
	LINUX_MIB_TCPFASTOPENPASSIVEFAIL = 87,
	LINUX_MIB_TCPFASTOPENLISTENOVERFLOW = 88,
	LINUX_MIB_TCPFASTOPENCOOKIEREQD = 89,
	LINUX_MIB_TCPFASTOPENBLACKHOLE = 90,
	LINUX_MIB_TCPSPURIOUS_RTX_HOSTQUEUES = 91,
	LINUX_MIB_BUSYPOLLRXPACKETS = 92,
	LINUX_MIB_TCPAUTOCORKING = 93,
	LINUX_MIB_TCPFROMZEROWINDOWADV = 94,
	LINUX_MIB_TCPTOZEROWINDOWADV = 95,
	LINUX_MIB_TCPWANTZEROWINDOWADV = 96,
	LINUX_MIB_TCPSYNRETRANS = 97,
	LINUX_MIB_TCPORIGDATASENT = 98,
	LINUX_MIB_TCPHYSTARTTRAINDETECT = 99,
	LINUX_MIB_TCPHYSTARTTRAINCWND = 100,
	LINUX_MIB_TCPHYSTARTDELAYDETECT = 101,
	LINUX_MIB_TCPHYSTARTDELAYCWND = 102,
	LINUX_MIB_TCPACKSKIPPEDSYNRECV = 103,
	LINUX_MIB_TCPACKSKIPPEDPAWS = 104,
	LINUX_MIB_TCPACKSKIPPEDSEQ = 105,
	LINUX_MIB_TCPACKSKIPPEDFINWAIT2 = 106,
	LINUX_MIB_TCPACKSKIPPEDTIMEWAIT = 107,
	LINUX_MIB_TCPACKSKIPPEDCHALLENGE = 108,
	LINUX_MIB_TCPWINPROBE = 109,
	LINUX_MIB_TCPKEEPALIVE = 110,
	LINUX_MIB_TCPMTUPFAIL = 111,
	LINUX_MIB_TCPMTUPSUCCESS = 112,
	LINUX_MIB_TCPDELIVERED = 113,
	LINUX_MIB_TCPDELIVEREDCE = 114,
	LINUX_MIB_TCPACKCOMPRESSED = 115,
	LINUX_MIB_TCPZEROWINDOWDROP = 116,
	LINUX_MIB_TCPRCVQDROP = 117,
	LINUX_MIB_TCPWQUEUETOOBIG = 118,
	LINUX_MIB_TCPFASTOPENPASSIVEALTKEY = 119,
	LINUX_MIB_TCPTIMEOUTREHASH = 120,
	LINUX_MIB_TCPDUPLICATEDATAREHASH = 121,
	LINUX_MIB_TCPDSACKRECVSEGS = 122,
	LINUX_MIB_TCPDSACKIGNOREDDUBIOUS = 123,
	__LINUX_MIB_MAX = 124,
};

enum {
	LINUX_MIB_XFRMNUM = 0,
	LINUX_MIB_XFRMINERROR = 1,
	LINUX_MIB_XFRMINBUFFERERROR = 2,
	LINUX_MIB_XFRMINHDRERROR = 3,
	LINUX_MIB_XFRMINNOSTATES = 4,
	LINUX_MIB_XFRMINSTATEPROTOERROR = 5,
	LINUX_MIB_XFRMINSTATEMODEERROR = 6,
	LINUX_MIB_XFRMINSTATESEQERROR = 7,
	LINUX_MIB_XFRMINSTATEEXPIRED = 8,
	LINUX_MIB_XFRMINSTATEMISMATCH = 9,
	LINUX_MIB_XFRMINSTATEINVALID = 10,
	LINUX_MIB_XFRMINTMPLMISMATCH = 11,
	LINUX_MIB_XFRMINNOPOLS = 12,
	LINUX_MIB_XFRMINPOLBLOCK = 13,
	LINUX_MIB_XFRMINPOLERROR = 14,
	LINUX_MIB_XFRMOUTERROR = 15,
	LINUX_MIB_XFRMOUTBUNDLEGENERROR = 16,
	LINUX_MIB_XFRMOUTBUNDLECHECKERROR = 17,
	LINUX_MIB_XFRMOUTNOSTATES = 18,
	LINUX_MIB_XFRMOUTSTATEPROTOERROR = 19,
	LINUX_MIB_XFRMOUTSTATEMODEERROR = 20,
	LINUX_MIB_XFRMOUTSTATESEQERROR = 21,
	LINUX_MIB_XFRMOUTSTATEEXPIRED = 22,
	LINUX_MIB_XFRMOUTPOLBLOCK = 23,
	LINUX_MIB_XFRMOUTPOLDEAD = 24,
	LINUX_MIB_XFRMOUTPOLERROR = 25,
	LINUX_MIB_XFRMFWDHDRERROR = 26,
	LINUX_MIB_XFRMOUTSTATEINVALID = 27,
	LINUX_MIB_XFRMACQUIREERROR = 28,
	__LINUX_MIB_XFRMMAX = 29,
};

enum {
	LINUX_MIB_TLSNUM = 0,
	LINUX_MIB_TLSCURRTXSW = 1,
	LINUX_MIB_TLSCURRRXSW = 2,
	LINUX_MIB_TLSCURRTXDEVICE = 3,
	LINUX_MIB_TLSCURRRXDEVICE = 4,
	LINUX_MIB_TLSTXSW = 5,
	LINUX_MIB_TLSRXSW = 6,
	LINUX_MIB_TLSTXDEVICE = 7,
	LINUX_MIB_TLSRXDEVICE = 8,
	LINUX_MIB_TLSDECRYPTERROR = 9,
	LINUX_MIB_TLSRXDEVICERESYNC = 10,
	__LINUX_MIB_TLSMAX = 11,
};

enum nf_inet_hooks {
	NF_INET_PRE_ROUTING = 0,
	NF_INET_LOCAL_IN = 1,
	NF_INET_FORWARD = 2,
	NF_INET_LOCAL_OUT = 3,
	NF_INET_POST_ROUTING = 4,
	NF_INET_NUMHOOKS = 5,
	NF_INET_INGRESS = 5,
};

enum {
	NFPROTO_UNSPEC = 0,
	NFPROTO_INET = 1,
	NFPROTO_IPV4 = 2,
	NFPROTO_ARP = 3,
	NFPROTO_NETDEV = 5,
	NFPROTO_BRIDGE = 7,
	NFPROTO_IPV6 = 10,
	NFPROTO_DECNET = 12,
	NFPROTO_NUMPROTO = 13,
};

enum {
	XFRM_POLICY_IN = 0,
	XFRM_POLICY_OUT = 1,
	XFRM_POLICY_FWD = 2,
	XFRM_POLICY_MASK = 3,
	XFRM_POLICY_MAX = 3,
};

enum netns_bpf_attach_type {
	NETNS_BPF_INVALID = 4294967295,
	NETNS_BPF_FLOW_DISSECTOR = 0,
	NETNS_BPF_SK_LOOKUP = 1,
	MAX_NETNS_BPF_ATTACH_TYPE = 2,
};

struct soc_builtin_dtb {
	long unsigned int vendor_id;
	long unsigned int arch_id;
	long unsigned int imp_id;
	void * (*dtb_func)();
};

typedef long unsigned int uintptr_t;

struct membuf {
	void *p;
	size_t left;
};

struct user_regset;

typedef int user_regset_active_fn(struct task_struct *, const struct user_regset *);

typedef int user_regset_get2_fn(struct task_struct *, const struct user_regset *, struct membuf);

typedef int user_regset_set_fn(struct task_struct *, const struct user_regset *, unsigned int, unsigned int, const void *, const void *);

typedef int user_regset_writeback_fn(struct task_struct *, const struct user_regset *, int);

struct user_regset {
	user_regset_get2_fn *regset_get;
	user_regset_set_fn *set;
	user_regset_active_fn *active;
	user_regset_writeback_fn *writeback;
	unsigned int n;
	unsigned int size;
	unsigned int align;
	unsigned int bias;
	unsigned int core_note_type;
};

struct user_regset_view {
	const char *name;
	const struct user_regset *regsets;
	unsigned int n;
	u32 e_flags;
	u16 e_machine;
	u8 ei_osabi;
};

enum {
	TASKSTATS_CMD_UNSPEC = 0,
	TASKSTATS_CMD_GET = 1,
	TASKSTATS_CMD_NEW = 2,
	__TASKSTATS_CMD_MAX = 3,
};

enum {
	HI_SOFTIRQ = 0,
	TIMER_SOFTIRQ = 1,
	NET_TX_SOFTIRQ = 2,
	NET_RX_SOFTIRQ = 3,
	BLOCK_SOFTIRQ = 4,
	IRQ_POLL_SOFTIRQ = 5,
	TASKLET_SOFTIRQ = 6,
	SCHED_SOFTIRQ = 7,
	HRTIMER_SOFTIRQ = 8,
	RCU_SOFTIRQ = 9,
	NR_SOFTIRQS = 10,
};

enum cpu_usage_stat {
	CPUTIME_USER = 0,
	CPUTIME_NICE = 1,
	CPUTIME_SYSTEM = 2,
	CPUTIME_SOFTIRQ = 3,
	CPUTIME_IRQ = 4,
	CPUTIME_IDLE = 5,
	CPUTIME_IOWAIT = 6,
	CPUTIME_STEAL = 7,
	CPUTIME_GUEST = 8,
	CPUTIME_GUEST_NICE = 9,
	NR_STATS = 10,
};

enum bpf_cgroup_storage_type {
	BPF_CGROUP_STORAGE_SHARED = 0,
	BPF_CGROUP_STORAGE_PERCPU = 1,
	__BPF_CGROUP_STORAGE_MAX = 2,
};

enum bpf_tramp_prog_type {
	BPF_TRAMP_FENTRY = 0,
	BPF_TRAMP_FEXIT = 1,
	BPF_TRAMP_MODIFY_RETURN = 2,
	BPF_TRAMP_MAX = 3,
	BPF_TRAMP_REPLACE = 4,
};

enum cgroup_subsys_id {
	CGROUP_SUBSYS_COUNT = 0,
};

struct trace_event_raw_sys_enter {
	struct trace_entry ent;
	long int id;
	long unsigned int args[6];
	char __data[0];
};

struct trace_event_raw_sys_exit {
	struct trace_entry ent;
	long int id;
	long int ret;
	char __data[0];
};

struct trace_event_data_offsets_sys_enter {};

struct trace_event_data_offsets_sys_exit {};

typedef void (*btf_trace_sys_enter)(void *, struct pt_regs *, long int);

typedef void (*btf_trace_sys_exit)(void *, struct pt_regs *, long int);

enum riscv_regset {
	REGSET_X = 0,
	REGSET_F = 1,
	REGSET_V = 2,
};

struct pt_regs_offset {
	const char *name;
	int offset;
};

enum memblock_flags {
	MEMBLOCK_NONE = 0,
	MEMBLOCK_HOTPLUG = 1,
	MEMBLOCK_MIRROR = 2,
	MEMBLOCK_NOMAP = 4,
};

struct memblock_region {
	phys_addr_t base;
	phys_addr_t size;
	enum memblock_flags flags;
};

struct memblock_type {
	long unsigned int cnt;
	long unsigned int max;
	phys_addr_t total_size;
	struct memblock_region *regions;
	char *name;
};

struct memblock {
	bool bottom_up;
	phys_addr_t current_limit;
	struct memblock_type memory;
	struct memblock_type reserved;
};

struct screen_info {
	__u8 orig_x;
	__u8 orig_y;
	__u16 ext_mem_k;
	__u16 orig_video_page;
	__u8 orig_video_mode;
	__u8 orig_video_cols;
	__u8 flags;
	__u8 unused2;
	__u16 orig_video_ega_bx;
	__u16 unused3;
	__u8 orig_video_lines;
	__u8 orig_video_isVGA;
	__u16 orig_video_points;
	__u16 lfb_width;
	__u16 lfb_height;
	__u16 lfb_depth;
	__u32 lfb_base;
	__u32 lfb_size;
	__u16 cl_magic;
	__u16 cl_offset;
	__u16 lfb_linelength;
	__u8 red_size;
	__u8 red_pos;
	__u8 green_size;
	__u8 green_pos;
	__u8 blue_size;
	__u8 blue_pos;
	__u8 rsvd_size;
	__u8 rsvd_pos;
	__u16 vesapm_seg;
	__u16 vesapm_off;
	__u16 pages;
	__u16 vesa_attributes;
	__u32 capabilities;
	__u32 ext_lfb_base;
	__u8 _reserved[2];
} __attribute__((packed));

struct cpu {
	int node_id;
	int hotpluggable;
	struct device dev;
};

struct user_regs_struct {
	long unsigned int pc;
	long unsigned int ra;
	long unsigned int sp;
	long unsigned int gp;
	long unsigned int tp;
	long unsigned int t0;
	long unsigned int t1;
	long unsigned int t2;
	long unsigned int s0;
	long unsigned int s1;
	long unsigned int a0;
	long unsigned int a1;
	long unsigned int a2;
	long unsigned int a3;
	long unsigned int a4;
	long unsigned int a5;
	long unsigned int a6;
	long unsigned int a7;
	long unsigned int s2;
	long unsigned int s3;
	long unsigned int s4;
	long unsigned int s5;
	long unsigned int s6;
	long unsigned int s7;
	long unsigned int s8;
	long unsigned int s9;
	long unsigned int s10;
	long unsigned int s11;
	long unsigned int t3;
	long unsigned int t4;
	long unsigned int t5;
	long unsigned int t6;
};

struct __riscv_f_ext_state {
	__u32 f[32];
	__u32 fcsr;
};

struct __riscv_q_ext_state {
	__u64 f[64];
	__u32 fcsr;
	__u32 reserved[3];
};

union __riscv_fp_state {
	struct __riscv_f_ext_state f;
	struct __riscv_d_ext_state d;
	struct __riscv_q_ext_state q;
};

struct sigaltstack {
	void *ss_sp;
	int ss_flags;
	size_t ss_size;
};

typedef struct sigaltstack stack_t;

struct sigcontext {
	struct user_regs_struct sc_regs;
	union __riscv_fp_state sc_fpregs;
	struct __riscv_v_state sc_vregs;
};

struct siginfo {
	union {
		struct {
			int si_signo;
			int si_errno;
			int si_code;
			union __sifields _sifields;
		};
		int _si_pad[32];
	};
};

struct ksignal {
	struct k_sigaction ka;
	kernel_siginfo_t info;
	int sig;
};

enum {
	EI_ETYPE_NONE = 0,
	EI_ETYPE_NULL = 1,
	EI_ETYPE_ERRNO = 2,
	EI_ETYPE_ERRNO_NULL = 3,
	EI_ETYPE_TRUE = 4,
};

struct syscall_metadata {
	const char *name;
	int syscall_nr;
	int nb_args;
	const char **types;
	const char **args;
	struct list_head enter_fields;
	struct trace_event_call *enter_event;
	struct trace_event_call *exit_event;
};

struct ucontext {
	long unsigned int uc_flags;
	struct ucontext *uc_link;
	stack_t uc_stack;
	sigset_t uc_sigmask;
	__u8 __unused[120];
	long: 64;
	struct sigcontext uc_mcontext;
};

struct rt_sigframe {
	struct siginfo info;
	struct ucontext uc;
};

typedef __kernel_long_t __kernel_off_t;

typedef __kernel_off_t off_t;

enum vdso_clock_mode {
	VDSO_CLOCKMODE_NONE = 0,
	VDSO_CLOCKMODE_ARCHTIMER = 1,
	VDSO_CLOCKMODE_MAX = 2,
	VDSO_CLOCKMODE_TIMENS = 2147483647,
};

struct clocksource {
	u64 (*read)(struct clocksource *);
	u64 mask;
	u32 mult;
	u32 shift;
	u64 max_idle_ns;
	u32 maxadj;
	u64 max_cycles;
	const char *name;
	struct list_head list;
	int rating;
	enum vdso_clock_mode vdso_clock_mode;
	long unsigned int flags;
	int (*enable)(struct clocksource *);
	void (*disable)(struct clocksource *);
	void (*suspend)(struct clocksource *);
	void (*resume)(struct clocksource *);
	void (*mark_unstable)(struct clocksource *);
	void (*tick_stable)(struct clocksource *);
	struct module *owner;
};

typedef u32 bug_insn_t;

enum lockdep_ok {
	LOCKDEP_STILL_OK = 0,
	LOCKDEP_NOW_UNRELIABLE = 1,
};

enum bug_trap_type {
	BUG_TRAP_TYPE_NONE = 0,
	BUG_TRAP_TYPE_WARN = 1,
	BUG_TRAP_TYPE_BUG = 2,
};

enum die_val {
	DIE_UNUSED = 0,
	DIE_TRAP = 1,
	DIE_OOPS = 2,
};

struct stack_trace {
	unsigned int nr_entries;
	unsigned int max_entries;
	long unsigned int *entries;
	unsigned int skip;
};

struct stackframe {
	long unsigned int fp;
	long unsigned int ra;
};

enum cache_type {
	CACHE_TYPE_NOCACHE = 0,
	CACHE_TYPE_INST = 1,
	CACHE_TYPE_DATA = 2,
	CACHE_TYPE_SEPARATE = 3,
	CACHE_TYPE_UNIFIED = 4,
};

struct cacheinfo {
	unsigned int id;
	enum cache_type type;
	unsigned int level;
	unsigned int coherency_line_size;
	unsigned int number_of_sets;
	unsigned int ways_of_associativity;
	unsigned int physical_line_partition;
	unsigned int size;
	cpumask_t shared_cpu_map;
	unsigned int attributes;
	void *fw_token;
	bool disable_sysfs;
	void *priv;
};

struct cpu_cacheinfo {
	struct cacheinfo *info_list;
	unsigned int num_levels;
	unsigned int num_leaves;
	bool cpu_map_populated;
};

struct riscv_cacheinfo_ops {
	const struct attribute_group * (*get_priv_group)(struct cacheinfo *);
};

enum fixed_addresses {
	FIX_HOLE = 0,
	FIX_PTE = 1,
	FIX_PMD = 2,
	FIX_TEXT_POKE1 = 3,
	FIX_TEXT_POKE0 = 4,
	FIX_EARLYCON_MEM_BASE = 5,
	__end_of_permanent_fixed_addresses = 6,
	FIX_BTMAP_END = 6,
	FIX_BTMAP_BEGIN = 453,
	__end_of_fixed_addresses = 454,
};

struct patch_insn {
	void *addr;
	u32 insn;
	atomic_t cpu_count;
};

typedef u32 probe_opcode_t;

typedef bool probes_handler_t(u32, long unsigned int, struct pt_regs *);

struct arch_probe_insn {
	probe_opcode_t *insn;
	probes_handler_t *handler;
	long unsigned int restore;
};

typedef u32 kprobe_opcode_t;

struct arch_specific_insn {
	struct arch_probe_insn api;
};

struct kprobe;

struct prev_kprobe {
	struct kprobe *kp;
	unsigned int status;
};

typedef int (*kprobe_pre_handler_t)(struct kprobe *, struct pt_regs *);

typedef void (*kprobe_post_handler_t)(struct kprobe *, struct pt_regs *, long unsigned int);

typedef int (*kprobe_fault_handler_t)(struct kprobe *, struct pt_regs *, int);

struct kprobe {
	struct hlist_node hlist;
	struct list_head list;
	long unsigned int nmissed;
	kprobe_opcode_t *addr;
	const char *symbol_name;
	unsigned int offset;
	kprobe_pre_handler_t pre_handler;
	kprobe_post_handler_t post_handler;
	kprobe_fault_handler_t fault_handler;
	kprobe_opcode_t opcode;
	struct arch_specific_insn ainsn;
	u32 flags;
};

struct kprobe_step_ctx {
	long unsigned int ss_pending;
	long unsigned int match_addr;
};

struct kprobe_ctlblk {
	unsigned int kprobe_status;
	long unsigned int saved_status;
	struct prev_kprobe prev_kprobe;
	struct kprobe_step_ctx ss_ctx;
};

struct kretprobe_instance;

typedef int (*kretprobe_handler_t)(struct kretprobe_instance *, struct pt_regs *);

struct kretprobe;

struct kretprobe_instance {
	union {
		struct hlist_node hlist;
		struct callback_head rcu;
	};
	struct kretprobe *rp;
	kprobe_opcode_t *ret_addr;
	struct task_struct *task;
	void *fp;
	char data[0];
};

struct kretprobe {
	struct kprobe kp;
	kretprobe_handler_t handler;
	kretprobe_handler_t entry_handler;
	int maxactive;
	int nmissed;
	size_t data_size;
	struct hlist_head free_instances;
	raw_spinlock_t lock;
};

struct kprobe_insn_cache {
	struct mutex mutex;
	void * (*alloc)();
	void (*free)(void *);
	const char *sym;
	struct list_head pages;
	size_t insn_size;
	int nr_garbage;
};

enum probe_insn {
	INSN_REJECTED = 0,
	INSN_GOOD_NO_SLOT = 1,
	INSN_GOOD = 2,
};

typedef u32 uprobe_opcode_t;

struct arch_uprobe {
	union {
		u8 insn[8];
		u8 ixol[8];
	};
	struct arch_probe_insn api;
	long unsigned int insn_size;
	bool simulate;
};

enum rp_check {
	RP_CHECK_CALL = 0,
	RP_CHECK_CHAIN_CALL = 1,
	RP_CHECK_RET = 2,
};

enum pageflags {
	PG_locked = 0,
	PG_referenced = 1,
	PG_uptodate = 2,
	PG_dirty = 3,
	PG_lru = 4,
	PG_active = 5,
	PG_workingset = 6,
	PG_waiters = 7,
	PG_error = 8,
	PG_slab = 9,
	PG_owner_priv_1 = 10,
	PG_arch_1 = 11,
	PG_reserved = 12,
	PG_private = 13,
	PG_private_2 = 14,
	PG_writeback = 15,
	PG_head = 16,
	PG_mappedtodisk = 17,
	PG_reclaim = 18,
	PG_swapbacked = 19,
	PG_unevictable = 20,
	PG_mlocked = 21,
	PG_arch_2 = 22,
	__NR_PAGEFLAGS = 23,
	PG_checked = 10,
	PG_swapcache = 10,
	PG_fscache = 14,
	PG_pinned = 10,
	PG_savepinned = 3,
	PG_foreign = 10,
	PG_xen_remapped = 10,
	PG_slob_free = 13,
	PG_double_map = 6,
	PG_isolated = 18,
	PG_reported = 2,
};

struct timens_offset {
	s64 sec;
	u64 nsec;
};

struct arch_vdso_data {};

struct vdso_timestamp {
	u64 sec;
	u64 nsec;
};

struct vdso_data {
	u32 seq;
	s32 clock_mode;
	u64 cycle_last;
	u64 mask;
	u32 mult;
	u32 shift;
	union {
		struct vdso_timestamp basetime[12];
		struct timens_offset offset[12];
	};
	s32 tz_minuteswest;
	s32 tz_dsttime;
	u32 hrtimer_res;
	u32 __unused;
	struct arch_vdso_data arch_data;
};

struct cpu_operations {
	const char *name;
	int (*cpu_prepare)(unsigned int);
	int (*cpu_start)(unsigned int, struct task_struct *);
	int (*cpu_disable)(unsigned int);
	void (*cpu_stop)();
	int (*cpu_is_stopped)(unsigned int);
};

struct riscv_ipi_ops {
	void (*ipi_inject)(const struct cpumask *);
	void (*ipi_clear)();
};

enum ipi_message_type {
	IPI_RESCHEDULE = 0,
	IPI_CALL_FUNC = 1,
	IPI_CPU_STOP = 2,
	IPI_CPU_CRASH_STOP = 3,
	IPI_IRQ_WORK = 4,
	IPI_MAX = 5,
};

enum sbi_ext_id {
	SBI_EXT_0_1_SET_TIMER = 0,
	SBI_EXT_0_1_CONSOLE_PUTCHAR = 1,
	SBI_EXT_0_1_CONSOLE_GETCHAR = 2,
	SBI_EXT_0_1_CLEAR_IPI = 3,
	SBI_EXT_0_1_SEND_IPI = 4,
	SBI_EXT_0_1_REMOTE_FENCE_I = 5,
	SBI_EXT_0_1_REMOTE_SFENCE_VMA = 6,
	SBI_EXT_0_1_REMOTE_SFENCE_VMA_ASID = 7,
	SBI_EXT_0_1_SHUTDOWN = 8,
	SBI_EXT_BASE = 16,
	SBI_EXT_TIME = 1414090053,
	SBI_EXT_IPI = 7557193,
	SBI_EXT_RFENCE = 1380339267,
	SBI_EXT_HSM = 4739917,
};

typedef __kernel_long_t __kernel_ptrdiff_t;

typedef __kernel_ptrdiff_t ptrdiff_t;

typedef __s64 Elf64_Sxword;

struct elf64_rela {
	Elf64_Addr r_offset;
	Elf64_Xword r_info;
	Elf64_Sxword r_addend;
};

typedef struct elf64_rela Elf64_Rela;

struct elf64_hdr {
	unsigned char e_ident[16];
	Elf64_Half e_type;
	Elf64_Half e_machine;
	Elf64_Word e_version;
	Elf64_Addr e_entry;
	Elf64_Off e_phoff;
	Elf64_Off e_shoff;
	Elf64_Word e_flags;
	Elf64_Half e_ehsize;
	Elf64_Half e_phentsize;
	Elf64_Half e_phnum;
	Elf64_Half e_shentsize;
	Elf64_Half e_shnum;
	Elf64_Half e_shstrndx;
};

typedef struct elf64_hdr Elf64_Ehdr;

struct got_entry {
	long unsigned int symbol_addr;
};

struct plt_entry {
	u32 insn_auipc;
	u32 insn_ld;
	u32 insn_jr;
};

struct dyn_arch_ftrace {};

struct dyn_ftrace {
	long unsigned int ip;
	long unsigned int flags;
	struct dyn_arch_ftrace arch;
};

struct perf_guest_info_callbacks {
	int (*is_in_guest)();
	int (*is_user_mode)();
	long unsigned int (*get_guest_ip)();
	void (*handle_intel_pt_intr)();
};

struct perf_callchain_entry_ctx {
	struct perf_callchain_entry *entry;
	u32 max_stack;
	u32 nr;
	short int contexts;
	bool contexts_maxed;
};

enum perf_sample_regs_abi {
	PERF_SAMPLE_REGS_ABI_NONE = 0,
	PERF_SAMPLE_REGS_ABI_32 = 1,
	PERF_SAMPLE_REGS_ABI_64 = 2,
};

enum perf_event_riscv_regs {
	PERF_REG_RISCV_PC = 0,
	PERF_REG_RISCV_RA = 1,
	PERF_REG_RISCV_SP = 2,
	PERF_REG_RISCV_GP = 3,
	PERF_REG_RISCV_TP = 4,
	PERF_REG_RISCV_T0 = 5,
	PERF_REG_RISCV_T1 = 6,
	PERF_REG_RISCV_T2 = 7,
	PERF_REG_RISCV_S0 = 8,
	PERF_REG_RISCV_S1 = 9,
	PERF_REG_RISCV_A0 = 10,
	PERF_REG_RISCV_A1 = 11,
	PERF_REG_RISCV_A2 = 12,
	PERF_REG_RISCV_A3 = 13,
	PERF_REG_RISCV_A4 = 14,
	PERF_REG_RISCV_A5 = 15,
	PERF_REG_RISCV_A6 = 16,
	PERF_REG_RISCV_A7 = 17,
	PERF_REG_RISCV_S2 = 18,
	PERF_REG_RISCV_S3 = 19,
	PERF_REG_RISCV_S4 = 20,
	PERF_REG_RISCV_S5 = 21,
	PERF_REG_RISCV_S6 = 22,
	PERF_REG_RISCV_S7 = 23,
	PERF_REG_RISCV_S8 = 24,
	PERF_REG_RISCV_S9 = 25,
	PERF_REG_RISCV_S10 = 26,
	PERF_REG_RISCV_S11 = 27,
	PERF_REG_RISCV_T3 = 28,
	PERF_REG_RISCV_T4 = 29,
	PERF_REG_RISCV_T5 = 30,
	PERF_REG_RISCV_T6 = 31,
	PERF_REG_RISCV_MAX = 32,
};

typedef u64 uint64_t;

enum sbi_ext_base_fid {
	SBI_EXT_BASE_GET_SPEC_VERSION = 0,
	SBI_EXT_BASE_GET_IMP_ID = 1,
	SBI_EXT_BASE_GET_IMP_VERSION = 2,
	SBI_EXT_BASE_PROBE_EXT = 3,
	SBI_EXT_BASE_GET_MVENDORID = 4,
	SBI_EXT_BASE_GET_MARCHID = 5,
	SBI_EXT_BASE_GET_MIMPID = 6,
};

enum sbi_ext_time_fid {
	SBI_EXT_TIME_SET_TIMER = 0,
};

enum sbi_ext_ipi_fid {
	SBI_EXT_IPI_SEND_IPI = 0,
};

enum sbi_ext_rfence_fid {
	SBI_EXT_RFENCE_REMOTE_FENCE_I = 0,
	SBI_EXT_RFENCE_REMOTE_SFENCE_VMA = 1,
	SBI_EXT_RFENCE_REMOTE_SFENCE_VMA_ASID = 2,
	SBI_EXT_RFENCE_REMOTE_HFENCE_GVMA_VMID = 3,
	SBI_EXT_RFENCE_REMOTE_HFENCE_GVMA = 4,
	SBI_EXT_RFENCE_REMOTE_HFENCE_VVMA_ASID = 5,
	SBI_EXT_RFENCE_REMOTE_HFENCE_VVMA = 6,
};

struct sbiret {
	long int error;
	long int value;
};

enum sbi_ext_hsm_fid {
	SBI_EXT_HSM_HART_START = 0,
	SBI_EXT_HSM_HART_STOP = 1,
	SBI_EXT_HSM_HART_STATUS = 2,
};

enum sbi_hsm_hart_status {
	SBI_HSM_HART_STATUS_STARTED = 0,
	SBI_HSM_HART_STATUS_STOPPED = 1,
	SBI_HSM_HART_STATUS_START_PENDING = 2,
	SBI_HSM_HART_STATUS_STOP_PENDING = 3,
};

enum irqreturn {
	IRQ_NONE = 0,
	IRQ_HANDLED = 1,
	IRQ_WAKE_THREAD = 2,
};

typedef enum irqreturn irqreturn_t;

struct kimage_arch {
	long unsigned int fdt_addr;
};

typedef void (*riscv_kexec_method)(long unsigned int, long unsigned int, long unsigned int, long unsigned int, long unsigned int);

typedef long unsigned int kimage_entry_t;

struct kexec_segment {
	union {
		void *buf;
		void *kbuf;
	};
	size_t bufsz;
	long unsigned int mem;
	size_t memsz;
};

struct kimage {
	kimage_entry_t head;
	kimage_entry_t *entry;
	kimage_entry_t *last_entry;
	long unsigned int start;
	struct page *control_code_page;
	struct page *swap_page;
	void *vmcoreinfo_data_copy;
	long unsigned int nr_segments;
	struct kexec_segment segment[16];
	struct list_head control_pages;
	struct list_head dest_pages;
	struct list_head unusable_pages;
	long unsigned int control_page;
	unsigned int type: 1;
	unsigned int preserve_context: 1;
	unsigned int file_mode: 1;
	struct kimage_arch arch;
};

typedef __be32 fdt32_t;

struct fdt_header {
	fdt32_t magic;
	fdt32_t totalsize;
	fdt32_t off_dt_struct;
	fdt32_t off_dt_strings;
	fdt32_t off_mem_rsvmap;
	fdt32_t version;
	fdt32_t last_comp_version;
	fdt32_t boot_cpuid_phys;
	fdt32_t size_dt_strings;
	fdt32_t size_dt_struct;
};

struct irq_desc;

typedef void (*irq_flow_handler_t)(struct irq_desc *);

struct msi_desc;

struct irq_common_data {
	unsigned int state_use_accessors;
	void *handler_data;
	struct msi_desc *msi_desc;
	cpumask_var_t affinity;
};

struct irq_chip;

struct irq_domain;

struct irq_data {
	u32 mask;
	unsigned int irq;
	long unsigned int hwirq;
	struct irq_common_data *common;
	struct irq_chip *chip;
	struct irq_domain *domain;
	struct irq_data *parent_data;
	void *chip_data;
};

struct irqaction;

struct irq_affinity_notify;

struct irq_desc {
	struct irq_common_data irq_common_data;
	struct irq_data irq_data;
	unsigned int *kstat_irqs;
	irq_flow_handler_t handle_irq;
	struct irqaction *action;
	unsigned int status_use_accessors;
	unsigned int core_internal_state__do_not_mess_with_it;
	unsigned int depth;
	unsigned int wake_depth;
	unsigned int tot_count;
	unsigned int irq_count;
	long unsigned int last_unhandled;
	unsigned int irqs_unhandled;
	atomic_t threads_handled;
	int threads_handled_last;
	raw_spinlock_t lock;
	struct cpumask *percpu_enabled;
	const struct cpumask *percpu_affinity;
	const struct cpumask *affinity_hint;
	struct irq_affinity_notify *affinity_notify;
	long unsigned int threads_oneshot;
	atomic_t threads_active;
	wait_queue_head_t wait_for_threads;
	struct proc_dir_entry *dir;
	struct callback_head rcu;
	struct kobject kobj;
	struct mutex request_mutex;
	int parent_irq;
	struct module *owner;
	const char *name;
	long: 64;
};

enum irqchip_irq_state {
	IRQCHIP_STATE_PENDING = 0,
	IRQCHIP_STATE_ACTIVE = 1,
	IRQCHIP_STATE_MASKED = 2,
	IRQCHIP_STATE_LINE_LEVEL = 3,
};

struct msi_msg;

struct irq_chip {
	struct device *parent_device;
	const char *name;
	unsigned int (*irq_startup)(struct irq_data *);
	void (*irq_shutdown)(struct irq_data *);
	void (*irq_enable)(struct irq_data *);
	void (*irq_disable)(struct irq_data *);
	void (*irq_ack)(struct irq_data *);
	void (*irq_mask)(struct irq_data *);
	void (*irq_mask_ack)(struct irq_data *);
	void (*irq_unmask)(struct irq_data *);
	void (*irq_eoi)(struct irq_data *);
	int (*irq_set_affinity)(struct irq_data *, const struct cpumask *, bool);
	int (*irq_retrigger)(struct irq_data *);
	int (*irq_set_type)(struct irq_data *, unsigned int);
	int (*irq_set_wake)(struct irq_data *, unsigned int);
	void (*irq_bus_lock)(struct irq_data *);
	void (*irq_bus_sync_unlock)(struct irq_data *);
	void (*irq_cpu_online)(struct irq_data *);
	void (*irq_cpu_offline)(struct irq_data *);
	void (*irq_suspend)(struct irq_data *);
	void (*irq_resume)(struct irq_data *);
	void (*irq_pm_shutdown)(struct irq_data *);
	void (*irq_calc_mask)(struct irq_data *);
	void (*irq_print_chip)(struct irq_data *, struct seq_file *);
	int (*irq_request_resources)(struct irq_data *);
	void (*irq_release_resources)(struct irq_data *);
	void (*irq_compose_msi_msg)(struct irq_data *, struct msi_msg *);
	void (*irq_write_msi_msg)(struct irq_data *, struct msi_msg *);
	int (*irq_get_irqchip_state)(struct irq_data *, enum irqchip_irq_state, bool *);
	int (*irq_set_irqchip_state)(struct irq_data *, enum irqchip_irq_state, bool);
	int (*irq_set_vcpu_affinity)(struct irq_data *, void *);
	void (*ipi_send_single)(struct irq_data *, unsigned int);
	void (*ipi_send_mask)(struct irq_data *, const struct cpumask *);
	int (*irq_nmi_setup)(struct irq_data *);
	void (*irq_nmi_teardown)(struct irq_data *);
	long unsigned int flags;
};

enum {
	IRQD_TRIGGER_MASK = 15,
	IRQD_SETAFFINITY_PENDING = 256,
	IRQD_ACTIVATED = 512,
	IRQD_NO_BALANCING = 1024,
	IRQD_PER_CPU = 2048,
	IRQD_AFFINITY_SET = 4096,
	IRQD_LEVEL = 8192,
	IRQD_WAKEUP_STATE = 16384,
	IRQD_MOVE_PCNTXT = 32768,
	IRQD_IRQ_DISABLED = 65536,
	IRQD_IRQ_MASKED = 131072,
	IRQD_IRQ_INPROGRESS = 262144,
	IRQD_WAKEUP_ARMED = 524288,
	IRQD_FORWARDED_TO_VCPU = 1048576,
	IRQD_AFFINITY_MANAGED = 2097152,
	IRQD_IRQ_STARTED = 4194304,
	IRQD_MANAGED_SHUTDOWN = 8388608,
	IRQD_SINGLE_TARGET = 16777216,
	IRQD_DEFAULT_TRIGGER_SET = 33554432,
	IRQD_CAN_RESERVE = 67108864,
	IRQD_MSI_NOMASK_QUIRK = 134217728,
	IRQD_HANDLE_ENFORCE_IRQCTX = 268435456,
	IRQD_AFFINITY_ON_ACTIVATE = 536870912,
	IRQD_IRQ_ENABLED_ON_SUSPEND = 1073741824,
};

typedef irqreturn_t (*irq_handler_t)(int, void *);

struct irqaction {
	irq_handler_t handler;
	void *dev_id;
	void *percpu_dev_id;
	struct irqaction *next;
	irq_handler_t thread_fn;
	struct task_struct *thread;
	struct irqaction *secondary;
	unsigned int irq;
	unsigned int flags;
	long unsigned int thread_flags;
	long unsigned int thread_mask;
	const char *name;
	struct proc_dir_entry *dir;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct irq_affinity_notify {
	unsigned int irq;
	struct kref kref;
	struct work_struct work;
	void (*notify)(struct irq_affinity_notify *, const cpumask_t *);
	void (*release)(struct kref *);
};

enum {
	MEMREMAP_WB = 1,
	MEMREMAP_WT = 2,
	MEMREMAP_WC = 4,
	MEMREMAP_ENC = 8,
	MEMREMAP_DEC = 16,
};

typedef struct {
	u32 type;
	u32 pad;
	u64 phys_addr;
	u64 virt_addr;
	u64 num_pages;
	u64 attribute;
} efi_memory_desc_t;

typedef long unsigned int ulong;

typedef u8 uint8_t;

enum zone_type {
	ZONE_DMA32 = 0,
	ZONE_NORMAL = 1,
	ZONE_MOVABLE = 2,
	__MAX_NR_ZONES = 3,
};

struct reserved_mem_ops;

struct reserved_mem {
	const char *name;
	long unsigned int fdt_node;
	long unsigned int phandle;
	const struct reserved_mem_ops *ops;
	phys_addr_t base;
	phys_addr_t size;
	void *priv;
};

struct reserved_mem_ops {
	int (*device_init)(struct reserved_mem *, struct device *);
	void (*device_release)(struct reserved_mem *, struct device *);
};

typedef int (*reservedmem_of_init_fn)(struct reserved_mem *);

struct pt_alloc_ops {
	pte_t * (*get_pte_virt)(phys_addr_t);
	phys_addr_t (*alloc_pte)(uintptr_t);
	pmd_t * (*get_pmd_virt)(phys_addr_t);
	phys_addr_t (*alloc_pmd)(uintptr_t);
};

enum vm_fault_reason {
	VM_FAULT_OOM = 1,
	VM_FAULT_SIGBUS = 2,
	VM_FAULT_MAJOR = 4,
	VM_FAULT_WRITE = 8,
	VM_FAULT_HWPOISON = 16,
	VM_FAULT_HWPOISON_LARGE = 32,
	VM_FAULT_SIGSEGV = 64,
	VM_FAULT_NOPAGE = 256,
	VM_FAULT_LOCKED = 512,
	VM_FAULT_RETRY = 1024,
	VM_FAULT_FALLBACK = 2048,
	VM_FAULT_DONE_COW = 4096,
	VM_FAULT_NEEDDSYNC = 8192,
	VM_FAULT_PTNOTSAME = 16384,
	VM_FAULT_HINDEX_MASK = 983040,
};

struct mm_walk;

struct mm_walk_ops {
	int (*pgd_entry)(pgd_t *, long unsigned int, long unsigned int, struct mm_walk *);
	int (*p4d_entry)(p4d_t *, long unsigned int, long unsigned int, struct mm_walk *);
	int (*pud_entry)(pud_t *, long unsigned int, long unsigned int, struct mm_walk *);
	int (*pmd_entry)(pmd_t *, long unsigned int, long unsigned int, struct mm_walk *);
	int (*pte_entry)(pte_t *, long unsigned int, long unsigned int, struct mm_walk *);
	int (*pte_hole)(long unsigned int, long unsigned int, int, struct mm_walk *);
	int (*hugetlb_entry)(pte_t *, long unsigned int, long unsigned int, long unsigned int, struct mm_walk *);
	int (*test_walk)(long unsigned int, long unsigned int, struct mm_walk *);
	int (*pre_vma)(long unsigned int, long unsigned int, struct mm_walk *);
	void (*post_vma)(struct mm_walk *);
};

enum page_walk_action {
	ACTION_SUBTREE = 0,
	ACTION_CONTINUE = 1,
	ACTION_AGAIN = 2,
};

struct mm_walk {
	const struct mm_walk_ops *ops;
	struct mm_struct *mm;
	pgd_t *pgd;
	struct vm_area_struct *vma;
	enum page_walk_action action;
	bool no_vma;
	void *private;
};

struct pageattr_masks {
	pgprot_t set_mask;
	pgprot_t clear_mask;
};

struct asid_info {
	atomic64_t generation;
	long unsigned int *map;
	atomic64_t *active;
	u64 *reserved;
	u32 bits;
	raw_spinlock_t lock;
	cpumask_t flush_pending;
	unsigned int ctxt_shift;
	void (*flush_cpu_ctxt_cb)();
};

enum dma_data_direction {
	DMA_BIDIRECTIONAL = 0,
	DMA_TO_DEVICE = 1,
	DMA_FROM_DEVICE = 2,
	DMA_NONE = 3,
};

enum {
	DUMP_PREFIX_NONE = 0,
	DUMP_PREFIX_ADDRESS = 1,
	DUMP_PREFIX_OFFSET = 2,
};

struct bpf_binary_header {
	u32 pages;
	int: 32;
	u8 image[0];
};

struct rv_jit_context {
	struct bpf_prog *prog;
	u16 *insns;
	int ninsns;
	int epilogue_offset;
	int *offset;
	long unsigned int flags;
	int stack_size;
};

struct rv_jit_data {
	struct bpf_binary_header *header;
	u8 *image;
	struct rv_jit_context ctx;
};

enum {
	BPF_REG_0 = 0,
	BPF_REG_1 = 1,
	BPF_REG_2 = 2,
	BPF_REG_3 = 3,
	BPF_REG_4 = 4,
	BPF_REG_5 = 5,
	BPF_REG_6 = 6,
	BPF_REG_7 = 7,
	BPF_REG_8 = 8,
	BPF_REG_9 = 9,
	BPF_REG_10 = 10,
	__MAX_BPF_REG = 11,
};

enum {
	RV_REG_ZERO = 0,
	RV_REG_RA = 1,
	RV_REG_SP = 2,
	RV_REG_GP = 3,
	RV_REG_TP = 4,
	RV_REG_T0 = 5,
	RV_REG_T1 = 6,
	RV_REG_T2 = 7,
	RV_REG_FP = 8,
	RV_REG_S1 = 9,
	RV_REG_A0 = 10,
	RV_REG_A1 = 11,
	RV_REG_A2 = 12,
	RV_REG_A3 = 13,
	RV_REG_A4 = 14,
	RV_REG_A5 = 15,
	RV_REG_A6 = 16,
	RV_REG_A7 = 17,
	RV_REG_S2 = 18,
	RV_REG_S3 = 19,
	RV_REG_S4 = 20,
	RV_REG_S5 = 21,
	RV_REG_S6 = 22,
	RV_REG_S7 = 23,
	RV_REG_S8 = 24,
	RV_REG_S9 = 25,
	RV_REG_S10 = 26,
	RV_REG_S11 = 27,
	RV_REG_T3 = 28,
	RV_REG_T4 = 29,
	RV_REG_T5 = 30,
	RV_REG_T6 = 31,
};

enum {
	RV_CTX_F_SEEN_TAIL_CALL = 0,
	RV_CTX_F_SEEN_CALL = 1,
	RV_CTX_F_SEEN_S1 = 9,
	RV_CTX_F_SEEN_S2 = 18,
	RV_CTX_F_SEEN_S3 = 19,
	RV_CTX_F_SEEN_S4 = 20,
	RV_CTX_F_SEEN_S5 = 21,
	RV_CTX_F_SEEN_S6 = 22,
};

typedef u64 gpa_t;

typedef u64 gfn_t;

typedef u64 hpa_t;

typedef u64 hfn_t;

typedef hfn_t kvm_pfn_t;

struct kvm_memory_slot;

struct gfn_to_hva_cache {
	u64 generation;
	gpa_t gpa;
	long unsigned int hva;
	long unsigned int len;
	struct kvm_memory_slot *memslot;
};

struct kvm_arch_memory_slot {};

struct kvm_memory_slot {
	gfn_t base_gfn;
	long unsigned int npages;
	long unsigned int *dirty_bitmap;
	struct kvm_arch_memory_slot arch;
	long unsigned int userspace_addr;
	u32 flags;
	short int id;
	u16 as_id;
};

struct gfn_to_pfn_cache {
	u64 generation;
	gfn_t gfn;
	kvm_pfn_t pfn;
	bool dirty;
};

struct kvm_mmu_memory_cache {
	int nobjs;
	gfp_t gfp_zero;
	struct kmem_cache *kmem_cache;
	void *objects[40];
};

struct kvm_vcpu;

struct kvm_io_device;

struct kvm_io_device_ops {
	int (*read)(struct kvm_vcpu *, struct kvm_io_device *, gpa_t, int, void *);
	int (*write)(struct kvm_vcpu *, struct kvm_io_device *, gpa_t, int, const void *);
	void (*destructor)(struct kvm_io_device *);
};

struct preempt_ops;

struct preempt_notifier {
	struct hlist_node link;
	struct preempt_ops *ops;
};

struct kvm_vcpu_stat {
	u64 halt_successful_poll;
	u64 halt_attempted_poll;
	u64 halt_poll_success_ns;
	u64 halt_poll_fail_ns;
	u64 halt_poll_invalid;
	u64 halt_wakeup;
	u64 ecall_exit_stat;
	u64 wfi_exit_stat;
	u64 mmio_exit_user;
	u64 mmio_exit_kernel;
	u64 exits;
};

struct kvm_mmio_fragment {
	gpa_t gpa;
	void *data;
	unsigned int len;
};

struct kvm_cpu_context {
	long unsigned int zero;
	long unsigned int ra;
	long unsigned int sp;
	long unsigned int gp;
	long unsigned int tp;
	long unsigned int t0;
	long unsigned int t1;
	long unsigned int t2;
	long unsigned int s0;
	long unsigned int s1;
	long unsigned int a0;
	long unsigned int a1;
	long unsigned int a2;
	long unsigned int a3;
	long unsigned int a4;
	long unsigned int a5;
	long unsigned int a6;
	long unsigned int a7;
	long unsigned int s2;
	long unsigned int s3;
	long unsigned int s4;
	long unsigned int s5;
	long unsigned int s6;
	long unsigned int s7;
	long unsigned int s8;
	long unsigned int s9;
	long unsigned int s10;
	long unsigned int s11;
	long unsigned int t3;
	long unsigned int t4;
	long unsigned int t5;
	long unsigned int t6;
	long unsigned int sepc;
	long unsigned int sstatus;
	long unsigned int hstatus;
	long: 64;
	union __riscv_fp_state fp;
};

struct kvm_vcpu_csr {
	long unsigned int vsstatus;
	long unsigned int hie;
	long unsigned int vstvec;
	long unsigned int vsscratch;
	long unsigned int vsepc;
	long unsigned int vscause;
	long unsigned int vstval;
	long unsigned int hvip;
	long unsigned int vsatp;
	long unsigned int scounteren;
};

struct kvm_vcpu_timer {
	bool init_done;
	bool next_set;
	u64 next_cycles;
	struct hrtimer hrt;
};

struct kvm_mmio_decode {
	long unsigned int insn;
	int insn_len;
	int len;
	int shift;
	int return_handled;
};

struct kvm_sbi_context {
	int return_handled;
};

struct kvm_mmu_page_cache {
	int nobjs;
	void *objects[32];
};

struct kvm_vcpu_arch {
	bool ran_atleast_once;
	long unsigned int isa;
	long unsigned int host_sscratch;
	long unsigned int host_stvec;
	long unsigned int host_scounteren;
	long: 64;
	struct kvm_cpu_context host_context;
	struct kvm_cpu_context guest_context;
	struct kvm_vcpu_csr guest_csr;
	struct kvm_cpu_context guest_reset_context;
	struct kvm_vcpu_csr guest_reset_csr;
	long unsigned int irqs_pending;
	long unsigned int irqs_pending_mask;
	struct kvm_vcpu_timer timer;
	struct kvm_mmio_decode mmio_decode;
	struct kvm_sbi_context sbi_context;
	struct kvm_mmu_page_cache mmu_page_cache;
	bool power_off;
	bool pause;
	int srcu_idx;
};

struct kvm;

struct kvm_run;

struct kvm_vcpu {
	struct kvm *kvm;
	struct preempt_notifier preempt_notifier;
	int cpu;
	int vcpu_id;
	int vcpu_idx;
	int srcu_idx;
	int mode;
	u64 requests;
	long unsigned int guest_debug;
	int pre_pcpu;
	struct list_head blocked_vcpu_list;
	struct mutex mutex;
	struct kvm_run *run;
	struct rcuwait wait;
	struct pid *pid;
	int sigset_active;
	sigset_t sigset;
	struct kvm_vcpu_stat stat;
	unsigned int halt_poll_ns;
	bool valid_wakeup;
	int mmio_needed;
	int mmio_read_completed;
	int mmio_is_write;
	int mmio_cur_fragment;
	int mmio_nr_fragments;
	struct kvm_mmio_fragment mmio_fragments[2];
	bool preempted;
	bool ready;
	long: 48;
	long: 64;
	struct kvm_vcpu_arch arch;
};

struct kvm_io_device {
	const struct kvm_io_device_ops *ops;
};

struct preempt_ops {
	void (*sched_in)(struct preempt_notifier *, int);
	void (*sched_out)(struct preempt_notifier *, struct task_struct *);
};

struct mmiowb_state {
	u16 nesting_count;
	u16 mmiowb_pending;
};

enum kobject_action {
	KOBJ_ADD = 0,
	KOBJ_REMOVE = 1,
	KOBJ_CHANGE = 2,
	KOBJ_MOVE = 3,
	KOBJ_ONLINE = 4,
	KOBJ_OFFLINE = 5,
	KOBJ_BIND = 6,
	KOBJ_UNBIND = 7,
};

struct trace_print_flags {
	long unsigned int mask;
	const char *name;
};

struct vm_unmapped_area_info {
	long unsigned int flags;
	long unsigned int length;
	long unsigned int low_limit;
	long unsigned int high_limit;
	long unsigned int align_mask;
	long unsigned int align_offset;
};

enum mmu_notifier_event {
	MMU_NOTIFY_UNMAP = 0,
	MMU_NOTIFY_CLEAR = 1,
	MMU_NOTIFY_PROTECTION_VMA = 2,
	MMU_NOTIFY_PROTECTION_PAGE = 3,
	MMU_NOTIFY_SOFT_DIRTY = 4,
	MMU_NOTIFY_RELEASE = 5,
	MMU_NOTIFY_MIGRATE = 6,
};

struct mmu_notifier;

struct mmu_notifier_range;

struct mmu_notifier_ops {
	void (*release)(struct mmu_notifier *, struct mm_struct *);
	int (*clear_flush_young)(struct mmu_notifier *, struct mm_struct *, long unsigned int, long unsigned int);
	int (*clear_young)(struct mmu_notifier *, struct mm_struct *, long unsigned int, long unsigned int);
	int (*test_young)(struct mmu_notifier *, struct mm_struct *, long unsigned int);
	void (*change_pte)(struct mmu_notifier *, struct mm_struct *, long unsigned int, pte_t);
	int (*invalidate_range_start)(struct mmu_notifier *, const struct mmu_notifier_range *);
	void (*invalidate_range_end)(struct mmu_notifier *, const struct mmu_notifier_range *);
	void (*invalidate_range)(struct mmu_notifier *, struct mm_struct *, long unsigned int, long unsigned int);
	struct mmu_notifier * (*alloc_notifier)(struct mm_struct *);
	void (*free_notifier)(struct mmu_notifier *);
};

struct mmu_notifier {
	struct hlist_node hlist;
	const struct mmu_notifier_ops *ops;
	struct mm_struct *mm;
	struct callback_head rcu;
	unsigned int users;
};

struct mmu_notifier_range {
	struct vm_area_struct *vma;
	struct mm_struct *mm;
	long unsigned int start;
	long unsigned int end;
	unsigned int flags;
	enum mmu_notifier_event event;
	void *migrate_pgmap_owner;
};

struct kvm_regs {};

struct kvm_fpu {};

struct kvm_debug_exit_arch {};

struct kvm_guest_debug_arch {};

struct kvm_sync_regs {};

struct kvm_sregs {};

struct kvm_userspace_memory_region {
	__u32 slot;
	__u32 flags;
	__u64 guest_phys_addr;
	__u64 memory_size;
	__u64 userspace_addr;
};

struct kvm_hyperv_exit {
	__u32 type;
	__u32 pad1;
	union {
		struct {
			__u32 msr;
			__u32 pad2;
			__u64 control;
			__u64 evt_page;
			__u64 msg_page;
		} synic;
		struct {
			__u64 input;
			__u64 result;
			__u64 params[2];
		} hcall;
		struct {
			__u32 msr;
			__u32 pad2;
			__u64 control;
			__u64 status;
			__u64 send_page;
			__u64 recv_page;
			__u64 pending_page;
		} syndbg;
	} u;
};

struct kvm_run {
	__u8 request_interrupt_window;
	__u8 immediate_exit;
	__u8 padding1[6];
	__u32 exit_reason;
	__u8 ready_for_interrupt_injection;
	__u8 if_flag;
	__u16 flags;
	__u64 cr8;
	__u64 apic_base;
	union {
		struct {
			__u64 hardware_exit_reason;
		} hw;
		struct {
			__u64 hardware_entry_failure_reason;
			__u32 cpu;
		} fail_entry;
		struct {
			__u32 exception;
			__u32 error_code;
		} ex;
		struct {
			__u8 direction;
			__u8 size;
			__u16 port;
			__u32 count;
			__u64 data_offset;
		} io;
		struct {
			struct kvm_debug_exit_arch arch;
		} debug;
		struct {
			__u64 phys_addr;
			__u8 data[8];
			__u32 len;
			__u8 is_write;
		} mmio;
		struct {
			__u64 nr;
			__u64 args[6];
			__u64 ret;
			__u32 longmode;
			__u32 pad;
		} hypercall;
		struct {
			__u64 rip;
			__u32 is_write;
			__u32 pad;
		} tpr_access;
		struct {
			__u8 icptcode;
			__u16 ipa;
			__u32 ipb;
		} s390_sieic;
		__u64 s390_reset_flags;
		struct {
			__u64 trans_exc_code;
			__u32 pgm_code;
		} s390_ucontrol;
		struct {
			__u32 dcrn;
			__u32 data;
			__u8 is_write;
		} dcr;
		struct {
			__u32 suberror;
			__u32 ndata;
			__u64 data[16];
		} internal;
		struct {
			__u64 gprs[32];
		} osi;
		struct {
			__u64 nr;
			__u64 ret;
			__u64 args[9];
		} papr_hcall;
		struct {
			__u16 subchannel_id;
			__u16 subchannel_nr;
			__u32 io_int_parm;
			__u32 io_int_word;
			__u32 ipb;
			__u8 dequeued;
		} s390_tsch;
		struct {
			__u32 epr;
		} epr;
		struct {
			__u32 type;
			__u64 flags;
		} system_event;
		struct {
			__u64 addr;
			__u8 ar;
			__u8 reserved;
			__u8 fc;
			__u8 sel1;
			__u16 sel2;
		} s390_stsi;
		struct {
			__u8 vector;
		} eoi;
		struct kvm_hyperv_exit hyperv;
		struct {
			__u64 esr_iss;
			__u64 fault_ipa;
		} arm_nisv;
		struct {
			__u8 error;
			__u8 pad[7];
			__u32 reason;
			__u32 index;
			__u64 data;
		} msr;
		char padding[256];
	};
	__u64 kvm_valid_regs;
	__u64 kvm_dirty_regs;
	union {
		struct kvm_sync_regs regs;
		char padding[2048];
	} s;
};

struct kvm_coalesced_mmio_zone {
	__u64 addr;
	__u32 size;
	union {
		__u32 pad;
		__u32 pio;
	};
};

struct kvm_coalesced_mmio {
	__u64 phys_addr;
	__u32 len;
	union {
		__u32 pad;
		__u32 pio;
	};
	__u8 data[8];
};

struct kvm_coalesced_mmio_ring {
	__u32 first;
	__u32 last;
	struct kvm_coalesced_mmio coalesced_mmio[0];
};

struct kvm_translation {
	__u64 linear_address;
	__u64 physical_address;
	__u8 valid;
	__u8 writeable;
	__u8 usermode;
	__u8 pad[5];
};

struct kvm_dirty_log {
	__u32 slot;
	__u32 padding1;
	union {
		void *dirty_bitmap;
		__u64 padding2;
	};
};

struct kvm_clear_dirty_log {
	__u32 slot;
	__u32 num_pages;
	__u64 first_page;
	union {
		void *dirty_bitmap;
		__u64 padding2;
	};
};

struct kvm_signal_mask {
	__u32 len;
	__u8 sigset[0];
};

struct kvm_mp_state {
	__u32 mp_state;
};

struct kvm_guest_debug {
	__u32 control;
	__u32 pad;
	struct kvm_guest_debug_arch arch;
};

struct kvm_ioeventfd {
	__u64 datamatch;
	__u64 addr;
	__u32 len;
	__s32 fd;
	__u32 flags;
	__u8 pad[36];
};

struct kvm_enable_cap {
	__u32 cap;
	__u32 flags;
	__u64 args[4];
	__u8 pad[64];
};

struct kvm_irqfd {
	__u32 fd;
	__u32 gsi;
	__u32 flags;
	__u32 resamplefd;
	__u8 pad[16];
};

struct kvm_create_device {
	__u32 type;
	__u32 fd;
	__u32 flags;
};

struct kvm_device_attr {
	__u32 flags;
	__u32 group;
	__u64 attr;
	__u64 addr;
};

enum kvm_device_type {
	KVM_DEV_TYPE_FSL_MPIC_20 = 1,
	KVM_DEV_TYPE_FSL_MPIC_42 = 2,
	KVM_DEV_TYPE_XICS = 3,
	KVM_DEV_TYPE_VFIO = 4,
	KVM_DEV_TYPE_ARM_VGIC_V2 = 5,
	KVM_DEV_TYPE_FLIC = 6,
	KVM_DEV_TYPE_ARM_VGIC_V3 = 7,
	KVM_DEV_TYPE_ARM_VGIC_ITS = 8,
	KVM_DEV_TYPE_XIVE = 9,
	KVM_DEV_TYPE_ARM_PV_TIME = 10,
	KVM_DEV_TYPE_MAX = 11,
};

struct kvm_guest_timer {
	u32 nsec_mult;
	u32 nsec_shift;
	u64 time_delta;
};

struct kvm_vm_stat {
	ulong remote_tlb_flush;
};

struct kvm_vmid {
	long unsigned int vmid_version;
	long unsigned int vmid;
};

struct khv_io {
	u64 status;
	u64 addr;
	u64 value;
	u64 reserved;
};

struct kvm_arch {
	struct kvm_vmid vmid;
	pgd_t *pgd;
	phys_addr_t pgd_phys;
	struct kvm_guest_timer timer;
	wait_queue_head_t waitq;
	struct khv_io *io_switch;
	volatile unsigned char *backend_intr_reg;
	volatile unsigned char *frontend_intr_reg;
	u32 enable_intr;
	u32 clear_intr;
	long unsigned int khv_base;
	phys_addr_t khv_base_phys_addr;
};

struct kvm_io_range {
	gpa_t addr;
	int len;
	struct kvm_io_device *dev;
};

struct kvm_io_bus {
	int dev_count;
	int ioeventfd_count;
	struct kvm_io_range range[0];
};

enum kvm_bus {
	KVM_MMIO_BUS = 0,
	KVM_PIO_BUS = 1,
	KVM_VIRTIO_CCW_NOTIFY_BUS = 2,
	KVM_FAST_MMIO_BUS = 3,
	KVM_NR_BUSES = 4,
};

enum {
	OUTSIDE_GUEST_MODE = 0,
	IN_GUEST_MODE = 1,
	EXITING_GUEST_MODE = 2,
	READING_SHADOW_PAGE_TABLES = 3,
};

struct kvm_host_map {
	struct page *page;
	void *hva;
	kvm_pfn_t pfn;
	kvm_pfn_t gfn;
};

struct kvm_memslots;

struct kvm_stat_data;

struct kvm {
	spinlock_t mmu_lock;
	struct mutex slots_lock;
	struct mm_struct *mm;
	struct kvm_memslots *memslots[1];
	struct kvm_vcpu *vcpus[65536];
	atomic_t online_vcpus;
	int created_vcpus;
	int last_boosted_vcpu;
	struct list_head vm_list;
	struct mutex lock;
	struct kvm_io_bus *buses[4];
	struct {
		spinlock_t lock;
		struct list_head items;
		struct list_head resampler_list;
		struct mutex resampler_lock;
	} irqfds;
	struct list_head ioeventfds;
	struct kvm_vm_stat stat;
	struct kvm_arch arch;
	refcount_t users_count;
	struct kvm_coalesced_mmio_ring *coalesced_mmio_ring;
	spinlock_t ring_lock;
	struct list_head coalesced_zones;
	struct mutex irq_lock;
	struct mmu_notifier mmu_notifier;
	long unsigned int mmu_notifier_seq;
	long int mmu_notifier_count;
	long int tlbs_dirty;
	struct list_head devices;
	u64 manual_dirty_log_protect;
	struct dentry *debugfs_dentry;
	struct kvm_stat_data **debugfs_stat_data;
	struct srcu_struct srcu;
	struct srcu_struct irq_srcu;
	pid_t userspace_pid;
	unsigned int max_halt_poll_ns;
};

struct kvm_memslots {
	u64 generation;
	short int id_to_index[512];
	atomic_t lru_slot;
	int used_slots;
	struct kvm_memory_slot memslots[0];
};

struct kvm_stats_debugfs_item;

struct kvm_stat_data {
	struct kvm *kvm;
	struct kvm_stats_debugfs_item *dbgfs_item;
};

enum kvm_mr_change {
	KVM_MR_CREATE = 0,
	KVM_MR_DELETE = 1,
	KVM_MR_MOVE = 2,
	KVM_MR_FLAGS_ONLY = 3,
};

enum kvm_stat_kind {
	KVM_STAT_VM = 0,
	KVM_STAT_VCPU = 1,
};

struct kvm_stats_debugfs_item {
	const char *name;
	int offset;
	enum kvm_stat_kind kind;
	int mode;
};

struct kvm_device_ops;

struct kvm_device {
	const struct kvm_device_ops *ops;
	struct kvm *kvm;
	void *private;
	struct list_head vm_node;
};

struct kvm_device_ops {
	const char *name;
	int (*create)(struct kvm_device *, u32);
	void (*init)(struct kvm_device *);
	void (*destroy)(struct kvm_device *);
	void (*release)(struct kvm_device *);
	int (*set_attr)(struct kvm_device *, struct kvm_device_attr *);
	int (*get_attr)(struct kvm_device *, struct kvm_device_attr *);
	int (*has_attr)(struct kvm_device *, struct kvm_device_attr *);
	long int (*ioctl)(struct kvm_device *, unsigned int, long unsigned int);
	int (*mmap)(struct kvm_device *, struct vm_area_struct *);
};

typedef int (*kvm_vm_thread_fn_t)(struct kvm *, uintptr_t);

struct miscdevice {
	int minor;
	const char *name;
	const struct file_operations *fops;
	struct list_head list;
	struct device *parent;
	struct device *this_device;
	const struct attribute_group **groups;
	const char *nodename;
	umode_t mode;
};

struct syscore_ops {
	struct list_head node;
	int (*suspend)();
	void (*resume)();
	void (*shutdown)();
};

struct trace_event_raw_kvm_userspace_exit {
	struct trace_entry ent;
	__u32 reason;
	int errno;
	char __data[0];
};

struct trace_event_raw_kvm_vcpu_wakeup {
	struct trace_entry ent;
	__u64 ns;
	bool waited;
	bool valid;
	char __data[0];
};

struct trace_event_raw_kvm_mmio {
	struct trace_entry ent;
	u32 type;
	u32 len;
	u64 gpa;
	u64 val;
	char __data[0];
};

struct trace_event_raw_kvm_fpu {
	struct trace_entry ent;
	u32 load;
	char __data[0];
};

struct trace_event_raw_kvm_age_page {
	struct trace_entry ent;
	u64 hva;
	u64 gfn;
	u8 level;
	u8 referenced;
	char __data[0];
};

struct trace_event_raw_kvm_halt_poll_ns {
	struct trace_entry ent;
	bool grow;
	unsigned int vcpu_id;
	unsigned int new;
	unsigned int old;
	char __data[0];
};

struct trace_event_data_offsets_kvm_userspace_exit {};

struct trace_event_data_offsets_kvm_vcpu_wakeup {};

struct trace_event_data_offsets_kvm_mmio {};

struct trace_event_data_offsets_kvm_fpu {};

struct trace_event_data_offsets_kvm_age_page {};

struct trace_event_data_offsets_kvm_halt_poll_ns {};

typedef void (*btf_trace_kvm_userspace_exit)(void *, __u32, int);

typedef void (*btf_trace_kvm_vcpu_wakeup)(void *, __u64, bool, bool);

typedef void (*btf_trace_kvm_mmio)(void *, int, int, u64, void *);

typedef void (*btf_trace_kvm_fpu)(void *, int);

typedef void (*btf_trace_kvm_age_page)(void *, ulong, int, struct kvm_memory_slot *, int);

typedef void (*btf_trace_kvm_halt_poll_ns)(void *, bool, unsigned int, unsigned int, unsigned int);

struct kvm_cpu_compat_check {
	void *opaque;
	int *ret;
};

struct kvm_vm_worker_thread_context {
	struct kvm *kvm;
	struct task_struct *parent;
	struct completion init_done;
	kvm_vm_thread_fn_t thread_fn;
	uintptr_t data;
	int err;
};

struct kvm_coalesced_mmio_dev {
	struct list_head list;
	struct kvm_io_device dev;
	struct kvm *kvm;
	struct kvm_coalesced_mmio_zone zone;
};

enum {
	kvm_ioeventfd_flag_nr_datamatch = 0,
	kvm_ioeventfd_flag_nr_pio = 1,
	kvm_ioeventfd_flag_nr_deassign = 2,
	kvm_ioeventfd_flag_nr_virtio_ccw_notify = 3,
	kvm_ioeventfd_flag_nr_fast_mmio = 4,
	kvm_ioeventfd_flag_nr_max = 5,
};

struct eventfd_ctx;

struct _ioeventfd {
	struct list_head list;
	u64 addr;
	int length;
	struct eventfd_ctx *eventfd;
	u64 datamatch;
	struct kvm_io_device dev;
	u8 bus_idx;
	bool wildcard;
};

typedef void (*exitcall_t)();

struct pdev_archdata {};

struct platform_device_id {
	char name[20];
	kernel_ulong_t driver_data;
};

struct mfd_cell;

struct platform_device {
	const char *name;
	int id;
	bool id_auto;
	struct device dev;
	u64 platform_dma_mask;
	struct device_dma_parameters dma_parms;
	u32 num_resources;
	struct resource *resource;
	const struct platform_device_id *id_entry;
	char *driver_override;
	struct mfd_cell *mfd_cell;
	struct pdev_archdata archdata;
};

struct platform_driver {
	int (*probe)(struct platform_device *);
	int (*remove)(struct platform_device *);
	void (*shutdown)(struct platform_device *);
	int (*suspend)(struct platform_device *, pm_message_t);
	int (*resume)(struct platform_device *);
	struct device_driver driver;
	const struct platform_device_id *id_table;
	bool prevent_deferred_probe;
};

struct kvm_one_reg {
	__u64 id;
	__u64 addr;
};

struct kvm_cpu_trap {
	long unsigned int sepc;
	long unsigned int scause;
	long unsigned int stval;
	long unsigned int htval;
	long unsigned int htinst;
};

enum tk_offsets {
	TK_OFFS_REAL = 0,
	TK_OFFS_BOOT = 1,
	TK_OFFS_TAI = 2,
	TK_OFFS_MAX = 3,
};

enum {
	WORK_STRUCT_PENDING_BIT = 0,
	WORK_STRUCT_DELAYED_BIT = 1,
	WORK_STRUCT_PWQ_BIT = 2,
	WORK_STRUCT_LINKED_BIT = 3,
	WORK_STRUCT_COLOR_SHIFT = 4,
	WORK_STRUCT_COLOR_BITS = 4,
	WORK_STRUCT_PENDING = 1,
	WORK_STRUCT_DELAYED = 2,
	WORK_STRUCT_PWQ = 4,
	WORK_STRUCT_LINKED = 8,
	WORK_STRUCT_STATIC = 0,
	WORK_NR_COLORS = 15,
	WORK_NO_COLOR = 15,
	WORK_CPU_UNBOUND = 8,
	WORK_STRUCT_FLAG_BITS = 8,
	WORK_OFFQ_FLAG_BASE = 4,
	__WORK_OFFQ_CANCELING = 4,
	WORK_OFFQ_CANCELING = 16,
	WORK_OFFQ_FLAG_BITS = 1,
	WORK_OFFQ_POOL_SHIFT = 5,
	WORK_OFFQ_LEFT = 59,
	WORK_OFFQ_POOL_BITS = 31,
	WORK_OFFQ_POOL_NONE = 2147483647,
	WORK_STRUCT_FLAG_MASK = 255,
	WORK_STRUCT_WQ_DATA_MASK = 4294967040,
	WORK_STRUCT_NO_POOL = 4294967264,
	WORK_BUSY_PENDING = 1,
	WORK_BUSY_RUNNING = 2,
	WORKER_DESC_LEN = 24,
};

struct free_area {
	struct list_head free_list[6];
	long unsigned int nr_free;
};

struct zone_padding {
	char x[0];
};

struct lruvec {
	struct list_head lists[5];
	long unsigned int anon_cost;
	long unsigned int file_cost;
	atomic_long_t nonresident_age;
	long unsigned int refaults[2];
	long unsigned int flags;
};

struct per_cpu_pages {
	int count;
	int high;
	int batch;
	struct list_head lists[4];
};

struct per_cpu_pageset {
	struct per_cpu_pages pcp;
	s8 stat_threshold;
	s8 vm_stat_diff[12];
};

struct per_cpu_nodestat {
	s8 stat_threshold;
	s8 vm_node_stat_diff[37];
};

struct pglist_data;

struct zone {
	long unsigned int _watermark[3];
	long unsigned int watermark_boost;
	long unsigned int nr_reserved_highatomic;
	long int lowmem_reserve[3];
	struct pglist_data *zone_pgdat;
	struct per_cpu_pageset *pageset;
	long unsigned int *pageblock_flags;
	long unsigned int zone_start_pfn;
	atomic_long_t managed_pages;
	long unsigned int spanned_pages;
	long unsigned int present_pages;
	long unsigned int cma_pages;
	const char *name;
	long unsigned int nr_isolate_pageblock;
	int initialized;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct zone_padding _pad1_;
	struct free_area free_area[15];
	long unsigned int flags;
	spinlock_t lock;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	struct zone_padding _pad2_;
	long unsigned int percpu_drift_mark;
	long unsigned int compact_cached_free_pfn;
	long unsigned int compact_cached_migrate_pfn[2];
	long unsigned int compact_init_migrate_pfn;
	long unsigned int compact_init_free_pfn;
	unsigned int compact_considered;
	unsigned int compact_defer_shift;
	int compact_order_failed;
	bool compact_blockskip_flush;
	bool contiguous;
	short: 16;
	struct zone_padding _pad3_;
	atomic_long_t vm_stat[12];
	atomic_long_t vm_numa_stat[0];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct zoneref {
	struct zone *zone;
	int zone_idx;
};

struct zonelist {
	struct zoneref _zonerefs[4];
};

struct pglist_data {
	struct zone node_zones[3];
	struct zonelist node_zonelists[1];
	int nr_zones;
	struct page *node_mem_map;
	long unsigned int node_start_pfn;
	long unsigned int node_present_pages;
	long unsigned int node_spanned_pages;
	int node_id;
	wait_queue_head_t kswapd_wait;
	wait_queue_head_t pfmemalloc_wait;
	struct task_struct *kswapd;
	struct task_struct *mkswapd[16];
	int kswapd_order;
	enum zone_type kswapd_highest_zoneidx;
	int kswapd_failures;
	int kcompactd_max_order;
	enum zone_type kcompactd_highest_zoneidx;
	wait_queue_head_t kcompactd_wait;
	struct task_struct *kcompactd;
	bool proactive_compact_trigger;
	long unsigned int totalreserve_pages;
	long: 64;
	long: 64;
	struct zone_padding _pad1_;
	spinlock_t lru_lock;
	struct lruvec __lruvec;
	long unsigned int flags;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct zone_padding _pad2_;
	struct per_cpu_nodestat *per_cpu_nodestats;
	atomic_long_t vm_stat[37];
	long: 64;
	long: 64;
};

typedef struct pglist_data pg_data_t;

struct clone_args {
	__u64 flags;
	__u64 pidfd;
	__u64 child_tid;
	__u64 parent_tid;
	__u64 exit_signal;
	__u64 stack;
	__u64 stack_size;
	__u64 tls;
	__u64 set_tid;
	__u64 set_tid_size;
	__u64 cgroup;
};

struct plist_head {
	struct list_head node_list;
};

enum hrtimer_mode {
	HRTIMER_MODE_ABS = 0,
	HRTIMER_MODE_REL = 1,
	HRTIMER_MODE_PINNED = 2,
	HRTIMER_MODE_SOFT = 4,
	HRTIMER_MODE_HARD = 8,
	HRTIMER_MODE_ABS_PINNED = 2,
	HRTIMER_MODE_REL_PINNED = 3,
	HRTIMER_MODE_ABS_SOFT = 4,
	HRTIMER_MODE_REL_SOFT = 5,
	HRTIMER_MODE_ABS_PINNED_SOFT = 6,
	HRTIMER_MODE_REL_PINNED_SOFT = 7,
	HRTIMER_MODE_ABS_HARD = 8,
	HRTIMER_MODE_REL_HARD = 9,
	HRTIMER_MODE_ABS_PINNED_HARD = 10,
	HRTIMER_MODE_REL_PINNED_HARD = 11,
};

struct fdtable {
	unsigned int max_fds;
	struct file **fd;
	long unsigned int *close_on_exec;
	long unsigned int *open_fds;
	long unsigned int *full_fds_bits;
	struct callback_head rcu;
};

struct files_struct {
	atomic_t count;
	bool resize_in_progress;
	wait_queue_head_t resize_wait;
	struct fdtable *fdt;
	struct fdtable fdtab;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	spinlock_t file_lock;
	unsigned int next_fd;
	long unsigned int close_on_exec_init[1];
	long unsigned int open_fds_init[1];
	long unsigned int full_fds_bits_init[1];
	struct file *fd_array[64];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct io_identity {
	struct files_struct *files;
	struct mm_struct *mm;
	const struct cred *creds;
	struct nsproxy *nsproxy;
	struct fs_struct *fs;
	long unsigned int fsize;
	refcount_t count;
};

struct io_uring_task {
	struct xarray xa;
	struct wait_queue_head wait;
	struct file *last;
	struct percpu_counter inflight;
	struct io_identity __identity;
	struct io_identity *identity;
	atomic_t in_idle;
	bool sqpoll;
};

struct robust_list {
	struct robust_list *next;
};

struct robust_list_head {
	struct robust_list list;
	long int futex_offset;
	struct robust_list *list_op_pending;
};

struct kernel_clone_args {
	u64 flags;
	int *pidfd;
	int *child_tid;
	int *parent_tid;
	int exit_signal;
	long unsigned int stack;
	long unsigned int stack_size;
	long unsigned int tls;
	pid_t *set_tid;
	size_t set_tid_size;
	int cgroup;
	struct cgroup *cgrp;
	struct css_set *cset;
};

struct multiprocess_signals {
	sigset_t signal;
	struct hlist_node node;
};

typedef int (*proc_visitor)(struct task_struct *, void *);

enum {
	IOPRIO_CLASS_NONE = 0,
	IOPRIO_CLASS_RT = 1,
	IOPRIO_CLASS_BE = 2,
	IOPRIO_CLASS_IDLE = 3,
};

enum pm_qos_type {
	PM_QOS_UNITIALIZED = 0,
	PM_QOS_MAX = 1,
	PM_QOS_MIN = 2,
};

struct pm_qos_constraints {
	struct plist_head list;
	s32 target_value;
	s32 default_value;
	s32 no_constraint_value;
	enum pm_qos_type type;
	struct blocking_notifier_head *notifiers;
};

struct freq_constraints {
	struct pm_qos_constraints min_freq;
	struct blocking_notifier_head min_freq_notifiers;
	struct pm_qos_constraints max_freq;
	struct blocking_notifier_head max_freq_notifiers;
};

struct pm_qos_flags {
	struct list_head list;
	s32 effective_flags;
};

struct dev_pm_qos_request;

struct dev_pm_qos {
	struct pm_qos_constraints resume_latency;
	struct pm_qos_constraints latency_tolerance;
	struct freq_constraints freq;
	struct pm_qos_flags flags;
	struct dev_pm_qos_request *resume_latency_req;
	struct dev_pm_qos_request *latency_tolerance_req;
	struct dev_pm_qos_request *flags_req;
};

struct vm_struct {
	struct vm_struct *next;
	void *addr;
	long unsigned int size;
	long unsigned int flags;
	struct page **pages;
	unsigned int nr_pages;
	phys_addr_t phys_addr;
	const void *caller;
};

struct mempolicy {};

typedef struct poll_table_struct poll_table;

enum {
	FUTEX_STATE_OK = 0,
	FUTEX_STATE_EXITING = 1,
	FUTEX_STATE_DEAD = 2,
};

enum proc_hidepid {
	HIDEPID_OFF = 0,
	HIDEPID_NO_ACCESS = 1,
	HIDEPID_INVISIBLE = 2,
	HIDEPID_NOT_PTRACEABLE = 4,
};

enum proc_pidonly {
	PROC_PIDONLY_OFF = 0,
	PROC_PIDONLY_ON = 1,
};

struct proc_fs_info {
	struct pid_namespace *pid_ns;
	struct dentry *proc_self;
	struct dentry *proc_thread_self;
	kgid_t pid_gid;
	enum proc_hidepid hide_pid;
	enum proc_pidonly pidonly;
};

struct pm_qos_flags_request {
	struct list_head node;
	s32 flags;
};

enum freq_qos_req_type {
	FREQ_QOS_MIN = 1,
	FREQ_QOS_MAX = 2,
};

struct freq_qos_request {
	enum freq_qos_req_type type;
	struct plist_node pnode;
	struct freq_constraints *qos;
};

enum dev_pm_qos_req_type {
	DEV_PM_QOS_RESUME_LATENCY = 1,
	DEV_PM_QOS_LATENCY_TOLERANCE = 2,
	DEV_PM_QOS_MIN_FREQUENCY = 3,
	DEV_PM_QOS_MAX_FREQUENCY = 4,
	DEV_PM_QOS_FLAGS = 5,
};

struct dev_pm_qos_request {
	enum dev_pm_qos_req_type type;
	union {
		struct plist_node pnode;
		struct pm_qos_flags_request flr;
		struct freq_qos_request freq;
	} data;
	struct device *dev;
};

struct trace_event_raw_task_newtask {
	struct trace_entry ent;
	pid_t pid;
	char comm[16];
	long unsigned int clone_flags;
	short int oom_score_adj;
	char __data[0];
};

struct trace_event_raw_task_rename {
	struct trace_entry ent;
	pid_t pid;
	char oldcomm[16];
	char newcomm[16];
	short int oom_score_adj;
	char __data[0];
};

struct trace_event_data_offsets_task_newtask {};

struct trace_event_data_offsets_task_rename {};

typedef void (*btf_trace_task_newtask)(void *, struct task_struct *, long unsigned int);

typedef void (*btf_trace_task_rename)(void *, struct task_struct *, const char *);

struct audit_context;

typedef void *__gnuc_va_list;

typedef __gnuc_va_list va_list;

struct atomic_notifier_head {
	spinlock_t lock;
	struct notifier_block *head;
};

struct taint_flag {
	char c_true;
	char c_false;
	bool module;
};

enum ftrace_dump_mode {
	DUMP_NONE = 0,
	DUMP_ALL = 1,
	DUMP_ORIG = 2,
};

enum kmsg_dump_reason {
	KMSG_DUMP_UNDEF = 0,
	KMSG_DUMP_PANIC = 1,
	KMSG_DUMP_OOPS = 2,
	KMSG_DUMP_EMERG = 3,
	KMSG_DUMP_SHUTDOWN = 4,
	KMSG_DUMP_MAX = 5,
};

enum reboot_mode {
	REBOOT_UNDEFINED = 4294967295,
	REBOOT_COLD = 0,
	REBOOT_WARM = 1,
	REBOOT_HARD = 2,
	REBOOT_SOFT = 3,
	REBOOT_GPIO = 4,
};

enum con_flush_mode {
	CONSOLE_FLUSH_PENDING = 0,
	CONSOLE_REPLAY_ALL = 1,
};

enum light_rebootmode_index {
	LIGHT_EVENT_PMIC_RESET = 0,
	LIGHT_EVENT_PMIC_ONKEY = 1,
	LIGHT_EVENT_PMIC_POWERUP = 2,
	LIGHT_EVENT_SW_REBOOT = 32,
	LIGHT_EVENT_SW_WATCHDOG = 33,
	LIGHT_EVENT_SW_PANIC = 34,
	LIGHT_EVENT_SW_HANG = 35,
	LIGHT_EVENT_MAX = 36,
};

struct warn_args {
	const char *fmt;
	va_list args;
};

struct device_attribute {
	struct attribute attr;
	ssize_t (*show)(struct device *, struct device_attribute *, char *);
	ssize_t (*store)(struct device *, struct device_attribute *, const char *, size_t);
};

enum cpuhp_smt_control {
	CPU_SMT_ENABLED = 0,
	CPU_SMT_DISABLED = 1,
	CPU_SMT_FORCE_DISABLED = 2,
	CPU_SMT_NOT_SUPPORTED = 3,
	CPU_SMT_NOT_IMPLEMENTED = 4,
};

struct smp_hotplug_thread {
	struct task_struct **store;
	struct list_head list;
	int (*thread_should_run)(unsigned int);
	void (*thread_fn)(unsigned int);
	void (*create)(unsigned int);
	void (*setup)(unsigned int);
	void (*cleanup)(unsigned int, bool);
	void (*park)(unsigned int);
	void (*unpark)(unsigned int);
	bool selfparking;
	const char *thread_comm;
};

struct sched_param {
	int sched_priority;
};

struct trace_event_raw_cpuhp_enter {
	struct trace_entry ent;
	unsigned int cpu;
	int target;
	int idx;
	void *fun;
	char __data[0];
};

struct trace_event_raw_cpuhp_multi_enter {
	struct trace_entry ent;
	unsigned int cpu;
	int target;
	int idx;
	void *fun;
	char __data[0];
};

struct trace_event_raw_cpuhp_exit {
	struct trace_entry ent;
	unsigned int cpu;
	int state;
	int idx;
	int ret;
	char __data[0];
};

struct trace_event_raw_cpuhp_pause {
	struct trace_entry ent;
	unsigned int cpus;
	unsigned int active_cpus;
	unsigned int time;
	unsigned char pause;
	char __data[0];
};

struct trace_event_data_offsets_cpuhp_enter {};

struct trace_event_data_offsets_cpuhp_multi_enter {};

struct trace_event_data_offsets_cpuhp_exit {};

struct trace_event_data_offsets_cpuhp_pause {};

typedef void (*btf_trace_cpuhp_enter)(void *, unsigned int, int, int, int (*)(unsigned int));

typedef void (*btf_trace_cpuhp_multi_enter)(void *, unsigned int, int, int, int (*)(unsigned int, struct hlist_node *), struct hlist_node *);

typedef void (*btf_trace_cpuhp_exit)(void *, unsigned int, int, int, int);

typedef void (*btf_trace_cpuhp_pause)(void *, struct cpumask *, u64, unsigned char);

struct cpuhp_cpu_state {
	enum cpuhp_state state;
	enum cpuhp_state target;
	enum cpuhp_state fail;
	struct task_struct *thread;
	bool should_run;
	bool rollback;
	bool single;
	bool bringup;
	struct hlist_node *node;
	struct hlist_node *last;
	enum cpuhp_state cb_state;
	int result;
	struct completion done_up;
	struct completion done_down;
};

struct cpuhp_step {
	const char *name;
	union {
		int (*single)(unsigned int);
		int (*multi)(unsigned int, struct hlist_node *);
	} startup;
	union {
		int (*single)(unsigned int);
		int (*multi)(unsigned int, struct hlist_node *);
	} teardown;
	struct hlist_head list;
	bool cant_stop;
	bool multi_instance;
};

enum cpu_mitigations {
	CPU_MITIGATIONS_OFF = 0,
	CPU_MITIGATIONS_AUTO = 1,
	CPU_MITIGATIONS_AUTO_NOSMT = 2,
};

struct __kernel_old_timeval {
	__kernel_long_t tv_sec;
	__kernel_long_t tv_usec;
};

struct rusage {
	struct __kernel_old_timeval ru_utime;
	struct __kernel_old_timeval ru_stime;
	__kernel_long_t ru_maxrss;
	__kernel_long_t ru_ixrss;
	__kernel_long_t ru_idrss;
	__kernel_long_t ru_isrss;
	__kernel_long_t ru_minflt;
	__kernel_long_t ru_majflt;
	__kernel_long_t ru_nswap;
	__kernel_long_t ru_inblock;
	__kernel_long_t ru_oublock;
	__kernel_long_t ru_msgsnd;
	__kernel_long_t ru_msgrcv;
	__kernel_long_t ru_nsignals;
	__kernel_long_t ru_nvcsw;
	__kernel_long_t ru_nivcsw;
};

typedef struct {} mm_segment_t;

struct waitid_info {
	pid_t pid;
	uid_t uid;
	int status;
	int cause;
};

struct wait_opts {
	enum pid_type wo_type;
	int wo_flags;
	struct pid *wo_pid;
	struct waitid_info *wo_info;
	int wo_stat;
	struct rusage *wo_rusage;
	wait_queue_entry_t child_wait;
	int notask_error;
};

typedef struct {
	unsigned int __softirq_pending;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
} irq_cpustat_t;

struct softirq_action {
	void (*action)(struct softirq_action *);
};

struct tasklet_struct {
	struct tasklet_struct *next;
	long unsigned int state;
	atomic_t count;
	bool use_callback;
	union {
		void (*func)(long unsigned int);
		void (*callback)(struct tasklet_struct *);
	};
	long unsigned int data;
};

enum {
	TASKLET_STATE_SCHED = 0,
	TASKLET_STATE_RUN = 1,
};

struct kernel_stat {
	long unsigned int irqs_sum;
	unsigned int softirqs[10];
};

struct trace_event_raw_irq_handler_entry {
	struct trace_entry ent;
	int irq;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_irq_handler_exit {
	struct trace_entry ent;
	int irq;
	int ret;
	char __data[0];
};

struct trace_event_raw_softirq {
	struct trace_entry ent;
	unsigned int vec;
	char __data[0];
};

struct trace_event_raw_tasklet {
	struct trace_entry ent;
	void *func;
	char __data[0];
};

struct trace_event_data_offsets_irq_handler_entry {
	u32 name;
};

struct trace_event_data_offsets_irq_handler_exit {};

struct trace_event_data_offsets_softirq {};

struct trace_event_data_offsets_tasklet {};

typedef void (*btf_trace_irq_handler_entry)(void *, int, struct irqaction *);

typedef void (*btf_trace_irq_handler_exit)(void *, int, struct irqaction *, int);

typedef void (*btf_trace_softirq_entry)(void *, unsigned int);

typedef void (*btf_trace_softirq_exit)(void *, unsigned int);

typedef void (*btf_trace_softirq_raise)(void *, unsigned int);

typedef void (*btf_trace_tasklet_entry)(void *, void *);

typedef void (*btf_trace_tasklet_exit)(void *, void *);

typedef void (*btf_trace_tasklet_hi_entry)(void *, void *);

typedef void (*btf_trace_tasklet_hi_exit)(void *, void *);

struct tasklet_head {
	struct tasklet_struct *head;
	struct tasklet_struct **tail;
};

enum {
	IORES_DESC_NONE = 0,
	IORES_DESC_CRASH_KERNEL = 1,
	IORES_DESC_ACPI_TABLES = 2,
	IORES_DESC_ACPI_NV_STORAGE = 3,
	IORES_DESC_PERSISTENT_MEMORY = 4,
	IORES_DESC_PERSISTENT_MEMORY_LEGACY = 5,
	IORES_DESC_DEVICE_PRIVATE_MEMORY = 6,
	IORES_DESC_RESERVED = 7,
	IORES_DESC_SOFT_RESERVED = 8,
};

typedef void (*dr_release_t)(struct device *, void *);

enum {
	REGION_INTERSECTS = 0,
	REGION_DISJOINT = 1,
	REGION_MIXED = 2,
};

struct resource_entry {
	struct list_head node;
	struct resource *res;
	resource_size_t offset;
	struct resource __res;
};

struct resource_constraint {
	resource_size_t min;
	resource_size_t max;
	resource_size_t align;
	resource_size_t (*alignf)(void *, const struct resource *, resource_size_t, resource_size_t);
	void *alignf_data;
};

enum {
	MAX_IORES_LEVEL = 5,
};

struct region_devres {
	struct resource *parent;
	resource_size_t start;
	resource_size_t n;
};

struct dentry_stat_t {
	long int nr_dentry;
	long int nr_unused;
	long int age_limit;
	long int want_pages;
	long int nr_negative;
	long int dummy;
};

struct files_stat_struct {
	long unsigned int nr_files;
	long unsigned int nr_free_files;
	long unsigned int max_files;
};

struct inodes_stat_t {
	long int nr_inodes;
	long int nr_unused;
	long int dummy[5];
};

enum sched_tunable_scaling {
	SCHED_TUNABLESCALING_NONE = 0,
	SCHED_TUNABLESCALING_LOG = 1,
	SCHED_TUNABLESCALING_LINEAR = 2,
	SCHED_TUNABLESCALING_END = 3,
};

enum sysctl_writes_mode {
	SYSCTL_WRITES_LEGACY = 4294967295,
	SYSCTL_WRITES_WARN = 0,
	SYSCTL_WRITES_STRICT = 1,
};

struct do_proc_dointvec_minmax_conv_param {
	int *min;
	int *max;
};

struct do_proc_douintvec_minmax_conv_param {
	unsigned int *min;
	unsigned int *max;
};

struct __user_cap_header_struct {
	__u32 version;
	int pid;
};

typedef struct __user_cap_header_struct *cap_user_header_t;

struct __user_cap_data_struct {
	__u32 effective;
	__u32 permitted;
	__u32 inheritable;
};

typedef struct __user_cap_data_struct *cap_user_data_t;

typedef struct siginfo siginfo_t;

struct sigqueue {
	struct list_head list;
	int flags;
	kernel_siginfo_t info;
	struct user_struct *user;
};

struct ptrace_peeksiginfo_args {
	__u64 off;
	__u32 flags;
	__s32 nr;
};

struct ptrace_syscall_info {
	__u8 op;
	__u8 pad[3];
	__u32 arch;
	__u64 instruction_pointer;
	__u64 stack_pointer;
	union {
		struct {
			__u64 nr;
			__u64 args[6];
		} entry;
		struct {
			__s64 rval;
			__u8 is_error;
		} exit;
		struct {
			__u64 nr;
			__u64 args[6];
			__u32 ret_data;
		} seccomp;
	};
};

enum siginfo_layout {
	SIL_KILL = 0,
	SIL_TIMER = 1,
	SIL_POLL = 2,
	SIL_FAULT = 3,
	SIL_FAULT_MCEERR = 4,
	SIL_FAULT_BNDERR = 5,
	SIL_FAULT_PKUERR = 6,
	SIL_CHLD = 7,
	SIL_RT = 8,
	SIL_SYS = 9,
};

struct fd {
	struct file *file;
	unsigned int flags;
};

enum {
	TRACE_SIGNAL_DELIVERED = 0,
	TRACE_SIGNAL_IGNORED = 1,
	TRACE_SIGNAL_ALREADY_PENDING = 2,
	TRACE_SIGNAL_OVERFLOW_FAIL = 3,
	TRACE_SIGNAL_LOSE_INFO = 4,
};

struct trace_event_raw_signal_generate {
	struct trace_entry ent;
	int sig;
	int errno;
	int code;
	char comm[16];
	pid_t pid;
	int group;
	int result;
	char __data[0];
};

struct trace_event_raw_signal_deliver {
	struct trace_entry ent;
	int sig;
	int errno;
	int code;
	long unsigned int sa_handler;
	long unsigned int sa_flags;
	char __data[0];
};

struct trace_event_data_offsets_signal_generate {};

struct trace_event_data_offsets_signal_deliver {};

typedef void (*btf_trace_signal_generate)(void *, int, struct kernel_siginfo *, struct task_struct *, int, int);

typedef void (*btf_trace_signal_deliver)(void *, int, struct kernel_siginfo *, struct k_sigaction *);

struct sysinfo {
	__kernel_long_t uptime;
	__kernel_ulong_t loads[3];
	__kernel_ulong_t totalram;
	__kernel_ulong_t freeram;
	__kernel_ulong_t sharedram;
	__kernel_ulong_t bufferram;
	__kernel_ulong_t totalswap;
	__kernel_ulong_t freeswap;
	__u16 procs;
	__u16 pad;
	__kernel_ulong_t totalhigh;
	__kernel_ulong_t freehigh;
	__u32 mem_unit;
	char _f[0];
};

struct rlimit64 {
	__u64 rlim_cur;
	__u64 rlim_max;
};

struct timens_offsets {
	struct timespec64 monotonic;
	struct timespec64 boottime;
};

struct time_namespace {
	struct kref kref;
	struct user_namespace *user_ns;
	struct ucounts *ucounts;
	struct ns_common ns;
	struct timens_offsets offsets;
	struct page *vvar_page;
	bool frozen_offsets;
};

enum uts_proc {
	UTS_PROC_OSTYPE = 0,
	UTS_PROC_OSRELEASE = 1,
	UTS_PROC_VERSION = 2,
	UTS_PROC_HOSTNAME = 3,
	UTS_PROC_DOMAINNAME = 4,
};

struct prctl_mm_map {
	__u64 start_code;
	__u64 end_code;
	__u64 start_data;
	__u64 end_data;
	__u64 start_brk;
	__u64 brk;
	__u64 start_stack;
	__u64 arg_start;
	__u64 arg_end;
	__u64 env_start;
	__u64 env_end;
	__u64 *auxv;
	__u32 auxv_size;
	__u32 exe_fd;
};

struct tms {
	__kernel_clock_t tms_utime;
	__kernel_clock_t tms_stime;
	__kernel_clock_t tms_cutime;
	__kernel_clock_t tms_cstime;
};

struct getcpu_cache {
	long unsigned int blob[16];
};

enum {
	PER_LINUX = 0,
	PER_LINUX_32BIT = 8388608,
	PER_LINUX_FDPIC = 524288,
	PER_SVR4 = 68157441,
	PER_SVR3 = 83886082,
	PER_SCOSVR3 = 117440515,
	PER_OSR5 = 100663299,
	PER_WYSEV386 = 83886084,
	PER_ISCR4 = 67108869,
	PER_BSD = 6,
	PER_SUNOS = 67108870,
	PER_XENIX = 83886087,
	PER_LINUX32 = 8,
	PER_LINUX32_3GB = 134217736,
	PER_IRIX32 = 67108873,
	PER_IRIXN32 = 67108874,
	PER_IRIX64 = 67108875,
	PER_RISCOS = 12,
	PER_SOLARIS = 67108877,
	PER_UW7 = 68157454,
	PER_OSF4 = 15,
	PER_HPUX = 16,
	PER_MASK = 255,
};

struct wq_flusher;

struct worker;

struct workqueue_attrs;

struct pool_workqueue;

struct wq_device;

struct workqueue_struct {
	struct list_head pwqs;
	struct list_head list;
	struct mutex mutex;
	int work_color;
	int flush_color;
	atomic_t nr_pwqs_to_flush;
	struct wq_flusher *first_flusher;
	struct list_head flusher_queue;
	struct list_head flusher_overflow;
	struct list_head maydays;
	struct worker *rescuer;
	int nr_drainers;
	int saved_max_active;
	struct workqueue_attrs *unbound_attrs;
	struct pool_workqueue *dfl_pwq;
	struct wq_device *wq_dev;
	char name[24];
	struct callback_head rcu;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	unsigned int flags;
	struct pool_workqueue *cpu_pwqs;
	struct pool_workqueue *numa_pwq_tbl[0];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct workqueue_attrs {
	int nice;
	cpumask_var_t cpumask;
	bool no_numa;
};

struct execute_work {
	struct work_struct work;
};

enum {
	WQ_UNBOUND = 2,
	WQ_FREEZABLE = 4,
	WQ_MEM_RECLAIM = 8,
	WQ_HIGHPRI = 16,
	WQ_CPU_INTENSIVE = 32,
	WQ_SYSFS = 64,
	WQ_POWER_EFFICIENT = 128,
	__WQ_DRAINING = 65536,
	__WQ_ORDERED = 131072,
	__WQ_LEGACY = 262144,
	__WQ_ORDERED_EXPLICIT = 524288,
	WQ_MAX_ACTIVE = 512,
	WQ_MAX_UNBOUND_PER_CPU = 4,
	WQ_DFL_ACTIVE = 256,
};

typedef unsigned int xa_mark_t;

enum xa_lock_type {
	XA_LOCK_IRQ = 1,
	XA_LOCK_BH = 2,
};

struct ida {
	struct xarray xa;
};

struct __una_u32 {
	u32 x;
};

enum hk_flags {
	HK_FLAG_TIMER = 1,
	HK_FLAG_RCU = 2,
	HK_FLAG_MISC = 4,
	HK_FLAG_SCHED = 8,
	HK_FLAG_TICK = 16,
	HK_FLAG_DOMAIN = 32,
	HK_FLAG_WQ = 64,
	HK_FLAG_MANAGED_IRQ = 128,
	HK_FLAG_KTHREAD = 256,
};

struct worker_pool;

struct worker {
	union {
		struct list_head entry;
		struct hlist_node hentry;
	};
	struct work_struct *current_work;
	work_func_t current_func;
	struct pool_workqueue *current_pwq;
	struct list_head scheduled;
	struct task_struct *task;
	struct worker_pool *pool;
	struct list_head node;
	long unsigned int last_active;
	unsigned int flags;
	int id;
	int sleeping;
	char desc[24];
	struct workqueue_struct *rescue_wq;
	work_func_t last_func;
};

struct pool_workqueue {
	struct worker_pool *pool;
	struct workqueue_struct *wq;
	int work_color;
	int flush_color;
	int refcnt;
	int nr_in_flight[15];
	int nr_active;
	int max_active;
	struct list_head delayed_works;
	struct list_head pwqs_node;
	struct list_head mayday_node;
	struct work_struct unbound_release_work;
	struct callback_head rcu;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct worker_pool {
	raw_spinlock_t lock;
	int cpu;
	int node;
	int id;
	unsigned int flags;
	long unsigned int watchdog_ts;
	struct list_head worklist;
	int nr_workers;
	int nr_idle;
	struct list_head idle_list;
	struct timer_list idle_timer;
	struct timer_list mayday_timer;
	struct hlist_head busy_hash[64];
	struct worker *manager;
	struct list_head workers;
	struct completion *detach_completion;
	struct ida worker_ida;
	struct workqueue_attrs *attrs;
	struct hlist_node hash_node;
	int refcnt;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	atomic_t nr_running;
	struct callback_head rcu;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

enum {
	POOL_MANAGER_ACTIVE = 1,
	POOL_DISASSOCIATED = 4,
	WORKER_DIE = 2,
	WORKER_IDLE = 4,
	WORKER_PREP = 8,
	WORKER_CPU_INTENSIVE = 64,
	WORKER_UNBOUND = 128,
	WORKER_REBOUND = 256,
	WORKER_NOT_RUNNING = 456,
	NR_STD_WORKER_POOLS = 2,
	UNBOUND_POOL_HASH_ORDER = 6,
	BUSY_WORKER_HASH_ORDER = 6,
	MAX_IDLE_WORKERS_RATIO = 4,
	IDLE_WORKER_TIMEOUT = 75000,
	MAYDAY_INITIAL_TIMEOUT = 2,
	MAYDAY_INTERVAL = 25,
	CREATE_COOLDOWN = 250,
	RESCUER_NICE_LEVEL = 4294967276,
	HIGHPRI_NICE_LEVEL = 4294967276,
	WQ_NAME_LEN = 24,
};

struct wq_flusher {
	struct list_head list;
	int flush_color;
	struct completion done;
};

struct wq_device {
	struct workqueue_struct *wq;
	struct device dev;
};

struct trace_event_raw_workqueue_queue_work {
	struct trace_entry ent;
	void *work;
	void *function;
	void *workqueue;
	unsigned int req_cpu;
	unsigned int cpu;
	char __data[0];
};

struct trace_event_raw_workqueue_activate_work {
	struct trace_entry ent;
	void *work;
	char __data[0];
};

struct trace_event_raw_workqueue_execute_start {
	struct trace_entry ent;
	void *work;
	void *function;
	char __data[0];
};

struct trace_event_raw_workqueue_execute_end {
	struct trace_entry ent;
	void *work;
	void *function;
	char __data[0];
};

struct trace_event_data_offsets_workqueue_queue_work {};

struct trace_event_data_offsets_workqueue_activate_work {};

struct trace_event_data_offsets_workqueue_execute_start {};

struct trace_event_data_offsets_workqueue_execute_end {};

typedef void (*btf_trace_workqueue_queue_work)(void *, unsigned int, struct pool_workqueue *, struct work_struct *);

typedef void (*btf_trace_workqueue_activate_work)(void *, struct work_struct *);

typedef void (*btf_trace_workqueue_execute_start)(void *, struct work_struct *);

typedef void (*btf_trace_workqueue_execute_end)(void *, struct work_struct *, work_func_t);

struct wq_barrier {
	struct work_struct work;
	struct completion done;
	struct task_struct *task;
};

struct cwt_wait {
	wait_queue_entry_t wait;
	struct work_struct *work;
};

struct apply_wqattrs_ctx {
	struct workqueue_struct *wq;
	struct workqueue_attrs *attrs;
	struct list_head list;
	struct pool_workqueue *dfl_pwq;
	struct pool_workqueue *pwq_tbl[0];
};

struct work_for_cpu {
	struct work_struct work;
	long int (*fn)(void *);
	void *arg;
	long int ret;
};

struct xa_node {
	unsigned char shift;
	unsigned char offset;
	unsigned char count;
	unsigned char nr_values;
	struct xa_node *parent;
	struct xarray *array;
	union {
		struct list_head private_list;
		struct callback_head callback_head;
	};
	void *slots[64];
	union {
		long unsigned int tags[3];
		long unsigned int marks[3];
	};
};

typedef struct {} local_lock_t;

struct radix_tree_preload {
	local_lock_t lock;
	unsigned int nr;
	struct xa_node *nodes;
};

typedef void (*task_work_func_t)(struct callback_head *);

enum task_work_notify_mode {
	TWA_NONE = 0,
	TWA_RESUME = 1,
	TWA_SIGNAL = 2,
};

enum {
	KERNEL_PARAM_OPS_FL_NOARG = 1,
};

enum {
	KERNEL_PARAM_FL_UNSAFE = 1,
	KERNEL_PARAM_FL_HWPARAM = 2,
};

struct param_attribute {
	struct module_attribute mattr;
	const struct kernel_param *param;
};

struct module_param_attrs {
	unsigned int num;
	struct attribute_group grp;
	struct param_attribute attrs[0];
};

struct module_version_attribute {
	struct module_attribute mattr;
	const char *module_name;
	const char *version;
};

enum lockdown_reason {
	LOCKDOWN_NONE = 0,
	LOCKDOWN_MODULE_SIGNATURE = 1,
	LOCKDOWN_DEV_MEM = 2,
	LOCKDOWN_EFI_TEST = 3,
	LOCKDOWN_KEXEC = 4,
	LOCKDOWN_HIBERNATION = 5,
	LOCKDOWN_PCI_ACCESS = 6,
	LOCKDOWN_IOPORT = 7,
	LOCKDOWN_MSR = 8,
	LOCKDOWN_ACPI_TABLES = 9,
	LOCKDOWN_PCMCIA_CIS = 10,
	LOCKDOWN_TIOCSSERIAL = 11,
	LOCKDOWN_MODULE_PARAMETERS = 12,
	LOCKDOWN_MMIOTRACE = 13,
	LOCKDOWN_DEBUGFS = 14,
	LOCKDOWN_XMON_WR = 15,
	LOCKDOWN_BPF_WRITE_USER = 16,
	LOCKDOWN_INTEGRITY_MAX = 17,
	LOCKDOWN_KCORE = 18,
	LOCKDOWN_KPROBES = 19,
	LOCKDOWN_BPF_READ = 20,
	LOCKDOWN_PERF = 21,
	LOCKDOWN_TRACEFS = 22,
	LOCKDOWN_XMON_RW = 23,
	LOCKDOWN_CONFIDENTIALITY_MAX = 24,
};

struct kmalloced_param {
	struct list_head list;
	char val[0];
};

struct kthread_work;

typedef void (*kthread_work_func_t)(struct kthread_work *);

struct kthread_worker;

struct kthread_work {
	struct list_head node;
	kthread_work_func_t func;
	struct kthread_worker *worker;
	int canceling;
};

enum {
	KTW_FREEZABLE = 1,
};

struct kthread_worker {
	unsigned int flags;
	raw_spinlock_t lock;
	struct list_head work_list;
	struct list_head delayed_work_list;
	struct task_struct *task;
	struct kthread_work *current_work;
};

struct kthread_delayed_work {
	struct kthread_work work;
	struct timer_list timer;
};

struct kthread_create_info {
	int (*threadfn)(void *);
	void *data;
	int node;
	struct task_struct *result;
	struct completion *done;
	struct list_head list;
};

struct kthread {
	long unsigned int flags;
	unsigned int cpu;
	int (*threadfn)(void *);
	void *data;
	mm_segment_t oldfs;
	struct completion parked;
	struct completion exited;
};

enum KTHREAD_BITS {
	KTHREAD_IS_PER_CPU = 0,
	KTHREAD_SHOULD_STOP = 1,
	KTHREAD_SHOULD_PARK = 2,
};

struct kthread_flush_work {
	struct kthread_work work;
	struct completion done;
};

struct ipc_ids {
	int in_use;
	short unsigned int seq;
	struct rw_semaphore rwsem;
	struct idr ipcs_idr;
	int max_idx;
	int last_idx;
	int next_id;
	struct rhashtable key_ht;
};

struct ipc_namespace {
	refcount_t count;
	struct ipc_ids ids[3];
	int sem_ctls[4];
	int used_sems;
	unsigned int msg_ctlmax;
	unsigned int msg_ctlmnb;
	unsigned int msg_ctlmni;
	atomic_t msg_bytes;
	atomic_t msg_hdrs;
	size_t shm_ctlmax;
	size_t shm_ctlall;
	long unsigned int shm_tot;
	int shm_ctlmni;
	int shm_rmid_forced;
	struct notifier_block ipcns_nb;
	struct vfsmount *mq_mnt;
	unsigned int mq_queues_count;
	unsigned int mq_queues_max;
	unsigned int mq_msg_max;
	unsigned int mq_msgsize_max;
	unsigned int mq_msg_default;
	unsigned int mq_msgsize_default;
	struct user_namespace *user_ns;
	struct ucounts *ucounts;
	struct llist_node mnt_llist;
	struct ns_common ns;
};

struct die_args {
	struct pt_regs *regs;
	const char *str;
	long int err;
	int trapnr;
	int signr;
};

struct srcu_notifier_head {
	struct mutex mutex;
	struct srcu_struct srcu;
	struct notifier_block *head;
};

struct kobj_attribute {
	struct attribute attr;
	ssize_t (*show)(struct kobject *, struct kobj_attribute *, char *);
	ssize_t (*store)(struct kobject *, struct kobj_attribute *, const char *, size_t);
};

enum what {
	PROC_EVENT_NONE = 0,
	PROC_EVENT_FORK = 1,
	PROC_EVENT_EXEC = 2,
	PROC_EVENT_UID = 4,
	PROC_EVENT_GID = 64,
	PROC_EVENT_SID = 128,
	PROC_EVENT_PTRACE = 256,
	PROC_EVENT_COMM = 512,
	PROC_EVENT_COREDUMP = 1073741824,
	PROC_EVENT_EXIT = 2147483648,
};

enum reboot_type {
	BOOT_TRIPLE = 116,
	BOOT_KBD = 107,
	BOOT_BIOS = 98,
	BOOT_ACPI = 97,
	BOOT_EFI = 101,
	BOOT_CF9_FORCE = 112,
	BOOT_CF9_SAFE = 113,
};

typedef u64 async_cookie_t;

typedef void (*async_func_t)(void *, async_cookie_t);

struct async_domain {
	struct list_head pending;
	unsigned int registered: 1;
};

struct async_entry {
	struct list_head domain_list;
	struct list_head global_list;
	struct work_struct work;
	async_cookie_t cookie;
	async_func_t func;
	void *data;
	struct async_domain *domain;
};

struct smpboot_thread_data {
	unsigned int cpu;
	unsigned int status;
	struct smp_hotplug_thread *ht;
};

enum {
	HP_THREAD_NONE = 0,
	HP_THREAD_ACTIVE = 1,
	HP_THREAD_PARKED = 2,
};

struct pin_cookie {};

enum {
	CSD_FLAG_LOCK = 1,
	IRQ_WORK_PENDING = 1,
	IRQ_WORK_BUSY = 2,
	IRQ_WORK_LAZY = 4,
	IRQ_WORK_HARD_IRQ = 8,
	IRQ_WORK_CLAIMED = 3,
	CSD_TYPE_ASYNC = 0,
	CSD_TYPE_SYNC = 16,
	CSD_TYPE_IRQ_WORK = 32,
	CSD_TYPE_TTWU = 48,
	CSD_FLAG_TYPE_MASK = 240,
};

typedef struct __call_single_data call_single_data_t;

struct dl_bw {
	raw_spinlock_t lock;
	u64 bw;
	u64 total_bw;
};

struct cpudl_item;

struct cpudl {
	raw_spinlock_t lock;
	int size;
	cpumask_var_t free_cpus;
	struct cpudl_item *elements;
};

struct cpupri_vec {
	atomic_t count;
	cpumask_var_t mask;
};

struct cpupri {
	struct cpupri_vec pri_to_cpu[102];
	int *cpu_to_pri;
};

struct perf_domain;

struct root_domain {
	atomic_t refcount;
	atomic_t rto_count;
	struct callback_head rcu;
	cpumask_var_t span;
	cpumask_var_t online;
	int overload;
	int overutilized;
	cpumask_var_t dlo_mask;
	atomic_t dlo_count;
	struct dl_bw dl_bw;
	struct cpudl cpudl;
	struct irq_work rto_push_work;
	raw_spinlock_t rto_lock;
	int rto_loop;
	int rto_cpu;
	atomic_t rto_loop_next;
	atomic_t rto_loop_start;
	cpumask_var_t rto_mask;
	struct cpupri cpupri;
	long unsigned int max_cpu_capacity;
	struct perf_domain *pd;
};

enum {
	SD_BALANCE_NEWIDLE = 1,
	SD_BALANCE_EXEC = 2,
	SD_BALANCE_FORK = 4,
	SD_BALANCE_WAKE = 8,
	SD_WAKE_AFFINE = 16,
	SD_ASYM_CPUCAPACITY = 32,
	SD_SHARE_CPUCAPACITY = 64,
	SD_SHARE_PKG_RESOURCES = 128,
	SD_SERIALIZE = 256,
	SD_ASYM_PACKING = 512,
	SD_PREFER_SIBLING = 1024,
	SD_OVERLAP = 2048,
	SD_NUMA = 4096,
};

struct sched_domain_shared {
	atomic_t ref;
	atomic_t nr_busy_cpus;
	int has_idle_cores;
};

struct sched_group;

struct sched_domain {
	struct sched_domain *parent;
	struct sched_domain *child;
	struct sched_group *groups;
	long unsigned int min_interval;
	long unsigned int max_interval;
	unsigned int busy_factor;
	unsigned int imbalance_pct;
	unsigned int cache_nice_tries;
	int nohz_idle;
	int flags;
	int level;
	long unsigned int last_balance;
	unsigned int balance_interval;
	unsigned int nr_balance_failed;
	u64 max_newidle_lb_cost;
	long unsigned int next_decay_max_lb_cost;
	u64 avg_scan_cost;
	char *name;
	union {
		void *private;
		struct callback_head rcu;
	};
	struct sched_domain_shared *shared;
	unsigned int span_weight;
	long unsigned int span[0];
};

struct sched_group_capacity;

struct sched_group {
	struct sched_group *next;
	atomic_t ref;
	unsigned int group_weight;
	struct sched_group_capacity *sgc;
	int asym_prefer_cpu;
	long unsigned int cpumask[0];
};

struct sched_group_capacity {
	atomic_t ref;
	long unsigned int capacity;
	long unsigned int min_capacity;
	long unsigned int max_capacity;
	long unsigned int next_update;
	int imbalance;
	int id;
	long unsigned int cpumask[0];
};

struct em_perf_state {
	long unsigned int frequency;
	long unsigned int power;
	long unsigned int cost;
};

struct em_perf_domain {
	struct em_perf_state *table;
	int nr_perf_states;
	int milliwatts;
	long unsigned int cpus[0];
};

enum ctx_state {
	CONTEXT_DISABLED = 4294967295,
	CONTEXT_KERNEL = 0,
	CONTEXT_USER = 1,
	CONTEXT_GUEST = 2,
};

struct kernel_cpustat {
	u64 cpustat[10];
};

struct trace_event_raw_sched_kthread_stop {
	struct trace_entry ent;
	char comm[16];
	pid_t pid;
	char __data[0];
};

struct trace_event_raw_sched_kthread_stop_ret {
	struct trace_entry ent;
	int ret;
	char __data[0];
};

struct trace_event_raw_sched_wakeup_template {
	struct trace_entry ent;
	char comm[16];
	pid_t pid;
	int prio;
	int success;
	int target_cpu;
	char __data[0];
};

struct trace_event_raw_sched_switch {
	struct trace_entry ent;
	char prev_comm[16];
	pid_t prev_pid;
	int prev_prio;
	long int prev_state;
	char next_comm[16];
	pid_t next_pid;
	int next_prio;
	char __data[0];
};

struct trace_event_raw_sched_migrate_task {
	struct trace_entry ent;
	char comm[16];
	pid_t pid;
	int prio;
	int orig_cpu;
	int dest_cpu;
	int running;
	char __data[0];
};

struct trace_event_raw_sched_process_template {
	struct trace_entry ent;
	char comm[16];
	pid_t pid;
	int prio;
	char __data[0];
};

struct trace_event_raw_sched_process_wait {
	struct trace_entry ent;
	char comm[16];
	pid_t pid;
	int prio;
	char __data[0];
};

struct trace_event_raw_sched_process_fork {
	struct trace_entry ent;
	char parent_comm[16];
	pid_t parent_pid;
	char child_comm[16];
	pid_t child_pid;
	char __data[0];
};

struct trace_event_raw_sched_process_exec {
	struct trace_entry ent;
	u32 __data_loc_filename;
	pid_t pid;
	pid_t old_pid;
	char __data[0];
};

struct trace_event_raw_sched_blocked_reason {
	struct trace_entry ent;
	pid_t pid;
	void *caller;
	bool io_wait;
	char __data[0];
};

struct trace_event_raw_sched_stat_runtime {
	struct trace_entry ent;
	char comm[16];
	pid_t pid;
	u64 runtime;
	u64 vruntime;
	char __data[0];
};

struct trace_event_raw_sched_pi_setprio {
	struct trace_entry ent;
	char comm[16];
	pid_t pid;
	int oldprio;
	int newprio;
	char __data[0];
};

struct trace_event_raw_sched_process_hang {
	struct trace_entry ent;
	char comm[16];
	pid_t pid;
	char __data[0];
};

struct trace_event_raw_sched_move_numa {
	struct trace_entry ent;
	pid_t pid;
	pid_t tgid;
	pid_t ngid;
	int src_cpu;
	int src_nid;
	int dst_cpu;
	int dst_nid;
	char __data[0];
};

struct trace_event_raw_sched_numa_pair_template {
	struct trace_entry ent;
	pid_t src_pid;
	pid_t src_tgid;
	pid_t src_ngid;
	int src_cpu;
	int src_nid;
	pid_t dst_pid;
	pid_t dst_tgid;
	pid_t dst_ngid;
	int dst_cpu;
	int dst_nid;
	char __data[0];
};

struct trace_event_raw_sched_wake_idle_without_ipi {
	struct trace_entry ent;
	int cpu;
	char __data[0];
};

struct trace_event_data_offsets_sched_kthread_stop {};

struct trace_event_data_offsets_sched_kthread_stop_ret {};

struct trace_event_data_offsets_sched_wakeup_template {};

struct trace_event_data_offsets_sched_switch {};

struct trace_event_data_offsets_sched_migrate_task {};

struct trace_event_data_offsets_sched_process_template {};

struct trace_event_data_offsets_sched_process_wait {};

struct trace_event_data_offsets_sched_process_fork {};

struct trace_event_data_offsets_sched_process_exec {
	u32 filename;
};

struct trace_event_data_offsets_sched_blocked_reason {};

struct trace_event_data_offsets_sched_stat_runtime {};

struct trace_event_data_offsets_sched_pi_setprio {};

struct trace_event_data_offsets_sched_process_hang {};

struct trace_event_data_offsets_sched_move_numa {};

struct trace_event_data_offsets_sched_numa_pair_template {};

struct trace_event_data_offsets_sched_wake_idle_without_ipi {};

typedef void (*btf_trace_sched_kthread_stop)(void *, struct task_struct *);

typedef void (*btf_trace_sched_kthread_stop_ret)(void *, int);

typedef void (*btf_trace_sched_waking)(void *, struct task_struct *);

typedef void (*btf_trace_sched_wakeup)(void *, struct task_struct *);

typedef void (*btf_trace_sched_wakeup_new)(void *, struct task_struct *);

typedef void (*btf_trace_sched_switch)(void *, bool, struct task_struct *, struct task_struct *);

typedef void (*btf_trace_sched_migrate_task)(void *, struct task_struct *, int);

typedef void (*btf_trace_sched_process_free)(void *, struct task_struct *);

typedef void (*btf_trace_sched_process_exit)(void *, struct task_struct *);

typedef void (*btf_trace_sched_wait_task)(void *, struct task_struct *);

typedef void (*btf_trace_sched_process_wait)(void *, struct pid *);

typedef void (*btf_trace_sched_process_fork)(void *, struct task_struct *, struct task_struct *);

typedef void (*btf_trace_sched_process_exec)(void *, struct task_struct *, pid_t, struct linux_binprm *);

typedef void (*btf_trace_sched_blocked_reason)(void *, struct task_struct *);

typedef void (*btf_trace_sched_stat_runtime)(void *, struct task_struct *, u64, u64);

typedef void (*btf_trace_sched_pi_setprio)(void *, struct task_struct *, struct task_struct *);

typedef void (*btf_trace_sched_process_hang)(void *, struct task_struct *);

typedef void (*btf_trace_sched_move_numa)(void *, struct task_struct *, int, int);

typedef void (*btf_trace_sched_stick_numa)(void *, struct task_struct *, int, struct task_struct *, int);

typedef void (*btf_trace_sched_swap_numa)(void *, struct task_struct *, int, struct task_struct *, int);

typedef void (*btf_trace_sched_wake_idle_without_ipi)(void *, int);

enum {
	MEMBARRIER_STATE_PRIVATE_EXPEDITED_READY = 1,
	MEMBARRIER_STATE_PRIVATE_EXPEDITED = 2,
	MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY = 4,
	MEMBARRIER_STATE_GLOBAL_EXPEDITED = 8,
	MEMBARRIER_STATE_PRIVATE_EXPEDITED_SYNC_CORE_READY = 16,
	MEMBARRIER_STATE_PRIVATE_EXPEDITED_SYNC_CORE = 32,
	MEMBARRIER_STATE_PRIVATE_EXPEDITED_RSEQ_READY = 64,
	MEMBARRIER_STATE_PRIVATE_EXPEDITED_RSEQ = 128,
};

struct wake_q_head {
	struct wake_q_node *first;
	struct wake_q_node **lastp;
	int count;
};

struct sched_attr {
	__u32 size;
	__u32 sched_policy;
	__u64 sched_flags;
	__s32 sched_nice;
	__u32 sched_priority;
	__u64 sched_runtime;
	__u64 sched_deadline;
	__u64 sched_period;
	__u32 sched_util_min;
	__u32 sched_util_max;
};

struct cpuidle_state_usage {
	long long unsigned int disable;
	long long unsigned int usage;
	u64 time_ns;
	long long unsigned int above;
	long long unsigned int below;
	long long unsigned int rejected;
};

struct cpuidle_device;

struct cpuidle_driver;

struct cpuidle_state {
	char name[16];
	char desc[32];
	u64 exit_latency_ns;
	u64 target_residency_ns;
	unsigned int flags;
	unsigned int exit_latency;
	int power_usage;
	unsigned int target_residency;
	int (*enter)(struct cpuidle_device *, struct cpuidle_driver *, int);
	int (*enter_dead)(struct cpuidle_device *, int);
	int (*enter_s2idle)(struct cpuidle_device *, struct cpuidle_driver *, int);
};

struct cpuidle_driver_kobj;

struct cpuidle_state_kobj;

struct cpuidle_device_kobj;

struct cpuidle_device {
	unsigned int registered: 1;
	unsigned int enabled: 1;
	unsigned int poll_time_limit: 1;
	unsigned int cpu;
	ktime_t next_hrtimer;
	int last_state_idx;
	u64 last_residency_ns;
	u64 poll_limit_ns;
	u64 forced_idle_latency_limit_ns;
	struct cpuidle_state_usage states_usage[10];
	struct cpuidle_state_kobj *kobjs[10];
	struct cpuidle_driver_kobj *kobj_driver;
	struct cpuidle_device_kobj *kobj_dev;
	struct list_head device_list;
};

struct cpuidle_driver {
	const char *name;
	struct module *owner;
	unsigned int bctimer: 1;
	struct cpuidle_state states[10];
	int state_count;
	int safe_state_index;
	struct cpumask *cpumask;
	const char *governor;
};

typedef int (*cpu_stop_fn_t)(void *);

struct cpu_stop_done;

struct cpu_stop_work {
	struct list_head list;
	cpu_stop_fn_t fn;
	void *arg;
	struct cpu_stop_done *done;
};

struct cpu_stop_done {
	atomic_t nr_todo;
	int ret;
	struct completion completion;
};

struct cpudl_item {
	u64 dl;
	int cpu;
	int idx;
};

struct rt_prio_array {
	long unsigned int bitmap[2];
	struct list_head queue[100];
};

struct rt_bandwidth {
	raw_spinlock_t rt_runtime_lock;
	ktime_t rt_period;
	u64 rt_runtime;
	struct hrtimer rt_period_timer;
	unsigned int rt_period_active;
};

struct dl_bandwidth {
	raw_spinlock_t dl_runtime_lock;
	u64 dl_runtime;
	u64 dl_period;
};

struct cfs_rq {
	struct load_weight load;
	unsigned int nr_running;
	unsigned int h_nr_running;
	unsigned int idle_h_nr_running;
	u64 exec_clock;
	u64 min_vruntime;
	struct rb_root_cached tasks_timeline;
	struct sched_entity *curr;
	struct sched_entity *next;
	struct sched_entity *last;
	struct sched_entity *skip;
	unsigned int nr_spread_over;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	struct sched_avg avg;
	struct {
		raw_spinlock_t lock;
		int nr;
		long unsigned int load_avg;
		long unsigned int util_avg;
		long unsigned int runnable_avg;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
	} removed;
};

struct rt_rq {
	struct rt_prio_array active;
	unsigned int rt_nr_running;
	unsigned int rr_nr_running;
	struct {
		int curr;
		int next;
	} highest_prio;
	long unsigned int rt_nr_migratory;
	long unsigned int rt_nr_total;
	int overloaded;
	struct plist_head pushable_tasks;
	int rt_queued;
	int rt_throttled;
	u64 rt_time;
	u64 rt_runtime;
	raw_spinlock_t rt_runtime_lock;
};

struct dl_rq {
	struct rb_root_cached root;
	long unsigned int dl_nr_running;
	struct {
		u64 curr;
		u64 next;
	} earliest_dl;
	long unsigned int dl_nr_migratory;
	int overloaded;
	struct rb_root_cached pushable_dl_tasks_root;
	u64 running_bw;
	u64 this_bw;
	u64 extra_bw;
	u64 bw_ratio;
};

struct perf_domain {
	struct em_perf_domain *em_pd;
	struct perf_domain *next;
	struct callback_head rcu;
};

struct rq {
	raw_spinlock_t lock;
	unsigned int nr_running;
	long unsigned int last_blocked_load_update_tick;
	unsigned int has_blocked_load;
	long: 32;
	long: 64;
	call_single_data_t nohz_csd;
	unsigned int nohz_tick_stopped;
	atomic_t nohz_flags;
	unsigned int ttwu_pending;
	u64 nr_switches;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct cfs_rq cfs;
	struct rt_rq rt;
	struct dl_rq dl;
	long unsigned int nr_uninterruptible;
	struct task_struct *curr;
	struct task_struct *idle;
	struct task_struct *stop;
	long unsigned int next_balance;
	struct mm_struct *prev_mm;
	unsigned int clock_update_flags;
	u64 clock;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	u64 clock_task;
	u64 clock_pelt;
	long unsigned int lost_idle_time;
	atomic_t nr_iowait;
	int membarrier_state;
	struct root_domain *rd;
	struct sched_domain *sd;
	long unsigned int cpu_capacity;
	long unsigned int cpu_capacity_orig;
	struct callback_head *balance_callback;
	unsigned char nohz_idle_balance;
	unsigned char idle_balance;
	long unsigned int misfit_task_load;
	int active_balance;
	int push_cpu;
	struct cpu_stop_work active_balance_work;
	int cpu;
	int online;
	struct list_head cfs_tasks;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct sched_avg avg_rt;
	struct sched_avg avg_dl;
	u64 idle_stamp;
	u64 avg_idle;
	u64 max_idle_balance_cost;
	long unsigned int calc_load_update;
	long int calc_load_active;
	long: 64;
	long: 64;
	long: 64;
	call_single_data_t hrtick_csd;
	struct hrtimer hrtick_timer;
	ktime_t hrtick_time;
	struct cpu_stop_work drain;
	struct cpu_stop_done drain_done;
	struct cpuidle_state *idle_state;
};

struct rq_flags {
	long unsigned int flags;
	struct pin_cookie cookie;
	unsigned int clock_update_flags;
};

enum {
	__SCHED_FEAT_GENTLE_FAIR_SLEEPERS = 0,
	__SCHED_FEAT_START_DEBIT = 1,
	__SCHED_FEAT_NEXT_BUDDY = 2,
	__SCHED_FEAT_LAST_BUDDY = 3,
	__SCHED_FEAT_CACHE_HOT_BUDDY = 4,
	__SCHED_FEAT_WAKEUP_PREEMPTION = 5,
	__SCHED_FEAT_HRTICK = 6,
	__SCHED_FEAT_DOUBLE_TICK = 7,
	__SCHED_FEAT_NONTASK_CAPACITY = 8,
	__SCHED_FEAT_TTWU_QUEUE = 9,
	__SCHED_FEAT_SIS_AVG_CPU = 10,
	__SCHED_FEAT_SIS_PROP = 11,
	__SCHED_FEAT_WARN_DOUBLE_CLOCK = 12,
	__SCHED_FEAT_RT_PUSH_IPI = 13,
	__SCHED_FEAT_RT_RUNTIME_SHARE = 14,
	__SCHED_FEAT_LB_MIN = 15,
	__SCHED_FEAT_ATTACH_AGE_LOAD = 16,
	__SCHED_FEAT_WA_IDLE = 17,
	__SCHED_FEAT_WA_WEIGHT = 18,
	__SCHED_FEAT_WA_BIAS = 19,
	__SCHED_FEAT_UTIL_EST = 20,
	__SCHED_FEAT_UTIL_EST_FASTUP = 21,
	__SCHED_FEAT_ALT_PERIOD = 22,
	__SCHED_FEAT_BASE_SLICE = 23,
	__SCHED_FEAT_NR = 24,
};

struct migration_arg {
	struct task_struct *task;
	int dest_cpu;
};

struct migration_swap_arg {
	struct task_struct *src_task;
	struct task_struct *dst_task;
	int src_cpu;
	int dst_cpu;
};

enum {
	cpuset = 0,
	possible = 1,
	fail = 2,
};

struct idle_timer {
	struct hrtimer timer;
	int done;
};

struct update_util_data {
	void (*func)(struct update_util_data *, u64, unsigned int);
};

enum cpu_idle_type {
	CPU_IDLE = 0,
	CPU_NOT_IDLE = 1,
	CPU_NEWLY_IDLE = 2,
	CPU_MAX_IDLE_TYPES = 3,
};

struct cfs_bandwidth {};

enum schedutil_type {
	FREQUENCY_UTIL = 0,
	ENERGY_UTIL = 1,
};

enum fbq_type {
	regular = 0,
	remote = 1,
	all = 2,
};

enum group_type {
	group_has_spare = 0,
	group_fully_busy = 1,
	group_misfit_task = 2,
	group_asym_packing = 3,
	group_imbalanced = 4,
	group_overloaded = 5,
};

enum migration_type {
	migrate_load = 0,
	migrate_util = 1,
	migrate_task = 2,
	migrate_misfit = 3,
};

struct lb_env {
	struct sched_domain *sd;
	struct rq *src_rq;
	int src_cpu;
	int dst_cpu;
	struct rq *dst_rq;
	struct cpumask *dst_grpmask;
	int new_dst_cpu;
	enum cpu_idle_type idle;
	long int imbalance;
	struct cpumask *cpus;
	unsigned int flags;
	unsigned int loop;
	unsigned int loop_break;
	unsigned int loop_max;
	enum fbq_type fbq_type;
	enum migration_type migration_type;
	struct list_head tasks;
	struct rq_flags *src_rq_rf;
};

struct sg_lb_stats {
	long unsigned int avg_load;
	long unsigned int group_load;
	long unsigned int group_capacity;
	long unsigned int group_util;
	long unsigned int group_runnable;
	unsigned int sum_nr_running;
	unsigned int sum_h_nr_running;
	unsigned int idle_cpus;
	unsigned int group_weight;
	enum group_type group_type;
	unsigned int group_asym_packing;
	long unsigned int group_misfit_task_load;
};

struct sd_lb_stats {
	struct sched_group *busiest;
	struct sched_group *local;
	long unsigned int total_load;
	long unsigned int total_capacity;
	long unsigned int avg_load;
	unsigned int prefer_sibling;
	struct sg_lb_stats busiest_stat;
	struct sg_lb_stats local_stat;
};

struct task_group;

typedef struct rt_rq *rt_rq_iter_t;

struct wait_bit_key {
	void *flags;
	int bit_nr;
	long unsigned int timeout;
};

struct wait_bit_queue_entry {
	struct wait_bit_key key;
	struct wait_queue_entry wq_entry;
};

typedef int wait_bit_action_f(struct wait_bit_key *, int);

struct swait_queue {
	struct task_struct *task;
	struct list_head task_list;
};

struct sd_flag_debug {
	unsigned int meta_flags;
	char *name;
};

struct sched_domain_attr {
	int relax_domain_level;
};

typedef const struct cpumask * (*sched_domain_mask_f)(int);

typedef int (*sched_domain_flags_f)();

struct sd_data {
	struct sched_domain **sd;
	struct sched_domain_shared **sds;
	struct sched_group **sg;
	struct sched_group_capacity **sgc;
};

struct sched_domain_topology_level {
	sched_domain_mask_f mask;
	sched_domain_flags_f sd_flags;
	int flags;
	int numa_level;
	struct sd_data data;
	char *name;
};

struct s_data {
	struct sched_domain **sd;
	struct root_domain *rd;
};

enum s_alloc {
	sa_rootdomain = 0,
	sa_sd = 1,
	sa_sd_storage = 2,
	sa_none = 3,
};

enum cpufreq_table_sorting {
	CPUFREQ_TABLE_UNSORTED = 0,
	CPUFREQ_TABLE_SORTED_ASCENDING = 1,
	CPUFREQ_TABLE_SORTED_DESCENDING = 2,
};

struct cpufreq_cpuinfo {
	unsigned int max_freq;
	unsigned int min_freq;
	unsigned int transition_latency;
};

struct clk;

struct cpufreq_governor;

struct cpufreq_frequency_table;

struct cpufreq_stats;

struct thermal_cooling_device;

struct cpufreq_policy {
	cpumask_var_t cpus;
	cpumask_var_t related_cpus;
	cpumask_var_t real_cpus;
	unsigned int shared_type;
	unsigned int cpu;
	struct clk *clk;
	struct cpufreq_cpuinfo cpuinfo;
	unsigned int min;
	unsigned int max;
	unsigned int cur;
	unsigned int restore_freq;
	unsigned int suspend_freq;
	unsigned int policy;
	unsigned int last_policy;
	struct cpufreq_governor *governor;
	void *governor_data;
	char last_governor[16];
	struct work_struct update;
	struct freq_constraints constraints;
	struct freq_qos_request *min_freq_req;
	struct freq_qos_request *max_freq_req;
	struct cpufreq_frequency_table *freq_table;
	enum cpufreq_table_sorting freq_table_sorted;
	struct list_head policy_list;
	struct kobject kobj;
	struct completion kobj_unregister;
	struct rw_semaphore rwsem;
	bool fast_switch_possible;
	bool fast_switch_enabled;
	bool strict_target;
	unsigned int transition_delay_us;
	bool dvfs_possible_from_any_cpu;
	unsigned int cached_target_freq;
	unsigned int cached_resolved_idx;
	bool transition_ongoing;
	spinlock_t transition_lock;
	wait_queue_head_t transition_wait;
	struct task_struct *transition_task;
	struct cpufreq_stats *stats;
	void *driver_data;
	struct thermal_cooling_device *cdev;
	struct notifier_block nb_min;
	struct notifier_block nb_max;
};

struct cpufreq_governor {
	char name[16];
	int (*init)(struct cpufreq_policy *);
	void (*exit)(struct cpufreq_policy *);
	int (*start)(struct cpufreq_policy *);
	void (*stop)(struct cpufreq_policy *);
	void (*limits)(struct cpufreq_policy *);
	ssize_t (*show_setspeed)(struct cpufreq_policy *, char *);
	int (*store_setspeed)(struct cpufreq_policy *, unsigned int);
	struct list_head governor_list;
	struct module *owner;
	u8 flags;
};

struct cpufreq_frequency_table {
	unsigned int flags;
	unsigned int driver_data;
	unsigned int frequency;
};

struct gov_attr_set {
	struct kobject kobj;
	struct list_head policy_list;
	struct mutex update_lock;
	int usage_count;
};

struct governor_attr {
	struct attribute attr;
	ssize_t (*show)(struct gov_attr_set *, char *);
	ssize_t (*store)(struct gov_attr_set *, const char *, size_t);
};

struct sugov_tunables {
	struct gov_attr_set attr_set;
	unsigned int rate_limit_us;
};

struct sugov_policy {
	struct cpufreq_policy *policy;
	struct sugov_tunables *tunables;
	struct list_head tunables_hook;
	raw_spinlock_t update_lock;
	u64 last_freq_update_time;
	s64 freq_update_delay_ns;
	unsigned int next_freq;
	unsigned int cached_raw_freq;
	struct irq_work irq_work;
	struct kthread_work work;
	struct mutex work_lock;
	struct kthread_worker worker;
	struct task_struct *thread;
	bool work_in_progress;
	bool limits_changed;
	bool need_freq_update;
};

struct sugov_cpu {
	struct update_util_data update_util;
	struct sugov_policy *sg_policy;
	unsigned int cpu;
	bool iowait_boost_pending;
	unsigned int iowait_boost;
	u64 last_update;
	long unsigned int bw_dl;
	long unsigned int max;
	long unsigned int saved_idle_calls;
};

enum {
	MEMBARRIER_FLAG_SYNC_CORE = 1,
	MEMBARRIER_FLAG_RSEQ = 2,
};

enum membarrier_cmd {
	MEMBARRIER_CMD_QUERY = 0,
	MEMBARRIER_CMD_GLOBAL = 1,
	MEMBARRIER_CMD_GLOBAL_EXPEDITED = 2,
	MEMBARRIER_CMD_REGISTER_GLOBAL_EXPEDITED = 4,
	MEMBARRIER_CMD_PRIVATE_EXPEDITED = 8,
	MEMBARRIER_CMD_REGISTER_PRIVATE_EXPEDITED = 16,
	MEMBARRIER_CMD_PRIVATE_EXPEDITED_SYNC_CORE = 32,
	MEMBARRIER_CMD_REGISTER_PRIVATE_EXPEDITED_SYNC_CORE = 64,
	MEMBARRIER_CMD_PRIVATE_EXPEDITED_RSEQ = 128,
	MEMBARRIER_CMD_REGISTER_PRIVATE_EXPEDITED_RSEQ = 256,
	MEMBARRIER_CMD_SHARED = 1,
};

enum membarrier_cmd_flag {
	MEMBARRIER_CMD_FLAG_CPU = 1,
};

struct ww_acquire_ctx;

struct ww_mutex {
	struct mutex base;
	struct ww_acquire_ctx *ctx;
};

struct ww_acquire_ctx {
	struct task_struct *task;
	long unsigned int stamp;
	unsigned int acquired;
	short unsigned int wounded;
	short unsigned int is_wait_die;
};

struct mutex_waiter {
	struct list_head list;
	struct task_struct *task;
	struct ww_acquire_ctx *ww_ctx;
};

enum mutex_trylock_recursive_enum {
	MUTEX_TRYLOCK_FAILED = 0,
	MUTEX_TRYLOCK_SUCCESS = 1,
	MUTEX_TRYLOCK_RECURSIVE = 2,
};

struct semaphore {
	raw_spinlock_t lock;
	unsigned int count;
	struct list_head wait_list;
};

struct semaphore_waiter {
	struct list_head list;
	struct task_struct *task;
	bool up;
};

enum rwsem_waiter_type {
	RWSEM_WAITING_FOR_WRITE = 0,
	RWSEM_WAITING_FOR_READ = 1,
};

struct rwsem_waiter {
	struct list_head list;
	struct task_struct *task;
	enum rwsem_waiter_type type;
	long unsigned int timeout;
	long unsigned int last_rowner;
};

enum rwsem_wake_type {
	RWSEM_WAKE_ANY = 0,
	RWSEM_WAKE_READERS = 1,
	RWSEM_WAKE_READ_OWNED = 2,
};

enum writer_wait_state {
	WRITER_NOT_FIRST = 0,
	WRITER_FIRST = 1,
	WRITER_HANDOFF = 2,
};

enum owner_state {
	OWNER_NULL = 1,
	OWNER_WRITER = 2,
	OWNER_READER = 4,
	OWNER_NONSPINNABLE = 8,
};

struct percpu_rw_semaphore_atomic {
	struct percpu_rw_semaphore rw_sem;
	struct list_head destroy_list_entry;
};

struct optimistic_spin_node {
	struct optimistic_spin_node *next;
	struct optimistic_spin_node *prev;
	int locked;
	int cpu;
};

struct hrtimer_sleeper {
	struct hrtimer timer;
	struct task_struct *task;
};

struct rt_mutex;

struct rt_mutex_waiter {
	struct rb_node tree_entry;
	struct rb_node pi_tree_entry;
	struct task_struct *task;
	struct rt_mutex *lock;
	int prio;
	u64 deadline;
};

struct rt_mutex {
	raw_spinlock_t wait_lock;
	struct rb_root_cached waiters;
	struct task_struct *owner;
};

enum rtmutex_chainwalk {
	RT_MUTEX_MIN_CHAINWALK = 0,
	RT_MUTEX_FULL_CHAINWALK = 1,
};

struct pm_qos_request {
	struct plist_node node;
	struct pm_qos_constraints *qos;
};

enum pm_qos_req_action {
	PM_QOS_ADD_REQ = 0,
	PM_QOS_UPDATE_REQ = 1,
	PM_QOS_REMOVE_REQ = 2,
};

typedef int suspend_state_t;

struct sysrq_key_op {
	void (* const handler)(int);
	const char * const help_msg;
	const char * const action_msg;
	const int enable_mask;
};

struct dev_printk_info {
	char subsystem[16];
	char device[48];
};

struct console {
	char name[16];
	void (*write)(struct console *, const char *, unsigned int);
	int (*read)(struct console *, char *, unsigned int);
	struct tty_driver * (*device)(struct console *, int *);
	void (*unblank)();
	int (*setup)(struct console *, char *);
	int (*exit)(struct console *);
	int (*match)(struct console *, char *, int, char *);
	short int flags;
	short int index;
	int cflag;
	void *data;
	struct console *next;
};

struct kmsg_dumper {
	struct list_head list;
	void (*dump)(struct kmsg_dumper *, enum kmsg_dump_reason);
	enum kmsg_dump_reason max_reason;
	bool active;
	bool registered;
	u32 cur_idx;
	u32 next_idx;
	u64 cur_seq;
	u64 next_seq;
};

struct trace_event_raw_console {
	struct trace_entry ent;
	u32 __data_loc_msg;
	char __data[0];
};

struct trace_event_data_offsets_console {
	u32 msg;
};

typedef void (*btf_trace_console)(void *, const char *, size_t);

struct printk_info {
	u64 seq;
	u64 ts_nsec;
	u16 text_len;
	u8 facility;
	u8 flags: 5;
	u8 level: 3;
	u32 caller_id;
	struct dev_printk_info dev_info;
};

struct printk_record {
	struct printk_info *info;
	char *text_buf;
	unsigned int text_buf_size;
};

struct prb_data_blk_lpos {
	long unsigned int begin;
	long unsigned int next;
};

struct prb_desc {
	atomic_long_t state_var;
	struct prb_data_blk_lpos text_blk_lpos;
};

struct prb_data_ring {
	unsigned int size_bits;
	char *data;
	atomic_long_t head_lpos;
	atomic_long_t tail_lpos;
};

struct prb_desc_ring {
	unsigned int count_bits;
	struct prb_desc *descs;
	struct printk_info *infos;
	atomic_long_t head_id;
	atomic_long_t tail_id;
	atomic_long_t last_finalized_id;
};

struct printk_ringbuffer {
	struct prb_desc_ring desc_ring;
	struct prb_data_ring text_data_ring;
	atomic_long_t fail;
};

struct prb_reserved_entry {
	struct printk_ringbuffer *rb;
	long unsigned int irqflags;
	long unsigned int id;
	unsigned int text_space;
};

enum desc_state {
	desc_miss = 4294967295,
	desc_reserved = 0,
	desc_committed = 1,
	desc_finalized = 2,
	desc_reusable = 3,
};

struct console_cmdline {
	char name[16];
	int index;
	bool user_specified;
	char *options;
};

enum devkmsg_log_bits {
	__DEVKMSG_LOG_BIT_ON = 0,
	__DEVKMSG_LOG_BIT_OFF = 1,
	__DEVKMSG_LOG_BIT_LOCK = 2,
};

enum devkmsg_log_masks {
	DEVKMSG_LOG_MASK_ON = 1,
	DEVKMSG_LOG_MASK_OFF = 2,
	DEVKMSG_LOG_MASK_LOCK = 4,
};

enum con_msg_format_flags {
	MSG_FORMAT_DEFAULT = 0,
	MSG_FORMAT_SYSLOG = 1,
};

enum log_flags {
	LOG_NEWLINE = 2,
	LOG_CONT = 8,
};

struct devkmsg_user {
	u64 seq;
	struct ratelimit_state rs;
	struct mutex lock;
	char buf[8192];
	struct printk_info info;
	char text_buf[8192];
	struct printk_record record;
};

struct printk_safe_seq_buf {
	atomic_t len;
	atomic_t message_lost;
	struct irq_work work;
	unsigned char buffer[8160];
};

struct prb_data_block {
	long unsigned int id;
	char data[0];
};

typedef long unsigned int irq_hw_number_t;

struct irq_affinity_desc {
	struct cpumask mask;
	unsigned int is_managed: 1;
};

enum {
	IRQ_TYPE_NONE = 0,
	IRQ_TYPE_EDGE_RISING = 1,
	IRQ_TYPE_EDGE_FALLING = 2,
	IRQ_TYPE_EDGE_BOTH = 3,
	IRQ_TYPE_LEVEL_HIGH = 4,
	IRQ_TYPE_LEVEL_LOW = 8,
	IRQ_TYPE_LEVEL_MASK = 12,
	IRQ_TYPE_SENSE_MASK = 15,
	IRQ_TYPE_DEFAULT = 15,
	IRQ_TYPE_PROBE = 16,
	IRQ_LEVEL = 256,
	IRQ_PER_CPU = 512,
	IRQ_NOPROBE = 1024,
	IRQ_NOREQUEST = 2048,
	IRQ_NOAUTOEN = 4096,
	IRQ_NO_BALANCING = 8192,
	IRQ_MOVE_PCNTXT = 16384,
	IRQ_NESTED_THREAD = 32768,
	IRQ_NOTHREAD = 65536,
	IRQ_PER_CPU_DEVID = 131072,
	IRQ_IS_POLLED = 262144,
	IRQ_DISABLE_UNLAZY = 524288,
	IRQ_HIDDEN = 1048576,
	IRQ_RAW = 2097152,
};

enum irq_domain_bus_token {
	DOMAIN_BUS_ANY = 0,
	DOMAIN_BUS_WIRED = 1,
	DOMAIN_BUS_GENERIC_MSI = 2,
	DOMAIN_BUS_PCI_MSI = 3,
	DOMAIN_BUS_PLATFORM_MSI = 4,
	DOMAIN_BUS_NEXUS = 5,
	DOMAIN_BUS_IPI = 6,
	DOMAIN_BUS_FSL_MC_MSI = 7,
	DOMAIN_BUS_TI_SCI_INTA_MSI = 8,
	DOMAIN_BUS_WAKEUP = 9,
	DOMAIN_BUS_VMD_MSI = 10,
};

struct irq_domain_ops;

struct irq_domain_chip_generic;

struct irq_domain {
	struct list_head link;
	const char *name;
	const struct irq_domain_ops *ops;
	void *host_data;
	unsigned int flags;
	unsigned int mapcount;
	struct fwnode_handle *fwnode;
	enum irq_domain_bus_token bus_token;
	struct irq_domain_chip_generic *gc;
	struct irq_domain *parent;
	irq_hw_number_t hwirq_max;
	unsigned int revmap_direct_max_irq;
	unsigned int revmap_size;
	struct xarray revmap_tree;
	struct mutex revmap_tree_mutex;
	unsigned int linear_revmap[0];
};

struct irq_chip_regs {
	long unsigned int enable;
	long unsigned int disable;
	long unsigned int mask;
	long unsigned int ack;
	long unsigned int eoi;
	long unsigned int type;
	long unsigned int polarity;
};

struct irq_chip_type {
	struct irq_chip chip;
	struct irq_chip_regs regs;
	irq_flow_handler_t handler;
	u32 type;
	u32 mask_cache_priv;
	u32 *mask_cache;
};

struct irq_chip_generic {
	raw_spinlock_t lock;
	void *reg_base;
	u32 (*reg_readl)(void *);
	void (*reg_writel)(u32, void *);
	void (*suspend)(struct irq_chip_generic *);
	void (*resume)(struct irq_chip_generic *);
	unsigned int irq_base;
	unsigned int irq_cnt;
	u32 mask_cache;
	u32 type_cache;
	u32 polarity_cache;
	u32 wake_enabled;
	u32 wake_active;
	unsigned int num_ct;
	void *private;
	long unsigned int installed;
	long unsigned int unused;
	struct irq_domain *domain;
	struct list_head list;
	struct irq_chip_type chip_types[0];
};

enum irq_gc_flags {
	IRQ_GC_INIT_MASK_CACHE = 1,
	IRQ_GC_INIT_NESTED_LOCK = 2,
	IRQ_GC_MASK_CACHE_PER_TYPE = 4,
	IRQ_GC_NO_MASK = 8,
	IRQ_GC_BE_IO = 16,
};

struct irq_domain_chip_generic {
	unsigned int irqs_per_chip;
	unsigned int num_chips;
	unsigned int irq_flags_to_clear;
	unsigned int irq_flags_to_set;
	enum irq_gc_flags gc_flags;
	struct irq_chip_generic *gc[0];
};

struct irq_fwspec {
	struct fwnode_handle *fwnode;
	int param_count;
	u32 param[16];
};

struct irq_domain_ops {
	int (*match)(struct irq_domain *, struct device_node *, enum irq_domain_bus_token);
	int (*select)(struct irq_domain *, struct irq_fwspec *, enum irq_domain_bus_token);
	int (*map)(struct irq_domain *, unsigned int, irq_hw_number_t);
	void (*unmap)(struct irq_domain *, unsigned int);
	int (*xlate)(struct irq_domain *, struct device_node *, const u32 *, unsigned int, long unsigned int *, unsigned int *);
	int (*alloc)(struct irq_domain *, unsigned int, unsigned int, void *);
	void (*free)(struct irq_domain *, unsigned int, unsigned int);
	int (*activate)(struct irq_domain *, struct irq_data *, bool);
	void (*deactivate)(struct irq_domain *, struct irq_data *);
	int (*translate)(struct irq_domain *, struct irq_fwspec *, long unsigned int *, unsigned int *);
};

enum {
	IRQS_AUTODETECT = 1,
	IRQS_SPURIOUS_DISABLED = 2,
	IRQS_POLL_INPROGRESS = 8,
	IRQS_ONESHOT = 32,
	IRQS_REPLAY = 64,
	IRQS_WAITING = 128,
	IRQS_PENDING = 512,
	IRQS_SUSPENDED = 2048,
	IRQS_TIMINGS = 4096,
	IRQS_NMI = 8192,
};

enum {
	_IRQ_DEFAULT_INIT_FLAGS = 0,
	_IRQ_PER_CPU = 512,
	_IRQ_LEVEL = 256,
	_IRQ_NOPROBE = 1024,
	_IRQ_NOREQUEST = 2048,
	_IRQ_NOTHREAD = 65536,
	_IRQ_NOAUTOEN = 4096,
	_IRQ_MOVE_PCNTXT = 16384,
	_IRQ_NO_BALANCING = 8192,
	_IRQ_NESTED_THREAD = 32768,
	_IRQ_PER_CPU_DEVID = 131072,
	_IRQ_IS_POLLED = 262144,
	_IRQ_DISABLE_UNLAZY = 524288,
	_IRQ_HIDDEN = 1048576,
	_IRQ_RAW = 2097152,
	_IRQF_MODIFY_MASK = 2096911,
};

enum {
	IRQTF_RUNTHREAD = 0,
	IRQTF_WARNED = 1,
	IRQTF_AFFINITY = 2,
	IRQTF_FORCED_THREAD = 3,
};

enum {
	IRQC_IS_HARDIRQ = 0,
	IRQC_IS_NESTED = 1,
};

enum {
	IRQ_SET_MASK_OK = 0,
	IRQ_SET_MASK_OK_NOCOPY = 1,
	IRQ_SET_MASK_OK_DONE = 2,
};

enum {
	IRQCHIP_SET_TYPE_MASKED = 1,
	IRQCHIP_EOI_IF_HANDLED = 2,
	IRQCHIP_MASK_ON_SUSPEND = 4,
	IRQCHIP_ONOFFLINE_ENABLED = 8,
	IRQCHIP_SKIP_SET_WAKE = 16,
	IRQCHIP_ONESHOT_SAFE = 32,
	IRQCHIP_EOI_THREADED = 64,
	IRQCHIP_SUPPORTS_LEVEL_MSI = 128,
	IRQCHIP_SUPPORTS_NMI = 256,
	IRQCHIP_ENABLE_WAKEUP_ON_SUSPEND = 512,
	IRQCHIP_AFFINITY_PRE_STARTUP = 1024,
};

struct msi_msg {
	u32 address_lo;
	u32 address_hi;
	u32 data;
};

struct platform_msi_priv_data;

struct platform_msi_desc {
	struct platform_msi_priv_data *msi_priv_data;
	u16 msi_index;
};

struct fsl_mc_msi_desc {
	u16 msi_index;
};

struct ti_sci_inta_msi_desc {
	u16 dev_index;
};

struct msi_desc {
	struct list_head list;
	unsigned int irq;
	unsigned int nvec_used;
	struct device *dev;
	struct msi_msg msg;
	struct irq_affinity_desc *affinity;
	void (*write_msi_msg)(struct msi_desc *, void *);
	void *write_msi_msg_data;
	union {
		struct {
			u32 masked;
			struct {
				u8 is_msix: 1;
				u8 multiple: 3;
				u8 multi_cap: 3;
				u8 maskbit: 1;
				u8 is_64: 1;
				u8 is_virtual: 1;
				u16 entry_nr;
				unsigned int default_irq;
			} msi_attrib;
			union {
				u8 mask_pos;
				void *mask_base;
			};
		};
		struct platform_msi_desc platform;
		struct fsl_mc_msi_desc fsl_mc;
		struct ti_sci_inta_msi_desc inta;
	};
};

enum {
	IRQ_STARTUP_NORMAL = 0,
	IRQ_STARTUP_MANAGED = 1,
	IRQ_STARTUP_ABORT = 2,
};

struct irq_devres {
	unsigned int irq;
	void *dev_id;
};

struct irq_desc_devres {
	unsigned int from;
	unsigned int cnt;
};

struct of_phandle_args {
	struct device_node *np;
	int args_count;
	uint32_t args[16];
};

enum {
	IRQ_DOMAIN_FLAG_HIERARCHY = 1,
	IRQ_DOMAIN_NAME_ALLOCATED = 2,
	IRQ_DOMAIN_FLAG_IPI_PER_CPU = 4,
	IRQ_DOMAIN_FLAG_IPI_SINGLE = 8,
	IRQ_DOMAIN_FLAG_MSI = 16,
	IRQ_DOMAIN_FLAG_MSI_REMAP = 32,
	IRQ_DOMAIN_MSI_NOMASK_QUIRK = 64,
	IRQ_DOMAIN_FLAG_NONCORE = 65536,
};

enum {
	IRQCHIP_FWNODE_REAL = 0,
	IRQCHIP_FWNODE_NAMED = 1,
	IRQCHIP_FWNODE_NAMED_ID = 2,
};

struct irqchip_fwid {
	struct fwnode_handle fwnode;
	unsigned int type;
	char *name;
	phys_addr_t *pa;
};

struct proc_ops {
	unsigned int proc_flags;
	int (*proc_open)(struct inode *, struct file *);
	ssize_t (*proc_read)(struct file *, char *, size_t, loff_t *);
	ssize_t (*proc_read_iter)(struct kiocb *, struct iov_iter *);
	ssize_t (*proc_write)(struct file *, const char *, size_t, loff_t *);
	loff_t (*proc_lseek)(struct file *, loff_t, int);
	int (*proc_release)(struct inode *, struct file *);
	__poll_t (*proc_poll)(struct file *, struct poll_table_struct *);
	long int (*proc_ioctl)(struct file *, unsigned int, long unsigned int);
	int (*proc_mmap)(struct file *, struct vm_area_struct *);
	long unsigned int (*proc_get_unmapped_area)(struct file *, long unsigned int, long unsigned int, long unsigned int, long unsigned int);
};

enum {
	AFFINITY = 0,
	AFFINITY_LIST = 1,
	EFFECTIVE = 2,
	EFFECTIVE_LIST = 3,
};

struct cpu_topology {
	int thread_id;
	int core_id;
	int package_id;
	int llc_id;
	cpumask_t thread_sibling;
	cpumask_t core_sibling;
	cpumask_t llc_sibling;
	cpumask_t android_vendor_data1;
};

struct irq_affinity {
	unsigned int pre_vectors;
	unsigned int post_vectors;
	unsigned int nr_sets;
	unsigned int set_size[4];
	void (*calc_sets)(struct irq_affinity *, unsigned int);
	void *priv;
};

struct node_vectors {
	unsigned int id;
	union {
		unsigned int nvectors;
		unsigned int ncpus;
	};
};

typedef void (*rcu_callback_t)(struct callback_head *);

typedef void (*call_rcu_func_t)(struct callback_head *, rcu_callback_t);

struct rcu_synchronize {
	struct callback_head head;
	struct completion completion;
};

struct trace_event_raw_rcu_utilization {
	struct trace_entry ent;
	const char *s;
	char __data[0];
};

struct trace_event_raw_rcu_stall_warning {
	struct trace_entry ent;
	const char *rcuname;
	const char *msg;
	char __data[0];
};

struct trace_event_data_offsets_rcu_utilization {};

struct trace_event_data_offsets_rcu_stall_warning {};

typedef void (*btf_trace_rcu_utilization)(void *, const char *);

typedef void (*btf_trace_rcu_stall_warning)(void *, const char *, const char *);

struct rcu_tasks;

typedef void (*rcu_tasks_gp_func_t)(struct rcu_tasks *);

typedef void (*pregp_func_t)();

typedef void (*pertask_func_t)(struct task_struct *, struct list_head *);

typedef void (*postscan_func_t)(struct list_head *);

typedef void (*holdouts_func_t)(struct list_head *, bool, bool *);

typedef void (*postgp_func_t)(struct rcu_tasks *);

struct rcu_tasks {
	struct callback_head *cbs_head;
	struct callback_head **cbs_tail;
	struct wait_queue_head cbs_wq;
	raw_spinlock_t cbs_lock;
	int gp_state;
	int gp_sleep;
	int init_fract;
	long unsigned int gp_jiffies;
	long unsigned int gp_start;
	long unsigned int n_gps;
	long unsigned int n_ipis;
	long unsigned int n_ipis_fails;
	struct task_struct *kthread_ptr;
	rcu_tasks_gp_func_t gp_func;
	pregp_func_t pregp_func;
	pertask_func_t pertask_func;
	postscan_func_t postscan_func;
	holdouts_func_t holdouts_func;
	postgp_func_t postgp_func;
	call_rcu_func_t call_func;
	char *name;
	char *kname;
};

enum {
	GP_IDLE = 0,
	GP_ENTER = 1,
	GP_PASSED = 2,
	GP_EXIT = 3,
	GP_REPLAY = 4,
};

struct rcu_cblist {
	struct callback_head *head;
	struct callback_head **tail;
	long int len;
};

enum rcutorture_type {
	RCU_FLAVOR = 0,
	RCU_TASKS_FLAVOR = 1,
	RCU_TASKS_RUDE_FLAVOR = 2,
	RCU_TASKS_TRACING_FLAVOR = 3,
	RCU_TRIVIAL_FLAVOR = 4,
	SRCU_FLAVOR = 5,
	INVALID_RCU_FLAVOR = 6,
};

struct rcu_exp_work {
	long unsigned int rew_s;
	struct work_struct rew_work;
};

struct rcu_node {
	raw_spinlock_t lock;
	long unsigned int gp_seq;
	long unsigned int gp_seq_needed;
	long unsigned int completedqs;
	long unsigned int qsmask;
	long unsigned int rcu_gp_init_mask;
	long unsigned int qsmaskinit;
	long unsigned int qsmaskinitnext;
	long unsigned int expmask;
	long unsigned int expmaskinit;
	long unsigned int expmaskinitnext;
	long unsigned int cbovldmask;
	long unsigned int ffmask;
	long unsigned int grpmask;
	int grplo;
	int grphi;
	u8 grpnum;
	u8 level;
	bool wait_blkd_tasks;
	struct rcu_node *parent;
	struct list_head blkd_tasks;
	struct list_head *gp_tasks;
	struct list_head *exp_tasks;
	struct list_head *boost_tasks;
	struct rt_mutex boost_mtx;
	long unsigned int boost_time;
	struct task_struct *boost_kthread_task;
	unsigned int boost_kthread_status;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	raw_spinlock_t fqslock;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	spinlock_t exp_lock;
	long unsigned int exp_seq_rq;
	wait_queue_head_t exp_wq[4];
	struct rcu_exp_work rew;
	bool exp_need_flush;
	long: 56;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

enum tick_dep_bits {
	TICK_DEP_BIT_POSIX_TIMER = 0,
	TICK_DEP_BIT_PERF_EVENTS = 1,
	TICK_DEP_BIT_SCHED = 2,
	TICK_DEP_BIT_CLOCK_UNSTABLE = 3,
	TICK_DEP_BIT_RCU = 4,
	TICK_DEP_BIT_RCU_EXP = 5,
};

union rcu_noqs {
	struct {
		u8 norm;
		u8 exp;
	} b;
	u16 s;
};

struct rcu_data {
	long unsigned int gp_seq;
	long unsigned int gp_seq_needed;
	union rcu_noqs cpu_no_qs;
	bool core_needs_qs;
	bool beenonline;
	bool gpwrap;
	bool exp_deferred_qs;
	bool cpu_started;
	struct rcu_node *mynode;
	long unsigned int grpmask;
	long unsigned int ticks_this_gp;
	struct irq_work defer_qs_iw;
	bool defer_qs_iw_pending;
	struct work_struct strict_work;
	struct rcu_segcblist cblist;
	long int qlen_last_fqs_check;
	long unsigned int n_cbs_invoked;
	long unsigned int n_force_qs_snap;
	long int blimit;
	int dynticks_snap;
	long int dynticks_nesting;
	long int dynticks_nmi_nesting;
	atomic_t dynticks;
	bool rcu_need_heavy_qs;
	bool rcu_urgent_qs;
	bool rcu_forced_tick;
	bool rcu_forced_tick_exp;
	struct callback_head barrier_head;
	int exp_dynticks_snap;
	struct task_struct *rcu_cpu_kthread_task;
	unsigned int rcu_cpu_kthread_status;
	char rcu_cpu_has_work;
	unsigned int softirq_snap;
	struct irq_work rcu_iw;
	bool rcu_iw_pending;
	long unsigned int rcu_iw_gp_seq;
	long unsigned int rcu_ofl_gp_seq;
	short int rcu_ofl_gp_flags;
	long unsigned int rcu_onl_gp_seq;
	short int rcu_onl_gp_flags;
	long unsigned int last_fqs_resched;
	int cpu;
};

struct rcu_state {
	struct rcu_node node[1];
	struct rcu_node *level[2];
	int ncpus;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	u8 boost;
	long unsigned int gp_seq;
	long unsigned int gp_max;
	struct task_struct *gp_kthread;
	struct swait_queue_head gp_wq;
	short int gp_flags;
	short int gp_state;
	long unsigned int gp_wake_time;
	long unsigned int gp_wake_seq;
	struct mutex barrier_mutex;
	atomic_t barrier_cpu_count;
	struct completion barrier_completion;
	long unsigned int barrier_sequence;
	struct mutex exp_mutex;
	struct mutex exp_wake_mutex;
	long unsigned int expedited_sequence;
	atomic_t expedited_need_qs;
	struct swait_queue_head expedited_wq;
	int ncpus_snap;
	u8 cbovld;
	u8 cbovldnext;
	long unsigned int jiffies_force_qs;
	long unsigned int jiffies_kick_kthreads;
	long unsigned int n_force_qs;
	long unsigned int gp_start;
	long unsigned int gp_end;
	long unsigned int gp_activity;
	long unsigned int gp_req_activity;
	long unsigned int jiffies_stall;
	long unsigned int jiffies_resched;
	long unsigned int n_force_qs_gpstart;
	const char *name;
	char abbr;
	long: 56;
	long: 64;
	long: 64;
	raw_spinlock_t ofl_lock;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct kvfree_rcu_bulk_data {
	long unsigned int nr_records;
	struct kvfree_rcu_bulk_data *next;
	void *records[0];
};

struct kfree_rcu_cpu;

struct kfree_rcu_cpu_work {
	struct rcu_work rcu_work;
	struct callback_head *head_free;
	struct kvfree_rcu_bulk_data *bkvhead_free[2];
	struct kfree_rcu_cpu *krcp;
};

struct kfree_rcu_cpu {
	struct callback_head *head;
	struct kvfree_rcu_bulk_data *bkvhead[2];
	struct kfree_rcu_cpu_work krw_arr[2];
	raw_spinlock_t lock;
	struct delayed_work monitor_work;
	bool monitor_todo;
	bool initialized;
	int count;
	struct work_struct page_cache_work;
	atomic_t work_in_progress;
	struct hrtimer hrtimer;
	struct llist_head bkvcache;
	int nr_bkv_objs;
};

struct rcu_stall_chk_rdr {
	int nesting;
	union rcu_special rs;
	bool on_blkd_list;
};

struct scatterlist {
	long unsigned int page_link;
	unsigned int offset;
	unsigned int length;
	dma_addr_t dma_address;
};

struct sg_table {
	struct scatterlist *sgl;
	unsigned int nents;
	unsigned int orig_nents;
};

struct dma_map_ops {
	void * (*alloc)(struct device *, size_t, dma_addr_t *, gfp_t, long unsigned int);
	void (*free)(struct device *, size_t, void *, dma_addr_t, long unsigned int);
	struct page * (*alloc_pages)(struct device *, size_t, dma_addr_t *, enum dma_data_direction, gfp_t);
	void (*free_pages)(struct device *, size_t, struct page *, dma_addr_t, enum dma_data_direction);
	void * (*alloc_noncoherent)(struct device *, size_t, dma_addr_t *, enum dma_data_direction, gfp_t);
	void (*free_noncoherent)(struct device *, size_t, void *, dma_addr_t, enum dma_data_direction);
	int (*mmap)(struct device *, struct vm_area_struct *, void *, dma_addr_t, size_t, long unsigned int);
	int (*get_sgtable)(struct device *, struct sg_table *, void *, dma_addr_t, size_t, long unsigned int);
	dma_addr_t (*map_page)(struct device *, struct page *, long unsigned int, size_t, enum dma_data_direction, long unsigned int);
	void (*unmap_page)(struct device *, dma_addr_t, size_t, enum dma_data_direction, long unsigned int);
	int (*map_sg)(struct device *, struct scatterlist *, int, enum dma_data_direction, long unsigned int);
	void (*unmap_sg)(struct device *, struct scatterlist *, int, enum dma_data_direction, long unsigned int);
	dma_addr_t (*map_resource)(struct device *, phys_addr_t, size_t, enum dma_data_direction, long unsigned int);
	void (*unmap_resource)(struct device *, dma_addr_t, size_t, enum dma_data_direction, long unsigned int);
	void (*sync_single_for_cpu)(struct device *, dma_addr_t, size_t, enum dma_data_direction);
	void (*sync_single_for_device)(struct device *, dma_addr_t, size_t, enum dma_data_direction);
	void (*sync_sg_for_cpu)(struct device *, struct scatterlist *, int, enum dma_data_direction);
	void (*sync_sg_for_device)(struct device *, struct scatterlist *, int, enum dma_data_direction);
	void (*cache_sync)(struct device *, void *, size_t, enum dma_data_direction);
	int (*dma_supported)(struct device *, u64);
	u64 (*get_required_mask)(struct device *);
	size_t (*max_mapping_size)(struct device *);
	long unsigned int (*get_merge_boundary)(struct device *);
};

enum swiotlb_force {
	SWIOTLB_NORMAL = 0,
	SWIOTLB_FORCE = 1,
	SWIOTLB_NO_FORCE = 2,
};

enum dma_sync_target {
	SYNC_FOR_CPU = 0,
	SYNC_FOR_DEVICE = 1,
};

struct dma_devres {
	size_t size;
	void *vaddr;
	dma_addr_t dma_handle;
	long unsigned int attrs;
};

struct dma_coherent_mem {
	void *virt_base;
	dma_addr_t device_base;
	long unsigned int pfn_base;
	int size;
	long unsigned int *bitmap;
	spinlock_t spinlock;
	bool use_dev_dma_pfn_offset;
};

struct trace_event_raw_swiotlb_bounced {
	struct trace_entry ent;
	u32 __data_loc_dev_name;
	u64 dma_mask;
	dma_addr_t dev_addr;
	size_t size;
	enum swiotlb_force swiotlb_force;
	char __data[0];
};

struct trace_event_data_offsets_swiotlb_bounced {
	u32 dev_name;
};

typedef void (*btf_trace_swiotlb_bounced)(void *, struct device *, dma_addr_t, size_t, enum swiotlb_force);

struct gen_pool;

typedef long unsigned int (*genpool_algo_t)(long unsigned int *, long unsigned int, long unsigned int, unsigned int, void *, struct gen_pool *, long unsigned int);

struct gen_pool {
	spinlock_t lock;
	struct list_head chunks;
	int min_alloc_order;
	genpool_algo_t algo;
	void *data;
	const char *name;
};

enum kcmp_type {
	KCMP_FILE = 0,
	KCMP_VM = 1,
	KCMP_FILES = 2,
	KCMP_FS = 3,
	KCMP_SIGHAND = 4,
	KCMP_IO = 5,
	KCMP_SYSVSEM = 6,
	KCMP_EPOLL_TFD = 7,
	KCMP_TYPES = 8,
};

struct kcmp_epoll_slot {
	__u32 efd;
	__u32 tfd;
	__u32 toff;
};

typedef __kernel_long_t __kernel_suseconds_t;

typedef __kernel_suseconds_t suseconds_t;

typedef __kernel_clock_t clock_t;

typedef __u64 timeu64_t;

struct __kernel_itimerspec {
	struct __kernel_timespec it_interval;
	struct __kernel_timespec it_value;
};

struct timezone {
	int tz_minuteswest;
	int tz_dsttime;
};

struct itimerspec64 {
	struct timespec64 it_interval;
	struct timespec64 it_value;
};

struct old_itimerspec32 {
	struct old_timespec32 it_interval;
	struct old_timespec32 it_value;
};

struct __kernel_timex_timeval {
	__kernel_time64_t tv_sec;
	long long int tv_usec;
};

struct __kernel_timex {
	unsigned int modes;
	long long int offset;
	long long int freq;
	long long int maxerror;
	long long int esterror;
	int status;
	long long int constant;
	long long int precision;
	long long int tolerance;
	struct __kernel_timex_timeval time;
	long long int tick;
	long long int ppsfreq;
	long long int jitter;
	int shift;
	long long int stabil;
	long long int jitcnt;
	long long int calcnt;
	long long int errcnt;
	long long int stbcnt;
	int tai;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct trace_event_raw_timer_class {
	struct trace_entry ent;
	void *timer;
	char __data[0];
};

struct trace_event_raw_timer_start {
	struct trace_entry ent;
	void *timer;
	void *function;
	long unsigned int expires;
	long unsigned int now;
	unsigned int flags;
	char __data[0];
};

struct trace_event_raw_timer_expire_entry {
	struct trace_entry ent;
	void *timer;
	long unsigned int now;
	void *function;
	long unsigned int baseclk;
	char __data[0];
};

struct trace_event_raw_hrtimer_init {
	struct trace_entry ent;
	void *hrtimer;
	clockid_t clockid;
	enum hrtimer_mode mode;
	char __data[0];
};

struct trace_event_raw_hrtimer_start {
	struct trace_entry ent;
	void *hrtimer;
	void *function;
	s64 expires;
	s64 softexpires;
	enum hrtimer_mode mode;
	char __data[0];
};

struct trace_event_raw_hrtimer_expire_entry {
	struct trace_entry ent;
	void *hrtimer;
	s64 now;
	void *function;
	char __data[0];
};

struct trace_event_raw_hrtimer_class {
	struct trace_entry ent;
	void *hrtimer;
	char __data[0];
};

struct trace_event_raw_itimer_state {
	struct trace_entry ent;
	int which;
	long long unsigned int expires;
	long int value_sec;
	long int value_nsec;
	long int interval_sec;
	long int interval_nsec;
	char __data[0];
};

struct trace_event_raw_itimer_expire {
	struct trace_entry ent;
	int which;
	pid_t pid;
	long long unsigned int now;
	char __data[0];
};

struct trace_event_raw_tick_stop {
	struct trace_entry ent;
	int success;
	int dependency;
	char __data[0];
};

struct trace_event_data_offsets_timer_class {};

struct trace_event_data_offsets_timer_start {};

struct trace_event_data_offsets_timer_expire_entry {};

struct trace_event_data_offsets_hrtimer_init {};

struct trace_event_data_offsets_hrtimer_start {};

struct trace_event_data_offsets_hrtimer_expire_entry {};

struct trace_event_data_offsets_hrtimer_class {};

struct trace_event_data_offsets_itimer_state {};

struct trace_event_data_offsets_itimer_expire {};

struct trace_event_data_offsets_tick_stop {};

typedef void (*btf_trace_timer_init)(void *, struct timer_list *);

typedef void (*btf_trace_timer_start)(void *, struct timer_list *, long unsigned int, unsigned int);

typedef void (*btf_trace_timer_expire_entry)(void *, struct timer_list *, long unsigned int);

typedef void (*btf_trace_timer_expire_exit)(void *, struct timer_list *);

typedef void (*btf_trace_timer_cancel)(void *, struct timer_list *);

typedef void (*btf_trace_hrtimer_init)(void *, struct hrtimer *, clockid_t, enum hrtimer_mode);

typedef void (*btf_trace_hrtimer_start)(void *, struct hrtimer *, enum hrtimer_mode);

typedef void (*btf_trace_hrtimer_expire_entry)(void *, struct hrtimer *, ktime_t *);

typedef void (*btf_trace_hrtimer_expire_exit)(void *, struct hrtimer *);

typedef void (*btf_trace_hrtimer_cancel)(void *, struct hrtimer *);

typedef void (*btf_trace_itimer_state)(void *, int, const struct itimerspec64 * const, long long unsigned int);

typedef void (*btf_trace_itimer_expire)(void *, int, struct pid *, long long unsigned int);

typedef void (*btf_trace_tick_stop)(void *, int, int);

struct timer_base {
	raw_spinlock_t lock;
	struct timer_list *running_timer;
	long unsigned int clk;
	long unsigned int next_expiry;
	unsigned int cpu;
	bool next_expiry_recalc;
	bool is_idle;
	bool timers_pending;
	long unsigned int pending_map[9];
	struct hlist_head vectors[576];
	long: 64;
	long: 64;
};

struct process_timer {
	struct timer_list timer;
	struct task_struct *task;
};

enum tick_device_mode {
	TICKDEV_MODE_PERIODIC = 0,
	TICKDEV_MODE_ONESHOT = 1,
};

struct clock_event_device;

struct tick_device {
	struct clock_event_device *evtdev;
	enum tick_device_mode mode;
};

enum clock_event_state {
	CLOCK_EVT_STATE_DETACHED = 0,
	CLOCK_EVT_STATE_SHUTDOWN = 1,
	CLOCK_EVT_STATE_PERIODIC = 2,
	CLOCK_EVT_STATE_ONESHOT = 3,
	CLOCK_EVT_STATE_ONESHOT_STOPPED = 4,
};

struct clock_event_device {
	void (*event_handler)(struct clock_event_device *);
	int (*set_next_event)(long unsigned int, struct clock_event_device *);
	int (*set_next_ktime)(ktime_t, struct clock_event_device *);
	ktime_t next_event;
	u64 max_delta_ns;
	u64 min_delta_ns;
	u32 mult;
	u32 shift;
	enum clock_event_state state_use_accessors;
	unsigned int features;
	long unsigned int retries;
	int (*set_state_periodic)(struct clock_event_device *);
	int (*set_state_oneshot)(struct clock_event_device *);
	int (*set_state_oneshot_stopped)(struct clock_event_device *);
	int (*set_state_shutdown)(struct clock_event_device *);
	int (*tick_resume)(struct clock_event_device *);
	void (*broadcast)(const struct cpumask *);
	void (*suspend)(struct clock_event_device *);
	void (*resume)(struct clock_event_device *);
	long unsigned int min_delta_ticks;
	long unsigned int max_delta_ticks;
	const char *name;
	int rating;
	int irq;
	int bound_on;
	const struct cpumask *cpumask;
	struct list_head list;
	struct module *owner;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct ktime_timestamps {
	u64 mono;
	u64 boot;
	u64 real;
};

struct system_time_snapshot {
	u64 cycles;
	ktime_t real;
	ktime_t raw;
	unsigned int clock_was_set_seq;
	u8 cs_was_changed_seq;
};

struct system_device_crosststamp {
	ktime_t device;
	ktime_t sys_realtime;
	ktime_t sys_monoraw;
};

struct system_counterval_t {
	u64 cycles;
	struct clocksource *cs;
};

typedef struct {
	seqcount_t seqcount;
} seqcount_latch_t;

struct tk_read_base {
	struct clocksource *clock;
	u64 mask;
	u64 cycle_last;
	u32 mult;
	u32 shift;
	u64 xtime_nsec;
	ktime_t base;
	u64 base_real;
};

struct timekeeper {
	struct tk_read_base tkr_mono;
	struct tk_read_base tkr_raw;
	u64 xtime_sec;
	long unsigned int ktime_sec;
	struct timespec64 wall_to_monotonic;
	ktime_t offs_real;
	ktime_t offs_boot;
	ktime_t offs_tai;
	s32 tai_offset;
	unsigned int clock_was_set_seq;
	u8 cs_was_changed_seq;
	ktime_t next_leap_ktime;
	u64 raw_sec;
	struct timespec64 monotonic_to_boot;
	u64 cycle_interval;
	u64 xtime_interval;
	s64 xtime_remainder;
	u64 raw_interval;
	u64 ntp_tick;
	s64 ntp_error;
	u32 ntp_error_shift;
	u32 ntp_err_mult;
	u32 skip_second_overflow;
};

struct audit_ntp_data {};

enum timekeeping_adv_mode {
	TK_ADV_TICK = 0,
	TK_ADV_FREQ = 1,
};

struct tk_fast {
	seqcount_latch_t seq;
	struct tk_read_base base[2];
};

enum audit_ntp_type {
	AUDIT_NTP_OFFSET = 0,
	AUDIT_NTP_FREQ = 1,
	AUDIT_NTP_STATUS = 2,
	AUDIT_NTP_TAI = 3,
	AUDIT_NTP_TICK = 4,
	AUDIT_NTP_ADJUST = 5,
	AUDIT_NTP_NVALS = 6,
};

enum tick_nohz_mode {
	NOHZ_MODE_INACTIVE = 0,
	NOHZ_MODE_LOWRES = 1,
	NOHZ_MODE_HIGHRES = 2,
};

struct tick_sched {
	struct hrtimer sched_timer;
	long unsigned int check_clocks;
	enum tick_nohz_mode nohz_mode;
	unsigned int inidle: 1;
	unsigned int tick_stopped: 1;
	unsigned int idle_active: 1;
	unsigned int do_timer_last: 1;
	unsigned int got_idle_tick: 1;
	ktime_t last_tick;
	ktime_t next_tick;
	long unsigned int idle_jiffies;
	long unsigned int idle_calls;
	long unsigned int idle_sleeps;
	ktime_t idle_entrytime;
	ktime_t idle_waketime;
	ktime_t idle_exittime;
	ktime_t idle_sleeptime;
	ktime_t iowait_sleeptime;
	long unsigned int last_jiffies;
	u64 timer_expires;
	u64 timer_expires_base;
	u64 next_timer;
	ktime_t idle_expires;
	atomic_t tick_dep_mask;
};

struct timer_list_iter {
	int cpu;
	bool second_pass;
	u64 now;
};

struct tm {
	int tm_sec;
	int tm_min;
	int tm_hour;
	int tm_mday;
	int tm_mon;
	long int tm_year;
	int tm_wday;
	int tm_yday;
};

struct cyclecounter {
	u64 (*read)(const struct cyclecounter *);
	u64 mask;
	u32 mult;
	u32 shift;
};

struct timecounter {
	const struct cyclecounter *cc;
	u64 cycle_last;
	u64 nsec;
	u64 mask;
	u64 frac;
};

typedef __kernel_timer_t timer_t;

struct rtc_time {
	int tm_sec;
	int tm_min;
	int tm_hour;
	int tm_mday;
	int tm_mon;
	int tm_year;
	int tm_wday;
	int tm_yday;
	int tm_isdst;
};

struct rtc_wkalrm {
	unsigned char enabled;
	unsigned char pending;
	struct rtc_time time;
};

enum alarmtimer_type {
	ALARM_REALTIME = 0,
	ALARM_BOOTTIME = 1,
	ALARM_NUMTYPE = 2,
	ALARM_REALTIME_FREEZER = 3,
	ALARM_BOOTTIME_FREEZER = 4,
};

enum alarmtimer_restart {
	ALARMTIMER_NORESTART = 0,
	ALARMTIMER_RESTART = 1,
};

struct alarm {
	struct timerqueue_node node;
	struct hrtimer timer;
	enum alarmtimer_restart (*function)(struct alarm *, ktime_t);
	enum alarmtimer_type type;
	int state;
	void *data;
};

struct cpu_timer {
	struct timerqueue_node node;
	struct timerqueue_head *head;
	struct pid *pid;
	struct list_head elist;
	int firing;
};

struct k_clock;

struct k_itimer {
	struct list_head list;
	struct hlist_node t_hash;
	spinlock_t it_lock;
	const struct k_clock *kclock;
	clockid_t it_clock;
	timer_t it_id;
	int it_active;
	s64 it_overrun;
	s64 it_overrun_last;
	int it_requeue_pending;
	int it_sigev_notify;
	ktime_t it_interval;
	struct signal_struct *it_signal;
	union {
		struct pid *it_pid;
		struct task_struct *it_process;
	};
	struct sigqueue *sigq;
	union {
		struct {
			struct hrtimer timer;
		} real;
		struct cpu_timer cpu;
		struct {
			struct alarm alarmtimer;
		} alarm;
	} it;
	struct callback_head rcu;
};

struct k_clock {
	int (*clock_getres)(const clockid_t, struct timespec64 *);
	int (*clock_set)(const clockid_t, const struct timespec64 *);
	int (*clock_get_timespec)(const clockid_t, struct timespec64 *);
	ktime_t (*clock_get_ktime)(const clockid_t);
	int (*clock_adj)(const clockid_t, struct __kernel_timex *);
	int (*timer_create)(struct k_itimer *);
	int (*nsleep)(const clockid_t, int, const struct timespec64 *);
	int (*timer_set)(struct k_itimer *, int, struct itimerspec64 *, struct itimerspec64 *);
	int (*timer_del)(struct k_itimer *);
	void (*timer_get)(struct k_itimer *, struct itimerspec64 *);
	void (*timer_rearm)(struct k_itimer *);
	s64 (*timer_forward)(struct k_itimer *, ktime_t);
	ktime_t (*timer_remaining)(struct k_itimer *, ktime_t);
	int (*timer_try_to_cancel)(struct k_itimer *);
	void (*timer_arm)(struct k_itimer *, ktime_t, bool, bool);
	void (*timer_wait_running)(struct k_itimer *);
};

struct class_interface {
	struct list_head node;
	struct class *class;
	int (*add_dev)(struct device *, struct class_interface *);
	void (*remove_dev)(struct device *, struct class_interface *);
};

struct rtc_class_ops {
	int (*ioctl)(struct device *, unsigned int, long unsigned int);
	int (*read_time)(struct device *, struct rtc_time *);
	int (*set_time)(struct device *, struct rtc_time *);
	int (*read_alarm)(struct device *, struct rtc_wkalrm *);
	int (*set_alarm)(struct device *, struct rtc_wkalrm *);
	int (*proc)(struct device *, struct seq_file *);
	int (*alarm_irq_enable)(struct device *, unsigned int);
	int (*read_offset)(struct device *, long int *);
	int (*set_offset)(struct device *, long int);
};

struct rtc_device;

struct rtc_timer {
	struct timerqueue_node node;
	ktime_t period;
	void (*func)(struct rtc_device *);
	struct rtc_device *rtc;
	int enabled;
};

struct rtc_device {
	struct device dev;
	struct module *owner;
	int id;
	const struct rtc_class_ops *ops;
	struct mutex ops_lock;
	struct cdev char_dev;
	long unsigned int flags;
	long unsigned int irq_data;
	spinlock_t irq_lock;
	wait_queue_head_t irq_queue;
	struct fasync_struct *async_queue;
	int irq_freq;
	int max_user_freq;
	struct timerqueue_head timerqueue;
	struct rtc_timer aie_timer;
	struct rtc_timer uie_rtctimer;
	struct hrtimer pie_timer;
	int pie_enabled;
	struct work_struct irqwork;
	int uie_unsupported;
	long int set_offset_nsec;
	bool registered;
	bool nvram_old_abi;
	struct bin_attribute *nvram;
	time64_t range_min;
	timeu64_t range_max;
	time64_t start_secs;
	time64_t offset_secs;
	bool set_start_time;
};

struct property_entry;

struct platform_device_info {
	struct device *parent;
	struct fwnode_handle *fwnode;
	bool of_node_reused;
	const char *name;
	int id;
	const struct resource *res;
	unsigned int num_res;
	const void *data;
	size_t size_data;
	u64 dma_mask;
	const struct property_entry *properties;
};

enum dev_prop_type {
	DEV_PROP_U8 = 0,
	DEV_PROP_U16 = 1,
	DEV_PROP_U32 = 2,
	DEV_PROP_U64 = 3,
	DEV_PROP_STRING = 4,
	DEV_PROP_REF = 5,
};

struct property_entry {
	const char *name;
	size_t length;
	bool is_inline;
	enum dev_prop_type type;
	union {
		const void *pointer;
		union {
			u8 u8_data[8];
			u16 u16_data[4];
			u32 u32_data[2];
			u64 u64_data[1];
			const char *str[1];
		} value;
	};
};

struct trace_event_raw_alarmtimer_suspend {
	struct trace_entry ent;
	s64 expires;
	unsigned char alarm_type;
	char __data[0];
};

struct trace_event_raw_alarm_class {
	struct trace_entry ent;
	void *alarm;
	unsigned char alarm_type;
	s64 expires;
	s64 now;
	char __data[0];
};

struct trace_event_data_offsets_alarmtimer_suspend {};

struct trace_event_data_offsets_alarm_class {};

typedef void (*btf_trace_alarmtimer_suspend)(void *, ktime_t, int);

typedef void (*btf_trace_alarmtimer_fired)(void *, struct alarm *, ktime_t);

typedef void (*btf_trace_alarmtimer_start)(void *, struct alarm *, ktime_t);

typedef void (*btf_trace_alarmtimer_cancel)(void *, struct alarm *, ktime_t);

struct alarm_base {
	spinlock_t lock;
	struct timerqueue_head timerqueue;
	ktime_t (*get_ktime)();
	void (*get_timespec)(struct timespec64 *);
	clockid_t base_clockid;
};

struct sigevent {
	sigval_t sigev_value;
	int sigev_signo;
	int sigev_notify;
	union {
		int _pad[12];
		int _tid;
		struct {
			void (*_function)(sigval_t);
			void *_attribute;
		} _sigev_thread;
	} _sigev_un;
};

typedef struct sigevent sigevent_t;

typedef unsigned int uint;

struct posix_clock;

struct posix_clock_operations {
	struct module *owner;
	int (*clock_adjtime)(struct posix_clock *, struct __kernel_timex *);
	int (*clock_gettime)(struct posix_clock *, struct timespec64 *);
	int (*clock_getres)(struct posix_clock *, struct timespec64 *);
	int (*clock_settime)(struct posix_clock *, const struct timespec64 *);
	long int (*ioctl)(struct posix_clock *, unsigned int, long unsigned int);
	int (*open)(struct posix_clock *, fmode_t);
	__poll_t (*poll)(struct posix_clock *, struct file *, poll_table *);
	int (*release)(struct posix_clock *);
	ssize_t (*read)(struct posix_clock *, uint, char *, size_t);
};

struct posix_clock {
	struct posix_clock_operations ops;
	struct cdev cdev;
	struct device *dev;
	struct rw_semaphore rwsem;
	bool zombie;
};

struct posix_clock_desc {
	struct file *fp;
	struct posix_clock *clk;
};

struct __kernel_old_itimerval {
	struct __kernel_old_timeval it_interval;
	struct __kernel_old_timeval it_value;
};

typedef s64 int64_t;

struct ce_unbind {
	struct clock_event_device *ce;
	int res;
};

enum tick_broadcast_state {
	TICK_BROADCAST_EXIT = 0,
	TICK_BROADCAST_ENTER = 1,
};

struct clock_read_data {
	u64 epoch_ns;
	u64 epoch_cyc;
	u64 sched_clock_mask;
	u64 (*read_sched_clock)();
	u32 mult;
	u32 shift;
};

struct clock_data {
	seqcount_latch_t seq;
	struct clock_read_data read_data[2];
	ktime_t wrap_kt;
	long unsigned int rate;
	u64 (*actual_read_sched_clock)();
};

union futex_key {
	struct {
		u64 i_seq;
		long unsigned int pgoff;
		unsigned int offset;
	} shared;
	struct {
		union {
			struct mm_struct *mm;
			u64 __tmp;
		};
		long unsigned int address;
		unsigned int offset;
	} private;
	struct {
		u64 ptr;
		long unsigned int word;
		unsigned int offset;
	} both;
};

struct futex_pi_state {
	struct list_head list;
	struct rt_mutex pi_mutex;
	struct task_struct *owner;
	refcount_t refcount;
	union futex_key key;
};

struct futex_q {
	struct plist_node list;
	struct task_struct *task;
	spinlock_t *lock_ptr;
	union futex_key key;
	struct futex_pi_state *pi_state;
	struct rt_mutex_waiter *rt_waiter;
	union futex_key *requeue_pi_key;
	u32 bitset;
};

struct futex_hash_bucket {
	atomic_t waiters;
	spinlock_t lock;
	struct plist_head chain;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

enum futex_access {
	FUTEX_READ = 0,
	FUTEX_WRITE = 1,
};

typedef bool (*smp_cond_func_t)(int, void *);

struct call_function_data {
	call_single_data_t *csd;
	cpumask_var_t cpumask;
	cpumask_var_t cpumask_ipi;
};

struct smp_call_on_cpu_struct {
	struct work_struct work;
	struct completion done;
	int (*func)(void *);
	void *data;
	int ret;
	int cpu;
};

struct latch_tree_root {
	seqcount_latch_t seq;
	struct rb_root tree[2];
};

struct latch_tree_ops {
	bool (*less)(struct latch_tree_node *, struct latch_tree_node *);
	int (*comp)(void *, struct latch_tree_node *);
};

struct module_use {
	struct list_head source_list;
	struct list_head target_list;
	struct module *source;
	struct module *target;
};

struct module_sect_attr {
	struct bin_attribute battr;
	long unsigned int address;
};

struct module_sect_attrs {
	struct attribute_group grp;
	unsigned int nsections;
	struct module_sect_attr attrs[0];
};

struct module_notes_attrs {
	struct kobject *dir;
	unsigned int notes;
	struct bin_attribute attrs[0];
};

enum mod_license {
	NOT_GPL_ONLY = 0,
	GPL_ONLY = 1,
	WILL_BE_GPL_ONLY = 2,
};

struct symsearch {
	const struct kernel_symbol *start;
	const struct kernel_symbol *stop;
	const s32 *crcs;
	enum mod_license license;
	bool unused;
};

enum kernel_read_file_id {
	READING_UNKNOWN = 0,
	READING_FIRMWARE = 1,
	READING_MODULE = 2,
	READING_KEXEC_IMAGE = 3,
	READING_KEXEC_INITRAMFS = 4,
	READING_POLICY = 5,
	READING_X509_CERTIFICATE = 6,
	READING_MAX_ID = 7,
};

enum kernel_load_data_id {
	LOADING_UNKNOWN = 0,
	LOADING_FIRMWARE = 1,
	LOADING_MODULE = 2,
	LOADING_KEXEC_IMAGE = 3,
	LOADING_KEXEC_INITRAMFS = 4,
	LOADING_POLICY = 5,
	LOADING_X509_CERTIFICATE = 6,
	LOADING_MAX_ID = 7,
};

enum {
	PROC_ENTRY_PERMANENT = 1,
};

struct load_info {
	const char *name;
	struct module *mod;
	Elf64_Ehdr *hdr;
	long unsigned int len;
	Elf64_Shdr *sechdrs;
	char *secstrings;
	char *strtab;
	long unsigned int symoffs;
	long unsigned int stroffs;
	long unsigned int init_typeoffs;
	long unsigned int core_typeoffs;
	struct _ddebug *debug;
	unsigned int num_debug;
	bool sig_ok;
	long unsigned int mod_kallsyms_init_off;
	struct {
		unsigned int sym;
		unsigned int str;
		unsigned int mod;
		unsigned int vers;
		unsigned int info;
		unsigned int pcpu;
	} index;
};

struct trace_event_raw_module_load {
	struct trace_entry ent;
	unsigned int taints;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_module_free {
	struct trace_entry ent;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_module_refcnt {
	struct trace_entry ent;
	long unsigned int ip;
	int refcnt;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_module_request {
	struct trace_entry ent;
	long unsigned int ip;
	bool wait;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_data_offsets_module_load {
	u32 name;
};

struct trace_event_data_offsets_module_free {
	u32 name;
};

struct trace_event_data_offsets_module_refcnt {
	u32 name;
};

struct trace_event_data_offsets_module_request {
	u32 name;
};

typedef void (*btf_trace_module_load)(void *, struct module *);

typedef void (*btf_trace_module_free)(void *, struct module *);

typedef void (*btf_trace_module_get)(void *, struct module *, long unsigned int);

typedef void (*btf_trace_module_put)(void *, struct module *, long unsigned int);

typedef void (*btf_trace_module_request)(void *, char *, bool, long unsigned int);

struct mod_tree_root {
	struct latch_tree_root root;
	long unsigned int addr_min;
	long unsigned int addr_max;
};

struct find_symbol_arg {
	const char *name;
	bool gplok;
	bool warn;
	struct module *owner;
	const s32 *crc;
	const struct kernel_symbol *sym;
	enum mod_license license;
};

struct mod_initfree {
	struct llist_node node;
	void *module_init;
};

struct kallsym_iter {
	loff_t pos;
	loff_t pos_arch_end;
	loff_t pos_mod_end;
	loff_t pos_ftrace_mod_end;
	loff_t pos_bpf_end;
	long unsigned int value;
	unsigned int nameoff;
	char type;
	char name[128];
	char module_name[56];
	int exported;
	int show_value;
};

struct elf64_note {
	Elf64_Word n_namesz;
	Elf64_Word n_descsz;
	Elf64_Word n_type;
};

struct elf_note_section {
	struct elf64_note n_hdr;
	u8 n_data[0];
};

typedef struct user_regs_struct elf_gregset_t;

struct elf_siginfo {
	int si_signo;
	int si_code;
	int si_errno;
};

struct elf_prstatus {
	struct elf_siginfo pr_info;
	short int pr_cursig;
	long unsigned int pr_sigpend;
	long unsigned int pr_sighold;
	pid_t pr_pid;
	pid_t pr_ppid;
	pid_t pr_pgrp;
	pid_t pr_sid;
	struct __kernel_old_timeval pr_utime;
	struct __kernel_old_timeval pr_stime;
	struct __kernel_old_timeval pr_cutime;
	struct __kernel_old_timeval pr_cstime;
	elf_gregset_t pr_reg;
	int pr_fpvalid;
};

typedef u32 note_buf_t[102];

typedef __kernel_ulong_t __kernel_ino_t;

typedef __kernel_ino_t ino_t;

enum kernfs_node_type {
	KERNFS_DIR = 1,
	KERNFS_FILE = 2,
	KERNFS_LINK = 4,
};

enum kernfs_root_flag {
	KERNFS_ROOT_CREATE_DEACTIVATED = 1,
	KERNFS_ROOT_EXTRA_OPEN_PERM_CHECK = 2,
	KERNFS_ROOT_SUPPORT_EXPORTOP = 4,
	KERNFS_ROOT_SUPPORT_USER_XATTR = 8,
};

struct kernfs_fs_context {
	struct kernfs_root *root;
	void *ns_tag;
	long unsigned int magic;
	bool new_sb_created;
};

struct static_key_true {
	struct static_key key;
};

enum {
	__PERCPU_REF_ATOMIC = 1,
	__PERCPU_REF_DEAD = 2,
	__PERCPU_REF_ATOMIC_DEAD = 3,
	__PERCPU_REF_FLAG_BITS = 2,
};

enum {
	CSS_NO_REF = 1,
	CSS_ONLINE = 2,
	CSS_RELEASED = 4,
	CSS_VISIBLE = 8,
	CSS_DYING = 16,
};

enum {
	CGRP_NOTIFY_ON_RELEASE = 0,
	CGRP_CPUSET_CLONE_CHILDREN = 1,
	CGRP_FREEZE = 2,
	CGRP_FROZEN = 3,
};

enum {
	CGRP_ROOT_NOPREFIX = 2,
	CGRP_ROOT_XATTR = 4,
	CGRP_ROOT_NS_DELEGATE = 8,
	CGRP_ROOT_CPUSET_V2_MODE = 16,
	CGRP_ROOT_MEMORY_LOCAL_EVENTS = 32,
	CGRP_ROOT_MEMORY_RECURSIVE_PROT = 64,
};

enum {
	CFTYPE_ONLY_ON_ROOT = 1,
	CFTYPE_NOT_ON_ROOT = 2,
	CFTYPE_NS_DELEGATABLE = 4,
	CFTYPE_NO_PREFIX = 8,
	CFTYPE_WORLD_WRITABLE = 16,
	CFTYPE_DEBUG = 32,
	CFTYPE_PRESSURE = 64,
	__CFTYPE_ONLY_ON_DFL = 65536,
	__CFTYPE_NOT_ON_DFL = 131072,
};

struct cgroup_taskset {
	struct list_head src_csets;
	struct list_head dst_csets;
	int nr_tasks;
	int ssid;
	struct list_head *csets;
	struct css_set *cur_cset;
	struct task_struct *cur_task;
};

struct css_task_iter {
	struct cgroup_subsys *ss;
	unsigned int flags;
	struct list_head *cset_pos;
	struct list_head *cset_head;
	struct list_head *tcset_pos;
	struct list_head *tcset_head;
	struct list_head *task_pos;
	struct list_head *cur_tasks_head;
	struct css_set *cur_cset;
	struct css_set *cur_dcset;
	struct task_struct *cur_task;
	struct list_head iters_node;
};

struct cgroup_fs_context {
	struct kernfs_fs_context kfc;
	struct cgroup_root *root;
	struct cgroup_namespace *ns;
	unsigned int flags;
	bool cpuset_clone_children;
	bool none;
	bool all_ss;
	u16 subsys_mask;
	char *name;
	char *release_agent;
};

struct cgroup_pidlist;

struct cgroup_file_ctx {
	struct cgroup_namespace *ns;
	struct {
		void *trigger;
	} psi;
	struct {
		bool started;
		struct css_task_iter iter;
	} procs;
	struct {
		struct cgroup_pidlist *pidlist;
	} procs1;
};

struct cgrp_cset_link {
	struct cgroup *cgrp;
	struct css_set *cset;
	struct list_head cset_link;
	struct list_head cgrp_link;
};

struct cgroup_mgctx {
	struct list_head preloaded_src_csets;
	struct list_head preloaded_dst_csets;
	struct cgroup_taskset tset;
	u16 ss_mask;
};

struct trace_event_raw_cgroup_root {
	struct trace_entry ent;
	int root;
	u16 ss_mask;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_cgroup {
	struct trace_entry ent;
	int root;
	int level;
	u64 id;
	u32 __data_loc_path;
	char __data[0];
};

struct trace_event_raw_cgroup_migrate {
	struct trace_entry ent;
	int dst_root;
	int dst_level;
	u64 dst_id;
	int pid;
	u32 __data_loc_dst_path;
	u32 __data_loc_comm;
	char __data[0];
};

struct trace_event_raw_cgroup_event {
	struct trace_entry ent;
	int root;
	int level;
	u64 id;
	u32 __data_loc_path;
	int val;
	char __data[0];
};

struct trace_event_data_offsets_cgroup_root {
	u32 name;
};

struct trace_event_data_offsets_cgroup {
	u32 path;
};

struct trace_event_data_offsets_cgroup_migrate {
	u32 dst_path;
	u32 comm;
};

struct trace_event_data_offsets_cgroup_event {
	u32 path;
};

typedef void (*btf_trace_cgroup_setup_root)(void *, struct cgroup_root *);

typedef void (*btf_trace_cgroup_destroy_root)(void *, struct cgroup_root *);

typedef void (*btf_trace_cgroup_remount)(void *, struct cgroup_root *);

typedef void (*btf_trace_cgroup_mkdir)(void *, struct cgroup *, const char *);

typedef void (*btf_trace_cgroup_rmdir)(void *, struct cgroup *, const char *);

typedef void (*btf_trace_cgroup_release)(void *, struct cgroup *, const char *);

typedef void (*btf_trace_cgroup_rename)(void *, struct cgroup *, const char *);

typedef void (*btf_trace_cgroup_freeze)(void *, struct cgroup *, const char *);

typedef void (*btf_trace_cgroup_unfreeze)(void *, struct cgroup *, const char *);

typedef void (*btf_trace_cgroup_attach_task)(void *, struct cgroup *, const char *, struct task_struct *, bool);

typedef void (*btf_trace_cgroup_transfer_tasks)(void *, struct cgroup *, const char *, struct task_struct *, bool);

typedef void (*btf_trace_cgroup_notify_populated)(void *, struct cgroup *, const char *, int);

typedef void (*btf_trace_cgroup_notify_frozen)(void *, struct cgroup *, const char *, int);

enum cgroup_opt_features {
	OPT_FEATURE_COUNT = 0,
};

enum cgroup2_param {
	Opt_nsdelegate = 0,
	Opt_memory_localevents = 1,
	Opt_memory_recursiveprot = 2,
	nr__cgroup2_params = 3,
};

struct cgroupstats {
	__u64 nr_sleeping;
	__u64 nr_running;
	__u64 nr_stopped;
	__u64 nr_uninterruptible;
	__u64 nr_io_wait;
};

enum cgroup_filetype {
	CGROUP_FILE_PROCS = 0,
	CGROUP_FILE_TASKS = 1,
};

struct cgroup_pidlist {
	struct {
		enum cgroup_filetype type;
		struct pid_namespace *ns;
	} key;
	pid_t *list;
	int length;
	struct list_head links;
	struct cgroup *owner;
	struct delayed_work destroy_dwork;
};

enum cgroup1_param {
	Opt_all = 0,
	Opt_clone_children = 1,
	Opt_cpuset_v2_mode = 2,
	Opt_name = 3,
	Opt_none = 4,
	Opt_noprefix = 5,
	Opt_release_agent = 6,
	Opt_xattr = 7,
};

struct kernel_pkey_query {
	__u32 supported_ops;
	__u32 key_size;
	__u16 max_data_size;
	__u16 max_sig_size;
	__u16 max_enc_size;
	__u16 max_dec_size;
};

enum kernel_pkey_operation {
	kernel_pkey_encrypt = 0,
	kernel_pkey_decrypt = 1,
	kernel_pkey_sign = 2,
	kernel_pkey_verify = 3,
};

struct kernel_pkey_params {
	struct key *key;
	const char *encoding;
	const char *hash_algo;
	char *info;
	__u32 in_len;
	union {
		__u32 out_len;
		__u32 in2_len;
	};
	enum kernel_pkey_operation op: 8;
};

struct key_preparsed_payload {
	char *description;
	union key_payload payload;
	const void *data;
	size_t datalen;
	size_t quotalen;
	time64_t expiry;
};

struct key_match_data {
	bool (*cmp)(const struct key *, const struct key_match_data *);
	const void *raw_data;
	void *preparsed;
	unsigned int lookup_type;
};

struct idmap_key {
	bool map_up;
	u32 id;
	u32 count;
};

struct ctl_path {
	const char *procname;
};

struct cpu_stopper {
	struct task_struct *thread;
	raw_spinlock_t lock;
	bool enabled;
	struct list_head works;
	struct cpu_stop_work stop_work;
};

enum multi_stop_state {
	MULTI_STOP_NONE = 0,
	MULTI_STOP_PREPARE = 1,
	MULTI_STOP_DISABLE_IRQ = 2,
	MULTI_STOP_RUN = 3,
	MULTI_STOP_EXIT = 4,
};

struct multi_stop_data {
	cpu_stop_fn_t fn;
	void *data;
	unsigned int num_threads;
	const struct cpumask *active_cpus;
	enum multi_stop_state state;
	atomic_t thread_ack;
};

enum {
	FTRACE_OPS_FL_ENABLED = 1,
	FTRACE_OPS_FL_DYNAMIC = 2,
	FTRACE_OPS_FL_SAVE_REGS = 4,
	FTRACE_OPS_FL_SAVE_REGS_IF_SUPPORTED = 8,
	FTRACE_OPS_FL_RECURSION_SAFE = 16,
	FTRACE_OPS_FL_STUB = 32,
	FTRACE_OPS_FL_INITIALIZED = 64,
	FTRACE_OPS_FL_DELETED = 128,
	FTRACE_OPS_FL_ADDING = 256,
	FTRACE_OPS_FL_REMOVING = 512,
	FTRACE_OPS_FL_MODIFYING = 1024,
	FTRACE_OPS_FL_ALLOC_TRAMP = 2048,
	FTRACE_OPS_FL_IPMODIFY = 4096,
	FTRACE_OPS_FL_PID = 8192,
	FTRACE_OPS_FL_RCU = 16384,
	FTRACE_OPS_FL_TRACE_ARRAY = 32768,
	FTRACE_OPS_FL_PERMANENT = 65536,
	FTRACE_OPS_FL_DIRECT = 131072,
};

struct kprobe_blacklist_entry {
	struct list_head list;
	long unsigned int start_addr;
	long unsigned int end_addr;
};

enum perf_record_ksymbol_type {
	PERF_RECORD_KSYMBOL_TYPE_UNKNOWN = 0,
	PERF_RECORD_KSYMBOL_TYPE_BPF = 1,
	PERF_RECORD_KSYMBOL_TYPE_OOL = 2,
	PERF_RECORD_KSYMBOL_TYPE_MAX = 3,
};

struct kprobe_insn_page {
	struct list_head list;
	kprobe_opcode_t *insns;
	struct kprobe_insn_cache *cache;
	int nused;
	int ngarbage;
	char slot_used[0];
};

enum kprobe_slot_state {
	SLOT_CLEAN = 0,
	SLOT_DIRTY = 1,
	SLOT_USED = 2,
};

struct seccomp_data {
	int nr;
	__u32 arch;
	__u64 instruction_pointer;
	__u64 args[6];
};

struct seccomp_notif_sizes {
	__u16 seccomp_notif;
	__u16 seccomp_notif_resp;
	__u16 seccomp_data;
};

struct seccomp_notif {
	__u64 id;
	__u32 pid;
	__u32 flags;
	struct seccomp_data data;
};

struct seccomp_notif_resp {
	__u64 id;
	__s64 val;
	__s32 error;
	__u32 flags;
};

struct seccomp_notif_addfd {
	__u64 id;
	__u32 flags;
	__u32 srcfd;
	__u32 newfd;
	__u32 newfd_flags;
};

struct action_cache {
	long unsigned int allow_native[8];
};

struct notification;

struct seccomp_filter {
	refcount_t refs;
	refcount_t users;
	bool log;
	struct action_cache cache;
	struct seccomp_filter *prev;
	struct bpf_prog *prog;
	struct notification *notif;
	struct mutex notify_lock;
	wait_queue_head_t wqh;
};

struct seccomp_metadata {
	__u64 filter_off;
	__u64 flags;
};

struct sock_fprog {
	short unsigned int len;
	struct sock_filter *filter;
};

enum notify_state {
	SECCOMP_NOTIFY_INIT = 0,
	SECCOMP_NOTIFY_SENT = 1,
	SECCOMP_NOTIFY_REPLIED = 2,
};

struct seccomp_knotif {
	struct task_struct *task;
	u64 id;
	const struct seccomp_data *data;
	enum notify_state state;
	int error;
	long int val;
	u32 flags;
	struct completion ready;
	struct list_head list;
	struct list_head addfd;
};

struct seccomp_kaddfd {
	struct file *file;
	int fd;
	unsigned int flags;
	int ret;
	struct completion completion;
	struct list_head list;
};

struct notification {
	struct semaphore request;
	u64 next_id;
	struct list_head notifications;
};

struct seccomp_log_name {
	u32 log;
	const char *name;
};

struct tp_module {
	struct list_head list;
	struct module *mod;
};

enum tp_func_state {
	TP_FUNC_0 = 0,
	TP_FUNC_1 = 1,
	TP_FUNC_2 = 2,
	TP_FUNC_N = 3,
};

enum tp_transition_sync {
	TP_TRANSITION_SYNC_1_0_1 = 0,
	TP_TRANSITION_SYNC_N_2_1 = 1,
	_NR_TP_TRANSITION_SYNC = 2,
};

struct tp_transition_snapshot {
	long unsigned int rcu;
	long unsigned int srcu;
	bool ongoing;
};

struct tp_probes {
	struct callback_head rcu;
	struct tracepoint_func probes[0];
};

struct ftrace_hash {
	long unsigned int size_bits;
	struct hlist_head *buckets;
	long unsigned int count;
	long unsigned int flags;
	struct callback_head rcu;
};

struct ftrace_func_entry {
	struct hlist_node hlist;
	long unsigned int ip;
	long unsigned int direct;
};

enum ftrace_bug_type {
	FTRACE_BUG_UNKNOWN = 0,
	FTRACE_BUG_INIT = 1,
	FTRACE_BUG_NOP = 2,
	FTRACE_BUG_CALL = 3,
	FTRACE_BUG_UPDATE = 4,
};

enum {
	FTRACE_FL_ENABLED = 2147483648,
	FTRACE_FL_REGS = 1073741824,
	FTRACE_FL_REGS_EN = 536870912,
	FTRACE_FL_TRAMP = 268435456,
	FTRACE_FL_TRAMP_EN = 134217728,
	FTRACE_FL_IPMODIFY = 67108864,
	FTRACE_FL_DISABLED = 33554432,
	FTRACE_FL_DIRECT = 16777216,
	FTRACE_FL_DIRECT_EN = 8388608,
};

enum {
	FTRACE_UPDATE_CALLS = 1,
	FTRACE_DISABLE_CALLS = 2,
	FTRACE_UPDATE_TRACE_FUNC = 4,
	FTRACE_START_FUNC_RET = 8,
	FTRACE_STOP_FUNC_RET = 16,
	FTRACE_MAY_SLEEP = 32,
};

enum {
	FTRACE_UPDATE_IGNORE = 0,
	FTRACE_UPDATE_MAKE_CALL = 1,
	FTRACE_UPDATE_MODIFY_CALL = 2,
	FTRACE_UPDATE_MAKE_NOP = 3,
};

enum {
	FTRACE_ITER_FILTER = 1,
	FTRACE_ITER_NOTRACE = 2,
	FTRACE_ITER_PRINTALL = 4,
	FTRACE_ITER_DO_PROBES = 8,
	FTRACE_ITER_PROBE = 16,
	FTRACE_ITER_MOD = 32,
	FTRACE_ITER_ENABLED = 64,
};

struct prog_entry;

struct event_filter {
	struct prog_entry *prog;
	char *filter_string;
};

struct trace_array_cpu;

struct array_buffer {
	struct trace_array *tr;
	struct trace_buffer *buffer;
	struct trace_array_cpu *data;
	u64 time_start;
	int cpu;
};

struct trace_pid_list;

struct trace_options;

struct cond_snapshot;

struct trace_array {
	struct list_head list;
	char *name;
	struct array_buffer array_buffer;
	struct array_buffer max_buffer;
	bool allocated_snapshot;
	long unsigned int max_latency;
	struct dentry *d_max_latency;
	struct work_struct fsnotify_work;
	struct irq_work fsnotify_irqwork;
	struct trace_pid_list *filtered_pids;
	struct trace_pid_list *filtered_no_pids;
	arch_spinlock_t max_lock;
	int buffer_disabled;
	int sys_refcount_enter;
	int sys_refcount_exit;
	struct trace_event_file *enter_syscall_files[449];
	struct trace_event_file *exit_syscall_files[449];
	int stop_count;
	int clock_id;
	int nr_topts;
	bool clear_trace;
	int buffer_percent;
	unsigned int n_err_log_entries;
	struct tracer *current_trace;
	unsigned int trace_flags;
	unsigned char trace_flags_index[32];
	unsigned int flags;
	raw_spinlock_t start_lock;
	struct list_head err_log;
	struct dentry *dir;
	struct dentry *options;
	struct dentry *percpu_dir;
	struct dentry *event_dir;
	struct trace_options *topts;
	struct list_head systems;
	struct list_head events;
	struct trace_event_file *trace_marker_file;
	cpumask_var_t tracing_cpumask;
	int ref;
	int trace_ref;
	struct ftrace_ops *ops;
	struct trace_pid_list *function_pids;
	struct trace_pid_list *function_no_pids;
	struct list_head func_probes;
	struct list_head mod_trace;
	struct list_head mod_notrace;
	int function_enabled;
	int time_stamp_abs_ref;
	struct list_head hist_vars;
	struct cond_snapshot *cond_snapshot;
};

struct tracer_flags;

struct tracer {
	const char *name;
	int (*init)(struct trace_array *);
	void (*reset)(struct trace_array *);
	void (*start)(struct trace_array *);
	void (*stop)(struct trace_array *);
	int (*update_thresh)(struct trace_array *);
	void (*open)(struct trace_iterator *);
	void (*pipe_open)(struct trace_iterator *);
	void (*close)(struct trace_iterator *);
	void (*pipe_close)(struct trace_iterator *);
	ssize_t (*read)(struct trace_iterator *, struct file *, char *, size_t, loff_t *);
	ssize_t (*splice_read)(struct trace_iterator *, struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int);
	void (*print_header)(struct seq_file *);
	enum print_line_t (*print_line)(struct trace_iterator *);
	int (*set_flag)(struct trace_array *, u32, u32, int);
	int (*flag_changed)(struct trace_array *, u32, int);
	struct tracer *next;
	struct tracer_flags *flags;
	int enabled;
	bool print_max;
	bool allow_instances;
	bool use_max_tr;
	bool noboot;
};

struct event_subsystem;

struct trace_subsystem_dir {
	struct list_head list;
	struct event_subsystem *subsystem;
	struct trace_array *tr;
	struct dentry *entry;
	int ref_count;
	int nr_events;
};

struct trace_array_cpu {
	atomic_t disabled;
	void *buffer_page;
	long unsigned int entries;
	long unsigned int saved_latency;
	long unsigned int critical_start;
	long unsigned int critical_end;
	long unsigned int critical_sequence;
	long unsigned int nice;
	long unsigned int policy;
	long unsigned int rt_priority;
	long unsigned int skipped_entries;
	u64 preempt_timestamp;
	pid_t pid;
	kuid_t uid;
	char comm[16];
	int ftrace_ignore_pid;
	bool ignore_pid;
};

struct trace_option_dentry;

struct trace_options {
	struct tracer *tracer;
	struct trace_option_dentry *topts;
};

struct tracer_opt;

struct trace_option_dentry {
	struct tracer_opt *opt;
	struct tracer_flags *flags;
	struct trace_array *tr;
	struct dentry *entry;
};

struct trace_pid_list {
	int pid_max;
	long unsigned int *pids;
};

enum {
	TRACE_PIDS = 1,
	TRACE_NO_PIDS = 2,
};

typedef bool (*cond_update_fn_t)(struct trace_array *, void *);

struct cond_snapshot {
	void *cond_data;
	cond_update_fn_t update;
};

enum {
	TRACE_ARRAY_FL_GLOBAL = 1,
};

struct tracer_opt {
	const char *name;
	u32 bit;
};

struct tracer_flags {
	u32 val;
	struct tracer_opt *opts;
	struct tracer *trace;
};

enum {
	TRACE_FTRACE_BIT = 0,
	TRACE_FTRACE_NMI_BIT = 1,
	TRACE_FTRACE_IRQ_BIT = 2,
	TRACE_FTRACE_SIRQ_BIT = 3,
	TRACE_FTRACE_TRANSITION_BIT = 4,
	TRACE_INTERNAL_BIT = 5,
	TRACE_INTERNAL_NMI_BIT = 6,
	TRACE_INTERNAL_IRQ_BIT = 7,
	TRACE_INTERNAL_SIRQ_BIT = 8,
	TRACE_INTERNAL_TRANSITION_BIT = 9,
	TRACE_BRANCH_BIT = 10,
	TRACE_IRQ_BIT = 11,
	TRACE_GRAPH_BIT = 12,
	TRACE_GRAPH_DEPTH_START_BIT = 13,
	TRACE_GRAPH_DEPTH_END_BIT = 14,
	TRACE_GRAPH_NOTRACE_BIT = 15,
};

enum {
	TRACE_CTX_NMI = 0,
	TRACE_CTX_IRQ = 1,
	TRACE_CTX_SOFTIRQ = 2,
	TRACE_CTX_NORMAL = 3,
	TRACE_CTX_TRANSITION = 4,
};

struct ftrace_mod_load {
	struct list_head list;
	char *func;
	char *module;
	int enable;
};

enum {
	FTRACE_HASH_FL_MOD = 1,
};

struct ftrace_func_command {
	struct list_head list;
	char *name;
	int (*func)(struct trace_array *, struct ftrace_hash *, char *, char *, char *, int);
};

struct ftrace_probe_ops {
	void (*func)(long unsigned int, long unsigned int, struct trace_array *, struct ftrace_probe_ops *, void *);
	int (*init)(struct ftrace_probe_ops *, struct trace_array *, long unsigned int, void *, void **);
	void (*free)(struct ftrace_probe_ops *, struct trace_array *, long unsigned int, void *);
	int (*print)(struct seq_file *, long unsigned int, struct ftrace_probe_ops *, void *);
};

typedef int (*ftrace_mapper_func)(void *);

struct trace_parser {
	bool cont;
	char *buffer;
	unsigned int idx;
	unsigned int size;
};

enum trace_iterator_bits {
	TRACE_ITER_PRINT_PARENT_BIT = 0,
	TRACE_ITER_SYM_OFFSET_BIT = 1,
	TRACE_ITER_SYM_ADDR_BIT = 2,
	TRACE_ITER_VERBOSE_BIT = 3,
	TRACE_ITER_RAW_BIT = 4,
	TRACE_ITER_HEX_BIT = 5,
	TRACE_ITER_BIN_BIT = 6,
	TRACE_ITER_BLOCK_BIT = 7,
	TRACE_ITER_PRINTK_BIT = 8,
	TRACE_ITER_ANNOTATE_BIT = 9,
	TRACE_ITER_USERSTACKTRACE_BIT = 10,
	TRACE_ITER_SYM_USEROBJ_BIT = 11,
	TRACE_ITER_PRINTK_MSGONLY_BIT = 12,
	TRACE_ITER_CONTEXT_INFO_BIT = 13,
	TRACE_ITER_LATENCY_FMT_BIT = 14,
	TRACE_ITER_RECORD_CMD_BIT = 15,
	TRACE_ITER_RECORD_TGID_BIT = 16,
	TRACE_ITER_OVERWRITE_BIT = 17,
	TRACE_ITER_STOP_ON_FREE_BIT = 18,
	TRACE_ITER_IRQ_INFO_BIT = 19,
	TRACE_ITER_MARKERS_BIT = 20,
	TRACE_ITER_EVENT_FORK_BIT = 21,
	TRACE_ITER_PAUSE_ON_TRACE_BIT = 22,
	TRACE_ITER_FUNCTION_BIT = 23,
	TRACE_ITER_FUNC_FORK_BIT = 24,
	TRACE_ITER_DISPLAY_GRAPH_BIT = 25,
	TRACE_ITER_STACKTRACE_BIT = 26,
	TRACE_ITER_LAST_BIT = 27,
};

struct event_subsystem {
	struct list_head list;
	const char *name;
	struct event_filter *filter;
	int ref_count;
};

enum regex_type {
	MATCH_FULL = 0,
	MATCH_FRONT_ONLY = 1,
	MATCH_MIDDLE_ONLY = 2,
	MATCH_END_ONLY = 3,
	MATCH_GLOB = 4,
	MATCH_INDEX = 5,
};

enum {
	FTRACE_MODIFY_ENABLE_FL = 1,
	FTRACE_MODIFY_MAY_SLEEP_FL = 2,
};

struct ftrace_func_probe {
	struct ftrace_probe_ops *probe_ops;
	struct ftrace_ops ops;
	struct trace_array *tr;
	struct list_head list;
	void *data;
	int ref;
};

struct ftrace_page {
	struct ftrace_page *next;
	struct dyn_ftrace *records;
	int index;
	int size;
};

struct ftrace_rec_iter {
	struct ftrace_page *pg;
	int index;
};

struct ftrace_iterator {
	loff_t pos;
	loff_t func_pos;
	loff_t mod_pos;
	struct ftrace_page *pg;
	struct dyn_ftrace *func;
	struct ftrace_func_probe *probe;
	struct ftrace_func_entry *probe_entry;
	struct trace_parser parser;
	struct ftrace_hash *hash;
	struct ftrace_ops *ops;
	struct trace_array *tr;
	struct list_head *mod_list;
	int pidx;
	int idx;
	unsigned int flags;
};

struct ftrace_glob {
	char *search;
	unsigned int len;
	int type;
};

struct ftrace_func_map {
	struct ftrace_func_entry entry;
	void *data;
};

struct ftrace_func_mapper {
	struct ftrace_hash hash;
};

enum graph_filter_type {
	GRAPH_FILTER_NOTRACE = 0,
	GRAPH_FILTER_FUNCTION = 1,
};

struct ftrace_graph_data {
	struct ftrace_hash *hash;
	struct ftrace_func_entry *entry;
	int idx;
	enum graph_filter_type type;
	struct ftrace_hash *new_hash;
	const struct seq_operations *seq_ops;
	struct trace_parser parser;
};

struct ftrace_mod_func {
	struct list_head list;
	char *name;
	long unsigned int ip;
	unsigned int size;
};

struct ftrace_mod_map {
	struct callback_head rcu;
	struct list_head list;
	struct module *mod;
	long unsigned int start_addr;
	long unsigned int end_addr;
	struct list_head funcs;
	unsigned int num_funcs;
};

struct ftrace_init_func {
	struct list_head list;
	long unsigned int ip;
};

enum ring_buffer_type {
	RINGBUF_TYPE_DATA_TYPE_LEN_MAX = 28,
	RINGBUF_TYPE_PADDING = 29,
	RINGBUF_TYPE_TIME_EXTEND = 30,
	RINGBUF_TYPE_TIME_STAMP = 31,
};

enum ring_buffer_flags {
	RB_FL_OVERWRITE = 1,
};

struct ring_buffer_per_cpu;

struct buffer_page;

struct ring_buffer_iter {
	struct ring_buffer_per_cpu *cpu_buffer;
	long unsigned int head;
	long unsigned int next_event;
	struct buffer_page *head_page;
	struct buffer_page *cache_reader_page;
	long unsigned int cache_read;
	u64 read_stamp;
	u64 page_stamp;
	struct ring_buffer_event *event;
	int missed_events;
};

struct rb_irq_work {
	struct irq_work work;
	wait_queue_head_t waiters;
	wait_queue_head_t full_waiters;
	bool waiters_pending;
	bool full_waiters_pending;
	bool wakeup_full;
};

struct trace_buffer {
	unsigned int flags;
	int cpus;
	atomic_t record_disabled;
	cpumask_var_t cpumask;
	struct lock_class_key *reader_lock_key;
	struct mutex mutex;
	struct ring_buffer_per_cpu **buffers;
	struct hlist_node node;
	u64 (*clock)();
	struct rb_irq_work irq_work;
	bool time_stamp_abs;
};

enum {
	RB_LEN_TIME_EXTEND = 8,
	RB_LEN_TIME_STAMP = 8,
};

struct buffer_data_page {
	u64 time_stamp;
	local_t commit;
	unsigned char data[0];
};

struct buffer_page {
	struct list_head list;
	local_t write;
	unsigned int read;
	local_t entries;
	long unsigned int real_end;
	struct buffer_data_page *page;
};

struct rb_event_info {
	u64 ts;
	u64 delta;
	u64 before;
	u64 after;
	long unsigned int length;
	struct buffer_page *tail_page;
	int add_timestamp;
};

enum {
	RB_ADD_STAMP_NONE = 0,
	RB_ADD_STAMP_EXTEND = 2,
	RB_ADD_STAMP_ABSOLUTE = 4,
	RB_ADD_STAMP_FORCE = 8,
};

enum {
	RB_CTX_TRANSITION = 0,
	RB_CTX_NMI = 1,
	RB_CTX_IRQ = 2,
	RB_CTX_SOFTIRQ = 3,
	RB_CTX_NORMAL = 4,
	RB_CTX_MAX = 5,
};

struct rb_time_struct {
	local64_t time;
};

typedef struct rb_time_struct rb_time_t;

struct ring_buffer_per_cpu {
	int cpu;
	atomic_t record_disabled;
	atomic_t resize_disabled;
	struct trace_buffer *buffer;
	raw_spinlock_t reader_lock;
	arch_spinlock_t lock;
	struct lock_class_key lock_key;
	struct buffer_data_page *free_page;
	long unsigned int nr_pages;
	unsigned int current_context;
	struct list_head *pages;
	struct buffer_page *head_page;
	struct buffer_page *tail_page;
	struct buffer_page *commit_page;
	struct buffer_page *reader_page;
	long unsigned int lost_events;
	long unsigned int last_overrun;
	long unsigned int nest;
	local_t entries_bytes;
	local_t entries;
	local_t overrun;
	local_t commit_overrun;
	local_t dropped_events;
	local_t committing;
	local_t commits;
	local_t pages_touched;
	local_t pages_read;
	long int last_pages_touch;
	size_t shortest_full;
	long unsigned int read;
	long unsigned int read_bytes;
	rb_time_t write_stamp;
	rb_time_t before_stamp;
	u64 read_stamp;
	long int nr_pages_to_update;
	struct list_head new_pages;
	struct work_struct update_pages_work;
	struct completion update_done;
	struct rb_irq_work irq_work;
};

typedef struct {
	int val[2];
} __kernel_fsid_t;

typedef struct fsnotify_mark_connector *fsnotify_connp_t;

struct fsnotify_mark_connector {
	spinlock_t lock;
	short unsigned int type;
	short unsigned int flags;
	__kernel_fsid_t fsid;
	union {
		fsnotify_connp_t *obj;
		struct fsnotify_mark_connector *destroy_next;
	};
	struct hlist_head list;
};

struct partial_page {
	unsigned int offset;
	unsigned int len;
	long unsigned int private;
};

struct splice_pipe_desc {
	struct page **pages;
	struct partial_page *partial;
	int nr_pages;
	unsigned int nr_pages_max;
	const struct pipe_buf_operations *ops;
	void (*spd_release)(struct splice_pipe_desc *, unsigned int);
};

struct trace_export {
	struct trace_export *next;
	void (*write)(struct trace_export *, const void *, unsigned int);
	int flags;
};

enum fsnotify_data_type {
	FSNOTIFY_EVENT_NONE = 0,
	FSNOTIFY_EVENT_PATH = 1,
	FSNOTIFY_EVENT_INODE = 2,
};

enum fsnotify_obj_type {
	FSNOTIFY_OBJ_TYPE_INODE = 0,
	FSNOTIFY_OBJ_TYPE_PARENT = 1,
	FSNOTIFY_OBJ_TYPE_VFSMOUNT = 2,
	FSNOTIFY_OBJ_TYPE_SB = 3,
	FSNOTIFY_OBJ_TYPE_COUNT = 4,
	FSNOTIFY_OBJ_TYPE_DETACHED = 4,
};

enum trace_iter_flags {
	TRACE_FILE_LAT_FMT = 1,
	TRACE_FILE_ANNOTATE = 2,
	TRACE_FILE_TIME_IN_NS = 4,
};

enum event_trigger_type {
	ETT_NONE = 0,
	ETT_TRACE_ONOFF = 1,
	ETT_SNAPSHOT = 2,
	ETT_STACKTRACE = 4,
	ETT_EVENT_ENABLE = 8,
	ETT_EVENT_HIST = 16,
	ETT_HIST_ENABLE = 32,
};

enum trace_type {
	__TRACE_FIRST_TYPE = 0,
	TRACE_FN = 1,
	TRACE_CTX = 2,
	TRACE_WAKE = 3,
	TRACE_STACK = 4,
	TRACE_PRINT = 5,
	TRACE_BPRINT = 6,
	TRACE_MMIO_RW = 7,
	TRACE_MMIO_MAP = 8,
	TRACE_BRANCH = 9,
	TRACE_GRAPH_RET = 10,
	TRACE_GRAPH_ENT = 11,
	TRACE_USER_STACK = 12,
	TRACE_BLK = 13,
	TRACE_BPUTS = 14,
	TRACE_HWLAT = 15,
	TRACE_RAW_DATA = 16,
	__TRACE_LAST_TYPE = 17,
};

struct ftrace_entry {
	struct trace_entry ent;
	long unsigned int ip;
	long unsigned int parent_ip;
};

struct stack_entry {
	struct trace_entry ent;
	int size;
	long unsigned int caller[8];
};

struct bprint_entry {
	struct trace_entry ent;
	long unsigned int ip;
	const char *fmt;
	u32 buf[0];
};

struct print_entry {
	struct trace_entry ent;
	long unsigned int ip;
	char buf[0];
};

struct raw_data_entry {
	struct trace_entry ent;
	unsigned int id;
	char buf[0];
};

struct bputs_entry {
	struct trace_entry ent;
	long unsigned int ip;
	const char *str;
};

enum trace_flag_type {
	TRACE_FLAG_IRQS_OFF = 1,
	TRACE_FLAG_IRQS_NOSUPPORT = 2,
	TRACE_FLAG_NEED_RESCHED = 4,
	TRACE_FLAG_HARDIRQ = 8,
	TRACE_FLAG_SOFTIRQ = 16,
	TRACE_FLAG_PREEMPT_RESCHED = 32,
	TRACE_FLAG_NMI = 64,
};

enum trace_iterator_flags {
	TRACE_ITER_PRINT_PARENT = 1,
	TRACE_ITER_SYM_OFFSET = 2,
	TRACE_ITER_SYM_ADDR = 4,
	TRACE_ITER_VERBOSE = 8,
	TRACE_ITER_RAW = 16,
	TRACE_ITER_HEX = 32,
	TRACE_ITER_BIN = 64,
	TRACE_ITER_BLOCK = 128,
	TRACE_ITER_PRINTK = 256,
	TRACE_ITER_ANNOTATE = 512,
	TRACE_ITER_USERSTACKTRACE = 1024,
	TRACE_ITER_SYM_USEROBJ = 2048,
	TRACE_ITER_PRINTK_MSGONLY = 4096,
	TRACE_ITER_CONTEXT_INFO = 8192,
	TRACE_ITER_LATENCY_FMT = 16384,
	TRACE_ITER_RECORD_CMD = 32768,
	TRACE_ITER_RECORD_TGID = 65536,
	TRACE_ITER_OVERWRITE = 131072,
	TRACE_ITER_STOP_ON_FREE = 262144,
	TRACE_ITER_IRQ_INFO = 524288,
	TRACE_ITER_MARKERS = 1048576,
	TRACE_ITER_EVENT_FORK = 2097152,
	TRACE_ITER_PAUSE_ON_TRACE = 4194304,
	TRACE_ITER_FUNCTION = 8388608,
	TRACE_ITER_FUNC_FORK = 16777216,
	TRACE_ITER_DISPLAY_GRAPH = 33554432,
	TRACE_ITER_STACKTRACE = 67108864,
};

struct saved_cmdlines_buffer {
	unsigned int map_pid_to_cmdline[32769];
	unsigned int *map_cmdline_to_pid;
	unsigned int cmdline_num;
	int cmdline_idx;
	char *saved_cmdlines;
};

struct ftrace_stack {
	long unsigned int calls[1024];
};

struct ftrace_stacks {
	struct ftrace_stack stacks[4];
};

struct trace_buffer_struct {
	int nesting;
	char buffer[4096];
};

struct ftrace_buffer_info {
	struct trace_iterator iter;
	void *spare;
	unsigned int spare_cpu;
	unsigned int read;
};

struct err_info {
	const char **errs;
	u8 type;
	u8 pos;
	u64 ts;
};

struct tracing_log_err {
	struct list_head list;
	struct err_info info;
	char loc[128];
	char cmd[256];
};

struct buffer_ref {
	struct trace_buffer *buffer;
	void *page;
	int cpu;
	refcount_t refcount;
};

struct ftrace_func_mapper;

struct ctx_switch_entry {
	struct trace_entry ent;
	unsigned int prev_pid;
	unsigned int next_pid;
	unsigned int next_cpu;
	unsigned char prev_prio;
	unsigned char prev_state;
	unsigned char next_prio;
	unsigned char next_state;
};

struct userstack_entry {
	struct trace_entry ent;
	unsigned int tgid;
	long unsigned int caller[8];
};

struct hwlat_entry {
	struct trace_entry ent;
	u64 duration;
	u64 outer_duration;
	u64 nmi_total_ts;
	struct timespec64 timestamp;
	unsigned int nmi_count;
	unsigned int seqnum;
	unsigned int count;
};

struct trace_mark {
	long long unsigned int val;
	char sym;
};

typedef int (*cmp_func_t)(const void *, const void *);

struct tracer_stat {
	const char *name;
	void * (*stat_start)(struct tracer_stat *);
	void * (*stat_next)(void *, int);
	cmp_func_t stat_cmp;
	int (*stat_show)(struct seq_file *, void *);
	void (*stat_release)(void *);
	int (*stat_headers)(struct seq_file *);
};

struct stat_node {
	struct rb_node node;
	void *stat;
};

struct stat_session {
	struct list_head session_list;
	struct tracer_stat *ts;
	struct rb_root stat_root;
	struct mutex stat_mutex;
	struct dentry *file;
};

struct trace_bprintk_fmt {
	struct list_head list;
	const char *fmt;
};

enum {
	TRACE_FUNC_OPT_STACK = 1,
};

struct ftrace_graph_ent {
	long unsigned int func;
	int depth;
} __attribute__((packed));

struct ftrace_graph_ret {
	long unsigned int func;
	long unsigned int overrun;
	long long unsigned int calltime;
	long long unsigned int rettime;
	int depth;
} __attribute__((packed));

typedef void (*trace_func_graph_ret_t)(struct ftrace_graph_ret *);

typedef int (*trace_func_graph_ent_t)(struct ftrace_graph_ent *);

struct fgraph_ops {
	trace_func_graph_ent_t entryfunc;
	trace_func_graph_ret_t retfunc;
};

enum {
	TRACE_NOP_OPT_ACCEPT = 1,
	TRACE_NOP_OPT_REFUSE = 2,
};

struct ftrace_graph_ent_entry {
	struct trace_entry ent;
	struct ftrace_graph_ent graph_ent;
} __attribute__((packed));

struct ftrace_graph_ret_entry {
	struct trace_entry ent;
	struct ftrace_graph_ret ret;
} __attribute__((packed));

struct fgraph_cpu_data {
	pid_t last_pid;
	int depth;
	int depth_irq;
	int ignore;
	long unsigned int enter_funcs[50];
};

struct fgraph_data {
	struct fgraph_cpu_data *cpu_data;
	struct ftrace_graph_ent_entry ent;
	struct ftrace_graph_ret_entry ret;
	int failed;
	int cpu;
} __attribute__((packed));

enum {
	FLAGS_FILL_FULL = 268435456,
	FLAGS_FILL_START = 536870912,
	FLAGS_FILL_END = 805306368,
};

enum req_opf {
	REQ_OP_READ = 0,
	REQ_OP_WRITE = 1,
	REQ_OP_FLUSH = 2,
	REQ_OP_DISCARD = 3,
	REQ_OP_SECURE_ERASE = 5,
	REQ_OP_WRITE_SAME = 7,
	REQ_OP_WRITE_ZEROES = 9,
	REQ_OP_ZONE_OPEN = 10,
	REQ_OP_ZONE_CLOSE = 11,
	REQ_OP_ZONE_FINISH = 12,
	REQ_OP_ZONE_APPEND = 13,
	REQ_OP_ZONE_RESET = 15,
	REQ_OP_ZONE_RESET_ALL = 17,
	REQ_OP_SCSI_IN = 32,
	REQ_OP_SCSI_OUT = 33,
	REQ_OP_DRV_IN = 34,
	REQ_OP_DRV_OUT = 35,
	REQ_OP_LAST = 36,
};

enum req_flag_bits {
	__REQ_FAILFAST_DEV = 8,
	__REQ_FAILFAST_TRANSPORT = 9,
	__REQ_FAILFAST_DRIVER = 10,
	__REQ_SYNC = 11,
	__REQ_META = 12,
	__REQ_PRIO = 13,
	__REQ_NOMERGE = 14,
	__REQ_IDLE = 15,
	__REQ_INTEGRITY = 16,
	__REQ_FUA = 17,
	__REQ_PREFLUSH = 18,
	__REQ_RAHEAD = 19,
	__REQ_BACKGROUND = 20,
	__REQ_NOWAIT = 21,
	__REQ_CGROUP_PUNT = 22,
	__REQ_NOUNMAP = 23,
	__REQ_HIPRI = 24,
	__REQ_DRV = 25,
	__REQ_SWAP = 26,
	__REQ_NR_BITS = 27,
};

struct disk_stats {
	u64 nsecs[4];
	long unsigned int sectors[4];
	long unsigned int ios[4];
	long unsigned int merges[4];
	long unsigned int io_ticks;
	local_t in_flight[2];
};

struct blk_mq_ctxs;

struct blk_mq_ctx {
	struct {
		spinlock_t lock;
		struct list_head rq_lists[3];
		long: 64;
	};
	unsigned int cpu;
	short unsigned int index_hw[3];
	struct blk_mq_hw_ctx *hctxs[3];
	long unsigned int rq_dispatched[2];
	long unsigned int rq_merged;
	long unsigned int rq_completed[2];
	struct request_queue *queue;
	struct blk_mq_ctxs *ctxs;
	struct kobject kobj;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct blk_mq_alloc_data {
	struct request_queue *q;
	blk_mq_req_flags_t flags;
	unsigned int shallow_depth;
	unsigned int cmd_flags;
	struct blk_mq_ctx *ctx;
	struct blk_mq_hw_ctx *hctx;
};

struct blk_stat_callback {
	struct list_head list;
	struct timer_list timer;
	struct blk_rq_stat *cpu_stat;
	int (*bucket_fn)(const struct request *);
	unsigned int buckets;
	struct blk_rq_stat *stat;
	void (*timer_fn)(struct blk_stat_callback *);
	void *data;
	struct callback_head rcu;
};

struct blk_flush_queue {
	unsigned int flush_pending_idx: 1;
	unsigned int flush_running_idx: 1;
	blk_status_t rq_status;
	long unsigned int flush_pending_since;
	struct list_head flush_queue[2];
	struct list_head flush_data_in_flight;
	struct request *flush_rq;
	struct lock_class_key key;
	spinlock_t mq_flush_lock;
};

struct blk_mq_tags {
	unsigned int nr_tags;
	unsigned int nr_reserved_tags;
	atomic_t active_queues;
	struct sbitmap_queue *bitmap_tags;
	struct sbitmap_queue *breserved_tags;
	struct sbitmap_queue __bitmap_tags;
	struct sbitmap_queue __breserved_tags;
	struct request **rqs;
	struct request **static_rqs;
	struct list_head page_list;
	spinlock_t lock;
};

struct blk_mq_ctxs {
	struct kobject kobj;
	struct blk_mq_ctx *queue_ctx;
};

struct ftrace_event_field {
	struct list_head link;
	const char *name;
	const char *type;
	int filter_type;
	int offset;
	int size;
	int is_signed;
};

enum {
	FORMAT_HEADER = 1,
	FORMAT_FIELD_SEPERATOR = 2,
	FORMAT_PRINTFMT = 3,
};

struct event_probe_data {
	struct trace_event_file *file;
	long unsigned int count;
	int ref;
	bool enable;
};

struct syscall_trace_enter {
	struct trace_entry ent;
	int nr;
	long unsigned int args[0];
};

struct syscall_trace_exit {
	struct trace_entry ent;
	int nr;
	long int ret;
};

struct syscall_tp_t {
	long long unsigned int regs;
	long unsigned int syscall_nr;
	long unsigned int ret;
};

struct syscall_tp_t___2 {
	long long unsigned int regs;
	long unsigned int syscall_nr;
	long unsigned int args[6];
};

enum perf_event_sample_format {
	PERF_SAMPLE_IP = 1,
	PERF_SAMPLE_TID = 2,
	PERF_SAMPLE_TIME = 4,
	PERF_SAMPLE_ADDR = 8,
	PERF_SAMPLE_READ = 16,
	PERF_SAMPLE_CALLCHAIN = 32,
	PERF_SAMPLE_ID = 64,
	PERF_SAMPLE_CPU = 128,
	PERF_SAMPLE_PERIOD = 256,
	PERF_SAMPLE_STREAM_ID = 512,
	PERF_SAMPLE_RAW = 1024,
	PERF_SAMPLE_BRANCH_STACK = 2048,
	PERF_SAMPLE_REGS_USER = 4096,
	PERF_SAMPLE_STACK_USER = 8192,
	PERF_SAMPLE_WEIGHT = 16384,
	PERF_SAMPLE_DATA_SRC = 32768,
	PERF_SAMPLE_IDENTIFIER = 65536,
	PERF_SAMPLE_TRANSACTION = 131072,
	PERF_SAMPLE_REGS_INTR = 262144,
	PERF_SAMPLE_PHYS_ADDR = 524288,
	PERF_SAMPLE_AUX = 1048576,
	PERF_SAMPLE_CGROUP = 2097152,
	PERF_SAMPLE_MAX = 4194304,
	__PERF_SAMPLE_CALLCHAIN_EARLY = 0,
};

typedef long unsigned int perf_trace_t[256];

struct filter_pred;

struct prog_entry {
	int target;
	int when_to_branch;
	struct filter_pred *pred;
};

typedef int (*filter_pred_fn_t)(struct filter_pred *, void *);

struct regex;

typedef int (*regex_match_func)(char *, struct regex *, int);

struct regex {
	char pattern[256];
	int len;
	int field_len;
	regex_match_func match;
};

struct filter_pred {
	filter_pred_fn_t fn;
	u64 val;
	struct regex regex;
	short unsigned int *ops;
	struct ftrace_event_field *field;
	int offset;
	int not;
	int op;
};

enum filter_op_ids {
	OP_GLOB = 0,
	OP_NE = 1,
	OP_EQ = 2,
	OP_LE = 3,
	OP_LT = 4,
	OP_GE = 5,
	OP_GT = 6,
	OP_BAND = 7,
	OP_MAX = 8,
};

enum {
	FILT_ERR_NONE = 0,
	FILT_ERR_INVALID_OP = 1,
	FILT_ERR_TOO_MANY_OPEN = 2,
	FILT_ERR_TOO_MANY_CLOSE = 3,
	FILT_ERR_MISSING_QUOTE = 4,
	FILT_ERR_OPERAND_TOO_LONG = 5,
	FILT_ERR_EXPECT_STRING = 6,
	FILT_ERR_EXPECT_DIGIT = 7,
	FILT_ERR_ILLEGAL_FIELD_OP = 8,
	FILT_ERR_FIELD_NOT_FOUND = 9,
	FILT_ERR_ILLEGAL_INTVAL = 10,
	FILT_ERR_BAD_SUBSYS_FILTER = 11,
	FILT_ERR_TOO_MANY_PREDS = 12,
	FILT_ERR_INVALID_FILTER = 13,
	FILT_ERR_IP_FIELD_ONLY = 14,
	FILT_ERR_INVALID_VALUE = 15,
	FILT_ERR_ERRNO = 16,
	FILT_ERR_NO_FILTER = 17,
};

struct filter_parse_error {
	int lasterr;
	int lasterr_pos;
};

typedef int (*parse_pred_fn)(const char *, void *, int, struct filter_parse_error *, struct filter_pred **);

enum {
	INVERT = 1,
	PROCESS_AND = 2,
	PROCESS_OR = 4,
};

struct ustring_buffer {
	char buffer[1024];
};

enum {
	TOO_MANY_CLOSE = 4294967295,
	TOO_MANY_OPEN = 4294967294,
	MISSING_QUOTE = 4294967293,
};

struct filter_list {
	struct list_head list;
	struct event_filter *filter;
};

struct function_filter_data {
	struct ftrace_ops *ops;
	int first_filter;
	int first_notrace;
};

struct event_trigger_ops;

struct event_command;

struct event_trigger_data {
	long unsigned int count;
	int ref;
	struct event_trigger_ops *ops;
	struct event_command *cmd_ops;
	struct event_filter *filter;
	char *filter_str;
	void *private_data;
	bool paused;
	bool paused_tmp;
	struct list_head list;
	char *name;
	struct list_head named_list;
	struct event_trigger_data *named_data;
};

struct event_trigger_ops {
	void (*func)(struct event_trigger_data *, void *, struct ring_buffer_event *);
	int (*init)(struct event_trigger_ops *, struct event_trigger_data *);
	void (*free)(struct event_trigger_ops *, struct event_trigger_data *);
	int (*print)(struct seq_file *, struct event_trigger_ops *, struct event_trigger_data *);
};

struct event_command {
	struct list_head list;
	char *name;
	enum event_trigger_type trigger_type;
	int flags;
	int (*func)(struct event_command *, struct trace_event_file *, char *, char *, char *);
	int (*reg)(char *, struct event_trigger_ops *, struct event_trigger_data *, struct trace_event_file *);
	void (*unreg)(char *, struct event_trigger_ops *, struct event_trigger_data *, struct trace_event_file *);
	void (*unreg_all)(struct trace_event_file *);
	int (*set_filter)(char *, struct event_trigger_data *, struct trace_event_file *);
	struct event_trigger_ops * (*get_trigger_ops)(char *, char *);
};

struct enable_trigger_data {
	struct trace_event_file *file;
	bool enable;
	bool hist;
};

enum event_command_flags {
	EVENT_CMD_FL_POST_TRIGGER = 1,
	EVENT_CMD_FL_NEEDS_REC = 2,
};

enum bpf_func_id {
	BPF_FUNC_unspec = 0,
	BPF_FUNC_map_lookup_elem = 1,
	BPF_FUNC_map_update_elem = 2,
	BPF_FUNC_map_delete_elem = 3,
	BPF_FUNC_probe_read = 4,
	BPF_FUNC_ktime_get_ns = 5,
	BPF_FUNC_trace_printk = 6,
	BPF_FUNC_get_prandom_u32 = 7,
	BPF_FUNC_get_smp_processor_id = 8,
	BPF_FUNC_skb_store_bytes = 9,
	BPF_FUNC_l3_csum_replace = 10,
	BPF_FUNC_l4_csum_replace = 11,
	BPF_FUNC_tail_call = 12,
	BPF_FUNC_clone_redirect = 13,
	BPF_FUNC_get_current_pid_tgid = 14,
	BPF_FUNC_get_current_uid_gid = 15,
	BPF_FUNC_get_current_comm = 16,
	BPF_FUNC_get_cgroup_classid = 17,
	BPF_FUNC_skb_vlan_push = 18,
	BPF_FUNC_skb_vlan_pop = 19,
	BPF_FUNC_skb_get_tunnel_key = 20,
	BPF_FUNC_skb_set_tunnel_key = 21,
	BPF_FUNC_perf_event_read = 22,
	BPF_FUNC_redirect = 23,
	BPF_FUNC_get_route_realm = 24,
	BPF_FUNC_perf_event_output = 25,
	BPF_FUNC_skb_load_bytes = 26,
	BPF_FUNC_get_stackid = 27,
	BPF_FUNC_csum_diff = 28,
	BPF_FUNC_skb_get_tunnel_opt = 29,
	BPF_FUNC_skb_set_tunnel_opt = 30,
	BPF_FUNC_skb_change_proto = 31,
	BPF_FUNC_skb_change_type = 32,
	BPF_FUNC_skb_under_cgroup = 33,
	BPF_FUNC_get_hash_recalc = 34,
	BPF_FUNC_get_current_task = 35,
	BPF_FUNC_probe_write_user = 36,
	BPF_FUNC_current_task_under_cgroup = 37,
	BPF_FUNC_skb_change_tail = 38,
	BPF_FUNC_skb_pull_data = 39,
	BPF_FUNC_csum_update = 40,
	BPF_FUNC_set_hash_invalid = 41,
	BPF_FUNC_get_numa_node_id = 42,
	BPF_FUNC_skb_change_head = 43,
	BPF_FUNC_xdp_adjust_head = 44,
	BPF_FUNC_probe_read_str = 45,
	BPF_FUNC_get_socket_cookie = 46,
	BPF_FUNC_get_socket_uid = 47,
	BPF_FUNC_set_hash = 48,
	BPF_FUNC_setsockopt = 49,
	BPF_FUNC_skb_adjust_room = 50,
	BPF_FUNC_redirect_map = 51,
	BPF_FUNC_sk_redirect_map = 52,
	BPF_FUNC_sock_map_update = 53,
	BPF_FUNC_xdp_adjust_meta = 54,
	BPF_FUNC_perf_event_read_value = 55,
	BPF_FUNC_perf_prog_read_value = 56,
	BPF_FUNC_getsockopt = 57,
	BPF_FUNC_override_return = 58,
	BPF_FUNC_sock_ops_cb_flags_set = 59,
	BPF_FUNC_msg_redirect_map = 60,
	BPF_FUNC_msg_apply_bytes = 61,
	BPF_FUNC_msg_cork_bytes = 62,
	BPF_FUNC_msg_pull_data = 63,
	BPF_FUNC_bind = 64,
	BPF_FUNC_xdp_adjust_tail = 65,
	BPF_FUNC_skb_get_xfrm_state = 66,
	BPF_FUNC_get_stack = 67,
	BPF_FUNC_skb_load_bytes_relative = 68,
	BPF_FUNC_fib_lookup = 69,
	BPF_FUNC_sock_hash_update = 70,
	BPF_FUNC_msg_redirect_hash = 71,
	BPF_FUNC_sk_redirect_hash = 72,
	BPF_FUNC_lwt_push_encap = 73,
	BPF_FUNC_lwt_seg6_store_bytes = 74,
	BPF_FUNC_lwt_seg6_adjust_srh = 75,
	BPF_FUNC_lwt_seg6_action = 76,
	BPF_FUNC_rc_repeat = 77,
	BPF_FUNC_rc_keydown = 78,
	BPF_FUNC_skb_cgroup_id = 79,
	BPF_FUNC_get_current_cgroup_id = 80,
	BPF_FUNC_get_local_storage = 81,
	BPF_FUNC_sk_select_reuseport = 82,
	BPF_FUNC_skb_ancestor_cgroup_id = 83,
	BPF_FUNC_sk_lookup_tcp = 84,
	BPF_FUNC_sk_lookup_udp = 85,
	BPF_FUNC_sk_release = 86,
	BPF_FUNC_map_push_elem = 87,
	BPF_FUNC_map_pop_elem = 88,
	BPF_FUNC_map_peek_elem = 89,
	BPF_FUNC_msg_push_data = 90,
	BPF_FUNC_msg_pop_data = 91,
	BPF_FUNC_rc_pointer_rel = 92,
	BPF_FUNC_spin_lock = 93,
	BPF_FUNC_spin_unlock = 94,
	BPF_FUNC_sk_fullsock = 95,
	BPF_FUNC_tcp_sock = 96,
	BPF_FUNC_skb_ecn_set_ce = 97,
	BPF_FUNC_get_listener_sock = 98,
	BPF_FUNC_skc_lookup_tcp = 99,
	BPF_FUNC_tcp_check_syncookie = 100,
	BPF_FUNC_sysctl_get_name = 101,
	BPF_FUNC_sysctl_get_current_value = 102,
	BPF_FUNC_sysctl_get_new_value = 103,
	BPF_FUNC_sysctl_set_new_value = 104,
	BPF_FUNC_strtol = 105,
	BPF_FUNC_strtoul = 106,
	BPF_FUNC_sk_storage_get = 107,
	BPF_FUNC_sk_storage_delete = 108,
	BPF_FUNC_send_signal = 109,
	BPF_FUNC_tcp_gen_syncookie = 110,
	BPF_FUNC_skb_output = 111,
	BPF_FUNC_probe_read_user = 112,
	BPF_FUNC_probe_read_kernel = 113,
	BPF_FUNC_probe_read_user_str = 114,
	BPF_FUNC_probe_read_kernel_str = 115,
	BPF_FUNC_tcp_send_ack = 116,
	BPF_FUNC_send_signal_thread = 117,
	BPF_FUNC_jiffies64 = 118,
	BPF_FUNC_read_branch_records = 119,
	BPF_FUNC_get_ns_current_pid_tgid = 120,
	BPF_FUNC_xdp_output = 121,
	BPF_FUNC_get_netns_cookie = 122,
	BPF_FUNC_get_current_ancestor_cgroup_id = 123,
	BPF_FUNC_sk_assign = 124,
	BPF_FUNC_ktime_get_boot_ns = 125,
	BPF_FUNC_seq_printf = 126,
	BPF_FUNC_seq_write = 127,
	BPF_FUNC_sk_cgroup_id = 128,
	BPF_FUNC_sk_ancestor_cgroup_id = 129,
	BPF_FUNC_ringbuf_output = 130,
	BPF_FUNC_ringbuf_reserve = 131,
	BPF_FUNC_ringbuf_submit = 132,
	BPF_FUNC_ringbuf_discard = 133,
	BPF_FUNC_ringbuf_query = 134,
	BPF_FUNC_csum_level = 135,
	BPF_FUNC_skc_to_tcp6_sock = 136,
	BPF_FUNC_skc_to_tcp_sock = 137,
	BPF_FUNC_skc_to_tcp_timewait_sock = 138,
	BPF_FUNC_skc_to_tcp_request_sock = 139,
	BPF_FUNC_skc_to_udp6_sock = 140,
	BPF_FUNC_get_task_stack = 141,
	BPF_FUNC_load_hdr_opt = 142,
	BPF_FUNC_store_hdr_opt = 143,
	BPF_FUNC_reserve_hdr_opt = 144,
	BPF_FUNC_inode_storage_get = 145,
	BPF_FUNC_inode_storage_delete = 146,
	BPF_FUNC_d_path = 147,
	BPF_FUNC_copy_from_user = 148,
	BPF_FUNC_snprintf_btf = 149,
	BPF_FUNC_seq_printf_btf = 150,
	BPF_FUNC_skb_cgroup_classid = 151,
	BPF_FUNC_redirect_neigh = 152,
	BPF_FUNC_per_cpu_ptr = 153,
	BPF_FUNC_this_cpu_ptr = 154,
	BPF_FUNC_redirect_peer = 155,
	__BPF_FUNC_MAX_ID = 156,
};

enum {
	BPF_F_INDEX_MASK = 4294967295,
	BPF_F_CURRENT_CPU = 4294967295,
	BPF_F_CTXLEN_MASK = 0,
};

enum {
	BPF_F_GET_BRANCH_RECORDS_SIZE = 1,
};

struct bpf_perf_event_value {
	__u64 counter;
	__u64 enabled;
	__u64 running;
};

struct bpf_raw_tracepoint_args {
	__u64 args[0];
};

enum bpf_task_fd_type {
	BPF_FD_TYPE_RAW_TRACEPOINT = 0,
	BPF_FD_TYPE_TRACEPOINT = 1,
	BPF_FD_TYPE_KPROBE = 2,
	BPF_FD_TYPE_KRETPROBE = 3,
	BPF_FD_TYPE_UPROBE = 4,
	BPF_FD_TYPE_URETPROBE = 5,
};

struct btf_ptr {
	void *ptr;
	__u32 type_id;
	__u32 flags;
};

enum {
	BTF_F_COMPACT = 1,
	BTF_F_NONAME = 2,
	BTF_F_PTR_RAW = 4,
	BTF_F_ZERO = 8,
};

enum bpf_arg_type {
	ARG_DONTCARE = 0,
	ARG_CONST_MAP_PTR = 1,
	ARG_PTR_TO_MAP_KEY = 2,
	ARG_PTR_TO_MAP_VALUE = 3,
	ARG_PTR_TO_UNINIT_MAP_VALUE = 4,
	ARG_PTR_TO_MAP_VALUE_OR_NULL = 5,
	ARG_PTR_TO_MEM = 6,
	ARG_PTR_TO_MEM_OR_NULL = 7,
	ARG_PTR_TO_UNINIT_MEM = 8,
	ARG_CONST_SIZE = 9,
	ARG_CONST_SIZE_OR_ZERO = 10,
	ARG_PTR_TO_CTX = 11,
	ARG_PTR_TO_CTX_OR_NULL = 12,
	ARG_ANYTHING = 13,
	ARG_PTR_TO_SPIN_LOCK = 14,
	ARG_PTR_TO_SOCK_COMMON = 15,
	ARG_PTR_TO_INT = 16,
	ARG_PTR_TO_LONG = 17,
	ARG_PTR_TO_SOCKET = 18,
	ARG_PTR_TO_SOCKET_OR_NULL = 19,
	ARG_PTR_TO_BTF_ID = 20,
	ARG_PTR_TO_ALLOC_MEM = 21,
	ARG_PTR_TO_ALLOC_MEM_OR_NULL = 22,
	ARG_CONST_ALLOC_SIZE_OR_ZERO = 23,
	ARG_PTR_TO_BTF_ID_SOCK_COMMON = 24,
	ARG_PTR_TO_PERCPU_BTF_ID = 25,
	__BPF_ARG_TYPE_MAX = 26,
};

enum bpf_return_type {
	RET_INTEGER = 0,
	RET_VOID = 1,
	RET_PTR_TO_MAP_VALUE = 2,
	RET_PTR_TO_MAP_VALUE_OR_NULL = 3,
	RET_PTR_TO_SOCKET_OR_NULL = 4,
	RET_PTR_TO_TCP_SOCK_OR_NULL = 5,
	RET_PTR_TO_SOCK_COMMON_OR_NULL = 6,
	RET_PTR_TO_ALLOC_MEM_OR_NULL = 7,
	RET_PTR_TO_BTF_ID_OR_NULL = 8,
	RET_PTR_TO_MEM_OR_BTF_ID_OR_NULL = 9,
	RET_PTR_TO_MEM_OR_BTF_ID = 10,
};

struct bpf_func_proto {
	u64 (*func)(u64, u64, u64, u64, u64);
	bool gpl_only;
	bool pkt_access;
	enum bpf_return_type ret_type;
	union {
		struct {
			enum bpf_arg_type arg1_type;
			enum bpf_arg_type arg2_type;
			enum bpf_arg_type arg3_type;
			enum bpf_arg_type arg4_type;
			enum bpf_arg_type arg5_type;
		};
		enum bpf_arg_type arg_type[5];
	};
	union {
		struct {
			u32 *arg1_btf_id;
			u32 *arg2_btf_id;
			u32 *arg3_btf_id;
			u32 *arg4_btf_id;
			u32 *arg5_btf_id;
		};
		u32 *arg_btf_id[5];
	};
	int *ret_btf_id;
	bool (*allowed)(const struct bpf_prog *);
};

enum bpf_access_type {
	BPF_READ = 1,
	BPF_WRITE = 2,
};

struct bpf_verifier_log;

struct bpf_insn_access_aux {
	enum bpf_reg_type reg_type;
	union {
		int ctx_field_size;
		u32 btf_id;
	};
	struct bpf_verifier_log *log;
};

struct bpf_verifier_ops {
	const struct bpf_func_proto * (*get_func_proto)(enum bpf_func_id, const struct bpf_prog *);
	bool (*is_valid_access)(int, int, enum bpf_access_type, const struct bpf_prog *, struct bpf_insn_access_aux *);
	int (*gen_prologue)(struct bpf_insn *, bool, const struct bpf_prog *);
	int (*gen_ld_abs)(const struct bpf_insn *, struct bpf_insn *);
	u32 (*convert_ctx_access)(enum bpf_access_type, const struct bpf_insn *, struct bpf_insn *, struct bpf_prog *, u32 *);
	int (*btf_struct_access)(struct bpf_verifier_log *, const struct btf_type *, int, int, enum bpf_access_type, u32 *);
};

struct bpf_array_aux {
	struct {
		spinlock_t lock;
		enum bpf_prog_type type;
		bool jited;
	} owner;
	struct list_head poke_progs;
	struct bpf_map *map;
	struct mutex poke_mutex;
	struct work_struct work;
};

struct bpf_array {
	struct bpf_map map;
	u32 elem_size;
	u32 index_mask;
	struct bpf_array_aux *aux;
	union {
		char value[0];
		void *ptrs[0];
		void *pptrs[0];
	};
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct bpf_event_entry {
	struct perf_event *event;
	struct file *perf_file;
	struct file *map_file;
	struct callback_head rcu;
};

typedef long unsigned int (*bpf_ctx_copy_t)(void *, const void *, long unsigned int, long unsigned int);

typedef struct user_regs_struct bpf_user_pt_regs_t;

struct bpf_perf_event_data {
	bpf_user_pt_regs_t regs;
	__u64 sample_period;
	__u64 addr;
};

enum perf_type_id {
	PERF_TYPE_HARDWARE = 0,
	PERF_TYPE_SOFTWARE = 1,
	PERF_TYPE_TRACEPOINT = 2,
	PERF_TYPE_HW_CACHE = 3,
	PERF_TYPE_RAW = 4,
	PERF_TYPE_BREAKPOINT = 5,
	PERF_TYPE_MAX = 6,
};

struct perf_event_query_bpf {
	__u32 ids_len;
	__u32 prog_cnt;
	__u32 ids[0];
};

struct bpf_perf_event_data_kern {
	bpf_user_pt_regs_t *regs;
	struct perf_sample_data *data;
	struct perf_event *event;
};

struct btf_id_set {
	u32 cnt;
	u32 ids[0];
};

struct trace_event_raw_bpf_trace_printk {
	struct trace_entry ent;
	u32 __data_loc_bpf_string;
	char __data[0];
};

struct trace_event_data_offsets_bpf_trace_printk {
	u32 bpf_string;
};

typedef void (*btf_trace_bpf_trace_printk)(void *, const char *);

struct bpf_trace_module {
	struct module *module;
	struct list_head list;
};

typedef u64 (*btf_bpf_probe_read_user)(void *, u32, const void *);

typedef u64 (*btf_bpf_probe_read_user_str)(void *, u32, const void *);

typedef u64 (*btf_bpf_probe_read_kernel)(void *, u32, const void *);

typedef u64 (*btf_bpf_probe_read_kernel_str)(void *, u32, const void *);

typedef u64 (*btf_bpf_probe_write_user)(void *, const void *, u32);

typedef u64 (*btf_bpf_trace_printk)(char *, u32, u64, u64, u64);

struct bpf_seq_printf_buf {
	char buf[768];
};

typedef u64 (*btf_bpf_seq_printf)(struct seq_file *, char *, u32, const void *, u32);

typedef u64 (*btf_bpf_seq_write)(struct seq_file *, const void *, u32);

typedef u64 (*btf_bpf_seq_printf_btf)(struct seq_file *, struct btf_ptr *, u32, u64);

typedef u64 (*btf_bpf_perf_event_read)(struct bpf_map *, u64);

typedef u64 (*btf_bpf_perf_event_read_value)(struct bpf_map *, u64, struct bpf_perf_event_value *, u32);

struct bpf_trace_sample_data {
	struct perf_sample_data sds[3];
};

typedef u64 (*btf_bpf_perf_event_output)(struct pt_regs *, struct bpf_map *, u64, void *, u64);

struct bpf_nested_pt_regs {
	struct pt_regs regs[3];
};

typedef u64 (*btf_bpf_get_current_task)();

typedef u64 (*btf_bpf_current_task_under_cgroup)(struct bpf_map *, u32);

struct send_signal_irq_work {
	struct irq_work irq_work;
	struct task_struct *task;
	u32 sig;
	enum pid_type type;
};

typedef u64 (*btf_bpf_send_signal)(u32);

typedef u64 (*btf_bpf_send_signal_thread)(u32);

typedef u64 (*btf_bpf_d_path)(struct path *, char *, u32);

typedef u64 (*btf_bpf_snprintf_btf)(char *, u32, struct btf_ptr *, u32, u64);

typedef u64 (*btf_bpf_perf_event_output_tp)(void *, struct bpf_map *, u64, void *, u64);

typedef u64 (*btf_bpf_get_stackid_tp)(void *, struct bpf_map *, u64);

typedef u64 (*btf_bpf_get_stack_tp)(void *, void *, u32, u64);

typedef u64 (*btf_bpf_perf_prog_read_value)(struct bpf_perf_event_data_kern *, struct bpf_perf_event_value *, u32);

typedef u64 (*btf_bpf_read_branch_records)(struct bpf_perf_event_data_kern *, void *, u32, u64);

struct bpf_raw_tp_regs {
	struct pt_regs regs[3];
};

typedef u64 (*btf_bpf_perf_event_output_raw_tp)(struct bpf_raw_tracepoint_args *, struct bpf_map *, u64, void *, u64);

typedef u64 (*btf_bpf_get_stackid_raw_tp)(struct bpf_raw_tracepoint_args *, struct bpf_map *, u64);

typedef u64 (*btf_bpf_get_stack_raw_tp)(struct bpf_raw_tracepoint_args *, void *, u32, u64);

enum dynevent_type {
	DYNEVENT_TYPE_SYNTH = 1,
	DYNEVENT_TYPE_KPROBE = 2,
	DYNEVENT_TYPE_NONE = 3,
};

struct dynevent_cmd;

typedef int (*dynevent_create_fn_t)(struct dynevent_cmd *);

struct dynevent_cmd {
	struct seq_buf seq;
	const char *event_name;
	unsigned int n_fields;
	enum dynevent_type type;
	dynevent_create_fn_t run_command;
	void *private_data;
};

struct kprobe_trace_entry_head {
	struct trace_entry ent;
	long unsigned int ip;
};

struct kretprobe_trace_entry_head {
	struct trace_entry ent;
	long unsigned int func;
	long unsigned int ret_ip;
};

struct dyn_event;

struct dyn_event_operations {
	struct list_head list;
	int (*create)(int, const char **);
	int (*show)(struct seq_file *, struct dyn_event *);
	bool (*is_busy)(struct dyn_event *);
	int (*free)(struct dyn_event *);
	bool (*match)(const char *, const char *, int, const char **, struct dyn_event *);
};

struct dyn_event {
	struct list_head list;
	struct dyn_event_operations *ops;
};

struct dynevent_arg {
	const char *str;
	char separator;
};

typedef int (*print_type_func_t)(struct trace_seq *, void *, void *);

enum fetch_op {
	FETCH_OP_NOP = 0,
	FETCH_OP_REG = 1,
	FETCH_OP_STACK = 2,
	FETCH_OP_STACKP = 3,
	FETCH_OP_RETVAL = 4,
	FETCH_OP_IMM = 5,
	FETCH_OP_COMM = 6,
	FETCH_OP_ARG = 7,
	FETCH_OP_FOFFS = 8,
	FETCH_OP_DATA = 9,
	FETCH_OP_DEREF = 10,
	FETCH_OP_UDEREF = 11,
	FETCH_OP_ST_RAW = 12,
	FETCH_OP_ST_MEM = 13,
	FETCH_OP_ST_UMEM = 14,
	FETCH_OP_ST_STRING = 15,
	FETCH_OP_ST_USTRING = 16,
	FETCH_OP_MOD_BF = 17,
	FETCH_OP_LP_ARRAY = 18,
	FETCH_OP_END = 19,
	FETCH_NOP_SYMBOL = 20,
};

struct fetch_insn {
	enum fetch_op op;
	union {
		unsigned int param;
		struct {
			unsigned int size;
			int offset;
		};
		struct {
			unsigned char basesize;
			unsigned char lshift;
			unsigned char rshift;
		};
		long unsigned int immediate;
		void *data;
	};
};

struct fetch_type {
	const char *name;
	size_t size;
	int is_signed;
	print_type_func_t print;
	const char *fmt;
	const char *fmttype;
};

struct probe_arg {
	struct fetch_insn *code;
	bool dynamic;
	unsigned int offset;
	unsigned int count;
	const char *name;
	const char *comm;
	char *fmt;
	const struct fetch_type *type;
};

struct trace_uprobe_filter {
	rwlock_t rwlock;
	int nr_systemwide;
	struct list_head perf_events;
};

struct trace_probe_event {
	unsigned int flags;
	struct trace_event_class class;
	struct trace_event_call call;
	struct list_head files;
	struct list_head probes;
	struct trace_uprobe_filter filter[0];
};

struct trace_probe {
	struct list_head list;
	struct trace_probe_event *event;
	ssize_t size;
	unsigned int nr_args;
	struct probe_arg args[0];
};

struct event_file_link {
	struct trace_event_file *file;
	struct list_head list;
};

enum {
	TP_ERR_FILE_NOT_FOUND = 0,
	TP_ERR_NO_REGULAR_FILE = 1,
	TP_ERR_BAD_REFCNT = 2,
	TP_ERR_REFCNT_OPEN_BRACE = 3,
	TP_ERR_BAD_REFCNT_SUFFIX = 4,
	TP_ERR_BAD_UPROBE_OFFS = 5,
	TP_ERR_MAXACT_NO_KPROBE = 6,
	TP_ERR_BAD_MAXACT = 7,
	TP_ERR_MAXACT_TOO_BIG = 8,
	TP_ERR_BAD_PROBE_ADDR = 9,
	TP_ERR_BAD_RETPROBE = 10,
	TP_ERR_BAD_ADDR_SUFFIX = 11,
	TP_ERR_NO_GROUP_NAME = 12,
	TP_ERR_GROUP_TOO_LONG = 13,
	TP_ERR_BAD_GROUP_NAME = 14,
	TP_ERR_NO_EVENT_NAME = 15,
	TP_ERR_EVENT_TOO_LONG = 16,
	TP_ERR_BAD_EVENT_NAME = 17,
	TP_ERR_EVENT_EXIST = 18,
	TP_ERR_RETVAL_ON_PROBE = 19,
	TP_ERR_BAD_STACK_NUM = 20,
	TP_ERR_BAD_ARG_NUM = 21,
	TP_ERR_BAD_VAR = 22,
	TP_ERR_BAD_REG_NAME = 23,
	TP_ERR_BAD_MEM_ADDR = 24,
	TP_ERR_BAD_IMM = 25,
	TP_ERR_IMMSTR_NO_CLOSE = 26,
	TP_ERR_FILE_ON_KPROBE = 27,
	TP_ERR_BAD_FILE_OFFS = 28,
	TP_ERR_SYM_ON_UPROBE = 29,
	TP_ERR_TOO_MANY_OPS = 30,
	TP_ERR_DEREF_NEED_BRACE = 31,
	TP_ERR_BAD_DEREF_OFFS = 32,
	TP_ERR_DEREF_OPEN_BRACE = 33,
	TP_ERR_COMM_CANT_DEREF = 34,
	TP_ERR_BAD_FETCH_ARG = 35,
	TP_ERR_ARRAY_NO_CLOSE = 36,
	TP_ERR_BAD_ARRAY_SUFFIX = 37,
	TP_ERR_BAD_ARRAY_NUM = 38,
	TP_ERR_ARRAY_TOO_BIG = 39,
	TP_ERR_BAD_TYPE = 40,
	TP_ERR_BAD_STRING = 41,
	TP_ERR_BAD_BITFIELD = 42,
	TP_ERR_ARG_NAME_TOO_LONG = 43,
	TP_ERR_NO_ARG_NAME = 44,
	TP_ERR_BAD_ARG_NAME = 45,
	TP_ERR_USED_ARG_NAME = 46,
	TP_ERR_ARG_TOO_LONG = 47,
	TP_ERR_NO_ARG_BODY = 48,
	TP_ERR_BAD_INSN_BNDRY = 49,
	TP_ERR_FAIL_REG_PROBE = 50,
	TP_ERR_DIFF_PROBE_TYPE = 51,
	TP_ERR_DIFF_ARG_TYPE = 52,
	TP_ERR_SAME_PROBE = 53,
};

struct trace_kprobe {
	struct dyn_event devent;
	struct kretprobe rp;
	long unsigned int *nhit;
	const char *symbol;
	struct trace_probe tp;
};

enum error_detector {
	ERROR_DETECTOR_KFENCE = 0,
	ERROR_DETECTOR_KASAN = 1,
};

struct trace_event_raw_error_report_template {
	struct trace_entry ent;
	enum error_detector error_detector;
	long unsigned int id;
	char __data[0];
};

struct trace_event_data_offsets_error_report_template {};

typedef void (*btf_trace_error_report_end)(void *, enum error_detector, long unsigned int);

struct trace_event_raw_cpu {
	struct trace_entry ent;
	u32 state;
	u32 cpu_id;
	char __data[0];
};

struct trace_event_raw_powernv_throttle {
	struct trace_entry ent;
	int chip_id;
	u32 __data_loc_reason;
	int pmax;
	char __data[0];
};

struct trace_event_raw_pstate_sample {
	struct trace_entry ent;
	u32 core_busy;
	u32 scaled_busy;
	u32 from;
	u32 to;
	u64 mperf;
	u64 aperf;
	u64 tsc;
	u32 freq;
	u32 io_boost;
	char __data[0];
};

struct trace_event_raw_cpu_frequency_limits {
	struct trace_entry ent;
	u32 min_freq;
	u32 max_freq;
	u32 cpu_id;
	char __data[0];
};

struct trace_event_raw_device_pm_callback_start {
	struct trace_entry ent;
	u32 __data_loc_device;
	u32 __data_loc_driver;
	u32 __data_loc_parent;
	u32 __data_loc_pm_ops;
	int event;
	char __data[0];
};

struct trace_event_raw_device_pm_callback_end {
	struct trace_entry ent;
	u32 __data_loc_device;
	u32 __data_loc_driver;
	int error;
	char __data[0];
};

struct trace_event_raw_suspend_resume {
	struct trace_entry ent;
	const char *action;
	int val;
	bool start;
	char __data[0];
};

struct trace_event_raw_wakeup_source {
	struct trace_entry ent;
	u32 __data_loc_name;
	u64 state;
	char __data[0];
};

struct trace_event_raw_clock {
	struct trace_entry ent;
	u32 __data_loc_name;
	u64 state;
	u64 cpu_id;
	char __data[0];
};

struct trace_event_raw_power_domain {
	struct trace_entry ent;
	u32 __data_loc_name;
	u64 state;
	u64 cpu_id;
	char __data[0];
};

struct trace_event_raw_cpu_latency_qos_request {
	struct trace_entry ent;
	s32 value;
	char __data[0];
};

struct trace_event_raw_pm_qos_update {
	struct trace_entry ent;
	enum pm_qos_req_action action;
	int prev_value;
	int curr_value;
	char __data[0];
};

struct trace_event_raw_dev_pm_qos_request {
	struct trace_entry ent;
	u32 __data_loc_name;
	enum dev_pm_qos_req_type type;
	s32 new_value;
	char __data[0];
};

struct trace_event_data_offsets_cpu {};

struct trace_event_data_offsets_powernv_throttle {
	u32 reason;
};

struct trace_event_data_offsets_pstate_sample {};

struct trace_event_data_offsets_cpu_frequency_limits {};

struct trace_event_data_offsets_device_pm_callback_start {
	u32 device;
	u32 driver;
	u32 parent;
	u32 pm_ops;
};

struct trace_event_data_offsets_device_pm_callback_end {
	u32 device;
	u32 driver;
};

struct trace_event_data_offsets_suspend_resume {};

struct trace_event_data_offsets_wakeup_source {
	u32 name;
};

struct trace_event_data_offsets_clock {
	u32 name;
};

struct trace_event_data_offsets_power_domain {
	u32 name;
};

struct trace_event_data_offsets_cpu_latency_qos_request {};

struct trace_event_data_offsets_pm_qos_update {};

struct trace_event_data_offsets_dev_pm_qos_request {
	u32 name;
};

typedef void (*btf_trace_cpu_idle)(void *, unsigned int, unsigned int);

typedef void (*btf_trace_powernv_throttle)(void *, int, const char *, int);

typedef void (*btf_trace_pstate_sample)(void *, u32, u32, u32, u32, u64, u64, u64, u32, u32);

typedef void (*btf_trace_cpu_frequency)(void *, unsigned int, unsigned int);

typedef void (*btf_trace_cpu_frequency_limits)(void *, struct cpufreq_policy *);

typedef void (*btf_trace_device_pm_callback_start)(void *, struct device *, const char *, int);

typedef void (*btf_trace_device_pm_callback_end)(void *, struct device *, int);

typedef void (*btf_trace_suspend_resume)(void *, const char *, int, bool);

typedef void (*btf_trace_wakeup_source_activate)(void *, const char *, unsigned int);

typedef void (*btf_trace_wakeup_source_deactivate)(void *, const char *, unsigned int);

typedef void (*btf_trace_clock_enable)(void *, const char *, unsigned int, unsigned int);

typedef void (*btf_trace_clock_disable)(void *, const char *, unsigned int, unsigned int);

typedef void (*btf_trace_clock_set_rate)(void *, const char *, unsigned int, unsigned int);

typedef void (*btf_trace_power_domain_target)(void *, const char *, unsigned int, unsigned int);

typedef void (*btf_trace_pm_qos_add_request)(void *, s32);

typedef void (*btf_trace_pm_qos_update_request)(void *, s32);

typedef void (*btf_trace_pm_qos_remove_request)(void *, s32);

typedef void (*btf_trace_pm_qos_update_target)(void *, enum pm_qos_req_action, int, int);

typedef void (*btf_trace_pm_qos_update_flags)(void *, enum pm_qos_req_action, int, int);

typedef void (*btf_trace_dev_pm_qos_add_request)(void *, const char *, enum dev_pm_qos_req_type, s32);

typedef void (*btf_trace_dev_pm_qos_update_request)(void *, const char *, enum dev_pm_qos_req_type, s32);

typedef void (*btf_trace_dev_pm_qos_remove_request)(void *, const char *, enum dev_pm_qos_req_type, s32);

struct trace_event_raw_rpm_internal {
	struct trace_entry ent;
	u32 __data_loc_name;
	int flags;
	int usage_count;
	int disable_depth;
	int runtime_auto;
	int request_pending;
	int irq_safe;
	int child_count;
	char __data[0];
};

struct trace_event_raw_rpm_return_int {
	struct trace_entry ent;
	u32 __data_loc_name;
	long unsigned int ip;
	int ret;
	char __data[0];
};

struct trace_event_data_offsets_rpm_internal {
	u32 name;
};

struct trace_event_data_offsets_rpm_return_int {
	u32 name;
};

typedef void (*btf_trace_rpm_suspend)(void *, struct device *, int);

typedef void (*btf_trace_rpm_resume)(void *, struct device *, int);

typedef void (*btf_trace_rpm_idle)(void *, struct device *, int);

typedef void (*btf_trace_rpm_usage)(void *, struct device *, int);

typedef void (*btf_trace_rpm_return_int)(void *, struct device *, long unsigned int, int);

typedef int (*dynevent_check_arg_fn_t)(void *);

struct dynevent_arg_pair {
	const char *lhs;
	const char *rhs;
	char operator;
	char separator;
};

struct trace_probe_log {
	const char *subsystem;
	const char **argv;
	int argc;
	int index;
};

enum uprobe_filter_ctx {
	UPROBE_FILTER_REGISTER = 0,
	UPROBE_FILTER_UNREGISTER = 1,
	UPROBE_FILTER_MMAP = 2,
};

struct uprobe_consumer {
	int (*handler)(struct uprobe_consumer *, struct pt_regs *);
	int (*ret_handler)(struct uprobe_consumer *, long unsigned int, struct pt_regs *);
	bool (*filter)(struct uprobe_consumer *, enum uprobe_filter_ctx, struct mm_struct *);
	struct uprobe_consumer *next;
};

struct uprobe_trace_entry_head {
	struct trace_entry ent;
	long unsigned int vaddr[0];
};

struct trace_uprobe {
	struct dyn_event devent;
	struct uprobe_consumer consumer;
	struct path path;
	struct inode *inode;
	char *filename;
	long unsigned int offset;
	long unsigned int ref_ctr_offset;
	long unsigned int nhit;
	struct trace_probe tp;
};

struct uprobe_dispatch_data {
	struct trace_uprobe *tu;
	long unsigned int bp_addr;
};

struct uprobe_cpu_buffer {
	struct mutex mutex;
	void *buf;
};

typedef bool (*filter_func_t)(struct uprobe_consumer *, enum uprobe_filter_ctx, struct mm_struct *);

enum cpu_pm_event {
	CPU_PM_ENTER = 0,
	CPU_PM_ENTER_FAILED = 1,
	CPU_PM_EXIT = 2,
	CPU_CLUSTER_PM_ENTER = 3,
	CPU_CLUSTER_PM_ENTER_FAILED = 4,
	CPU_CLUSTER_PM_EXIT = 5,
};

typedef __u16 __le16;

typedef __u64 __le64;

typedef __u64 __be64;

struct rhash_lock_head;

struct bucket_table {
	unsigned int size;
	unsigned int nest;
	u32 hash_rnd;
	struct list_head walkers;
	struct callback_head rcu;
	struct bucket_table *future_tbl;
	struct lockdep_map dep_map;
	long: 64;
	struct rhash_lock_head *buckets[0];
};

struct rnd_state {
	__u32 s1;
	__u32 s2;
	__u32 s3;
	__u32 s4;
};

enum xdp_action {
	XDP_ABORTED = 0,
	XDP_DROP = 1,
	XDP_PASS = 2,
	XDP_TX = 3,
	XDP_REDIRECT = 4,
};

enum bpf_jit_poke_reason {
	BPF_POKE_REASON_TAIL_CALL = 0,
};

enum bpf_text_poke_type {
	BPF_MOD_CALL = 0,
	BPF_MOD_JUMP = 1,
};

enum xdp_mem_type {
	MEM_TYPE_PAGE_SHARED = 0,
	MEM_TYPE_PAGE_ORDER0 = 1,
	MEM_TYPE_PAGE_POOL = 2,
	MEM_TYPE_XSK_BUFF_POOL = 3,
	MEM_TYPE_MAX = 4,
};

struct xdp_cpumap_stats {
	unsigned int redirect;
	unsigned int pass;
	unsigned int drop;
};

typedef void (*bpf_jit_fill_hole_t)(void *, unsigned int);

struct bpf_prog_dummy {
	struct bpf_prog prog;
};

typedef u64 (*btf_bpf_user_rnd_u32)();

typedef u64 (*btf_bpf_get_raw_cpu_id)();

struct _bpf_dtab_netdev {
	struct net_device *dev;
};

struct rhash_lock_head {};

struct zero_copy_allocator;

struct page_pool;

struct xdp_mem_allocator {
	struct xdp_mem_info mem;
	union {
		void *allocator;
		struct page_pool *page_pool;
		struct zero_copy_allocator *zc_alloc;
	};
	struct rhash_head node;
	struct callback_head rcu;
};

struct trace_event_raw_xdp_exception {
	struct trace_entry ent;
	int prog_id;
	u32 act;
	int ifindex;
	char __data[0];
};

struct trace_event_raw_xdp_bulk_tx {
	struct trace_entry ent;
	int ifindex;
	u32 act;
	int drops;
	int sent;
	int err;
	char __data[0];
};

struct trace_event_raw_xdp_redirect_template {
	struct trace_entry ent;
	int prog_id;
	u32 act;
	int ifindex;
	int err;
	int to_ifindex;
	u32 map_id;
	int map_index;
	char __data[0];
};

struct trace_event_raw_xdp_cpumap_kthread {
	struct trace_entry ent;
	int map_id;
	u32 act;
	int cpu;
	unsigned int drops;
	unsigned int processed;
	int sched;
	unsigned int xdp_pass;
	unsigned int xdp_drop;
	unsigned int xdp_redirect;
	char __data[0];
};

struct trace_event_raw_xdp_cpumap_enqueue {
	struct trace_entry ent;
	int map_id;
	u32 act;
	int cpu;
	unsigned int drops;
	unsigned int processed;
	int to_cpu;
	char __data[0];
};

struct trace_event_raw_xdp_devmap_xmit {
	struct trace_entry ent;
	int from_ifindex;
	u32 act;
	int to_ifindex;
	int drops;
	int sent;
	int err;
	char __data[0];
};

struct trace_event_raw_mem_disconnect {
	struct trace_entry ent;
	const struct xdp_mem_allocator *xa;
	u32 mem_id;
	u32 mem_type;
	const void *allocator;
	char __data[0];
};

struct trace_event_raw_mem_connect {
	struct trace_entry ent;
	const struct xdp_mem_allocator *xa;
	u32 mem_id;
	u32 mem_type;
	const void *allocator;
	const struct xdp_rxq_info *rxq;
	int ifindex;
	char __data[0];
};

struct trace_event_raw_mem_return_failed {
	struct trace_entry ent;
	const struct page *page;
	u32 mem_id;
	u32 mem_type;
	char __data[0];
};

struct trace_event_data_offsets_xdp_exception {};

struct trace_event_data_offsets_xdp_bulk_tx {};

struct trace_event_data_offsets_xdp_redirect_template {};

struct trace_event_data_offsets_xdp_cpumap_kthread {};

struct trace_event_data_offsets_xdp_cpumap_enqueue {};

struct trace_event_data_offsets_xdp_devmap_xmit {};

struct trace_event_data_offsets_mem_disconnect {};

struct trace_event_data_offsets_mem_connect {};

struct trace_event_data_offsets_mem_return_failed {};

typedef void (*btf_trace_xdp_exception)(void *, const struct net_device *, const struct bpf_prog *, u32);

typedef void (*btf_trace_xdp_bulk_tx)(void *, const struct net_device *, int, int, int);

typedef void (*btf_trace_xdp_redirect)(void *, const struct net_device *, const struct bpf_prog *, const void *, int, const struct bpf_map *, u32);

typedef void (*btf_trace_xdp_redirect_err)(void *, const struct net_device *, const struct bpf_prog *, const void *, int, const struct bpf_map *, u32);

typedef void (*btf_trace_xdp_redirect_map)(void *, const struct net_device *, const struct bpf_prog *, const void *, int, const struct bpf_map *, u32);

typedef void (*btf_trace_xdp_redirect_map_err)(void *, const struct net_device *, const struct bpf_prog *, const void *, int, const struct bpf_map *, u32);

typedef void (*btf_trace_xdp_cpumap_kthread)(void *, int, unsigned int, unsigned int, int, struct xdp_cpumap_stats *);

typedef void (*btf_trace_xdp_cpumap_enqueue)(void *, int, unsigned int, unsigned int, int);

typedef void (*btf_trace_xdp_devmap_xmit)(void *, const struct net_device *, const struct net_device *, int, int, int);

typedef void (*btf_trace_mem_disconnect)(void *, const struct xdp_mem_allocator *);

typedef void (*btf_trace_mem_connect)(void *, const struct xdp_mem_allocator *, const struct xdp_rxq_info *);

typedef void (*btf_trace_mem_return_failed)(void *, const struct xdp_mem_info *, const struct page *);

enum bpf_cmd {
	BPF_MAP_CREATE = 0,
	BPF_MAP_LOOKUP_ELEM = 1,
	BPF_MAP_UPDATE_ELEM = 2,
	BPF_MAP_DELETE_ELEM = 3,
	BPF_MAP_GET_NEXT_KEY = 4,
	BPF_PROG_LOAD = 5,
	BPF_OBJ_PIN = 6,
	BPF_OBJ_GET = 7,
	BPF_PROG_ATTACH = 8,
	BPF_PROG_DETACH = 9,
	BPF_PROG_TEST_RUN = 10,
	BPF_PROG_GET_NEXT_ID = 11,
	BPF_MAP_GET_NEXT_ID = 12,
	BPF_PROG_GET_FD_BY_ID = 13,
	BPF_MAP_GET_FD_BY_ID = 14,
	BPF_OBJ_GET_INFO_BY_FD = 15,
	BPF_PROG_QUERY = 16,
	BPF_RAW_TRACEPOINT_OPEN = 17,
	BPF_BTF_LOAD = 18,
	BPF_BTF_GET_FD_BY_ID = 19,
	BPF_TASK_FD_QUERY = 20,
	BPF_MAP_LOOKUP_AND_DELETE_ELEM = 21,
	BPF_MAP_FREEZE = 22,
	BPF_BTF_GET_NEXT_ID = 23,
	BPF_MAP_LOOKUP_BATCH = 24,
	BPF_MAP_LOOKUP_AND_DELETE_BATCH = 25,
	BPF_MAP_UPDATE_BATCH = 26,
	BPF_MAP_DELETE_BATCH = 27,
	BPF_LINK_CREATE = 28,
	BPF_LINK_UPDATE = 29,
	BPF_LINK_GET_FD_BY_ID = 30,
	BPF_LINK_GET_NEXT_ID = 31,
	BPF_ENABLE_STATS = 32,
	BPF_ITER_CREATE = 33,
	BPF_LINK_DETACH = 34,
	BPF_PROG_BIND_MAP = 35,
};

enum bpf_link_type {
	BPF_LINK_TYPE_UNSPEC = 0,
	BPF_LINK_TYPE_RAW_TRACEPOINT = 1,
	BPF_LINK_TYPE_TRACING = 2,
	BPF_LINK_TYPE_CGROUP = 3,
	BPF_LINK_TYPE_ITER = 4,
	BPF_LINK_TYPE_NETNS = 5,
	BPF_LINK_TYPE_XDP = 6,
	MAX_BPF_LINK_TYPE = 7,
};

enum {
	BPF_ANY = 0,
	BPF_NOEXIST = 1,
	BPF_EXIST = 2,
	BPF_F_LOCK = 4,
};

enum {
	BPF_F_NO_PREALLOC = 1,
	BPF_F_NO_COMMON_LRU = 2,
	BPF_F_NUMA_NODE = 4,
	BPF_F_RDONLY = 8,
	BPF_F_WRONLY = 16,
	BPF_F_STACK_BUILD_ID = 32,
	BPF_F_ZERO_SEED = 64,
	BPF_F_RDONLY_PROG = 128,
	BPF_F_WRONLY_PROG = 256,
	BPF_F_CLONE = 512,
	BPF_F_MMAPABLE = 1024,
	BPF_F_PRESERVE_ELEMS = 2048,
	BPF_F_INNER_MAP = 4096,
};

enum bpf_stats_type {
	BPF_STATS_RUN_TIME = 0,
};

struct bpf_prog_info {
	__u32 type;
	__u32 id;
	__u8 tag[8];
	__u32 jited_prog_len;
	__u32 xlated_prog_len;
	__u64 jited_prog_insns;
	__u64 xlated_prog_insns;
	__u64 load_time;
	__u32 created_by_uid;
	__u32 nr_map_ids;
	__u64 map_ids;
	char name[16];
	__u32 ifindex;
	__u32 gpl_compatible: 1;
	__u64 netns_dev;
	__u64 netns_ino;
	__u32 nr_jited_ksyms;
	__u32 nr_jited_func_lens;
	__u64 jited_ksyms;
	__u64 jited_func_lens;
	__u32 btf_id;
	__u32 func_info_rec_size;
	__u64 func_info;
	__u32 nr_func_info;
	__u32 nr_line_info;
	__u64 line_info;
	__u64 jited_line_info;
	__u32 nr_jited_line_info;
	__u32 line_info_rec_size;
	__u32 jited_line_info_rec_size;
	__u32 nr_prog_tags;
	__u64 prog_tags;
	__u64 run_time_ns;
	__u64 run_cnt;
};

struct bpf_map_info {
	__u32 type;
	__u32 id;
	__u32 key_size;
	__u32 value_size;
	__u32 max_entries;
	__u32 map_flags;
	char name[16];
	__u32 ifindex;
	__u32 btf_vmlinux_value_type_id;
	__u64 netns_dev;
	__u64 netns_ino;
	__u32 btf_id;
	__u32 btf_key_type_id;
	__u32 btf_value_type_id;
};

struct bpf_btf_info {
	__u64 btf;
	__u32 btf_size;
	__u32 id;
};

struct bpf_link_info {
	__u32 type;
	__u32 id;
	__u32 prog_id;
	union {
		struct {
			__u64 tp_name;
			__u32 tp_name_len;
		} raw_tracepoint;
		struct {
			__u32 attach_type;
		} tracing;
		struct {
			__u64 cgroup_id;
			__u32 attach_type;
		} cgroup;
		struct {
			__u64 target_name;
			__u32 target_name_len;
			union {
				struct {
					__u32 map_id;
				} map;
			};
		} iter;
		struct {
			__u32 netns_ino;
			__u32 attach_type;
		} netns;
		struct {
			__u32 ifindex;
		} xdp;
	};
};

struct bpf_spin_lock {
	__u32 val;
};

struct bpf_attach_target_info {
	struct btf_func_model fmodel;
	long int tgt_addr;
	const char *tgt_name;
	const struct btf_type *tgt_type;
};

struct bpf_link_ops;

struct bpf_link {
	atomic64_t refcnt;
	u32 id;
	enum bpf_link_type type;
	const struct bpf_link_ops *ops;
	struct bpf_prog *prog;
	struct work_struct work;
};

struct bpf_link_ops {
	void (*release)(struct bpf_link *);
	void (*dealloc)(struct bpf_link *);
	int (*detach)(struct bpf_link *);
	int (*update_prog)(struct bpf_link *, struct bpf_prog *, struct bpf_prog *);
	void (*show_fdinfo)(const struct bpf_link *, struct seq_file *);
	int (*fill_link_info)(const struct bpf_link *, struct bpf_link_info *);
};

struct bpf_link_primer {
	struct bpf_link *link;
	struct file *file;
	int fd;
	u32 id;
};

enum perf_bpf_event_type {
	PERF_BPF_EVENT_UNKNOWN = 0,
	PERF_BPF_EVENT_PROG_LOAD = 1,
	PERF_BPF_EVENT_PROG_UNLOAD = 2,
	PERF_BPF_EVENT_MAX = 3,
};

enum bpf_audit {
	BPF_AUDIT_LOAD = 0,
	BPF_AUDIT_UNLOAD = 1,
	BPF_AUDIT_MAX = 2,
};

struct bpf_tracing_link {
	struct bpf_link link;
	enum bpf_attach_type attach_type;
	struct bpf_trampoline *trampoline;
	struct bpf_prog *tgt_prog;
};

struct bpf_raw_tp_link {
	struct bpf_link link;
	struct bpf_raw_event_map *btp;
};

struct audit_buffer;

struct btf_member {
	__u32 name_off;
	__u32 type;
	__u32 offset;
};

enum btf_func_linkage {
	BTF_FUNC_STATIC = 0,
	BTF_FUNC_GLOBAL = 1,
	BTF_FUNC_EXTERN = 2,
};

struct btf_var_secinfo {
	__u32 type;
	__u32 offset;
	__u32 size;
};

enum sk_action {
	SK_DROP = 0,
	SK_PASS = 1,
};

struct bpf_verifier_log {
	u32 level;
	char kbuf[1024];
	char *ubuf;
	u32 len_used;
	u32 len_total;
};

struct bpf_subprog_info {
	u32 start;
	u32 linfo_idx;
	u16 stack_depth;
	bool has_tail_call;
	bool tail_call_reachable;
	bool has_ld_abs;
};

struct bpf_id_pair {
	u32 old;
	u32 cur;
};

struct bpf_verifier_stack_elem;

struct bpf_verifier_state;

struct bpf_verifier_state_list;

struct bpf_insn_aux_data;

struct bpf_verifier_env {
	u32 insn_idx;
	u32 prev_insn_idx;
	struct bpf_prog *prog;
	const struct bpf_verifier_ops *ops;
	struct bpf_verifier_stack_elem *head;
	int stack_size;
	bool strict_alignment;
	bool test_state_freq;
	struct bpf_verifier_state *cur_state;
	struct bpf_verifier_state_list **explored_states;
	struct bpf_verifier_state_list *free_list;
	struct bpf_map *used_maps[64];
	u32 used_map_cnt;
	u32 id_gen;
	bool explore_alu_limits;
	bool allow_ptr_leaks;
	bool allow_uninit_stack;
	bool allow_ptr_to_map_access;
	bool bpf_capable;
	bool bypass_spec_v1;
	bool bypass_spec_v4;
	bool seen_direct_write;
	struct bpf_insn_aux_data *insn_aux_data;
	const struct bpf_line_info *prev_linfo;
	struct bpf_verifier_log log;
	struct bpf_subprog_info subprog_info[257];
	struct bpf_id_pair idmap_scratch[75];
	struct {
		int *insn_state;
		int *insn_stack;
		int cur_stack;
	} cfg;
	u32 pass_cnt;
	u32 subprog_cnt;
	u32 prev_insn_processed;
	u32 insn_processed;
	u32 prev_jmps_processed;
	u32 jmps_processed;
	u64 verification_time;
	u32 max_states_per_insn;
	u32 total_states;
	u32 peak_states;
	u32 longest_mark_read_walk;
};

struct bpf_struct_ops {
	const struct bpf_verifier_ops *verifier_ops;
	int (*init)(struct btf *);
	int (*check_member)(const struct btf_type *, const struct btf_member *);
	int (*init_member)(const struct btf_type *, const struct btf_member *, void *, const void *);
	int (*reg)(void *);
	void (*unreg)(void *);
	const struct btf_type *type;
	const struct btf_type *value_type;
	const char *name;
	struct btf_func_model func_models[64];
	u32 type_id;
	u32 value_id;
};

typedef u32 (*bpf_convert_ctx_access_t)(enum bpf_access_type, const struct bpf_insn *, struct bpf_insn *, struct bpf_prog *, u32 *);

struct tnum {
	u64 value;
	u64 mask;
};

enum bpf_reg_liveness {
	REG_LIVE_NONE = 0,
	REG_LIVE_READ32 = 1,
	REG_LIVE_READ64 = 2,
	REG_LIVE_READ = 3,
	REG_LIVE_WRITTEN = 4,
	REG_LIVE_DONE = 8,
};

struct bpf_reg_state {
	enum bpf_reg_type type;
	union {
		u16 range;
		struct bpf_map *map_ptr;
		u32 btf_id;
		u32 mem_size;
		long unsigned int raw;
	};
	s32 off;
	u32 id;
	u32 ref_obj_id;
	struct tnum var_off;
	s64 smin_value;
	s64 smax_value;
	u64 umin_value;
	u64 umax_value;
	s32 s32_min_value;
	s32 s32_max_value;
	u32 u32_min_value;
	u32 u32_max_value;
	struct bpf_reg_state *parent;
	u32 frameno;
	s32 subreg_def;
	enum bpf_reg_liveness live;
	bool precise;
};

enum bpf_stack_slot_type {
	STACK_INVALID = 0,
	STACK_SPILL = 1,
	STACK_MISC = 2,
	STACK_ZERO = 3,
};

struct bpf_stack_state {
	struct bpf_reg_state spilled_ptr;
	u8 slot_type[8];
};

struct bpf_reference_state {
	int id;
	int insn_idx;
};

struct bpf_func_state {
	struct bpf_reg_state regs[11];
	int callsite;
	u32 frameno;
	u32 subprogno;
	int acquired_refs;
	struct bpf_reference_state *refs;
	int allocated_stack;
	struct bpf_stack_state *stack;
};

struct bpf_idx_pair {
	u32 prev_idx;
	u32 idx;
};

struct bpf_verifier_state {
	struct bpf_func_state *frame[8];
	struct bpf_verifier_state *parent;
	u32 branches;
	u32 insn_idx;
	u32 curframe;
	u32 active_spin_lock;
	bool speculative;
	u32 first_insn_idx;
	u32 last_insn_idx;
	struct bpf_idx_pair *jmp_history;
	u32 jmp_history_cnt;
};

struct bpf_verifier_state_list {
	struct bpf_verifier_state state;
	struct bpf_verifier_state_list *next;
	int miss_cnt;
	int hit_cnt;
};

struct bpf_insn_aux_data {
	union {
		enum bpf_reg_type ptr_type;
		long unsigned int map_ptr_state;
		s32 call_imm;
		u32 alu_limit;
		struct {
			u32 map_index;
			u32 map_off;
		};
		struct {
			enum bpf_reg_type reg_type;
			union {
				u32 btf_id;
				u32 mem_size;
			};
		} btf_var;
	};
	u64 map_key_state;
	int ctx_field_size;
	u32 seen;
	bool sanitize_stack_spill;
	bool zext_dst;
	u8 alu_state;
	unsigned int orig_idx;
	bool prune_point;
};

struct bpf_verifier_stack_elem {
	struct bpf_verifier_state st;
	int insn_idx;
	int prev_insn_idx;
	struct bpf_verifier_stack_elem *next;
	u32 log_pos;
};

enum {
	BTF_SOCK_TYPE_INET = 0,
	BTF_SOCK_TYPE_INET_CONN = 1,
	BTF_SOCK_TYPE_INET_REQ = 2,
	BTF_SOCK_TYPE_INET_TW = 3,
	BTF_SOCK_TYPE_REQ = 4,
	BTF_SOCK_TYPE_SOCK = 5,
	BTF_SOCK_TYPE_SOCK_COMMON = 6,
	BTF_SOCK_TYPE_TCP = 7,
	BTF_SOCK_TYPE_TCP_REQ = 8,
	BTF_SOCK_TYPE_TCP_TW = 9,
	BTF_SOCK_TYPE_TCP6 = 10,
	BTF_SOCK_TYPE_UDP = 11,
	BTF_SOCK_TYPE_UDP6 = 12,
	MAX_BTF_SOCK_TYPE = 13,
};

typedef void (*bpf_insn_print_t)(void *, const char *, ...);

typedef const char * (*bpf_insn_revmap_call_t)(void *, const struct bpf_insn *);

typedef const char * (*bpf_insn_print_imm_t)(void *, const struct bpf_insn *, __u64);

struct bpf_insn_cbs {
	bpf_insn_print_t cb_print;
	bpf_insn_revmap_call_t cb_call;
	bpf_insn_print_imm_t cb_imm;
	void *private_data;
};

struct bpf_call_arg_meta {
	struct bpf_map *map_ptr;
	bool raw_mode;
	bool pkt_access;
	int regno;
	int access_size;
	int mem_size;
	u64 msize_max_value;
	int ref_obj_id;
	int func_id;
	u32 btf_id;
	u32 ret_btf_id;
};

enum reg_arg_type {
	SRC_OP = 0,
	DST_OP = 1,
	DST_OP_NO_MARK = 2,
};

enum stack_access_src {
	ACCESS_DIRECT = 1,
	ACCESS_HELPER = 2,
};

struct bpf_reg_types {
	const enum bpf_reg_type types[10];
	u32 *btf_id;
};

enum {
	REASON_BOUNDS = 4294967295,
	REASON_TYPE = 4294967294,
	REASON_PATHS = 4294967293,
	REASON_LIMIT = 4294967292,
	REASON_STACK = 4294967291,
};

struct bpf_sanitize_info {
	struct bpf_insn_aux_data aux;
	bool mask_to_left;
};

enum {
	DISCOVERED = 16,
	EXPLORED = 32,
	FALLTHROUGH = 1,
	BRANCH = 2,
};

struct tree_descr {
	const char *name;
	const struct file_operations *ops;
	int mode;
};

struct umd_info {
	const char *driver_name;
	struct file *pipe_to_umh;
	struct file *pipe_from_umh;
	struct path wd;
	struct pid *tgid;
};

struct bpf_preload_info {
	char link_name[16];
	int link_id;
};

struct bpf_preload_ops {
	struct umd_info info;
	int (*preload)(struct bpf_preload_info *);
	int (*finish)();
	struct module *owner;
};

enum bpf_type {
	BPF_TYPE_UNSPEC = 0,
	BPF_TYPE_PROG = 1,
	BPF_TYPE_MAP = 2,
	BPF_TYPE_LINK = 3,
};

struct map_iter {
	void *key;
	bool done;
};

enum {
	OPT_MODE = 0,
};

struct bpf_mount_opts {
	umode_t mode;
};

struct bpf_pidns_info {
	__u32 pid;
	__u32 tgid;
};

typedef u64 (*btf_bpf_map_lookup_elem)(struct bpf_map *, void *);

typedef u64 (*btf_bpf_map_update_elem)(struct bpf_map *, void *, void *, u64);

typedef u64 (*btf_bpf_map_delete_elem)(struct bpf_map *, void *);

typedef u64 (*btf_bpf_map_push_elem)(struct bpf_map *, void *, u64);

typedef u64 (*btf_bpf_map_pop_elem)(struct bpf_map *, void *);

typedef u64 (*btf_bpf_map_peek_elem)(struct bpf_map *, void *);

typedef u64 (*btf_bpf_get_smp_processor_id)();

typedef u64 (*btf_bpf_get_numa_node_id)();

typedef u64 (*btf_bpf_ktime_get_ns)();

typedef u64 (*btf_bpf_ktime_get_boot_ns)();

typedef u64 (*btf_bpf_get_current_pid_tgid)();

typedef u64 (*btf_bpf_get_current_uid_gid)();

typedef u64 (*btf_bpf_get_current_comm)(char *, u32);

typedef u64 (*btf_bpf_spin_lock)(struct bpf_spin_lock *);

typedef u64 (*btf_bpf_spin_unlock)(struct bpf_spin_lock *);

typedef u64 (*btf_bpf_jiffies64)();

typedef u64 (*btf_bpf_get_current_cgroup_id)();

typedef u64 (*btf_bpf_get_current_ancestor_cgroup_id)(int);

typedef u64 (*btf_bpf_strtol)(const char *, size_t, u64, long int *);

typedef u64 (*btf_bpf_strtoul)(const char *, size_t, u64, long unsigned int *);

typedef u64 (*btf_bpf_get_ns_current_pid_tgid)(u64, u64, struct bpf_pidns_info *, u32);

typedef u64 (*btf_bpf_event_output_data)(void *, struct bpf_map *, u64, void *, u64);

typedef u64 (*btf_bpf_copy_from_user)(void *, u32, const void *);

typedef u64 (*btf_bpf_per_cpu_ptr)(const void *, u32);

typedef u64 (*btf_bpf_this_cpu_ptr)(const void *);

union bpf_iter_link_info {
	struct {
		__u32 map_fd;
	} map;
};

typedef int (*bpf_iter_attach_target_t)(struct bpf_prog *, union bpf_iter_link_info *, struct bpf_iter_aux_info *);

typedef void (*bpf_iter_detach_target_t)(struct bpf_iter_aux_info *);

typedef void (*bpf_iter_show_fdinfo_t)(const struct bpf_iter_aux_info *, struct seq_file *);

typedef int (*bpf_iter_fill_link_info_t)(const struct bpf_iter_aux_info *, struct bpf_link_info *);

struct bpf_iter_reg {
	const char *target;
	bpf_iter_attach_target_t attach_target;
	bpf_iter_detach_target_t detach_target;
	bpf_iter_show_fdinfo_t show_fdinfo;
	bpf_iter_fill_link_info_t fill_link_info;
	u32 ctx_arg_info_size;
	struct bpf_ctx_arg_aux ctx_arg_info[2];
	const struct bpf_iter_seq_info *seq_info;
};

struct bpf_iter_meta {
	union {
		struct seq_file *seq;
	};
	u64 session_id;
	u64 seq_num;
};

struct bpf_iter_target_info {
	struct list_head list;
	const struct bpf_iter_reg *reg_info;
	u32 btf_id;
};

struct bpf_iter_link {
	struct bpf_link link;
	struct bpf_iter_aux_info aux;
	struct bpf_iter_target_info *tinfo;
};

struct bpf_iter_priv_data {
	struct bpf_iter_target_info *tinfo;
	const struct bpf_iter_seq_info *seq_info;
	struct bpf_prog *prog;
	u64 session_id;
	u64 seq_num;
	bool done_stop;
	long: 56;
	u8 target_private[0];
};

struct bpf_iter_seq_map_info {
	u32 map_id;
};

struct bpf_iter__bpf_map {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct bpf_map *map;
	};
};

struct bpf_iter_seq_task_common {
	struct pid_namespace *ns;
};

struct bpf_iter_seq_task_info {
	struct bpf_iter_seq_task_common common;
	u32 tid;
};

struct bpf_iter__task {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct task_struct *task;
	};
};

struct bpf_iter_seq_task_file_info {
	struct bpf_iter_seq_task_common common;
	struct task_struct *task;
	struct files_struct *files;
	u32 tid;
	u32 fd;
};

struct bpf_iter__task_file {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct task_struct *task;
	};
	u32 fd;
	union {
		struct file *file;
	};
};

struct bpf_iter_seq_prog_info {
	u32 prog_id;
};

struct bpf_iter__bpf_prog {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct bpf_prog *prog;
	};
};

struct bpf_iter__bpf_map_elem {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct bpf_map *map;
	};
	union {
		void *key;
	};
	union {
		void *value;
	};
};

struct hlist_nulls_head {
	struct hlist_nulls_node *first;
};

struct pcpu_freelist_node;

struct pcpu_freelist_head {
	struct pcpu_freelist_node *first;
	raw_spinlock_t lock;
};

struct pcpu_freelist_node {
	struct pcpu_freelist_node *next;
};

struct pcpu_freelist {
	struct pcpu_freelist_head *freelist;
	struct pcpu_freelist_head extralist;
};

struct bpf_lru_node {
	struct list_head list;
	u16 cpu;
	u8 type;
	u8 ref;
};

struct bpf_lru_list {
	struct list_head lists[3];
	unsigned int counts[2];
	struct list_head *next_inactive_rotation;
	raw_spinlock_t lock;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct bpf_lru_locallist {
	struct list_head lists[2];
	u16 next_steal;
	raw_spinlock_t lock;
};

struct bpf_common_lru {
	struct bpf_lru_list lru_list;
	struct bpf_lru_locallist *local_list;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

typedef bool (*del_from_htab_func)(void *, struct bpf_lru_node *);

struct bpf_lru {
	union {
		struct bpf_common_lru common_lru;
		struct bpf_lru_list *percpu_lru;
	};
	del_from_htab_func del_from_htab;
	void *del_arg;
	unsigned int hash_offset;
	unsigned int nr_scans;
	bool percpu;
	long: 56;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct bucket {
	struct hlist_nulls_head head;
	union {
		raw_spinlock_t raw_lock;
		spinlock_t lock;
	};
};

struct htab_elem;

struct bpf_htab {
	struct bpf_map map;
	struct bucket *buckets;
	void *elems;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	union {
		struct pcpu_freelist freelist;
		struct bpf_lru lru;
	};
	struct htab_elem **extra_elems;
	atomic_t count;
	u32 n_buckets;
	u32 elem_size;
	u32 hashrnd;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct htab_elem {
	union {
		struct hlist_nulls_node hash_node;
		struct {
			void *padding;
			union {
				struct bpf_htab *htab;
				struct pcpu_freelist_node fnode;
				struct htab_elem *batch_flink;
			};
		};
	};
	union {
		struct callback_head rcu;
		struct bpf_lru_node lru_node;
	};
	u32 hash;
	int: 32;
	char key[0];
};

struct bpf_iter_seq_hash_map_info {
	struct bpf_map *map;
	struct bpf_htab *htab;
	void *percpu_value_buf;
	u32 bucket_id;
	u32 skip_elems;
};

struct bpf_iter_seq_array_map_info {
	struct bpf_map *map;
	void *percpu_value_buf;
	u32 index;
};

struct prog_poke_elem {
	struct list_head list;
	struct bpf_prog_aux *aux;
};

enum bpf_lru_list_type {
	BPF_LRU_LIST_T_ACTIVE = 0,
	BPF_LRU_LIST_T_INACTIVE = 1,
	BPF_LRU_LIST_T_FREE = 2,
	BPF_LRU_LOCAL_LIST_T_FREE = 3,
	BPF_LRU_LOCAL_LIST_T_PENDING = 4,
};

struct bpf_lpm_trie_key {
	__u32 prefixlen;
	__u8 data[0];
};

struct lpm_trie_node {
	struct callback_head rcu;
	struct lpm_trie_node *child[2];
	u32 prefixlen;
	u32 flags;
	u8 data[0];
};

struct lpm_trie {
	struct bpf_map map;
	struct lpm_trie_node *root;
	size_t n_entries;
	size_t max_prefixlen;
	size_t data_size;
	spinlock_t lock;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
};

struct bpf_queue_stack {
	struct bpf_map map;
	raw_spinlock_t lock;
	u32 head;
	u32 tail;
	u32 size;
	char elements[0];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

enum {
	BPF_RB_NO_WAKEUP = 1,
	BPF_RB_FORCE_WAKEUP = 2,
};

enum {
	BPF_RB_AVAIL_DATA = 0,
	BPF_RB_RING_SIZE = 1,
	BPF_RB_CONS_POS = 2,
	BPF_RB_PROD_POS = 3,
};

enum {
	BPF_RINGBUF_BUSY_BIT = 2147483648,
	BPF_RINGBUF_DISCARD_BIT = 1073741824,
	BPF_RINGBUF_HDR_SZ = 8,
};

struct bpf_ringbuf {
	wait_queue_head_t waitq;
	struct irq_work work;
	u64 mask;
	struct page **pages;
	int nr_pages;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	spinlock_t spinlock;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long unsigned int consumer_pos;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long unsigned int producer_pos;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	char data[0];
};

struct bpf_ringbuf_map {
	struct bpf_map map;
	struct bpf_map_memory memory;
	struct bpf_ringbuf *rb;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct bpf_ringbuf_hdr {
	u32 len;
	u32 pg_off;
};

typedef u64 (*btf_bpf_ringbuf_reserve)(struct bpf_map *, u64, u64);

typedef u64 (*btf_bpf_ringbuf_submit)(void *, u64);

typedef u64 (*btf_bpf_ringbuf_discard)(void *, u64);

typedef u64 (*btf_bpf_ringbuf_output)(struct bpf_map *, void *, u64, u64);

typedef u64 (*btf_bpf_ringbuf_query)(struct bpf_map *, u64);

struct bpf_tramp_progs {
	struct bpf_prog *progs[40];
	int nr_progs;
};

struct btf_enum {
	__u32 name_off;
	__s32 val;
};

struct btf_array {
	__u32 type;
	__u32 index_type;
	__u32 nelems;
};

struct btf_param {
	__u32 name_off;
	__u32 type;
};

enum {
	BTF_VAR_STATIC = 0,
	BTF_VAR_GLOBAL_ALLOCATED = 1,
	BTF_VAR_GLOBAL_EXTERN = 2,
};

struct btf_var {
	__u32 linkage;
};

struct bpf_flow_keys {
	__u16 nhoff;
	__u16 thoff;
	__u16 addr_proto;
	__u8 is_frag;
	__u8 is_first_frag;
	__u8 is_encap;
	__u8 ip_proto;
	__be16 n_proto;
	__be16 sport;
	__be16 dport;
	union {
		struct {
			__be32 ipv4_src;
			__be32 ipv4_dst;
		};
		struct {
			__u32 ipv6_src[4];
			__u32 ipv6_dst[4];
		};
	};
	__u32 flags;
	__be32 flow_label;
};

struct bpf_sock {
	__u32 bound_dev_if;
	__u32 family;
	__u32 type;
	__u32 protocol;
	__u32 mark;
	__u32 priority;
	__u32 src_ip4;
	__u32 src_ip6[4];
	__u32 src_port;
	__be16 dst_port;
	__u32 dst_ip4;
	__u32 dst_ip6[4];
	__u32 state;
	__s32 rx_queue_mapping;
};

struct __sk_buff {
	__u32 len;
	__u32 pkt_type;
	__u32 mark;
	__u32 queue_mapping;
	__u32 protocol;
	__u32 vlan_present;
	__u32 vlan_tci;
	__u32 vlan_proto;
	__u32 priority;
	__u32 ingress_ifindex;
	__u32 ifindex;
	__u32 tc_index;
	__u32 cb[5];
	__u32 hash;
	__u32 tc_classid;
	__u32 data;
	__u32 data_end;
	__u32 napi_id;
	__u32 family;
	__u32 remote_ip4;
	__u32 local_ip4;
	__u32 remote_ip6[4];
	__u32 local_ip6[4];
	__u32 remote_port;
	__u32 local_port;
	__u32 data_meta;
	union {
		struct bpf_flow_keys *flow_keys;
	};
	__u64 tstamp;
	__u32 wire_len;
	__u32 gso_segs;
	union {
		struct bpf_sock *sk;
	};
	__u32 gso_size;
};

struct xdp_md {
	__u32 data;
	__u32 data_end;
	__u32 data_meta;
	__u32 ingress_ifindex;
	__u32 rx_queue_index;
	__u32 egress_ifindex;
};

struct sk_msg_md {
	union {
		void *data;
	};
	union {
		void *data_end;
	};
	__u32 family;
	__u32 remote_ip4;
	__u32 local_ip4;
	__u32 remote_ip6[4];
	__u32 local_ip6[4];
	__u32 remote_port;
	__u32 local_port;
	__u32 size;
	union {
		struct bpf_sock *sk;
	};
};

struct sk_reuseport_md {
	union {
		void *data;
	};
	union {
		void *data_end;
	};
	__u32 len;
	__u32 eth_protocol;
	__u32 ip_protocol;
	__u32 bind_inany;
	__u32 hash;
};

struct bpf_sock_ops {
	__u32 op;
	union {
		__u32 args[4];
		__u32 reply;
		__u32 replylong[4];
	};
	__u32 family;
	__u32 remote_ip4;
	__u32 local_ip4;
	__u32 remote_ip6[4];
	__u32 local_ip6[4];
	__u32 remote_port;
	__u32 local_port;
	__u32 is_fullsock;
	__u32 snd_cwnd;
	__u32 srtt_us;
	__u32 bpf_sock_ops_cb_flags;
	__u32 state;
	__u32 rtt_min;
	__u32 snd_ssthresh;
	__u32 rcv_nxt;
	__u32 snd_nxt;
	__u32 snd_una;
	__u32 mss_cache;
	__u32 ecn_flags;
	__u32 rate_delivered;
	__u32 rate_interval_us;
	__u32 packets_out;
	__u32 retrans_out;
	__u32 total_retrans;
	__u32 segs_in;
	__u32 data_segs_in;
	__u32 segs_out;
	__u32 data_segs_out;
	__u32 lost_out;
	__u32 sacked_out;
	__u32 sk_txhash;
	__u64 bytes_received;
	__u64 bytes_acked;
	union {
		struct bpf_sock *sk;
	};
	union {
		void *skb_data;
	};
	union {
		void *skb_data_end;
	};
	__u32 skb_len;
	__u32 skb_tcp_flags;
};

struct bpf_sk_lookup {
	union {
		struct bpf_sock *sk;
	};
	__u32 family;
	__u32 protocol;
	__u32 remote_ip4;
	__u32 remote_ip6[4];
	__u32 remote_port;
	__u32 local_ip4;
	__u32 local_ip6[4];
	__u32 local_port;
};

struct sk_reuseport_kern {
	struct sk_buff *skb;
	struct sock *sk;
	struct sock *selected_sk;
	void *data_end;
	u32 hash;
	u32 reuseport_id;
	bool bind_inany;
};

struct bpf_flow_dissector {
	struct bpf_flow_keys *flow_keys;
	const struct sk_buff *skb;
	void *data;
	void *data_end;
};

struct inet_listen_hashbucket {
	spinlock_t lock;
	unsigned int count;
	union {
		struct hlist_head head;
		struct hlist_nulls_head nulls_head;
	};
};

struct inet_ehash_bucket;

struct inet_bind_hashbucket;

struct inet_hashinfo {
	struct inet_ehash_bucket *ehash;
	spinlock_t *ehash_locks;
	unsigned int ehash_mask;
	unsigned int ehash_locks_mask;
	struct kmem_cache *bind_bucket_cachep;
	struct inet_bind_hashbucket *bhash;
	unsigned int bhash_size;
	unsigned int lhash2_mask;
	struct inet_listen_hashbucket *lhash2;
	long: 64;
	struct inet_listen_hashbucket listening_hash[32];
};

struct ip_ra_chain {
	struct ip_ra_chain *next;
	struct sock *sk;
	union {
		void (*destructor)(struct sock *);
		struct sock *saved_sk;
	};
	struct callback_head rcu;
};

struct inet_peer_base {
	struct rb_root rb_root;
	seqlock_t lock;
	int total;
};

struct tcp_fastopen_context {
	siphash_key_t key[2];
	int num;
	struct callback_head rcu;
};

struct xdp_txq_info {
	struct net_device *dev;
};

struct xdp_buff {
	void *data;
	void *data_end;
	void *data_meta;
	void *data_hard_start;
	struct xdp_rxq_info *rxq;
	struct xdp_txq_info *txq;
	u32 frame_sz;
};

struct bpf_sock_ops_kern {
	struct sock *sk;
	union {
		u32 args[4];
		u32 reply;
		u32 replylong[4];
	};
	struct sk_buff *syn_skb;
	struct sk_buff *skb;
	void *skb_data_end;
	u8 op;
	u8 is_fullsock;
	u8 remaining_opt_len;
	u64 temp;
};

struct bpf_sk_lookup_kern {
	u16 family;
	u16 protocol;
	__be16 sport;
	u16 dport;
	struct {
		__be32 saddr;
		__be32 daddr;
	} v4;
	struct {
		const struct in6_addr *saddr;
		const struct in6_addr *daddr;
	} v6;
	struct sock *selected_sk;
	bool no_reuseport;
};

struct lwtunnel_state {
	__u16 type;
	__u16 flags;
	__u16 headroom;
	atomic_t refcnt;
	int (*orig_output)(struct net *, struct sock *, struct sk_buff *);
	int (*orig_input)(struct sk_buff *);
	struct callback_head rcu;
	__u8 data[0];
};

struct sock_reuseport {
	struct callback_head rcu;
	u16 max_socks;
	u16 num_socks;
	unsigned int synq_overflow_ts;
	unsigned int reuseport_id;
	unsigned int bind_inany: 1;
	unsigned int has_conns: 1;
	struct bpf_prog *prog;
	struct sock *socks[0];
};

struct inet_ehash_bucket {
	struct hlist_nulls_head chain;
};

struct inet_bind_hashbucket {
	spinlock_t lock;
	struct hlist_head chain;
};

struct ack_sample {
	u32 pkts_acked;
	s32 rtt_us;
	u32 in_flight;
};

struct rate_sample {
	u64 prior_mstamp;
	u32 prior_delivered;
	s32 delivered;
	long int interval_us;
	u32 snd_interval_us;
	u32 rcv_interval_us;
	long int rtt_us;
	int losses;
	u32 acked_sacked;
	u32 prior_in_flight;
	bool is_app_limited;
	bool is_retrans;
	bool is_ack_delayed;
};

struct sk_msg_sg {
	u32 start;
	u32 curr;
	u32 end;
	u32 size;
	u32 copybreak;
	long unsigned int copy;
	struct scatterlist data[19];
};

struct sk_msg {
	struct sk_msg_sg sg;
	void *data;
	void *data_end;
	u32 apply_bytes;
	u32 cork_bytes;
	u32 flags;
	struct sk_buff *skb;
	struct sock *sk_redir;
	struct sock *sk;
	struct list_head list;
};

enum verifier_phase {
	CHECK_META = 0,
	CHECK_TYPE = 1,
};

struct resolve_vertex {
	const struct btf_type *t;
	u32 type_id;
	u16 next_member;
};

enum visit_state {
	NOT_VISITED = 0,
	VISITED = 1,
	RESOLVED = 2,
};

enum resolve_mode {
	RESOLVE_TBD = 0,
	RESOLVE_PTR = 1,
	RESOLVE_STRUCT_OR_ARRAY = 2,
};

struct btf_sec_info {
	u32 off;
	u32 len;
};

struct btf_verifier_env {
	struct btf *btf;
	u8 *visit_states;
	struct resolve_vertex stack[32];
	struct bpf_verifier_log log;
	u32 log_type_id;
	u32 top_stack;
	enum verifier_phase phase;
	enum resolve_mode resolve_mode;
};

struct btf_show {
	u64 flags;
	void *target;
	void (*showfn)(struct btf_show *, const char *, va_list);
	const struct btf *btf;
	struct {
		u8 depth;
		u8 depth_to_show;
		u8 depth_check;
		u8 array_member: 1;
		u8 array_terminated: 1;
		u16 array_encoding;
		u32 type_id;
		int status;
		const struct btf_type *type;
		const struct btf_member *member;
		char name[80];
	} state;
	struct {
		u32 size;
		void *head;
		void *data;
		u8 safe[32];
	} obj;
};

struct btf_kind_operations {
	s32 (*check_meta)(struct btf_verifier_env *, const struct btf_type *, u32);
	int (*resolve)(struct btf_verifier_env *, const struct resolve_vertex *);
	int (*check_member)(struct btf_verifier_env *, const struct btf_type *, const struct btf_member *, const struct btf_type *);
	int (*check_kflag_member)(struct btf_verifier_env *, const struct btf_type *, const struct btf_member *, const struct btf_type *);
	void (*log_details)(struct btf_verifier_env *, const struct btf_type *);
	void (*show)(const struct btf *, const struct btf_type *, u32, void *, u8, struct btf_show *);
};

struct bpf_ctx_convert {
	struct __sk_buff BPF_PROG_TYPE_SOCKET_FILTER_prog;
	struct sk_buff BPF_PROG_TYPE_SOCKET_FILTER_kern;
	struct __sk_buff BPF_PROG_TYPE_SCHED_CLS_prog;
	struct sk_buff BPF_PROG_TYPE_SCHED_CLS_kern;
	struct __sk_buff BPF_PROG_TYPE_SCHED_ACT_prog;
	struct sk_buff BPF_PROG_TYPE_SCHED_ACT_kern;
	struct xdp_md BPF_PROG_TYPE_XDP_prog;
	struct xdp_buff BPF_PROG_TYPE_XDP_kern;
	struct __sk_buff BPF_PROG_TYPE_LWT_IN_prog;
	struct sk_buff BPF_PROG_TYPE_LWT_IN_kern;
	struct __sk_buff BPF_PROG_TYPE_LWT_OUT_prog;
	struct sk_buff BPF_PROG_TYPE_LWT_OUT_kern;
	struct __sk_buff BPF_PROG_TYPE_LWT_XMIT_prog;
	struct sk_buff BPF_PROG_TYPE_LWT_XMIT_kern;
	struct __sk_buff BPF_PROG_TYPE_LWT_SEG6LOCAL_prog;
	struct sk_buff BPF_PROG_TYPE_LWT_SEG6LOCAL_kern;
	struct bpf_sock_ops BPF_PROG_TYPE_SOCK_OPS_prog;
	struct bpf_sock_ops_kern BPF_PROG_TYPE_SOCK_OPS_kern;
	struct __sk_buff BPF_PROG_TYPE_SK_SKB_prog;
	struct sk_buff BPF_PROG_TYPE_SK_SKB_kern;
	struct sk_msg_md BPF_PROG_TYPE_SK_MSG_prog;
	struct sk_msg BPF_PROG_TYPE_SK_MSG_kern;
	struct __sk_buff BPF_PROG_TYPE_FLOW_DISSECTOR_prog;
	struct bpf_flow_dissector BPF_PROG_TYPE_FLOW_DISSECTOR_kern;
	bpf_user_pt_regs_t BPF_PROG_TYPE_KPROBE_prog;
	struct pt_regs BPF_PROG_TYPE_KPROBE_kern;
	__u64 BPF_PROG_TYPE_TRACEPOINT_prog;
	u64 BPF_PROG_TYPE_TRACEPOINT_kern;
	struct bpf_perf_event_data BPF_PROG_TYPE_PERF_EVENT_prog;
	struct bpf_perf_event_data_kern BPF_PROG_TYPE_PERF_EVENT_kern;
	struct bpf_raw_tracepoint_args BPF_PROG_TYPE_RAW_TRACEPOINT_prog;
	u64 BPF_PROG_TYPE_RAW_TRACEPOINT_kern;
	struct bpf_raw_tracepoint_args BPF_PROG_TYPE_RAW_TRACEPOINT_WRITABLE_prog;
	u64 BPF_PROG_TYPE_RAW_TRACEPOINT_WRITABLE_kern;
	void *BPF_PROG_TYPE_TRACING_prog;
	void *BPF_PROG_TYPE_TRACING_kern;
	struct sk_reuseport_md BPF_PROG_TYPE_SK_REUSEPORT_prog;
	struct sk_reuseport_kern BPF_PROG_TYPE_SK_REUSEPORT_kern;
	struct bpf_sk_lookup BPF_PROG_TYPE_SK_LOOKUP_prog;
	struct bpf_sk_lookup_kern BPF_PROG_TYPE_SK_LOOKUP_kern;
	void *BPF_PROG_TYPE_STRUCT_OPS_prog;
	void *BPF_PROG_TYPE_STRUCT_OPS_kern;
	void *BPF_PROG_TYPE_EXT_prog;
	void *BPF_PROG_TYPE_EXT_kern;
};

enum {
	__ctx_convertBPF_PROG_TYPE_SOCKET_FILTER = 0,
	__ctx_convertBPF_PROG_TYPE_SCHED_CLS = 1,
	__ctx_convertBPF_PROG_TYPE_SCHED_ACT = 2,
	__ctx_convertBPF_PROG_TYPE_XDP = 3,
	__ctx_convertBPF_PROG_TYPE_LWT_IN = 4,
	__ctx_convertBPF_PROG_TYPE_LWT_OUT = 5,
	__ctx_convertBPF_PROG_TYPE_LWT_XMIT = 6,
	__ctx_convertBPF_PROG_TYPE_LWT_SEG6LOCAL = 7,
	__ctx_convertBPF_PROG_TYPE_SOCK_OPS = 8,
	__ctx_convertBPF_PROG_TYPE_SK_SKB = 9,
	__ctx_convertBPF_PROG_TYPE_SK_MSG = 10,
	__ctx_convertBPF_PROG_TYPE_FLOW_DISSECTOR = 11,
	__ctx_convertBPF_PROG_TYPE_KPROBE = 12,
	__ctx_convertBPF_PROG_TYPE_TRACEPOINT = 13,
	__ctx_convertBPF_PROG_TYPE_PERF_EVENT = 14,
	__ctx_convertBPF_PROG_TYPE_RAW_TRACEPOINT = 15,
	__ctx_convertBPF_PROG_TYPE_RAW_TRACEPOINT_WRITABLE = 16,
	__ctx_convertBPF_PROG_TYPE_TRACING = 17,
	__ctx_convertBPF_PROG_TYPE_SK_REUSEPORT = 18,
	__ctx_convertBPF_PROG_TYPE_SK_LOOKUP = 19,
	__ctx_convertBPF_PROG_TYPE_STRUCT_OPS = 20,
	__ctx_convertBPF_PROG_TYPE_EXT = 21,
	__ctx_convert_unused = 22,
};

enum bpf_struct_walk_result {
	WALK_SCALAR = 0,
	WALK_PTR = 1,
	WALK_STRUCT = 2,
};

struct btf_show_snprintf {
	struct btf_show show;
	int len_left;
	int len;
};

struct bpf_dispatcher_prog {
	struct bpf_prog *prog;
	refcount_t users;
};

struct bpf_dispatcher {
	struct mutex mutex;
	void *func;
	struct bpf_dispatcher_prog progs[48];
	int num_progs;
	void *image;
	u32 image_off;
	struct bpf_ksym ksym;
};

struct bpf_devmap_val {
	__u32 ifindex;
	union {
		int fd;
		__u32 id;
	} bpf_prog;
};

enum net_device_flags {
	IFF_UP = 1,
	IFF_BROADCAST = 2,
	IFF_DEBUG = 4,
	IFF_LOOPBACK = 8,
	IFF_POINTOPOINT = 16,
	IFF_NOTRAILERS = 32,
	IFF_RUNNING = 64,
	IFF_NOARP = 128,
	IFF_PROMISC = 256,
	IFF_ALLMULTI = 512,
	IFF_MASTER = 1024,
	IFF_SLAVE = 2048,
	IFF_MULTICAST = 4096,
	IFF_PORTSEL = 8192,
	IFF_AUTOMEDIA = 16384,
	IFF_DYNAMIC = 32768,
	IFF_LOWER_UP = 65536,
	IFF_DORMANT = 131072,
	IFF_ECHO = 262144,
};

struct xdp_dev_bulk_queue {
	struct xdp_frame *q[16];
	struct list_head flush_node;
	struct net_device *dev;
	struct net_device *dev_rx;
	unsigned int count;
};

enum netdev_cmd {
	NETDEV_UP = 1,
	NETDEV_DOWN = 2,
	NETDEV_REBOOT = 3,
	NETDEV_CHANGE = 4,
	NETDEV_REGISTER = 5,
	NETDEV_UNREGISTER = 6,
	NETDEV_CHANGEMTU = 7,
	NETDEV_CHANGEADDR = 8,
	NETDEV_PRE_CHANGEADDR = 9,
	NETDEV_GOING_DOWN = 10,
	NETDEV_CHANGENAME = 11,
	NETDEV_FEAT_CHANGE = 12,
	NETDEV_BONDING_FAILOVER = 13,
	NETDEV_PRE_UP = 14,
	NETDEV_PRE_TYPE_CHANGE = 15,
	NETDEV_POST_TYPE_CHANGE = 16,
	NETDEV_POST_INIT = 17,
	NETDEV_RELEASE = 18,
	NETDEV_NOTIFY_PEERS = 19,
	NETDEV_JOIN = 20,
	NETDEV_CHANGEUPPER = 21,
	NETDEV_RESEND_IGMP = 22,
	NETDEV_PRECHANGEMTU = 23,
	NETDEV_CHANGEINFODATA = 24,
	NETDEV_BONDING_INFO = 25,
	NETDEV_PRECHANGEUPPER = 26,
	NETDEV_CHANGELOWERSTATE = 27,
	NETDEV_UDP_TUNNEL_PUSH_INFO = 28,
	NETDEV_UDP_TUNNEL_DROP_INFO = 29,
	NETDEV_CHANGE_TX_QUEUE_LEN = 30,
	NETDEV_CVLAN_FILTER_PUSH_INFO = 31,
	NETDEV_CVLAN_FILTER_DROP_INFO = 32,
	NETDEV_SVLAN_FILTER_PUSH_INFO = 33,
	NETDEV_SVLAN_FILTER_DROP_INFO = 34,
};

struct netdev_notifier_info {
	struct net_device *dev;
	struct netlink_ext_ack *extack;
};

struct bpf_dtab;

struct bpf_dtab_netdev {
	struct net_device *dev;
	struct hlist_node index_hlist;
	struct bpf_dtab *dtab;
	struct bpf_prog *xdp_prog;
	struct callback_head rcu;
	unsigned int idx;
	struct bpf_devmap_val val;
};

struct bpf_dtab {
	struct bpf_map map;
	struct bpf_dtab_netdev **netdev_map;
	struct list_head list;
	struct hlist_head *dev_index_head;
	spinlock_t index_lock;
	unsigned int items;
	u32 n_buckets;
	long: 32;
	long: 64;
	long: 64;
};

struct bpf_cpumap_val {
	__u32 qsize;
	union {
		int fd;
		__u32 id;
	} bpf_prog;
};

typedef struct bio_vec skb_frag_t;

struct skb_shared_hwtstamps {
	ktime_t hwtstamp;
};

struct skb_shared_info {
	__u8 __unused;
	__u8 meta_len;
	__u8 nr_frags;
	__u8 tx_flags;
	short unsigned int gso_size;
	short unsigned int gso_segs;
	struct sk_buff *frag_list;
	struct skb_shared_hwtstamps hwtstamps;
	unsigned int gso_type;
	u32 tskey;
	atomic_t dataref;
	void *destructor_arg;
	skb_frag_t frags[17];
};

struct bpf_nh_params {
	u32 nh_family;
	union {
		u32 ipv4_nh;
		struct in6_addr ipv6_nh;
	};
};

struct bpf_redirect_info {
	u32 flags;
	u32 tgt_index;
	void *tgt_value;
	struct bpf_map *map;
	u32 kern_flags;
	struct bpf_nh_params nh;
};

struct ptr_ring {
	int producer;
	spinlock_t producer_lock;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	int consumer_head;
	int consumer_tail;
	spinlock_t consumer_lock;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	int size;
	int batch;
	void **queue;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct bpf_cpu_map_entry;

struct xdp_bulk_queue {
	void *q[8];
	struct list_head flush_node;
	struct bpf_cpu_map_entry *obj;
	unsigned int count;
};

struct bpf_cpu_map;

struct bpf_cpu_map_entry {
	u32 cpu;
	int map_id;
	struct xdp_bulk_queue *bulkq;
	struct bpf_cpu_map *cmap;
	struct ptr_ring *queue;
	struct task_struct *kthread;
	struct bpf_cpumap_val value;
	struct bpf_prog *prog;
	atomic_t refcnt;
	struct callback_head rcu;
	struct work_struct kthread_stop_wq;
};

struct bpf_cpu_map {
	struct bpf_map map;
	struct bpf_cpu_map_entry **cpu_map;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct bpf_local_storage_map_bucket;

struct bpf_local_storage_map {
	struct bpf_map map;
	struct bpf_local_storage_map_bucket *buckets;
	u32 bucket_log;
	u16 elem_size;
	u16 cache_idx;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct bpf_local_storage_data;

struct bpf_local_storage {
	struct bpf_local_storage_data *cache[16];
	struct hlist_head list;
	void *owner;
	struct callback_head rcu;
	raw_spinlock_t lock;
};

struct bpf_local_storage_map_bucket {
	struct hlist_head list;
	raw_spinlock_t lock;
};

struct bpf_local_storage_data {
	struct bpf_local_storage_map *smap;
	u8 data[0];
};

struct bpf_local_storage_elem {
	struct hlist_node map_node;
	struct hlist_node snode;
	struct bpf_local_storage *local_storage;
	struct callback_head rcu;
	long: 64;
	struct bpf_local_storage_data sdata;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct bpf_local_storage_cache {
	spinlock_t idx_lock;
	u64 idx_usage_counts[16];
};

struct rhlist_head {
	struct rhash_head rhead;
	struct rhlist_head *next;
};

struct bpf_prog_offload_ops {
	int (*insn_hook)(struct bpf_verifier_env *, int, int);
	int (*finalize)(struct bpf_verifier_env *);
	int (*replace_insn)(struct bpf_verifier_env *, u32, struct bpf_insn *);
	int (*remove_insns)(struct bpf_verifier_env *, u32, u32);
	int (*prepare)(struct bpf_prog *);
	int (*translate)(struct bpf_prog *);
	void (*destroy)(struct bpf_prog *);
};

struct bpf_offload_dev {
	const struct bpf_prog_offload_ops *ops;
	struct list_head netdevs;
	void *priv;
};

struct bpf_offload_netdev {
	struct rhash_head l;
	struct net_device *netdev;
	struct bpf_offload_dev *offdev;
	struct list_head progs;
	struct list_head maps;
	struct list_head offdev_netdevs;
};

struct ns_get_path_bpf_prog_args {
	struct bpf_prog *prog;
	struct bpf_prog_info *info;
};

struct ns_get_path_bpf_map_args {
	struct bpf_offloaded_map *offmap;
	struct bpf_map_info *info;
};

struct pernet_operations {
	struct list_head list;
	int (*init)(struct net *);
	void (*pre_exit)(struct net *);
	void (*exit)(struct net *);
	void (*exit_batch)(struct list_head *);
	unsigned int *id;
	size_t size;
};

struct bpf_netns_link {
	struct bpf_link link;
	enum bpf_attach_type type;
	enum netns_bpf_attach_type netns_type;
	struct net *net;
	struct list_head node;
};

enum bpf_stack_build_id_status {
	BPF_STACK_BUILD_ID_EMPTY = 0,
	BPF_STACK_BUILD_ID_VALID = 1,
	BPF_STACK_BUILD_ID_IP = 2,
};

struct bpf_stack_build_id {
	__s32 status;
	unsigned char build_id[20];
	union {
		__u64 offset;
		__u64 ip;
	};
};

enum {
	BPF_F_SKIP_FIELD_MASK = 255,
	BPF_F_USER_STACK = 256,
	BPF_F_FAST_STACK_CMP = 512,
	BPF_F_REUSE_STACKID = 1024,
	BPF_F_USER_BUILD_ID = 2048,
};

typedef __u32 Elf32_Addr;

typedef __u16 Elf32_Half;

typedef __u32 Elf32_Off;

struct elf32_hdr {
	unsigned char e_ident[16];
	Elf32_Half e_type;
	Elf32_Half e_machine;
	Elf32_Word e_version;
	Elf32_Addr e_entry;
	Elf32_Off e_phoff;
	Elf32_Off e_shoff;
	Elf32_Word e_flags;
	Elf32_Half e_ehsize;
	Elf32_Half e_phentsize;
	Elf32_Half e_phnum;
	Elf32_Half e_shentsize;
	Elf32_Half e_shnum;
	Elf32_Half e_shstrndx;
};

typedef struct elf32_hdr Elf32_Ehdr;

struct elf32_phdr {
	Elf32_Word p_type;
	Elf32_Off p_offset;
	Elf32_Addr p_vaddr;
	Elf32_Addr p_paddr;
	Elf32_Word p_filesz;
	Elf32_Word p_memsz;
	Elf32_Word p_flags;
	Elf32_Word p_align;
};

typedef struct elf32_phdr Elf32_Phdr;

struct elf64_phdr {
	Elf64_Word p_type;
	Elf64_Word p_flags;
	Elf64_Off p_offset;
	Elf64_Addr p_vaddr;
	Elf64_Addr p_paddr;
	Elf64_Xword p_filesz;
	Elf64_Xword p_memsz;
	Elf64_Xword p_align;
};

typedef struct elf64_phdr Elf64_Phdr;

typedef struct elf32_note Elf32_Nhdr;

enum perf_callchain_context {
	PERF_CONTEXT_HV = 4294967264,
	PERF_CONTEXT_KERNEL = 4294967168,
	PERF_CONTEXT_USER = 4294966784,
	PERF_CONTEXT_GUEST = 4294965248,
	PERF_CONTEXT_GUEST_KERNEL = 4294965120,
	PERF_CONTEXT_GUEST_USER = 4294964736,
	PERF_CONTEXT_MAX = 4294963201,
};

struct stack_map_bucket {
	struct pcpu_freelist_node fnode;
	u32 hash;
	u32 nr;
	u64 data[0];
};

struct bpf_stack_map {
	struct bpf_map map;
	void *elems;
	struct pcpu_freelist freelist;
	u32 n_buckets;
	struct stack_map_bucket *buckets[0];
	long: 64;
	long: 64;
	long: 64;
};

struct stack_map_irq_work {
	struct irq_work irq_work;
	struct mm_struct *mm;
};

typedef u64 (*btf_bpf_get_stackid)(struct pt_regs *, struct bpf_map *, u64);

typedef u64 (*btf_bpf_get_stackid_pe)(struct bpf_perf_event_data_kern *, struct bpf_map *, u64);

typedef u64 (*btf_bpf_get_stack)(struct pt_regs *, void *, u32, u64);

typedef u64 (*btf_bpf_get_task_stack)(struct task_struct *, void *, u32, u64);

typedef u64 (*btf_bpf_get_stack_pe)(struct bpf_perf_event_data_kern *, void *, u32, u64);

enum sock_type {
	SOCK_STREAM = 1,
	SOCK_DGRAM = 2,
	SOCK_RAW = 3,
	SOCK_RDM = 4,
	SOCK_SEQPACKET = 5,
	SOCK_DCCP = 6,
	SOCK_PACKET = 10,
};

enum {
	IPPROTO_IP = 0,
	IPPROTO_ICMP = 1,
	IPPROTO_IGMP = 2,
	IPPROTO_IPIP = 4,
	IPPROTO_TCP = 6,
	IPPROTO_EGP = 8,
	IPPROTO_PUP = 12,
	IPPROTO_UDP = 17,
	IPPROTO_IDP = 22,
	IPPROTO_TP = 29,
	IPPROTO_DCCP = 33,
	IPPROTO_IPV6 = 41,
	IPPROTO_RSVP = 46,
	IPPROTO_GRE = 47,
	IPPROTO_ESP = 50,
	IPPROTO_AH = 51,
	IPPROTO_MTP = 92,
	IPPROTO_BEETPH = 94,
	IPPROTO_ENCAP = 98,
	IPPROTO_PIM = 103,
	IPPROTO_COMP = 108,
	IPPROTO_SCTP = 132,
	IPPROTO_UDPLITE = 136,
	IPPROTO_MPLS = 137,
	IPPROTO_ETHERNET = 143,
	IPPROTO_RAW = 255,
	IPPROTO_MPTCP = 262,
	IPPROTO_MAX = 263,
};

enum sock_flags {
	SOCK_DEAD = 0,
	SOCK_DONE = 1,
	SOCK_URGINLINE = 2,
	SOCK_KEEPOPEN = 3,
	SOCK_LINGER = 4,
	SOCK_DESTROY = 5,
	SOCK_BROADCAST = 6,
	SOCK_TIMESTAMP = 7,
	SOCK_ZAPPED = 8,
	SOCK_USE_WRITE_QUEUE = 9,
	SOCK_DBG = 10,
	SOCK_RCVTSTAMP = 11,
	SOCK_RCVTSTAMPNS = 12,
	SOCK_LOCALROUTE = 13,
	SOCK_MEMALLOC = 14,
	SOCK_TIMESTAMPING_RX_SOFTWARE = 15,
	SOCK_FASYNC = 16,
	SOCK_RXQ_OVFL = 17,
	SOCK_ZEROCOPY = 18,
	SOCK_WIFI_STATUS = 19,
	SOCK_NOFCS = 20,
	SOCK_FILTER_LOCKED = 21,
	SOCK_SELECT_ERR_QUEUE = 22,
	SOCK_RCU_FREE = 23,
	SOCK_TXTIME = 24,
	SOCK_XDP = 25,
	SOCK_TSTAMP_NEW = 26,
};

struct reuseport_array {
	struct bpf_map map;
	struct sock *ptrs[0];
};

enum bpf_struct_ops_state {
	BPF_STRUCT_OPS_STATE_INIT = 0,
	BPF_STRUCT_OPS_STATE_INUSE = 1,
	BPF_STRUCT_OPS_STATE_TOBEFREE = 2,
};

struct bpf_struct_ops_value {
	refcount_t refcnt;
	enum bpf_struct_ops_state state;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	char data[0];
};

struct bpf_struct_ops_map {
	struct bpf_map map;
	const struct bpf_struct_ops *st_ops;
	struct mutex lock;
	struct bpf_prog **progs;
	void *image;
	struct bpf_struct_ops_value *uvalue;
	struct bpf_struct_ops_value kvalue;
};

struct bpf_struct_ops_tcp_congestion_ops {
	refcount_t refcnt;
	enum bpf_struct_ops_state state;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct tcp_congestion_ops data;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

enum perf_branch_sample_type {
	PERF_SAMPLE_BRANCH_USER = 1,
	PERF_SAMPLE_BRANCH_KERNEL = 2,
	PERF_SAMPLE_BRANCH_HV = 4,
	PERF_SAMPLE_BRANCH_ANY = 8,
	PERF_SAMPLE_BRANCH_ANY_CALL = 16,
	PERF_SAMPLE_BRANCH_ANY_RETURN = 32,
	PERF_SAMPLE_BRANCH_IND_CALL = 64,
	PERF_SAMPLE_BRANCH_ABORT_TX = 128,
	PERF_SAMPLE_BRANCH_IN_TX = 256,
	PERF_SAMPLE_BRANCH_NO_TX = 512,
	PERF_SAMPLE_BRANCH_COND = 1024,
	PERF_SAMPLE_BRANCH_CALL_STACK = 2048,
	PERF_SAMPLE_BRANCH_IND_JUMP = 4096,
	PERF_SAMPLE_BRANCH_CALL = 8192,
	PERF_SAMPLE_BRANCH_NO_FLAGS = 16384,
	PERF_SAMPLE_BRANCH_NO_CYCLES = 32768,
	PERF_SAMPLE_BRANCH_TYPE_SAVE = 65536,
	PERF_SAMPLE_BRANCH_HW_INDEX = 131072,
	PERF_SAMPLE_BRANCH_MAX = 262144,
};

enum perf_event_read_format {
	PERF_FORMAT_TOTAL_TIME_ENABLED = 1,
	PERF_FORMAT_TOTAL_TIME_RUNNING = 2,
	PERF_FORMAT_ID = 4,
	PERF_FORMAT_GROUP = 8,
	PERF_FORMAT_MAX = 16,
};

enum perf_event_ioc_flags {
	PERF_IOC_FLAG_GROUP = 1,
};

struct perf_event_mmap_page {
	__u32 version;
	__u32 compat_version;
	__u32 lock;
	__u32 index;
	__s64 offset;
	__u64 time_enabled;
	__u64 time_running;
	union {
		__u64 capabilities;
		struct {
			__u64 cap_bit0: 1;
			__u64 cap_bit0_is_deprecated: 1;
			__u64 cap_user_rdpmc: 1;
			__u64 cap_user_time: 1;
			__u64 cap_user_time_zero: 1;
			__u64 cap_user_time_short: 1;
			__u64 cap_____res: 58;
		};
	};
	__u16 pmc_width;
	__u16 time_shift;
	__u32 time_mult;
	__u64 time_offset;
	__u64 time_zero;
	__u32 size;
	__u32 __reserved_1;
	__u64 time_cycles;
	__u64 time_mask;
	__u8 __reserved[928];
	__u64 data_head;
	__u64 data_tail;
	__u64 data_offset;
	__u64 data_size;
	__u64 aux_head;
	__u64 aux_tail;
	__u64 aux_offset;
	__u64 aux_size;
};

struct perf_event_header {
	__u32 type;
	__u16 misc;
	__u16 size;
};

struct perf_ns_link_info {
	__u64 dev;
	__u64 ino;
};

enum {
	NET_NS_INDEX = 0,
	UTS_NS_INDEX = 1,
	IPC_NS_INDEX = 2,
	PID_NS_INDEX = 3,
	USER_NS_INDEX = 4,
	MNT_NS_INDEX = 5,
	CGROUP_NS_INDEX = 6,
	NR_NAMESPACES = 7,
};

enum perf_event_type {
	PERF_RECORD_MMAP = 1,
	PERF_RECORD_LOST = 2,
	PERF_RECORD_COMM = 3,
	PERF_RECORD_EXIT = 4,
	PERF_RECORD_THROTTLE = 5,
	PERF_RECORD_UNTHROTTLE = 6,
	PERF_RECORD_FORK = 7,
	PERF_RECORD_READ = 8,
	PERF_RECORD_SAMPLE = 9,
	PERF_RECORD_MMAP2 = 10,
	PERF_RECORD_AUX = 11,
	PERF_RECORD_ITRACE_START = 12,
	PERF_RECORD_LOST_SAMPLES = 13,
	PERF_RECORD_SWITCH = 14,
	PERF_RECORD_SWITCH_CPU_WIDE = 15,
	PERF_RECORD_NAMESPACES = 16,
	PERF_RECORD_KSYMBOL = 17,
	PERF_RECORD_BPF_EVENT = 18,
	PERF_RECORD_CGROUP = 19,
	PERF_RECORD_TEXT_POKE = 20,
	PERF_RECORD_MAX = 21,
};

enum perf_addr_filter_action_t {
	PERF_ADDR_FILTER_ACTION_STOP = 0,
	PERF_ADDR_FILTER_ACTION_START = 1,
	PERF_ADDR_FILTER_ACTION_FILTER = 2,
};

struct perf_addr_filter {
	struct list_head entry;
	struct path path;
	long unsigned int offset;
	long unsigned int size;
	enum perf_addr_filter_action_t action;
};

struct swevent_hlist {
	struct hlist_head heads[256];
	struct callback_head callback_head;
};

struct pmu_event_list {
	raw_spinlock_t lock;
	struct list_head list;
};

struct perf_buffer {
	refcount_t refcount;
	struct callback_head callback_head;
	int nr_pages;
	int overwrite;
	int paused;
	atomic_t poll;
	local_t head;
	unsigned int nest;
	local_t events;
	local_t wakeup;
	local_t lost;
	long int watermark;
	long int aux_watermark;
	spinlock_t event_lock;
	struct list_head event_list;
	atomic_t mmap_count;
	long unsigned int mmap_locked;
	struct user_struct *mmap_user;
	long int aux_head;
	unsigned int aux_nest;
	long int aux_wakeup;
	long unsigned int aux_pgoff;
	int aux_nr_pages;
	int aux_overwrite;
	atomic_t aux_mmap_count;
	long unsigned int aux_mmap_locked;
	void (*free_aux)(void *);
	refcount_t aux_refcount;
	int aux_in_sampling;
	void **aux_pages;
	void *aux_priv;
	struct perf_event_mmap_page *user_page;
	void *data_pages[0];
};

struct perf_pmu_events_attr {
	struct device_attribute attr;
	u64 id;
	const char *event_str;
};

struct match_token {
	int token;
	const char *pattern;
};

enum {
	MAX_OPT_ARGS = 3,
};

typedef struct {
	char *from;
	char *to;
} substring_t;

struct min_heap {
	void *data;
	int nr;
	int size;
};

struct min_heap_callbacks {
	int elem_size;
	bool (*less)(const void *, const void *);
	void (*swp)(void *, void *);
};

typedef int (*remote_function_f)(void *);

struct remote_function_call {
	struct task_struct *p;
	remote_function_f func;
	void *info;
	int ret;
};

typedef void (*event_f)(struct perf_event *, struct perf_cpu_context *, struct perf_event_context *, void *);

struct event_function_struct {
	struct perf_event *event;
	event_f func;
	void *data;
};

enum event_type_t {
	EVENT_FLEXIBLE = 1,
	EVENT_PINNED = 2,
	EVENT_TIME = 4,
	EVENT_CPU = 8,
	EVENT_ALL = 3,
};

struct stop_event_data {
	struct perf_event *event;
	unsigned int restart;
};

struct perf_read_data {
	struct perf_event *event;
	bool group;
	int ret;
};

struct perf_read_event {
	struct perf_event_header header;
	u32 pid;
	u32 tid;
};

typedef void perf_iterate_f(struct perf_event *, void *);

struct remote_output {
	struct perf_buffer *rb;
	int err;
};

struct perf_task_event {
	struct task_struct *task;
	struct perf_event_context *task_ctx;
	struct {
		struct perf_event_header header;
		u32 pid;
		u32 ppid;
		u32 tid;
		u32 ptid;
		u64 time;
	} event_id;
};

struct perf_comm_event {
	struct task_struct *task;
	char *comm;
	int comm_size;
	struct {
		struct perf_event_header header;
		u32 pid;
		u32 tid;
	} event_id;
};

struct perf_namespaces_event {
	struct task_struct *task;
	struct {
		struct perf_event_header header;
		u32 pid;
		u32 tid;
		u64 nr_namespaces;
		struct perf_ns_link_info link_info[7];
	} event_id;
};

struct perf_mmap_event {
	struct vm_area_struct *vma;
	const char *file_name;
	int file_size;
	int maj;
	int min;
	u64 ino;
	u64 ino_generation;
	u32 prot;
	u32 flags;
	struct {
		struct perf_event_header header;
		u32 pid;
		u32 tid;
		u64 start;
		u64 len;
		u64 pgoff;
	} event_id;
};

struct perf_switch_event {
	struct task_struct *task;
	struct task_struct *next_prev;
	struct {
		struct perf_event_header header;
		u32 next_prev_pid;
		u32 next_prev_tid;
	} event_id;
};

struct perf_ksymbol_event {
	const char *name;
	int name_len;
	struct {
		struct perf_event_header header;
		u64 addr;
		u32 len;
		u16 ksym_type;
		u16 flags;
	} event_id;
};

struct perf_bpf_event {
	struct bpf_prog *prog;
	struct {
		struct perf_event_header header;
		u16 type;
		u16 flags;
		u32 id;
		u8 tag[8];
	} event_id;
};

struct perf_text_poke_event {
	const void *old_bytes;
	const void *new_bytes;
	size_t pad;
	u16 old_len;
	u16 new_len;
	struct {
		struct perf_event_header header;
		u64 addr;
	} event_id;
};

struct swevent_htable {
	struct swevent_hlist *swevent_hlist;
	struct mutex hlist_mutex;
	int hlist_refcount;
	int recursion[4];
};

enum perf_probe_config {
	PERF_PROBE_CONFIG_IS_RETPROBE = 1,
	PERF_UPROBE_REF_CTR_OFFSET_BITS = 32,
	PERF_UPROBE_REF_CTR_OFFSET_SHIFT = 32,
};

enum {
	IF_ACT_NONE = 4294967295,
	IF_ACT_FILTER = 0,
	IF_ACT_START = 1,
	IF_ACT_STOP = 2,
	IF_SRC_FILE = 3,
	IF_SRC_KERNEL = 4,
	IF_SRC_FILEADDR = 5,
	IF_SRC_KERNELADDR = 6,
};

enum {
	IF_STATE_ACTION = 0,
	IF_STATE_SOURCE = 1,
	IF_STATE_END = 2,
};

struct perf_aux_event {
	struct perf_event_header header;
	u32 pid;
	u32 tid;
};

struct perf_aux_event___2 {
	struct perf_event_header header;
	u64 offset;
	u64 size;
	u64 flags;
};

struct callchain_cpus_entries {
	struct callback_head callback_head;
	struct perf_callchain_entry *cpu_entries[0];
};

struct uprobe {
	struct rb_node rb_node;
	refcount_t ref;
	struct rw_semaphore register_rwsem;
	struct rw_semaphore consumer_rwsem;
	struct list_head pending_list;
	struct uprobe_consumer *consumers;
	struct inode *inode;
	loff_t offset;
	loff_t ref_ctr_offset;
	long unsigned int flags;
	struct arch_uprobe arch;
};

struct vm_special_mapping {
	const char *name;
	struct page **pages;
	vm_fault_t (*fault)(const struct vm_special_mapping *, struct vm_area_struct *, struct vm_fault *);
	int (*mremap)(const struct vm_special_mapping *, struct vm_area_struct *);
};

struct xol_area {
	wait_queue_head_t wq;
	atomic_t slot_count;
	long unsigned int *bitmap;
	struct vm_special_mapping xol_mapping;
	struct page *pages[2];
	long unsigned int vaddr;
};

typedef long unsigned int vm_flags_t;

struct compact_control;

struct capture_control {
	struct compact_control *cc;
	struct page *page;
};

struct page_vma_mapped_walk {
	struct page *page;
	struct vm_area_struct *vma;
	long unsigned int address;
	pmd_t *pmd;
	pte_t *pte;
	spinlock_t *ptl;
	unsigned int flags;
};

struct compact_control {
	struct list_head freepages;
	struct list_head migratepages;
	unsigned int nr_freepages;
	unsigned int nr_migratepages;
	long unsigned int free_pfn;
	long unsigned int migrate_pfn;
	long unsigned int fast_start_pfn;
	struct zone *zone;
	long unsigned int total_migrate_scanned;
	long unsigned int total_free_scanned;
	short unsigned int fast_search_fail;
	short int search_order;
	const gfp_t gfp_mask;
	int order;
	int migratetype;
	const unsigned int alloc_flags;
	const int highest_zoneidx;
	enum migrate_mode mode;
	bool ignore_skip_hint;
	bool no_set_skip_hint;
	bool ignore_block_suitable;
	bool direct_compaction;
	bool proactive_compaction;
	bool whole_zone;
	bool contended;
	bool rescan;
	bool alloc_contig;
};

struct delayed_uprobe {
	struct list_head list;
	struct uprobe *uprobe;
	struct mm_struct *mm;
};

struct map_info {
	struct map_info *next;
	struct mm_struct *mm;
	long unsigned int vaddr;
};

enum key_being_used_for {
	VERIFYING_MODULE_SIGNATURE = 0,
	VERIFYING_FIRMWARE_SIGNATURE = 1,
	VERIFYING_KEXEC_PE_SIGNATURE = 2,
	VERIFYING_KEY_SIGNATURE = 3,
	VERIFYING_KEY_SELF_SIGNATURE = 4,
	VERIFYING_UNSPECIFIED_SIGNATURE = 5,
	NR__KEY_BEING_USED_FOR = 6,
};

struct pkcs7_message;

struct __key_reference_with_attributes;

typedef struct __key_reference_with_attributes *key_ref_t;

typedef void (*xa_update_node_t)(struct xa_node *);

struct xa_state {
	struct xarray *xa;
	long unsigned int xa_index;
	unsigned char xa_shift;
	unsigned char xa_sibs;
	unsigned char xa_offset;
	unsigned char xa_pad;
	struct xa_node *xa_node;
	struct xa_node *xa_alloc;
	xa_update_node_t xa_update;
};

typedef int __kernel_rwf_t;

enum positive_aop_returns {
	AOP_WRITEPAGE_ACTIVATE = 524288,
	AOP_TRUNCATED_PAGE = 524289,
};

struct vm_event_state {
	long unsigned int event[68];
};

enum iter_type {
	ITER_IOVEC = 4,
	ITER_KVEC = 8,
	ITER_BVEC = 16,
	ITER_PIPE = 32,
	ITER_DISCARD = 64,
};

enum mapping_flags {
	AS_EIO = 0,
	AS_ENOSPC = 1,
	AS_MM_ALL_LOCKS = 2,
	AS_UNEVICTABLE = 3,
	AS_EXITING = 4,
	AS_NO_WRITEBACK_TAGS = 5,
	AS_THP_SUPPORT = 6,
};

struct wait_page_key {
	struct page *page;
	int bit_nr;
	int page_match;
};

struct pagevec {
	unsigned char nr;
	bool percpu_pvec_drained;
	struct page *pages[15];
};

struct fid {
	union {
		struct {
			u32 ino;
			u32 gen;
			u32 parent_ino;
			u32 parent_gen;
		} i32;
		struct {
			u32 block;
			u16 partref;
			u16 parent_partref;
			u32 generation;
			u32 parent_block;
			u32 parent_generation;
		} udf;
		__u32 raw[0];
	};
};

struct trace_event_raw_mm_filemap_op_page_cache {
	struct trace_entry ent;
	long unsigned int pfn;
	long unsigned int i_ino;
	long unsigned int index;
	dev_t s_dev;
	char __data[0];
};

struct trace_event_raw_filemap_set_wb_err {
	struct trace_entry ent;
	long unsigned int i_ino;
	dev_t s_dev;
	errseq_t errseq;
	char __data[0];
};

struct trace_event_raw_file_check_and_advance_wb_err {
	struct trace_entry ent;
	struct file *file;
	long unsigned int i_ino;
	dev_t s_dev;
	errseq_t old;
	errseq_t new;
	char __data[0];
};

struct trace_event_data_offsets_mm_filemap_op_page_cache {};

struct trace_event_data_offsets_filemap_set_wb_err {};

struct trace_event_data_offsets_file_check_and_advance_wb_err {};

typedef void (*btf_trace_mm_filemap_delete_from_page_cache)(void *, struct page *);

typedef void (*btf_trace_mm_filemap_add_to_page_cache)(void *, struct page *);

typedef void (*btf_trace_filemap_set_wb_err)(void *, struct address_space *, errseq_t);

typedef void (*btf_trace_file_check_and_advance_wb_err)(void *, struct file *, errseq_t);

enum behavior {
	EXCLUSIVE = 0,
	SHARED = 1,
	DROP = 2,
};

struct reciprocal_value {
	u32 m;
	u8 sh1;
	u8 sh2;
};

struct kmem_cache_order_objects {
	unsigned int x;
};

struct kmem_cache_cpu;

struct kmem_cache_node;

struct kmem_cache {
	struct kmem_cache_cpu *cpu_slab;
	slab_flags_t flags;
	long unsigned int min_partial;
	unsigned int size;
	unsigned int object_size;
	struct reciprocal_value reciprocal_size;
	unsigned int offset;
	unsigned int cpu_partial;
	struct kmem_cache_order_objects oo;
	struct kmem_cache_order_objects max;
	struct kmem_cache_order_objects min;
	gfp_t allocflags;
	int refcount;
	void (*ctor)(void *);
	unsigned int inuse;
	unsigned int align;
	unsigned int red_left_pad;
	const char *name;
	struct list_head list;
	struct kobject kobj;
	unsigned int useroffset;
	unsigned int usersize;
	struct kmem_cache_node *node[1];
};

struct kmem_cache_cpu {
	void **freelist;
	long unsigned int tid;
	struct page *page;
	struct page *partial;
};

struct kmem_cache_node {
	spinlock_t list_lock;
	long unsigned int nr_partial;
	struct list_head partial;
	atomic_long_t nr_slabs;
	atomic_long_t total_objects;
	struct list_head full;
};

enum oom_constraint {
	CONSTRAINT_NONE = 0,
	CONSTRAINT_CPUSET = 1,
	CONSTRAINT_MEMORY_POLICY = 2,
	CONSTRAINT_MEMCG = 3,
};

struct oom_control {
	struct zonelist *zonelist;
	nodemask_t *nodemask;
	struct mem_cgroup *memcg;
	const gfp_t gfp_mask;
	const int order;
	long unsigned int totalpages;
	struct task_struct *chosen;
	long int chosen_points;
	struct task_struct *chosen_non_negative_adj;
	long int chosen_non_negative_adj_points;
	enum oom_constraint constraint;
};

enum memcg_memory_event {
	MEMCG_LOW = 0,
	MEMCG_HIGH = 1,
	MEMCG_MAX = 2,
	MEMCG_OOM = 3,
	MEMCG_OOM_KILL = 4,
	MEMCG_SWAP_HIGH = 5,
	MEMCG_SWAP_MAX = 6,
	MEMCG_SWAP_FAIL = 7,
	MEMCG_NR_MEMORY_EVENTS = 8,
};

struct mmu_gather_batch {
	struct mmu_gather_batch *next;
	unsigned int nr;
	unsigned int max;
	struct page *pages[0];
};

struct mmu_gather {
	struct mm_struct *mm;
	long unsigned int start;
	long unsigned int end;
	unsigned int fullmm: 1;
	unsigned int need_flush_all: 1;
	unsigned int freed_tables: 1;
	unsigned int cleared_ptes: 1;
	unsigned int cleared_pmds: 1;
	unsigned int cleared_puds: 1;
	unsigned int cleared_p4ds: 1;
	unsigned int vma_exec: 1;
	unsigned int vma_huge: 1;
	unsigned int batch_count;
	struct mmu_gather_batch *active;
	struct mmu_gather_batch local;
	struct page *__pages[8];
};

enum compact_priority {
	COMPACT_PRIO_SYNC_FULL = 0,
	MIN_COMPACT_PRIORITY = 0,
	COMPACT_PRIO_SYNC_LIGHT = 1,
	MIN_COMPACT_COSTLY_PRIORITY = 1,
	DEF_COMPACT_PRIORITY = 1,
	COMPACT_PRIO_ASYNC = 2,
	INIT_COMPACT_PRIORITY = 2,
};

enum compact_result {
	COMPACT_NOT_SUITABLE_ZONE = 0,
	COMPACT_SKIPPED = 1,
	COMPACT_DEFERRED = 2,
	COMPACT_NO_SUITABLE_PAGE = 3,
	COMPACT_CONTINUE = 4,
	COMPACT_COMPLETE = 5,
	COMPACT_PARTIAL_SKIPPED = 6,
	COMPACT_CONTENDED = 7,
	COMPACT_SUCCESS = 8,
};

struct trace_event_raw_oom_score_adj_update {
	struct trace_entry ent;
	pid_t pid;
	char comm[16];
	short int oom_score_adj;
	char __data[0];
};

struct trace_event_raw_reclaim_retry_zone {
	struct trace_entry ent;
	int node;
	int zone_idx;
	int order;
	long unsigned int reclaimable;
	long unsigned int available;
	long unsigned int min_wmark;
	int no_progress_loops;
	bool wmark_check;
	char __data[0];
};

struct trace_event_raw_mark_victim {
	struct trace_entry ent;
	int pid;
	char __data[0];
};

struct trace_event_raw_wake_reaper {
	struct trace_entry ent;
	int pid;
	char __data[0];
};

struct trace_event_raw_start_task_reaping {
	struct trace_entry ent;
	int pid;
	char __data[0];
};

struct trace_event_raw_finish_task_reaping {
	struct trace_entry ent;
	int pid;
	char __data[0];
};

struct trace_event_raw_skip_task_reaping {
	struct trace_entry ent;
	int pid;
	char __data[0];
};

struct trace_event_raw_compact_retry {
	struct trace_entry ent;
	int order;
	int priority;
	int result;
	int retries;
	int max_retries;
	bool ret;
	char __data[0];
};

struct trace_event_data_offsets_oom_score_adj_update {};

struct trace_event_data_offsets_reclaim_retry_zone {};

struct trace_event_data_offsets_mark_victim {};

struct trace_event_data_offsets_wake_reaper {};

struct trace_event_data_offsets_start_task_reaping {};

struct trace_event_data_offsets_finish_task_reaping {};

struct trace_event_data_offsets_skip_task_reaping {};

struct trace_event_data_offsets_compact_retry {};

typedef void (*btf_trace_oom_score_adj_update)(void *, struct task_struct *);

typedef void (*btf_trace_reclaim_retry_zone)(void *, struct zoneref *, int, long unsigned int, long unsigned int, long unsigned int, int, bool);

typedef void (*btf_trace_mark_victim)(void *, int);

typedef void (*btf_trace_wake_reaper)(void *, int);

typedef void (*btf_trace_start_task_reaping)(void *, int);

typedef void (*btf_trace_finish_task_reaping)(void *, int);

typedef void (*btf_trace_skip_task_reaping)(void *, int);

typedef void (*btf_trace_compact_retry)(void *, int, enum compact_priority, enum compact_result, int, int, bool);

enum wb_congested_state {
	WB_async_congested = 0,
	WB_sync_congested = 1,
};

enum {
	XA_CHECK_SCHED = 4096,
};

struct fprop_global {
	struct percpu_counter events;
	unsigned int period;
	seqcount_t sequence;
};

enum wb_state {
	WB_registered = 0,
	WB_writeback_running = 1,
	WB_has_dirty_io = 2,
	WB_start_all = 3,
};

enum {
	BLK_RW_ASYNC = 0,
	BLK_RW_SYNC = 1,
};

struct wb_lock_cookie {
	bool locked;
	long unsigned int flags;
};

struct wb_domain {
	spinlock_t lock;
	struct fprop_global completions;
	struct timer_list period_timer;
	long unsigned int period_time;
	long unsigned int dirty_limit_tstamp;
	long unsigned int dirty_limit;
};

typedef int (*writepage_t)(struct page *, struct writeback_control *, void *);

struct dirty_throttle_control {
	struct bdi_writeback *wb;
	struct fprop_local_percpu *wb_completions;
	long unsigned int avail;
	long unsigned int dirty;
	long unsigned int thresh;
	long unsigned int bg_thresh;
	long unsigned int wb_dirty;
	long unsigned int wb_thresh;
	long unsigned int wb_bg_thresh;
	long unsigned int pos_ratio;
};

typedef void compound_page_dtor(struct page *);

struct trace_event_raw_mm_lru_insertion {
	struct trace_entry ent;
	struct page *page;
	long unsigned int pfn;
	int lru;
	long unsigned int flags;
	char __data[0];
};

struct trace_event_raw_mm_lru_activate {
	struct trace_entry ent;
	struct page *page;
	long unsigned int pfn;
	char __data[0];
};

struct trace_event_data_offsets_mm_lru_insertion {};

struct trace_event_data_offsets_mm_lru_activate {};

typedef void (*btf_trace_mm_lru_insertion)(void *, struct page *, int);

typedef void (*btf_trace_mm_lru_activate)(void *, struct page *);

struct lru_rotate {
	local_lock_t lock;
	struct pagevec pvec;
};

struct lru_pvecs {
	local_lock_t lock;
	struct pagevec lru_add;
	struct pagevec lru_deactivate_file;
	struct pagevec lru_deactivate;
	struct pagevec lru_lazyfree;
	struct pagevec lru_lazyfree_movetail;
	struct pagevec activate_page;
};

typedef struct {
	long unsigned int val;
} swp_entry_t;

enum lruvec_flags {
	LRUVEC_CONGESTED = 0,
};

enum pgdat_flags {
	PGDAT_DIRTY = 0,
	PGDAT_WRITEBACK = 1,
	PGDAT_RECLAIM_LOCKED = 2,
};

struct reclaim_stat {
	unsigned int nr_dirty;
	unsigned int nr_unqueued_dirty;
	unsigned int nr_congested;
	unsigned int nr_writeback;
	unsigned int nr_immediate;
	unsigned int nr_pageout;
	unsigned int nr_activate[2];
	unsigned int nr_ref_keep;
	unsigned int nr_unmap_fail;
	unsigned int nr_lazyfree_fail;
};

struct mem_cgroup_reclaim_cookie {
	pg_data_t *pgdat;
	unsigned int generation;
};

enum ttu_flags {
	TTU_MIGRATION = 1,
	TTU_MUNLOCK = 2,
	TTU_SPLIT_HUGE_PMD = 4,
	TTU_IGNORE_MLOCK = 8,
	TTU_SYNC = 16,
	TTU_IGNORE_HWPOISON = 32,
	TTU_BATCH_FLUSH = 64,
	TTU_RMAP_LOCKED = 128,
	TTU_SPLIT_FREEZE = 256,
};

enum migrate_reason {
	MR_COMPACTION = 0,
	MR_MEMORY_FAILURE = 1,
	MR_MEMORY_HOTPLUG = 2,
	MR_SYSCALL = 3,
	MR_MEMPOLICY_MBIND = 4,
	MR_NUMA_MISPLACED = 5,
	MR_CONTIG_RANGE = 6,
	MR_TYPES = 7,
};

struct trace_event_raw_mm_vmscan_kswapd_sleep {
	struct trace_entry ent;
	int nid;
	char __data[0];
};

struct trace_event_raw_mm_vmscan_kswapd_wake {
	struct trace_entry ent;
	int nid;
	int zid;
	int order;
	char __data[0];
};

struct trace_event_raw_mm_vmscan_wakeup_kswapd {
	struct trace_entry ent;
	int nid;
	int zid;
	int order;
	gfp_t gfp_flags;
	char __data[0];
};

struct trace_event_raw_mm_vmscan_direct_reclaim_begin_template {
	struct trace_entry ent;
	int order;
	gfp_t gfp_flags;
	char __data[0];
};

struct trace_event_raw_mm_vmscan_direct_reclaim_end_template {
	struct trace_entry ent;
	long unsigned int nr_reclaimed;
	char __data[0];
};

struct trace_event_raw_mm_shrink_slab_start {
	struct trace_entry ent;
	struct shrinker *shr;
	void *shrink;
	int nid;
	long int nr_objects_to_shrink;
	gfp_t gfp_flags;
	long unsigned int cache_items;
	long long unsigned int delta;
	long unsigned int total_scan;
	int priority;
	char __data[0];
};

struct trace_event_raw_mm_shrink_slab_end {
	struct trace_entry ent;
	struct shrinker *shr;
	int nid;
	void *shrink;
	long int unused_scan;
	long int new_scan;
	int retval;
	long int total_scan;
	char __data[0];
};

struct trace_event_raw_mm_vmscan_lru_isolate {
	struct trace_entry ent;
	int highest_zoneidx;
	int order;
	long unsigned int nr_requested;
	long unsigned int nr_scanned;
	long unsigned int nr_skipped;
	long unsigned int nr_taken;
	isolate_mode_t isolate_mode;
	int lru;
	char __data[0];
};

struct trace_event_raw_mm_vmscan_writepage {
	struct trace_entry ent;
	long unsigned int pfn;
	int reclaim_flags;
	char __data[0];
};

struct trace_event_raw_mm_vmscan_lru_shrink_inactive {
	struct trace_entry ent;
	int nid;
	long unsigned int nr_scanned;
	long unsigned int nr_reclaimed;
	long unsigned int nr_dirty;
	long unsigned int nr_writeback;
	long unsigned int nr_congested;
	long unsigned int nr_immediate;
	unsigned int nr_activate0;
	unsigned int nr_activate1;
	long unsigned int nr_ref_keep;
	long unsigned int nr_unmap_fail;
	int priority;
	int reclaim_flags;
	char __data[0];
};

struct trace_event_raw_mm_vmscan_lru_shrink_active {
	struct trace_entry ent;
	int nid;
	long unsigned int nr_taken;
	long unsigned int nr_active;
	long unsigned int nr_deactivated;
	long unsigned int nr_referenced;
	int priority;
	int reclaim_flags;
	char __data[0];
};

struct trace_event_raw_mm_vmscan_inactive_list_is_low {
	struct trace_entry ent;
	int nid;
	int reclaim_idx;
	long unsigned int total_inactive;
	long unsigned int inactive;
	long unsigned int total_active;
	long unsigned int active;
	long unsigned int ratio;
	int reclaim_flags;
	char __data[0];
};

struct trace_event_raw_mm_vmscan_node_reclaim_begin {
	struct trace_entry ent;
	int nid;
	int order;
	gfp_t gfp_flags;
	char __data[0];
};

struct trace_event_data_offsets_mm_vmscan_kswapd_sleep {};

struct trace_event_data_offsets_mm_vmscan_kswapd_wake {};

struct trace_event_data_offsets_mm_vmscan_wakeup_kswapd {};

struct trace_event_data_offsets_mm_vmscan_direct_reclaim_begin_template {};

struct trace_event_data_offsets_mm_vmscan_direct_reclaim_end_template {};

struct trace_event_data_offsets_mm_shrink_slab_start {};

struct trace_event_data_offsets_mm_shrink_slab_end {};

struct trace_event_data_offsets_mm_vmscan_lru_isolate {};

struct trace_event_data_offsets_mm_vmscan_writepage {};

struct trace_event_data_offsets_mm_vmscan_lru_shrink_inactive {};

struct trace_event_data_offsets_mm_vmscan_lru_shrink_active {};

struct trace_event_data_offsets_mm_vmscan_inactive_list_is_low {};

struct trace_event_data_offsets_mm_vmscan_node_reclaim_begin {};

typedef void (*btf_trace_mm_vmscan_kswapd_sleep)(void *, int);

typedef void (*btf_trace_mm_vmscan_kswapd_wake)(void *, int, int, int);

typedef void (*btf_trace_mm_vmscan_wakeup_kswapd)(void *, int, int, int, gfp_t);

typedef void (*btf_trace_mm_vmscan_direct_reclaim_begin)(void *, int, gfp_t);

typedef void (*btf_trace_mm_vmscan_direct_reclaim_end)(void *, long unsigned int);

typedef void (*btf_trace_mm_shrink_slab_start)(void *, struct shrinker *, struct shrink_control *, long int, long unsigned int, long long unsigned int, long unsigned int, int);

typedef void (*btf_trace_mm_shrink_slab_end)(void *, struct shrinker *, int, int, long int, long int, long int);

typedef void (*btf_trace_mm_vmscan_lru_isolate)(void *, int, int, long unsigned int, long unsigned int, long unsigned int, long unsigned int, isolate_mode_t, int);

typedef void (*btf_trace_mm_vmscan_writepage)(void *, struct page *);

typedef void (*btf_trace_mm_vmscan_lru_shrink_inactive)(void *, int, long unsigned int, long unsigned int, struct reclaim_stat *, int, int);

typedef void (*btf_trace_mm_vmscan_lru_shrink_active)(void *, int, long unsigned int, long unsigned int, long unsigned int, long unsigned int, int, int);

typedef void (*btf_trace_mm_vmscan_inactive_list_is_low)(void *, int, int, long unsigned int, long unsigned int, long unsigned int, long unsigned int, long unsigned int, int);

typedef void (*btf_trace_mm_vmscan_node_reclaim_begin)(void *, int, int, gfp_t);

typedef void (*btf_trace_mm_vmscan_node_reclaim_end)(void *, long unsigned int);

struct scan_control {
	long unsigned int nr_to_reclaim;
	nodemask_t *nodemask;
	struct mem_cgroup *target_mem_cgroup;
	long unsigned int anon_cost;
	long unsigned int file_cost;
	unsigned int may_deactivate: 2;
	unsigned int force_deactivate: 1;
	unsigned int skipped_deactivate: 1;
	unsigned int may_writepage: 1;
	unsigned int may_unmap: 1;
	unsigned int may_swap: 1;
	unsigned int memcg_low_reclaim: 1;
	unsigned int memcg_low_skipped: 1;
	unsigned int hibernation_mode: 1;
	unsigned int compaction_ready: 1;
	unsigned int cache_trim_mode: 1;
	unsigned int file_is_tiny: 1;
	s8 order;
	s8 priority;
	s8 reclaim_idx;
	gfp_t gfp_mask;
	long unsigned int nr_scanned;
	long unsigned int nr_reclaimed;
	struct {
		unsigned int dirty;
		unsigned int unqueued_dirty;
		unsigned int congested;
		unsigned int writeback;
		unsigned int immediate;
		unsigned int file_taken;
		unsigned int taken;
	} nr;
	struct reclaim_state reclaim_state;
};

typedef enum {
	PAGE_KEEP = 0,
	PAGE_ACTIVATE = 1,
	PAGE_SUCCESS = 2,
	PAGE_CLEAN = 3,
} pageout_t;

enum page_references {
	PAGEREF_RECLAIM = 0,
	PAGEREF_RECLAIM_CLEAN = 1,
	PAGEREF_KEEP = 2,
	PAGEREF_ACTIVATE = 3,
};

enum scan_balance {
	SCAN_EQUAL = 0,
	SCAN_FRACT = 1,
	SCAN_ANON = 2,
	SCAN_FILE = 3,
};

struct kstatfs {
	long int f_type;
	long int f_bsize;
	u64 f_blocks;
	u64 f_bfree;
	u64 f_bavail;
	u64 f_files;
	u64 f_ffree;
	__kernel_fsid_t f_fsid;
	long int f_namelen;
	long int f_frsize;
	long int f_flags;
	long int f_spare[4];
};

struct xattr;

typedef int (*initxattrs)(struct inode *, const struct xattr *, void *);

struct xattr {
	const char *name;
	void *value;
	size_t value_len;
};

struct constant_table {
	const char *name;
	int value;
};

struct shared_policy {};

struct simple_xattrs {
	struct list_head head;
	spinlock_t lock;
};

struct simple_xattr {
	struct list_head list;
	char *name;
	size_t size;
	char value[0];
};

struct shmem_inode_info {
	spinlock_t lock;
	unsigned int seals;
	long unsigned int flags;
	long unsigned int alloced;
	long unsigned int swapped;
	struct list_head shrinklist;
	struct list_head swaplist;
	struct shared_policy policy;
	struct simple_xattrs xattrs;
	atomic_t stop_eviction;
	struct inode vfs_inode;
};

struct shmem_sb_info {
	long unsigned int max_blocks;
	struct percpu_counter used_blocks;
	long unsigned int max_inodes;
	long unsigned int free_inodes;
	spinlock_t stat_lock;
	umode_t mode;
	unsigned char huge;
	kuid_t uid;
	kgid_t gid;
	bool full_inums;
	ino_t next_ino;
	ino_t *ino_batch;
	struct mempolicy *mpol;
	spinlock_t shrinklist_lock;
	struct list_head shrinklist;
	long unsigned int shrinklist_len;
};

enum sgp_type {
	SGP_READ = 0,
	SGP_CACHE = 1,
	SGP_NOHUGE = 2,
	SGP_HUGE = 3,
	SGP_WRITE = 4,
	SGP_FALLOC = 5,
};

enum fid_type {
	FILEID_ROOT = 0,
	FILEID_INO32_GEN = 1,
	FILEID_INO32_GEN_PARENT = 2,
	FILEID_BTRFS_WITHOUT_PARENT = 77,
	FILEID_BTRFS_WITH_PARENT = 78,
	FILEID_BTRFS_WITH_PARENT_ROOT = 79,
	FILEID_UDF_WITHOUT_PARENT = 81,
	FILEID_UDF_WITH_PARENT = 82,
	FILEID_NILFS_WITHOUT_PARENT = 97,
	FILEID_NILFS_WITH_PARENT = 98,
	FILEID_FAT_WITHOUT_PARENT = 113,
	FILEID_FAT_WITH_PARENT = 114,
	FILEID_LUSTRE = 151,
	FILEID_KERNFS = 254,
	FILEID_INVALID = 255,
};

struct shmem_falloc {
	wait_queue_head_t *waitq;
	long unsigned int start;
	long unsigned int next;
	long unsigned int nr_falloced;
	long unsigned int nr_unswapped;
};

struct shmem_options {
	long long unsigned int blocks;
	long long unsigned int inodes;
	struct mempolicy *mpol;
	kuid_t uid;
	kgid_t gid;
	umode_t mode;
	bool full_inums;
	int huge;
	int seen;
};

enum shmem_param {
	Opt_gid = 0,
	Opt_huge = 1,
	Opt_mode = 2,
	Opt_mpol = 3,
	Opt_nr_blocks = 4,
	Opt_nr_inodes = 5,
	Opt_size = 6,
	Opt_uid = 7,
	Opt_inode32 = 8,
	Opt_inode64 = 9,
};

enum writeback_stat_item {
	NR_DIRTY_THRESHOLD = 0,
	NR_DIRTY_BG_THRESHOLD = 1,
	NR_VM_WRITEBACK_STAT_ITEMS = 2,
};

struct contig_page_info {
	long unsigned int free_pages;
	long unsigned int free_blocks_total;
	long unsigned int free_blocks_suitable;
};

struct pcpu_group_info {
	int nr_units;
	long unsigned int base_offset;
	unsigned int *cpu_map;
};

struct pcpu_alloc_info {
	size_t static_size;
	size_t reserved_size;
	size_t dyn_size;
	size_t unit_size;
	size_t atom_size;
	size_t alloc_size;
	size_t __ai_size;
	int nr_groups;
	struct pcpu_group_info groups[0];
};

typedef void * (*pcpu_fc_alloc_fn_t)(unsigned int, size_t, size_t);

typedef void (*pcpu_fc_free_fn_t)(void *, size_t);

typedef int pcpu_fc_cpu_distance_fn_t(unsigned int, unsigned int);

struct trace_event_raw_percpu_alloc_percpu {
	struct trace_entry ent;
	bool reserved;
	bool is_atomic;
	size_t size;
	size_t align;
	void *base_addr;
	int off;
	void *ptr;
	char __data[0];
};

struct trace_event_raw_percpu_free_percpu {
	struct trace_entry ent;
	void *base_addr;
	int off;
	void *ptr;
	char __data[0];
};

struct trace_event_raw_percpu_alloc_percpu_fail {
	struct trace_entry ent;
	bool reserved;
	bool is_atomic;
	size_t size;
	size_t align;
	char __data[0];
};

struct trace_event_raw_percpu_create_chunk {
	struct trace_entry ent;
	void *base_addr;
	char __data[0];
};

struct trace_event_raw_percpu_destroy_chunk {
	struct trace_entry ent;
	void *base_addr;
	char __data[0];
};

struct trace_event_data_offsets_percpu_alloc_percpu {};

struct trace_event_data_offsets_percpu_free_percpu {};

struct trace_event_data_offsets_percpu_alloc_percpu_fail {};

struct trace_event_data_offsets_percpu_create_chunk {};

struct trace_event_data_offsets_percpu_destroy_chunk {};

typedef void (*btf_trace_percpu_alloc_percpu)(void *, bool, bool, size_t, size_t, void *, int, void *);

typedef void (*btf_trace_percpu_free_percpu)(void *, void *, int, void *);

typedef void (*btf_trace_percpu_alloc_percpu_fail)(void *, bool, bool, size_t, size_t);

typedef void (*btf_trace_percpu_create_chunk)(void *, void *);

typedef void (*btf_trace_percpu_destroy_chunk)(void *, void *);

enum pcpu_chunk_type {
	PCPU_CHUNK_ROOT = 0,
	PCPU_NR_CHUNK_TYPES = 1,
	PCPU_FAIL_ALLOC = 1,
};

struct pcpu_block_md {
	int scan_hint;
	int scan_hint_start;
	int contig_hint;
	int contig_hint_start;
	int left_free;
	int right_free;
	int first_free;
	int nr_bits;
};

struct pcpu_chunk {
	struct list_head list;
	int free_bytes;
	struct pcpu_block_md chunk_md;
	void *base_addr;
	long unsigned int *alloc_map;
	long unsigned int *bound_map;
	struct pcpu_block_md *md_blocks;
	void *data;
	bool immutable;
	int start_offset;
	int end_offset;
	int nr_pages;
	int nr_populated;
	int nr_empty_pop_pages;
	long unsigned int populated[0];
};

struct obj_cgroup;

struct trace_event_raw_kmem_alloc {
	struct trace_entry ent;
	long unsigned int call_site;
	const void *ptr;
	size_t bytes_req;
	size_t bytes_alloc;
	gfp_t gfp_flags;
	char __data[0];
};

struct trace_event_raw_kmem_alloc_node {
	struct trace_entry ent;
	long unsigned int call_site;
	const void *ptr;
	size_t bytes_req;
	size_t bytes_alloc;
	gfp_t gfp_flags;
	int node;
	char __data[0];
};

struct trace_event_raw_kmem_free {
	struct trace_entry ent;
	long unsigned int call_site;
	const void *ptr;
	char __data[0];
};

struct trace_event_raw_mm_page_free {
	struct trace_entry ent;
	long unsigned int pfn;
	unsigned int order;
	char __data[0];
};

struct trace_event_raw_mm_page_free_batched {
	struct trace_entry ent;
	long unsigned int pfn;
	char __data[0];
};

struct trace_event_raw_mm_page_alloc {
	struct trace_entry ent;
	long unsigned int pfn;
	unsigned int order;
	gfp_t gfp_flags;
	int migratetype;
	char __data[0];
};

struct trace_event_raw_mm_page {
	struct trace_entry ent;
	long unsigned int pfn;
	unsigned int order;
	int migratetype;
	char __data[0];
};

struct trace_event_raw_mm_page_pcpu_drain {
	struct trace_entry ent;
	long unsigned int pfn;
	unsigned int order;
	int migratetype;
	char __data[0];
};

struct trace_event_raw_mm_page_alloc_extfrag {
	struct trace_entry ent;
	long unsigned int pfn;
	int alloc_order;
	int fallback_order;
	int alloc_migratetype;
	int fallback_migratetype;
	int change_ownership;
	char __data[0];
};

struct trace_event_raw_rss_stat {
	struct trace_entry ent;
	unsigned int mm_id;
	unsigned int curr;
	int member;
	long int size;
	char __data[0];
};

struct trace_event_data_offsets_kmem_alloc {};

struct trace_event_data_offsets_kmem_alloc_node {};

struct trace_event_data_offsets_kmem_free {};

struct trace_event_data_offsets_mm_page_free {};

struct trace_event_data_offsets_mm_page_free_batched {};

struct trace_event_data_offsets_mm_page_alloc {};

struct trace_event_data_offsets_mm_page {};

struct trace_event_data_offsets_mm_page_pcpu_drain {};

struct trace_event_data_offsets_mm_page_alloc_extfrag {};

struct trace_event_data_offsets_rss_stat {};

typedef void (*btf_trace_kmalloc)(void *, long unsigned int, const void *, size_t, size_t, gfp_t);

typedef void (*btf_trace_kmem_cache_alloc)(void *, long unsigned int, const void *, size_t, size_t, gfp_t);

typedef void (*btf_trace_kmalloc_node)(void *, long unsigned int, const void *, size_t, size_t, gfp_t, int);

typedef void (*btf_trace_kmem_cache_alloc_node)(void *, long unsigned int, const void *, size_t, size_t, gfp_t, int);

typedef void (*btf_trace_kfree)(void *, long unsigned int, const void *);

typedef void (*btf_trace_kmem_cache_free)(void *, long unsigned int, const void *);

typedef void (*btf_trace_mm_page_free)(void *, struct page *, unsigned int);

typedef void (*btf_trace_mm_page_free_batched)(void *, struct page *);

typedef void (*btf_trace_mm_page_alloc)(void *, struct page *, unsigned int, gfp_t, int);

typedef void (*btf_trace_mm_page_alloc_zone_locked)(void *, struct page *, unsigned int, int);

typedef void (*btf_trace_mm_page_pcpu_drain)(void *, struct page *, unsigned int, int);

typedef void (*btf_trace_mm_page_alloc_extfrag)(void *, struct page *, int, int, int, int);

typedef void (*btf_trace_rss_stat)(void *, struct mm_struct *, int, long int);

enum slab_state {
	DOWN = 0,
	PARTIAL = 1,
	PARTIAL_NODE = 2,
	UP = 3,
	FULL = 4,
};

struct kmalloc_info_struct {
	const char *name[2];
	unsigned int size;
};

struct slabinfo {
	long unsigned int active_objs;
	long unsigned int num_objs;
	long unsigned int active_slabs;
	long unsigned int num_slabs;
	long unsigned int shared_avail;
	unsigned int limit;
	unsigned int batchcount;
	unsigned int shared;
	unsigned int objects_per_slab;
	unsigned int cache_order;
};

enum pageblock_bits {
	PB_migrate = 0,
	PB_migrate_end = 2,
	PB_migrate_skip = 3,
	NR_PAGEBLOCK_BITS = 4,
};

struct alloc_context {
	struct zonelist *zonelist;
	nodemask_t *nodemask;
	struct zoneref *preferred_zoneref;
	int migratetype;
	enum zone_type highest_zoneidx;
	bool spread_dirty_pages;
};

struct trace_event_raw_mm_compaction_isolate_template {
	struct trace_entry ent;
	long unsigned int start_pfn;
	long unsigned int end_pfn;
	long unsigned int nr_scanned;
	long unsigned int nr_taken;
	char __data[0];
};

struct trace_event_raw_mm_compaction_migratepages {
	struct trace_entry ent;
	long unsigned int nr_migrated;
	long unsigned int nr_failed;
	char __data[0];
};

struct trace_event_raw_mm_compaction_begin {
	struct trace_entry ent;
	long unsigned int zone_start;
	long unsigned int migrate_pfn;
	long unsigned int free_pfn;
	long unsigned int zone_end;
	bool sync;
	char __data[0];
};

struct trace_event_raw_mm_compaction_end {
	struct trace_entry ent;
	long unsigned int zone_start;
	long unsigned int migrate_pfn;
	long unsigned int free_pfn;
	long unsigned int zone_end;
	bool sync;
	int status;
	char __data[0];
};

struct trace_event_raw_mm_compaction_try_to_compact_pages {
	struct trace_entry ent;
	int order;
	gfp_t gfp_mask;
	int prio;
	char __data[0];
};

struct trace_event_raw_mm_compaction_suitable_template {
	struct trace_entry ent;
	int nid;
	enum zone_type idx;
	int order;
	int ret;
	char __data[0];
};

struct trace_event_raw_mm_compaction_defer_template {
	struct trace_entry ent;
	int nid;
	enum zone_type idx;
	int order;
	unsigned int considered;
	unsigned int defer_shift;
	int order_failed;
	char __data[0];
};

struct trace_event_raw_mm_compaction_kcompactd_sleep {
	struct trace_entry ent;
	int nid;
	char __data[0];
};

struct trace_event_raw_kcompactd_wake_template {
	struct trace_entry ent;
	int nid;
	int order;
	enum zone_type highest_zoneidx;
	char __data[0];
};

struct trace_event_data_offsets_mm_compaction_isolate_template {};

struct trace_event_data_offsets_mm_compaction_migratepages {};

struct trace_event_data_offsets_mm_compaction_begin {};

struct trace_event_data_offsets_mm_compaction_end {};

struct trace_event_data_offsets_mm_compaction_try_to_compact_pages {};

struct trace_event_data_offsets_mm_compaction_suitable_template {};

struct trace_event_data_offsets_mm_compaction_defer_template {};

struct trace_event_data_offsets_mm_compaction_kcompactd_sleep {};

struct trace_event_data_offsets_kcompactd_wake_template {};

typedef void (*btf_trace_mm_compaction_isolate_migratepages)(void *, long unsigned int, long unsigned int, long unsigned int, long unsigned int);

typedef void (*btf_trace_mm_compaction_isolate_freepages)(void *, long unsigned int, long unsigned int, long unsigned int, long unsigned int);

typedef void (*btf_trace_mm_compaction_migratepages)(void *, long unsigned int, int, struct list_head *);

typedef void (*btf_trace_mm_compaction_begin)(void *, long unsigned int, long unsigned int, long unsigned int, long unsigned int, bool);

typedef void (*btf_trace_mm_compaction_end)(void *, long unsigned int, long unsigned int, long unsigned int, long unsigned int, bool, int);

typedef void (*btf_trace_mm_compaction_try_to_compact_pages)(void *, int, gfp_t, int);

typedef void (*btf_trace_mm_compaction_finished)(void *, struct zone *, int, int);

typedef void (*btf_trace_mm_compaction_suitable)(void *, struct zone *, int, int);

typedef void (*btf_trace_mm_compaction_deferred)(void *, struct zone *, int);

typedef void (*btf_trace_mm_compaction_defer_compaction)(void *, struct zone *, int);

typedef void (*btf_trace_mm_compaction_defer_reset)(void *, struct zone *, int);

typedef void (*btf_trace_mm_compaction_kcompactd_sleep)(void *, int);

typedef void (*btf_trace_mm_compaction_wakeup_kcompactd)(void *, int, int, enum zone_type);

typedef void (*btf_trace_mm_compaction_kcompactd_wake)(void *, int, int, enum zone_type);

typedef enum {
	ISOLATE_ABORT = 0,
	ISOLATE_NONE = 1,
	ISOLATE_SUCCESS = 2,
} isolate_migrate_t;

struct anon_vma_chain {
	struct vm_area_struct *vma;
	struct anon_vma *anon_vma;
	struct list_head same_vma;
	struct rb_node rb;
	long unsigned int rb_subtree_last;
};

struct rb_augment_callbacks {
	void (*propagate)(struct rb_node *, struct rb_node *);
	void (*copy)(struct rb_node *, struct rb_node *);
	void (*rotate)(struct rb_node *, struct rb_node *);
};

enum lru_status {
	LRU_REMOVED = 0,
	LRU_REMOVED_RETRY = 1,
	LRU_ROTATE = 2,
	LRU_SKIP = 3,
	LRU_RETRY = 4,
};

typedef enum lru_status (*list_lru_walk_cb)(struct list_head *, struct list_lru_one *, spinlock_t *, void *);

typedef struct {
	long unsigned int pd;
} hugepd_t;

struct migration_target_control {
	int nid;
	nodemask_t *nmask;
	gfp_t gfp_mask;
};

struct follow_page_context {
	struct dev_pagemap *pgmap;
	unsigned int page_mask;
};

typedef struct {
	u64 val;
} pfn_t;

typedef unsigned int pgtbl_mod_mask;

struct zap_details {
	struct address_space *check_mapping;
	long unsigned int first_index;
	long unsigned int last_index;
	struct page *single_page;
};

typedef int (*pte_fn_t)(pte_t *, long unsigned int, void *);

enum {
	SWP_USED = 1,
	SWP_WRITEOK = 2,
	SWP_DISCARDABLE = 4,
	SWP_DISCARDING = 8,
	SWP_SOLIDSTATE = 16,
	SWP_CONTINUED = 32,
	SWP_BLKDEV = 64,
	SWP_ACTIVATED = 128,
	SWP_FS_OPS = 256,
	SWP_AREA_DISCARD = 512,
	SWP_PAGE_DISCARD = 1024,
	SWP_STABLE_WRITES = 2048,
	SWP_SYNCHRONOUS_IO = 4096,
	SWP_VALID = 8192,
	SWP_SCANNING = 16384,
};

struct trace_event_raw_spf {
	struct trace_entry ent;
	long unsigned int caller;
	long unsigned int vm_start;
	long unsigned int vm_end;
	long unsigned int address;
	char __data[0];
};

struct trace_event_data_offsets_spf {};

typedef void (*btf_trace_spf_pte_lock)(void *, long unsigned int, struct vm_area_struct *, long unsigned int);

typedef void (*btf_trace_spf_vma_changed)(void *, long unsigned int, struct vm_area_struct *, long unsigned int);

typedef void (*btf_trace_spf_vma_noanon)(void *, long unsigned int, struct vm_area_struct *, long unsigned int);

typedef void (*btf_trace_spf_vma_notsup)(void *, long unsigned int, struct vm_area_struct *, long unsigned int);

typedef void (*btf_trace_spf_vma_access)(void *, long unsigned int, struct vm_area_struct *, long unsigned int);

typedef void (*btf_trace_spf_pmd_changed)(void *, long unsigned int, struct vm_area_struct *, long unsigned int);

struct copy_subpage_arg {
	struct page *dst;
	struct page *src;
	struct vm_area_struct *vma;
};

struct hstate;

struct hugepage_subpool {
	spinlock_t lock;
	long int count;
	long int max_hpages;
	long int used_hpages;
	struct hstate *hstate;
	long int min_hpages;
	long int rsv_hpages;
};

struct hstate {
	int next_nid_to_alloc;
	int next_nid_to_free;
	unsigned int order;
	long unsigned int mask;
	long unsigned int max_huge_pages;
	long unsigned int nr_huge_pages;
	long unsigned int free_huge_pages;
	long unsigned int resv_huge_pages;
	long unsigned int surplus_huge_pages;
	long unsigned int nr_overcommit_huge_pages;
	struct list_head hugepage_activelist;
	struct list_head hugepage_freelists[1];
	unsigned int nr_huge_pages_node[1];
	unsigned int free_huge_pages_node[1];
	unsigned int surplus_huge_pages_node[1];
	char name[32];
};

enum {
	HUGETLB_SHMFS_INODE = 1,
	HUGETLB_ANONHUGE_INODE = 2,
};

struct hugetlbfs_sb_info {
	long int max_inodes;
	long int free_inodes;
	spinlock_t stat_lock;
	struct hstate *hstate;
	struct hugepage_subpool *spool;
	kuid_t uid;
	kgid_t gid;
	umode_t mode;
};

struct trace_event_raw_vm_unmapped_area {
	struct trace_entry ent;
	long unsigned int addr;
	long unsigned int total_vm;
	long unsigned int flags;
	long unsigned int length;
	long unsigned int low_limit;
	long unsigned int high_limit;
	long unsigned int align_mask;
	long unsigned int align_offset;
	char __data[0];
};

struct trace_event_data_offsets_vm_unmapped_area {};

typedef void (*btf_trace_vm_unmapped_area)(void *, long unsigned int, struct vm_unmapped_area_info *);

enum pgt_entry {
	NORMAL_PMD = 0,
	HPAGE_PMD = 1,
	NORMAL_PUD = 2,
};

struct rmap_walk_control {
	void *arg;
	bool (*rmap_one)(struct page *, struct vm_area_struct *, long unsigned int, void *);
	int (*done)(struct page *);
	struct anon_vma * (*anon_lock)(struct page *);
	bool (*invalid_vma)(struct vm_area_struct *, void *);
};

struct page_referenced_arg {
	int mapcount;
	int referenced;
	long unsigned int vm_flags;
	struct mem_cgroup *memcg;
};

struct vmap_area {
	long unsigned int va_start;
	long unsigned int va_end;
	struct rb_node rb_node;
	struct list_head list;
	union {
		long unsigned int subtree_max_size;
		struct vm_struct *vm;
		struct llist_node purge_list;
	};
};

struct vfree_deferred {
	struct llist_head list;
	struct work_struct wq;
};

enum fit_type {
	NOTHING_FIT = 0,
	FL_FIT_TYPE = 1,
	LE_FIT_TYPE = 2,
	RE_FIT_TYPE = 3,
	NE_FIT_TYPE = 4,
};

struct vmap_block_queue {
	spinlock_t lock;
	struct list_head free;
};

struct vmap_block {
	spinlock_t lock;
	struct vmap_area *va;
	long unsigned int free;
	long unsigned int dirty;
	long unsigned int dirty_min;
	long unsigned int dirty_max;
	struct list_head free_list;
	struct callback_head callback_head;
	struct list_head purge;
};

struct va_format {
	const char *fmt;
	va_list *va;
};

struct page_frag_cache {
	void *va;
	__u16 offset;
	__u16 size;
	unsigned int pagecnt_bias;
	bool pfmemalloc;
};

enum zone_flags {
	ZONE_BOOSTED_WATERMARK = 0,
};

enum meminit_context {
	MEMINIT_EARLY = 0,
	MEMINIT_HOTPLUG = 1,
};

struct acr_info {
	long unsigned int nr_mapped;
	long unsigned int nr_migrated;
	long unsigned int nr_reclaimed;
	unsigned int err;
	long unsigned int failed_pfn;
};

enum mminit_level {
	MMINIT_WARNING = 0,
	MMINIT_VERIFY = 1,
	MMINIT_TRACE = 2,
};

typedef int fpi_t;

struct pcpu_drain {
	struct zone *zone;
	struct work_struct work;
};

struct madvise_walk_private {
	struct mmu_gather *tlb;
	bool pageout;
};

enum {
	BIO_NO_PAGE_REF = 0,
	BIO_CLONED = 1,
	BIO_BOUNCED = 2,
	BIO_WORKINGSET = 3,
	BIO_QUIET = 4,
	BIO_CHAIN = 5,
	BIO_REFFED = 6,
	BIO_THROTTLED = 7,
	BIO_TRACE_COMPLETION = 8,
	BIO_CGROUP_ACCT = 9,
	BIO_TRACKED = 10,
	BIO_FLAG_LAST = 11,
};

struct vma_swap_readahead {
	short unsigned int win;
	short unsigned int offset;
	short unsigned int nr_pte;
	pte_t *ptes;
};

union swap_header {
	struct {
		char reserved[4086];
		char magic[10];
	} magic;
	struct {
		char bootbits[1024];
		__u32 version;
		__u32 last_page;
		__u32 nr_badpages;
		unsigned char sws_uuid[16];
		unsigned char sws_volume[16];
		__u32 padding[117];
		__u32 badpages[1];
	} info;
};

struct swap_extent {
	struct rb_node rb_node;
	long unsigned int start_page;
	long unsigned int nr_pages;
	sector_t start_block;
};

struct swap_slots_cache {
	bool lock_initialized;
	struct mutex alloc_lock;
	swp_entry_t *slots;
	int nr;
	int cur;
	spinlock_t free_lock;
	swp_entry_t *slots_ret;
	int n_ret;
};

struct dma_pool {
	struct list_head page_list;
	spinlock_t lock;
	size_t size;
	struct device *dev;
	size_t allocation;
	size_t boundary;
	char name[32];
	struct list_head pools;
};

struct dma_page {
	struct list_head page_list;
	void *vaddr;
	dma_addr_t dma;
	unsigned int in_use;
	unsigned int offset;
};

enum string_size_units {
	STRING_UNITS_10 = 0,
	STRING_UNITS_2 = 1,
};

struct resv_map {
	struct kref refs;
	spinlock_t lock;
	struct list_head regions;
	long int adds_in_progress;
	struct list_head region_cache;
	long int region_cache_count;
};

struct file_region {
	struct list_head link;
	long int from;
	long int to;
};

struct huge_bootmem_page {
	struct list_head list;
	struct hstate *hstate;
};

enum vma_resv_mode {
	VMA_NEEDS_RESV = 0,
	VMA_COMMIT_RESV = 1,
	VMA_END_RESV = 2,
	VMA_ADD_RESV = 3,
};

struct hugetlb_cgroup;

struct mmu_notifier_subscriptions_hdr {
	bool valid;
};

struct mmu_notifier_subscriptions {
	struct mmu_notifier_subscriptions_hdr hdr;
	struct hlist_head list;
	bool has_itree;
	spinlock_t lock;
	long unsigned int invalidate_seq;
	long unsigned int active_invalidate_ranges;
	struct rb_root_cached itree;
	wait_queue_head_t wq;
	struct hlist_head deferred_list;
};

struct interval_tree_node {
	struct rb_node rb;
	long unsigned int start;
	long unsigned int last;
	long unsigned int __subtree_last;
};

struct mmu_interval_notifier;

struct mmu_interval_notifier_ops {
	bool (*invalidate)(struct mmu_interval_notifier *, const struct mmu_notifier_range *, long unsigned int);
};

struct mmu_interval_notifier {
	struct interval_tree_node interval_tree;
	const struct mmu_interval_notifier_ops *ops;
	struct mm_struct *mm;
	struct hlist_node deferred_item;
	long unsigned int invalidate_seq;
};

enum stat_item {
	ALLOC_FASTPATH = 0,
	ALLOC_SLOWPATH = 1,
	FREE_FASTPATH = 2,
	FREE_SLOWPATH = 3,
	FREE_FROZEN = 4,
	FREE_ADD_PARTIAL = 5,
	FREE_REMOVE_PARTIAL = 6,
	ALLOC_FROM_PARTIAL = 7,
	ALLOC_SLAB = 8,
	ALLOC_REFILL = 9,
	ALLOC_NODE_MISMATCH = 10,
	FREE_SLAB = 11,
	CPUSLAB_FLUSH = 12,
	DEACTIVATE_FULL = 13,
	DEACTIVATE_EMPTY = 14,
	DEACTIVATE_TO_HEAD = 15,
	DEACTIVATE_TO_TAIL = 16,
	DEACTIVATE_REMOTE_FREES = 17,
	DEACTIVATE_BYPASS = 18,
	ORDER_FALLBACK = 19,
	CMPXCHG_DOUBLE_CPU_FAIL = 20,
	CMPXCHG_DOUBLE_FAIL = 21,
	CPU_PARTIAL_ALLOC = 22,
	CPU_PARTIAL_FREE = 23,
	CPU_PARTIAL_NODE = 24,
	CPU_PARTIAL_DRAIN = 25,
	NR_SLUB_STAT_ITEMS = 26,
};

struct track {
	long unsigned int addr;
	long unsigned int addrs[16];
	int cpu;
	int pid;
	long unsigned int when;
};

enum track_item {
	TRACK_ALLOC = 0,
	TRACK_FREE = 1,
};

struct detached_freelist {
	struct page *page;
	void *tail;
	void *freelist;
	int cnt;
	struct kmem_cache *s;
};

struct location {
	long unsigned int count;
	long unsigned int addr;
	long long int sum_time;
	long int min_time;
	long int max_time;
	long int min_pid;
	long int max_pid;
	long unsigned int cpus[1];
	nodemask_t nodes;
};

struct loc_track {
	long unsigned int max;
	long unsigned int count;
	struct location *loc;
	loff_t idx;
};

enum slab_stat_type {
	SL_ALL = 0,
	SL_PARTIAL = 1,
	SL_CPU = 2,
	SL_OBJECTS = 3,
	SL_TOTAL = 4,
};

struct slab_attribute {
	struct attribute attr;
	ssize_t (*show)(struct kmem_cache *, char *);
	ssize_t (*store)(struct kmem_cache *, const char *, size_t);
};

struct saved_alias {
	struct kmem_cache *s;
	const char *name;
	struct saved_alias *next;
};

enum slab_modes {
	M_NONE = 0,
	M_PARTIAL = 1,
	M_FULL = 2,
	M_FREE = 3,
};

struct buffer_head;

typedef void bh_end_io_t(struct buffer_head *, int);

struct buffer_head {
	long unsigned int b_state;
	struct buffer_head *b_this_page;
	struct page *b_page;
	sector_t b_blocknr;
	size_t b_size;
	char *b_data;
	struct block_device *b_bdev;
	bh_end_io_t *b_end_io;
	void *b_private;
	struct list_head b_assoc_buffers;
	struct address_space *b_assoc_map;
	atomic_t b_count;
	spinlock_t b_uptodate_lock;
};

typedef struct page *new_page_t(struct page *, long unsigned int);

typedef void free_page_t(struct page *, long unsigned int);

enum bh_state_bits {
	BH_Uptodate = 0,
	BH_Dirty = 1,
	BH_Lock = 2,
	BH_Req = 3,
	BH_Mapped = 4,
	BH_New = 5,
	BH_Async_Read = 6,
	BH_Async_Write = 7,
	BH_Delay = 8,
	BH_Boundary = 9,
	BH_Write_EIO = 10,
	BH_Unwritten = 11,
	BH_Quiet = 12,
	BH_Meta = 13,
	BH_Prio = 14,
	BH_Defer_Completion = 15,
	BH_PrivateStart = 16,
};

struct trace_event_raw_mm_migrate_pages {
	struct trace_entry ent;
	long unsigned int succeeded;
	long unsigned int failed;
	long unsigned int thp_succeeded;
	long unsigned int thp_failed;
	long unsigned int thp_split;
	enum migrate_mode mode;
	int reason;
	char __data[0];
};

struct trace_event_raw_mm_migrate_pages_start {
	struct trace_entry ent;
	enum migrate_mode mode;
	int reason;
	char __data[0];
};

struct trace_event_data_offsets_mm_migrate_pages {};

struct trace_event_data_offsets_mm_migrate_pages_start {};

typedef void (*btf_trace_mm_migrate_pages)(void *, long unsigned int, long unsigned int, long unsigned int, long unsigned int, long unsigned int, enum migrate_mode, int);

typedef void (*btf_trace_mm_migrate_pages_start)(void *, enum migrate_mode, int);

struct trace_event_raw_test_pages_isolated {
	struct trace_entry ent;
	long unsigned int start_pfn;
	long unsigned int end_pfn;
	long unsigned int fin_pfn;
	char __data[0];
};

struct trace_event_data_offsets_test_pages_isolated {};

typedef void (*btf_trace_test_pages_isolated)(void *, long unsigned int, long unsigned int, long unsigned int);

struct debugfs_u32_array {
	u32 *array;
	u32 n_elements;
};

struct cma {
	long unsigned int base_pfn;
	long unsigned int count;
	long unsigned int *bitmap;
	unsigned int order_per_bit;
	struct mutex lock;
	struct hlist_head mem_head;
	spinlock_t mem_head_lock;
	struct debugfs_u32_array dfs_bitmap;
	char name[64];
};

struct cma_alloc_info {
	long unsigned int nr_migrated;
	long unsigned int nr_reclaimed;
	long unsigned int nr_mapped;
	unsigned int nr_isolate_fail;
	unsigned int nr_migrate_fail;
	unsigned int nr_test_fail;
};

struct trace_event_raw_cma_alloc_class {
	struct trace_entry ent;
	u32 __data_loc_name;
	long unsigned int pfn;
	const struct page *page;
	unsigned int count;
	unsigned int align;
	char __data[0];
};

struct trace_event_raw_cma_release {
	struct trace_entry ent;
	u32 __data_loc_name;
	long unsigned int pfn;
	const struct page *page;
	unsigned int count;
	char __data[0];
};

struct trace_event_raw_cma_alloc_start {
	struct trace_entry ent;
	u32 __data_loc_name;
	unsigned int count;
	unsigned int align;
	char __data[0];
};

struct trace_event_raw_cma_alloc_info {
	struct trace_entry ent;
	u32 __data_loc_name;
	long unsigned int pfn;
	unsigned int count;
	unsigned int align;
	long unsigned int nr_migrated;
	long unsigned int nr_reclaimed;
	long unsigned int nr_mapped;
	unsigned int err_iso;
	unsigned int err_mig;
	unsigned int err_test;
	char __data[0];
};

struct trace_event_data_offsets_cma_alloc_class {
	u32 name;
};

struct trace_event_data_offsets_cma_release {
	u32 name;
};

struct trace_event_data_offsets_cma_alloc_start {
	u32 name;
};

struct trace_event_data_offsets_cma_alloc_info {
	u32 name;
};

typedef void (*btf_trace_cma_release)(void *, const char *, long unsigned int, const struct page *, unsigned int);

typedef void (*btf_trace_cma_alloc_start)(void *, const char *, unsigned int, unsigned int);

typedef void (*btf_trace_cma_alloc_info)(void *, const char *, const struct page *, unsigned int, unsigned int, struct cma_alloc_info *);

typedef void (*btf_trace_cma_alloc_finish)(void *, const char *, long unsigned int, const struct page *, unsigned int, unsigned int);

typedef void (*btf_trace_cma_alloc_busy_retry)(void *, const char *, long unsigned int, const struct page *, unsigned int, unsigned int);

struct cma_mem {
	struct hlist_node node;
	struct page *p;
	long unsigned int n;
};

struct frame_vector {
	unsigned int nr_allocated;
	unsigned int nr_frames;
	bool got_ref;
	bool is_pfns;
	void *ptrs[0];
};

struct hugetlbfs_inode_info {
	struct shared_policy policy;
	struct inode vfs_inode;
	unsigned int seals;
};

struct open_how {
	__u64 flags;
	__u64 mode;
	__u64 resolve;
};

struct open_flags {
	int open_flag;
	umode_t mode;
	int acc_mode;
	int intent;
	int lookup_flags;
};

typedef __kernel_rwf_t rwf_t;

enum vfs_get_super_keying {
	vfs_get_single_super = 0,
	vfs_get_single_reconf_super = 1,
	vfs_get_keyed_super = 2,
	vfs_get_independent_super = 3,
};

struct kobj_map;

struct char_device_struct {
	struct char_device_struct *next;
	unsigned int major;
	unsigned int baseminor;
	int minorct;
	char name[64];
	struct cdev *cdev;
};

struct stat {
	long unsigned int st_dev;
	long unsigned int st_ino;
	unsigned int st_mode;
	unsigned int st_nlink;
	unsigned int st_uid;
	unsigned int st_gid;
	long unsigned int st_rdev;
	long unsigned int __pad1;
	long int st_size;
	int st_blksize;
	int __pad2;
	long int st_blocks;
	long int st_atime;
	long unsigned int st_atime_nsec;
	long int st_mtime;
	long unsigned int st_mtime_nsec;
	long int st_ctime;
	long unsigned int st_ctime_nsec;
	unsigned int __unused4;
	unsigned int __unused5;
};

struct statx_timestamp {
	__s64 tv_sec;
	__u32 tv_nsec;
	__s32 __reserved;
};

struct statx {
	__u32 stx_mask;
	__u32 stx_blksize;
	__u64 stx_attributes;
	__u32 stx_nlink;
	__u32 stx_uid;
	__u32 stx_gid;
	__u16 stx_mode;
	__u16 __spare0[1];
	__u64 stx_ino;
	__u64 stx_size;
	__u64 stx_blocks;
	__u64 stx_attributes_mask;
	struct statx_timestamp stx_atime;
	struct statx_timestamp stx_btime;
	struct statx_timestamp stx_ctime;
	struct statx_timestamp stx_mtime;
	__u32 stx_rdev_major;
	__u32 stx_rdev_minor;
	__u32 stx_dev_major;
	__u32 stx_dev_minor;
	__u64 stx_mnt_id;
	__u64 __spare2;
	__u64 __spare3[12];
};

struct mount;

struct mnt_namespace {
	atomic_t count;
	struct ns_common ns;
	struct mount *root;
	struct list_head list;
	spinlock_t ns_lock;
	struct user_namespace *user_ns;
	struct ucounts *ucounts;
	u64 seq;
	wait_queue_head_t poll;
	u64 event;
	unsigned int mounts;
	unsigned int pending_mounts;
};

struct mnt_pcp;

struct mountpoint;

struct mount {
	struct hlist_node mnt_hash;
	struct mount *mnt_parent;
	struct dentry *mnt_mountpoint;
	struct vfsmount mnt;
	union {
		struct callback_head mnt_rcu;
		struct llist_node mnt_llist;
	};
	struct mnt_pcp *mnt_pcp;
	struct list_head mnt_mounts;
	struct list_head mnt_child;
	struct list_head mnt_instance;
	const char *mnt_devname;
	struct list_head mnt_list;
	struct list_head mnt_expire;
	struct list_head mnt_share;
	struct list_head mnt_slave_list;
	struct list_head mnt_slave;
	struct mount *mnt_master;
	struct mnt_namespace *mnt_ns;
	struct mountpoint *mnt_mp;
	union {
		struct hlist_node mnt_mp_list;
		struct hlist_node mnt_umount;
	};
	struct list_head mnt_umounting;
	struct fsnotify_mark_connector *mnt_fsnotify_marks;
	__u32 mnt_fsnotify_mask;
	int mnt_id;
	int mnt_group_id;
	int mnt_expiry_mark;
	struct hlist_head mnt_pins;
	struct hlist_head mnt_stuck_children;
};

struct mnt_pcp {
	int mnt_count;
	int mnt_writers;
};

struct mountpoint {
	struct hlist_node m_hash;
	struct dentry *m_dentry;
	struct hlist_head m_list;
	int m_count;
};

typedef short unsigned int ushort;

struct user_arg_ptr {
	union {
		const char * const *native;
	} ptr;
};

enum inode_i_mutex_lock_class {
	I_MUTEX_NORMAL = 0,
	I_MUTEX_PARENT = 1,
	I_MUTEX_CHILD = 2,
	I_MUTEX_XATTR = 3,
	I_MUTEX_NONDIR2 = 4,
	I_MUTEX_PARENT2 = 5,
};

struct pseudo_fs_context {
	const struct super_operations *ops;
	const struct xattr_handler **xattr;
	const struct dentry_operations *dops;
	long unsigned int magic;
};

struct name_snapshot {
	struct qstr name;
	unsigned char inline_name[32];
};

struct saved {
	struct path link;
	struct delayed_call done;
	const char *name;
	unsigned int seq;
};

struct nameidata {
	struct path path;
	struct qstr last;
	struct path root;
	struct inode *inode;
	unsigned int flags;
	unsigned int seq;
	unsigned int m_seq;
	unsigned int r_seq;
	int last_type;
	unsigned int depth;
	int total_link_count;
	struct saved *stack;
	struct saved internal[2];
	struct filename *name;
	struct nameidata *saved;
	unsigned int root_seq;
	int dfd;
	kuid_t dir_uid;
	umode_t dir_mode;
};

enum {
	LAST_NORM = 0,
	LAST_ROOT = 1,
	LAST_DOT = 2,
	LAST_DOTDOT = 3,
};

struct trace_event_raw_inodepath {
	struct trace_entry ent;
	long unsigned int ino;
	long unsigned int dev;
	u32 __data_loc_path;
	char __data[0];
};

struct trace_event_data_offsets_inodepath {
	u32 path;
};

typedef void (*btf_trace_inodepath)(void *, struct inode *, char *);

enum {
	WALK_TRAILING = 1,
	WALK_MORE = 2,
	WALK_NOFOLLOW = 4,
};

struct f_owner_ex {
	int type;
	__kernel_pid_t pid;
};

struct flock {
	short int l_type;
	short int l_whence;
	__kernel_off_t l_start;
	__kernel_off_t l_len;
	__kernel_pid_t l_pid;
};

struct file_clone_range {
	__s64 src_fd;
	__u64 src_offset;
	__u64 src_length;
	__u64 dest_offset;
};

struct file_dedupe_range_info {
	__s64 dest_fd;
	__u64 dest_offset;
	__u64 bytes_deduped;
	__s32 status;
	__u32 reserved;
};

struct file_dedupe_range {
	__u64 src_offset;
	__u64 src_length;
	__u16 dest_count;
	__u16 reserved1;
	__u32 reserved2;
	struct file_dedupe_range_info info[0];
};

typedef int get_block_t(struct inode *, sector_t, struct buffer_head *, int);

struct fiemap_extent;

struct fiemap_extent_info {
	unsigned int fi_flags;
	unsigned int fi_extents_mapped;
	unsigned int fi_extents_max;
	struct fiemap_extent *fi_extents_start;
};

struct space_resv {
	__s16 l_type;
	__s16 l_whence;
	__s64 l_start;
	__s64 l_len;
	__s32 l_sysid;
	__u32 l_pid;
	__s32 l_pad[4];
};

struct fiemap_extent {
	__u64 fe_logical;
	__u64 fe_physical;
	__u64 fe_length;
	__u64 fe_reserved64[2];
	__u32 fe_flags;
	__u32 fe_reserved[3];
};

struct fiemap {
	__u64 fm_start;
	__u64 fm_length;
	__u32 fm_flags;
	__u32 fm_mapped_extents;
	__u32 fm_extent_count;
	__u32 fm_reserved;
	struct fiemap_extent fm_extents[0];
};

struct linux_dirent64 {
	u64 d_ino;
	s64 d_off;
	short unsigned int d_reclen;
	unsigned char d_type;
	char d_name[0];
};

struct linux_dirent {
	long unsigned int d_ino;
	long unsigned int d_off;
	short unsigned int d_reclen;
	char d_name[1];
};

struct getdents_callback {
	struct dir_context ctx;
	struct linux_dirent *current_dir;
	int prev_reclen;
	int count;
	int error;
};

struct getdents_callback64 {
	struct dir_context ctx;
	struct linux_dirent64 *current_dir;
	int prev_reclen;
	int count;
	int error;
};

typedef struct {
	long unsigned int fds_bits[16];
} __kernel_fd_set;

typedef __kernel_fd_set fd_set;

struct old_timeval32 {
	old_time32_t tv_sec;
	s32 tv_usec;
};

struct poll_table_entry {
	struct file *filp;
	__poll_t key;
	wait_queue_entry_t wait;
	wait_queue_head_t *wait_address;
};

struct poll_table_page;

struct poll_wqueues {
	poll_table pt;
	struct poll_table_page *table;
	struct task_struct *polling_task;
	int triggered;
	int error;
	int inline_index;
	struct poll_table_entry inline_entries[9];
};

struct poll_table_page {
	struct poll_table_page *next;
	struct poll_table_entry *entry;
	struct poll_table_entry entries[0];
};

enum poll_time_type {
	PT_TIMEVAL = 0,
	PT_OLD_TIMEVAL = 1,
	PT_TIMESPEC = 2,
	PT_OLD_TIMESPEC = 3,
};

typedef struct {
	long unsigned int *in;
	long unsigned int *out;
	long unsigned int *ex;
	long unsigned int *res_in;
	long unsigned int *res_out;
	long unsigned int *res_ex;
} fd_set_bits;

struct sigset_argpack {
	sigset_t *p;
	size_t size;
};

struct poll_list {
	struct poll_list *next;
	int len;
	struct pollfd entries[0];
};

enum dentry_d_lock_class {
	DENTRY_D_LOCK_NORMAL = 0,
	DENTRY_D_LOCK_NESTED = 1,
};

struct external_name {
	union {
		atomic_t count;
		struct callback_head head;
	} u;
	unsigned char name[0];
};

enum d_walk_ret {
	D_WALK_CONTINUE = 0,
	D_WALK_QUIT = 1,
	D_WALK_NORETRY = 2,
	D_WALK_SKIP = 3,
};

struct check_mount {
	struct vfsmount *mnt;
	unsigned int mounted;
};

struct select_data {
	struct dentry *start;
	union {
		long int found;
		struct dentry *victim;
	};
	struct list_head dispose;
};

struct fsxattr {
	__u32 fsx_xflags;
	__u32 fsx_extsize;
	__u32 fsx_nextents;
	__u32 fsx_projid;
	__u32 fsx_cowextsize;
	unsigned char fsx_pad[8];
};

enum file_time_flags {
	S_ATIME = 1,
	S_MTIME = 2,
	S_CTIME = 4,
	S_VERSION = 8,
};

struct proc_mounts {
	struct mnt_namespace *ns;
	struct path root;
	int (*show)(struct seq_file *, struct vfsmount *);
	struct mount cursor;
};

enum umount_tree_flags {
	UMOUNT_SYNC = 1,
	UMOUNT_PROPAGATE = 2,
	UMOUNT_CONNECTED = 4,
};

struct simple_transaction_argresp {
	ssize_t size;
	char data[0];
};

struct simple_attr {
	int (*get)(void *, u64 *);
	int (*set)(void *, u64);
	char get_buf[24];
	char set_buf[24];
	void *data;
	const char *fmt;
	struct mutex mutex;
};

struct wb_completion {
	atomic_t cnt;
	wait_queue_head_t *waitq;
};

struct wb_writeback_work {
	long int nr_pages;
	struct super_block *sb;
	enum writeback_sync_modes sync_mode;
	unsigned int tagged_writepages: 1;
	unsigned int for_kupdate: 1;
	unsigned int range_cyclic: 1;
	unsigned int for_background: 1;
	unsigned int for_sync: 1;
	unsigned int auto_free: 1;
	enum wb_reason reason;
	struct list_head list;
	struct wb_completion *done;
};

struct trace_event_raw_writeback_page_template {
	struct trace_entry ent;
	char name[32];
	ino_t ino;
	long unsigned int index;
	char __data[0];
};

struct trace_event_raw_writeback_dirty_inode_template {
	struct trace_entry ent;
	char name[32];
	ino_t ino;
	long unsigned int state;
	long unsigned int flags;
	char __data[0];
};

struct trace_event_raw_writeback_write_inode_template {
	struct trace_entry ent;
	char name[32];
	ino_t ino;
	int sync_mode;
	ino_t cgroup_ino;
	char __data[0];
};

struct trace_event_raw_writeback_work_class {
	struct trace_entry ent;
	char name[32];
	long int nr_pages;
	dev_t sb_dev;
	int sync_mode;
	int for_kupdate;
	int range_cyclic;
	int for_background;
	int reason;
	ino_t cgroup_ino;
	char __data[0];
};

struct trace_event_raw_writeback_pages_written {
	struct trace_entry ent;
	long int pages;
	char __data[0];
};

struct trace_event_raw_writeback_class {
	struct trace_entry ent;
	char name[32];
	ino_t cgroup_ino;
	char __data[0];
};

struct trace_event_raw_writeback_bdi_register {
	struct trace_entry ent;
	char name[32];
	char __data[0];
};

struct trace_event_raw_wbc_class {
	struct trace_entry ent;
	char name[32];
	long int nr_to_write;
	long int pages_skipped;
	int sync_mode;
	int for_kupdate;
	int for_background;
	int for_reclaim;
	int range_cyclic;
	long int range_start;
	long int range_end;
	ino_t cgroup_ino;
	char __data[0];
};

struct trace_event_raw_writeback_queue_io {
	struct trace_entry ent;
	char name[32];
	long unsigned int older;
	long int age;
	int moved;
	int reason;
	ino_t cgroup_ino;
	char __data[0];
};

struct trace_event_raw_global_dirty_state {
	struct trace_entry ent;
	long unsigned int nr_dirty;
	long unsigned int nr_writeback;
	long unsigned int background_thresh;
	long unsigned int dirty_thresh;
	long unsigned int dirty_limit;
	long unsigned int nr_dirtied;
	long unsigned int nr_written;
	char __data[0];
};

struct trace_event_raw_bdi_dirty_ratelimit {
	struct trace_entry ent;
	char bdi[32];
	long unsigned int write_bw;
	long unsigned int avg_write_bw;
	long unsigned int dirty_rate;
	long unsigned int dirty_ratelimit;
	long unsigned int task_ratelimit;
	long unsigned int balanced_dirty_ratelimit;
	ino_t cgroup_ino;
	char __data[0];
};

struct trace_event_raw_balance_dirty_pages {
	struct trace_entry ent;
	char bdi[32];
	long unsigned int limit;
	long unsigned int setpoint;
	long unsigned int dirty;
	long unsigned int bdi_setpoint;
	long unsigned int bdi_dirty;
	long unsigned int dirty_ratelimit;
	long unsigned int task_ratelimit;
	unsigned int dirtied;
	unsigned int dirtied_pause;
	long unsigned int paused;
	long int pause;
	long unsigned int period;
	long int think;
	ino_t cgroup_ino;
	char __data[0];
};

struct trace_event_raw_writeback_sb_inodes_requeue {
	struct trace_entry ent;
	char name[32];
	ino_t ino;
	long unsigned int state;
	long unsigned int dirtied_when;
	ino_t cgroup_ino;
	char __data[0];
};

struct trace_event_raw_writeback_congest_waited_template {
	struct trace_entry ent;
	unsigned int usec_timeout;
	unsigned int usec_delayed;
	char __data[0];
};

struct trace_event_raw_writeback_single_inode_template {
	struct trace_entry ent;
	char name[32];
	ino_t ino;
	long unsigned int state;
	long unsigned int dirtied_when;
	long unsigned int writeback_index;
	long int nr_to_write;
	long unsigned int wrote;
	ino_t cgroup_ino;
	char __data[0];
};

struct trace_event_raw_writeback_inode_template {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	long unsigned int state;
	__u16 mode;
	long unsigned int dirtied_when;
	char __data[0];
};

struct trace_event_data_offsets_writeback_page_template {};

struct trace_event_data_offsets_writeback_dirty_inode_template {};

struct trace_event_data_offsets_writeback_write_inode_template {};

struct trace_event_data_offsets_writeback_work_class {};

struct trace_event_data_offsets_writeback_pages_written {};

struct trace_event_data_offsets_writeback_class {};

struct trace_event_data_offsets_writeback_bdi_register {};

struct trace_event_data_offsets_wbc_class {};

struct trace_event_data_offsets_writeback_queue_io {};

struct trace_event_data_offsets_global_dirty_state {};

struct trace_event_data_offsets_bdi_dirty_ratelimit {};

struct trace_event_data_offsets_balance_dirty_pages {};

struct trace_event_data_offsets_writeback_sb_inodes_requeue {};

struct trace_event_data_offsets_writeback_congest_waited_template {};

struct trace_event_data_offsets_writeback_single_inode_template {};

struct trace_event_data_offsets_writeback_inode_template {};

typedef void (*btf_trace_writeback_dirty_page)(void *, struct page *, struct address_space *);

typedef void (*btf_trace_wait_on_page_writeback)(void *, struct page *, struct address_space *);

typedef void (*btf_trace_writeback_mark_inode_dirty)(void *, struct inode *, int);

typedef void (*btf_trace_writeback_dirty_inode_start)(void *, struct inode *, int);

typedef void (*btf_trace_writeback_dirty_inode)(void *, struct inode *, int);

typedef void (*btf_trace_writeback_write_inode_start)(void *, struct inode *, struct writeback_control *);

typedef void (*btf_trace_writeback_write_inode)(void *, struct inode *, struct writeback_control *);

typedef void (*btf_trace_writeback_queue)(void *, struct bdi_writeback *, struct wb_writeback_work *);

typedef void (*btf_trace_writeback_exec)(void *, struct bdi_writeback *, struct wb_writeback_work *);

typedef void (*btf_trace_writeback_start)(void *, struct bdi_writeback *, struct wb_writeback_work *);

typedef void (*btf_trace_writeback_written)(void *, struct bdi_writeback *, struct wb_writeback_work *);

typedef void (*btf_trace_writeback_wait)(void *, struct bdi_writeback *, struct wb_writeback_work *);

typedef void (*btf_trace_writeback_pages_written)(void *, long int);

typedef void (*btf_trace_writeback_wake_background)(void *, struct bdi_writeback *);

typedef void (*btf_trace_writeback_bdi_register)(void *, struct backing_dev_info *);

typedef void (*btf_trace_wbc_writepage)(void *, struct writeback_control *, struct backing_dev_info *);

typedef void (*btf_trace_writeback_queue_io)(void *, struct bdi_writeback *, struct wb_writeback_work *, long unsigned int, int);

typedef void (*btf_trace_global_dirty_state)(void *, long unsigned int, long unsigned int);

typedef void (*btf_trace_bdi_dirty_ratelimit)(void *, struct bdi_writeback *, long unsigned int, long unsigned int);

typedef void (*btf_trace_balance_dirty_pages)(void *, struct bdi_writeback *, long unsigned int, long unsigned int, long unsigned int, long unsigned int, long unsigned int, long unsigned int, long unsigned int, long unsigned int, long unsigned int, long int, long unsigned int);

typedef void (*btf_trace_writeback_sb_inodes_requeue)(void *, struct inode *);

typedef void (*btf_trace_writeback_congestion_wait)(void *, unsigned int, unsigned int);

typedef void (*btf_trace_writeback_wait_iff_congested)(void *, unsigned int, unsigned int);

typedef void (*btf_trace_writeback_single_inode_start)(void *, struct inode *, struct writeback_control *, long unsigned int);

typedef void (*btf_trace_writeback_single_inode)(void *, struct inode *, struct writeback_control *, long unsigned int);

typedef void (*btf_trace_writeback_lazytime)(void *, struct inode *);

typedef void (*btf_trace_writeback_lazytime_iput)(void *, struct inode *);

typedef void (*btf_trace_writeback_dirty_inode_enqueue)(void *, struct inode *);

typedef void (*btf_trace_sb_mark_inode_writeback)(void *, struct inode *);

typedef void (*btf_trace_sb_clear_inode_writeback)(void *, struct inode *);

struct splice_desc {
	size_t total_len;
	unsigned int len;
	unsigned int flags;
	union {
		void *userptr;
		struct file *file;
		void *data;
	} u;
	loff_t pos;
	loff_t *opos;
	size_t num_spliced;
	bool need_wakeup;
};

typedef int splice_actor(struct pipe_inode_info *, struct pipe_buffer *, struct splice_desc *);

typedef int splice_direct_actor(struct pipe_inode_info *, struct splice_desc *);

typedef int __kernel_daddr_t;

struct ustat {
	__kernel_daddr_t f_tfree;
	__kernel_ino_t f_tinode;
	char f_fname[6];
	char f_fpack[6];
};

struct statfs {
	__kernel_long_t f_type;
	__kernel_long_t f_bsize;
	__kernel_long_t f_blocks;
	__kernel_long_t f_bfree;
	__kernel_long_t f_bavail;
	__kernel_long_t f_files;
	__kernel_long_t f_ffree;
	__kernel_fsid_t f_fsid;
	__kernel_long_t f_namelen;
	__kernel_long_t f_frsize;
	__kernel_long_t f_flags;
	__kernel_long_t f_spare[4];
};

struct statfs64 {
	__kernel_long_t f_type;
	__kernel_long_t f_bsize;
	__u64 f_blocks;
	__u64 f_bfree;
	__u64 f_bavail;
	__u64 f_files;
	__u64 f_ffree;
	__kernel_fsid_t f_fsid;
	__kernel_long_t f_namelen;
	__kernel_long_t f_frsize;
	__kernel_long_t f_flags;
	__kernel_long_t f_spare[4];
};

struct fs_pin {
	wait_queue_head_t wait;
	int done;
	struct hlist_node s_list;
	struct hlist_node m_list;
	void (*kill)(struct fs_pin *);
};

typedef struct ns_common *ns_get_path_helper_t(void *);

struct ns_get_path_task_args {
	const struct proc_ns_operations *ns_ops;
	struct task_struct *task;
};

enum legacy_fs_param {
	LEGACY_FS_UNSET_PARAMS = 0,
	LEGACY_FS_MONOLITHIC_PARAMS = 1,
	LEGACY_FS_INDIVIDUAL_PARAMS = 2,
};

struct legacy_fs_context {
	char *legacy_data;
	size_t data_size;
	enum legacy_fs_param param_type;
};

enum fsconfig_command {
	FSCONFIG_SET_FLAG = 0,
	FSCONFIG_SET_STRING = 1,
	FSCONFIG_SET_BINARY = 2,
	FSCONFIG_SET_PATH = 3,
	FSCONFIG_SET_PATH_EMPTY = 4,
	FSCONFIG_SET_FD = 5,
	FSCONFIG_CMD_CREATE = 6,
	FSCONFIG_CMD_RECONFIGURE = 7,
};

struct dax_device;

struct iomap_page_ops;

struct iomap {
	u64 addr;
	loff_t offset;
	u64 length;
	u16 type;
	u16 flags;
	struct block_device *bdev;
	struct dax_device *dax_dev;
	void *inline_data;
	void *private;
	const struct iomap_page_ops *page_ops;
};

struct iomap_page_ops {
	int (*page_prepare)(struct inode *, loff_t, unsigned int, struct iomap *);
	void (*page_done)(struct inode *, loff_t, unsigned int, struct page *, struct iomap *);
};

enum blktrace_act {
	__BLK_TA_QUEUE = 1,
	__BLK_TA_BACKMERGE = 2,
	__BLK_TA_FRONTMERGE = 3,
	__BLK_TA_GETRQ = 4,
	__BLK_TA_SLEEPRQ = 5,
	__BLK_TA_REQUEUE = 6,
	__BLK_TA_ISSUE = 7,
	__BLK_TA_COMPLETE = 8,
	__BLK_TA_PLUG = 9,
	__BLK_TA_UNPLUG_IO = 10,
	__BLK_TA_UNPLUG_TIMER = 11,
	__BLK_TA_INSERT = 12,
	__BLK_TA_SPLIT = 13,
	__BLK_TA_BOUNCE = 14,
	__BLK_TA_REMAP = 15,
	__BLK_TA_ABORT = 16,
	__BLK_TA_DRV_DATA = 17,
	__BLK_TA_CGROUP = 256,
};

struct decrypt_bh_ctx {
	struct work_struct work;
	struct buffer_head *bh;
};

struct bh_lru {
	struct buffer_head *bhs[16];
};

struct bh_accounting {
	int nr;
	int ratelimit;
};

enum {
	DISK_EVENT_MEDIA_CHANGE = 1,
	DISK_EVENT_EJECT_REQUEST = 2,
};

struct blk_integrity_profile;

struct blk_integrity {
	const struct blk_integrity_profile *profile;
	unsigned char flags;
	unsigned char tuple_size;
	unsigned char interval_exp;
	unsigned char tag_size;
};

enum {
	BIOSET_NEED_BVECS = 1,
	BIOSET_NEED_RESCUER = 2,
};

struct bdev_inode {
	struct block_device bdev;
	struct inode vfs_inode;
};

struct blkdev_dio {
	union {
		struct kiocb *iocb;
		struct task_struct *waiter;
	};
	size_t size;
	atomic_t ref;
	bool multi_bio: 1;
	bool should_dirty: 1;
	bool is_sync: 1;
	struct bio bio;
};

struct bd_holder_disk {
	struct list_head list;
	struct gendisk *disk;
	int refcnt;
};

typedef int dio_iodone_t(struct kiocb *, loff_t, ssize_t, void *);

typedef void dio_submit_t(struct bio *, struct inode *, loff_t);

enum {
	DIO_LOCKING = 1,
	DIO_SKIP_HOLES = 2,
};

struct dio_submit {
	struct bio *bio;
	unsigned int blkbits;
	unsigned int blkfactor;
	unsigned int start_zero_done;
	int pages_in_io;
	sector_t block_in_file;
	unsigned int blocks_available;
	int reap_counter;
	sector_t final_block_in_request;
	int boundary;
	get_block_t *get_block;
	dio_submit_t *submit_io;
	loff_t logical_offset_in_bio;
	sector_t final_block_in_bio;
	sector_t next_block_for_io;
	struct page *cur_page;
	unsigned int cur_page_offset;
	unsigned int cur_page_len;
	sector_t cur_page_block;
	loff_t cur_page_fs_offset;
	struct iov_iter *iter;
	unsigned int head;
	unsigned int tail;
	size_t from;
	size_t to;
};

struct dio {
	int flags;
	int op;
	int op_flags;
	blk_qc_t bio_cookie;
	struct gendisk *bio_disk;
	struct inode *inode;
	loff_t i_size;
	dio_iodone_t *end_io;
	void *private;
	spinlock_t bio_lock;
	int page_errors;
	int is_async;
	bool defer_completion;
	bool should_dirty;
	int io_error;
	long unsigned int refcount;
	struct bio *bio_list;
	struct task_struct *waiter;
	struct kiocb *iocb;
	ssize_t result;
	union {
		struct page *pages[64];
		struct work_struct complete_work;
	};
	long: 64;
};

struct bvec_iter_all {
	struct bio_vec bv;
	int idx;
	unsigned int done;
};

struct trace_event_raw_android_fs_data_start_template {
	struct trace_entry ent;
	u32 __data_loc_pathbuf;
	loff_t offset;
	int bytes;
	loff_t i_size;
	u32 __data_loc_cmdline;
	pid_t pid;
	ino_t ino;
	char __data[0];
};

struct trace_event_raw_android_fs_data_end_template {
	struct trace_entry ent;
	ino_t ino;
	loff_t offset;
	int bytes;
	char __data[0];
};

struct trace_event_data_offsets_android_fs_data_start_template {
	u32 pathbuf;
	u32 cmdline;
};

struct trace_event_data_offsets_android_fs_data_end_template {};

typedef void (*btf_trace_android_fs_dataread_start)(void *, struct inode *, loff_t, int, pid_t, char *, char *);

typedef void (*btf_trace_android_fs_dataread_end)(void *, struct inode *, loff_t, int);

typedef void (*btf_trace_android_fs_datawrite_start)(void *, struct inode *, loff_t, int, pid_t, char *, char *);

typedef void (*btf_trace_android_fs_datawrite_end)(void *, struct inode *, loff_t, int);

struct mpage_readpage_args {
	struct bio *bio;
	struct page *page;
	unsigned int nr_pages;
	bool is_readahead;
	sector_t last_block_in_bio;
	struct buffer_head map_bh;
	long unsigned int first_logical_block;
	get_block_t *get_block;
};

struct mpage_data {
	struct bio *bio;
	sector_t last_block_in_bio;
	get_block_t *get_block;
	unsigned int use_writepage;
};

typedef u32 nlink_t;

typedef int (*proc_write_t)(struct file *, char *, size_t);

struct proc_dir_entry {
	atomic_t in_use;
	refcount_t refcnt;
	struct list_head pde_openers;
	spinlock_t pde_unload_lock;
	struct completion *pde_unload_completion;
	const struct inode_operations *proc_iops;
	union {
		const struct proc_ops *proc_ops;
		const struct file_operations *proc_dir_ops;
	};
	const struct dentry_operations *proc_dops;
	union {
		const struct seq_operations *seq_ops;
		int (*single_show)(struct seq_file *, void *);
	};
	proc_write_t write;
	void *data;
	unsigned int state_size;
	unsigned int low_ino;
	nlink_t nlink;
	kuid_t uid;
	kgid_t gid;
	loff_t size;
	struct proc_dir_entry *parent;
	struct rb_root subdir;
	struct rb_node subdir_node;
	char *name;
	umode_t mode;
	u8 flags;
	u8 namelen;
	char inline_name[0];
};

union proc_op {
	int (*proc_get_link)(struct dentry *, struct path *);
	int (*proc_show)(struct seq_file *, struct pid_namespace *, struct pid *, struct task_struct *);
	const char *lsm;
};

struct proc_inode {
	struct pid *pid;
	unsigned int fd;
	union proc_op op;
	struct proc_dir_entry *pde;
	struct ctl_table_header *sysctl;
	struct ctl_table *sysctl_entry;
	struct hlist_node sibling_inodes;
	const struct proc_ns_operations *ns_ops;
	struct inode vfs_inode;
};

struct proc_fs_opts {
	int flag;
	const char *str;
};

struct fsnotify_group;

struct fsnotify_iter_info;

struct fsnotify_mark;

struct fsnotify_event;

struct fsnotify_ops {
	int (*handle_event)(struct fsnotify_group *, u32, const void *, int, struct inode *, const struct qstr *, u32, struct fsnotify_iter_info *);
	int (*handle_inode_event)(struct fsnotify_mark *, u32, struct inode *, struct inode *, const struct qstr *, u32);
	void (*free_group_priv)(struct fsnotify_group *);
	void (*freeing_mark)(struct fsnotify_mark *, struct fsnotify_group *);
	void (*free_event)(struct fsnotify_event *);
	void (*free_mark)(struct fsnotify_mark *);
};

struct inotify_group_private_data {
	spinlock_t idr_lock;
	struct idr idr;
	struct ucounts *ucounts;
};

struct fsnotify_group {
	const struct fsnotify_ops *ops;
	refcount_t refcnt;
	spinlock_t notification_lock;
	struct list_head notification_list;
	wait_queue_head_t notification_waitq;
	unsigned int q_len;
	unsigned int max_events;
	unsigned int priority;
	bool shutdown;
	struct mutex mark_mutex;
	atomic_t num_marks;
	atomic_t user_waits;
	struct list_head marks_list;
	struct fasync_struct *fsn_fa;
	struct fsnotify_event *overflow_event;
	struct mem_cgroup *memcg;
	union {
		void *private;
		struct inotify_group_private_data inotify_data;
	};
};

struct fsnotify_iter_info {
	struct fsnotify_mark *marks[4];
	unsigned int report_mask;
	int srcu_idx;
};

struct fsnotify_mark {
	__u32 mask;
	refcount_t refcnt;
	struct fsnotify_group *group;
	struct list_head g_list;
	spinlock_t lock;
	struct hlist_node obj_list;
	struct fsnotify_mark_connector *connector;
	__u32 ignored_mask;
	unsigned int flags;
};

struct fsnotify_event {
	struct list_head list;
	long unsigned int objectid;
};

struct file_handle {
	__u32 handle_bytes;
	int handle_type;
	unsigned char f_handle[0];
};

struct inotify_inode_mark {
	struct fsnotify_mark fsn_mark;
	int wd;
};

struct dnotify_struct {
	struct dnotify_struct *dn_next;
	__u32 dn_mask;
	int dn_fd;
	struct file *dn_filp;
	fl_owner_t dn_owner;
};

struct dnotify_mark {
	struct fsnotify_mark fsn_mark;
	struct dnotify_struct *dn;
};

struct inotify_event_info {
	struct fsnotify_event fse;
	u32 mask;
	int wd;
	u32 sync_cookie;
	int name_len;
	char name[0];
};

struct inotify_event {
	__s32 wd;
	__u32 mask;
	__u32 cookie;
	__u32 len;
	char name[0];
};

struct epoll_event {
	__poll_t events;
	__u64 data;
};

struct wakeup_source {
	const char *name;
	int id;
	struct list_head entry;
	spinlock_t lock;
	struct wake_irq *wakeirq;
	struct timer_list timer;
	long unsigned int timer_expires;
	ktime_t total_time;
	ktime_t max_time;
	ktime_t last_time;
	ktime_t start_prevent_time;
	ktime_t prevent_sleep_time;
	long unsigned int event_count;
	long unsigned int active_count;
	long unsigned int relax_count;
	long unsigned int expire_count;
	long unsigned int wakeup_count;
	struct device *dev;
	bool active: 1;
	bool autosleep_enabled: 1;
};

struct epoll_filefd {
	struct file *file;
	int fd;
} __attribute__((packed));

struct nested_call_node {
	struct list_head llink;
	void *cookie;
	void *ctx;
};

struct nested_calls {
	struct list_head tasks_call_list;
	spinlock_t lock;
};

struct eventpoll;

struct epitem {
	union {
		struct rb_node rbn;
		struct callback_head rcu;
	};
	struct list_head rdllink;
	struct epitem *next;
	struct epoll_filefd ffd;
	int nwait;
	struct list_head pwqlist;
	struct eventpoll *ep;
	struct list_head fllink;
	struct wakeup_source *ws;
	struct epoll_event event;
};

struct eventpoll {
	struct mutex mtx;
	wait_queue_head_t wq;
	wait_queue_head_t poll_wait;
	struct list_head rdllist;
	rwlock_t lock;
	struct rb_root_cached rbr;
	struct epitem *ovflist;
	struct wakeup_source *ws;
	struct user_struct *user;
	struct file *file;
	u64 gen;
	unsigned int napi_id;
};

struct eppoll_entry {
	struct list_head llink;
	struct epitem *base;
	wait_queue_entry_t wait;
	wait_queue_head_t *whead;
};

struct ep_pqueue {
	poll_table pt;
	struct epitem *epi;
};

struct ep_send_events_data {
	int maxevents;
	struct epoll_event *events;
	int res;
};

struct signalfd_siginfo {
	__u32 ssi_signo;
	__s32 ssi_errno;
	__s32 ssi_code;
	__u32 ssi_pid;
	__u32 ssi_uid;
	__s32 ssi_fd;
	__u32 ssi_tid;
	__u32 ssi_band;
	__u32 ssi_overrun;
	__u32 ssi_trapno;
	__s32 ssi_status;
	__s32 ssi_int;
	__u64 ssi_ptr;
	__u64 ssi_utime;
	__u64 ssi_stime;
	__u64 ssi_addr;
	__u16 ssi_addr_lsb;
	__u16 __pad2;
	__s32 ssi_syscall;
	__u64 ssi_call_addr;
	__u32 ssi_arch;
	__u8 __pad[28];
};

struct signalfd_ctx {
	sigset_t sigmask;
};

struct timerfd_ctx {
	union {
		struct hrtimer tmr;
		struct alarm alarm;
	} t;
	ktime_t tintv;
	ktime_t moffs;
	wait_queue_head_t wqh;
	u64 ticks;
	int clockid;
	short unsigned int expired;
	short unsigned int settime_flags;
	struct callback_head rcu;
	struct list_head clist;
	spinlock_t cancel_lock;
	bool might_cancel;
};

struct eventfd_ctx {
	struct kref kref;
	wait_queue_head_t wqh;
	__u64 count;
	unsigned int flags;
	int id;
};

struct kioctx;

struct kioctx_table {
	struct callback_head rcu;
	unsigned int nr;
	struct kioctx *table[0];
};

typedef __kernel_ulong_t aio_context_t;

enum {
	IOCB_CMD_PREAD = 0,
	IOCB_CMD_PWRITE = 1,
	IOCB_CMD_FSYNC = 2,
	IOCB_CMD_FDSYNC = 3,
	IOCB_CMD_POLL = 5,
	IOCB_CMD_NOOP = 6,
	IOCB_CMD_PREADV = 7,
	IOCB_CMD_PWRITEV = 8,
};

struct io_event {
	__u64 data;
	__u64 obj;
	__s64 res;
	__s64 res2;
};

struct iocb {
	__u64 aio_data;
	__u32 aio_key;
	__kernel_rwf_t aio_rw_flags;
	__u16 aio_lio_opcode;
	__s16 aio_reqprio;
	__u32 aio_fildes;
	__u64 aio_buf;
	__u64 aio_nbytes;
	__s64 aio_offset;
	__u64 aio_reserved2;
	__u32 aio_flags;
	__u32 aio_resfd;
};

typedef int kiocb_cancel_fn(struct kiocb *);

struct aio_ring {
	unsigned int id;
	unsigned int nr;
	unsigned int head;
	unsigned int tail;
	unsigned int magic;
	unsigned int compat_features;
	unsigned int incompat_features;
	unsigned int header_length;
	struct io_event io_events[0];
};

struct kioctx_cpu;

struct ctx_rq_wait;

struct kioctx {
	struct percpu_ref users;
	atomic_t dead;
	struct percpu_ref reqs;
	long unsigned int user_id;
	struct kioctx_cpu *cpu;
	unsigned int req_batch;
	unsigned int max_reqs;
	unsigned int nr_events;
	long unsigned int mmap_base;
	long unsigned int mmap_size;
	struct page **ring_pages;
	long int nr_pages;
	struct rcu_work free_rwork;
	struct ctx_rq_wait *rq_wait;
	long: 64;
	long: 64;
	long: 64;
	struct {
		atomic_t reqs_available;
		long: 32;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
	};
	struct {
		spinlock_t ctx_lock;
		struct list_head active_reqs;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
	};
	struct {
		struct mutex ring_lock;
		wait_queue_head_t wait;
		long: 64;
	};
	struct {
		unsigned int tail;
		unsigned int completed_events;
		spinlock_t completion_lock;
		long: 32;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
	};
	struct page *internal_pages[8];
	struct file *aio_ring_file;
	unsigned int id;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct kioctx_cpu {
	unsigned int reqs_available;
};

struct ctx_rq_wait {
	struct completion comp;
	atomic_t count;
};

struct fsync_iocb {
	struct file *file;
	struct work_struct work;
	bool datasync;
	struct cred *creds;
};

struct poll_iocb {
	struct file *file;
	struct wait_queue_head *head;
	__poll_t events;
	bool cancelled;
	bool work_scheduled;
	bool work_need_resched;
	struct wait_queue_entry wait;
	struct work_struct work;
};

struct aio_kiocb {
	union {
		struct file *ki_filp;
		struct kiocb rw;
		struct fsync_iocb fsync;
		struct poll_iocb poll;
	};
	struct kioctx *ki_ctx;
	kiocb_cancel_fn *ki_cancel;
	struct io_event ki_res;
	struct list_head ki_list;
	refcount_t ki_refcnt;
	struct eventfd_ctx *ki_eventfd;
};

struct aio_poll_table {
	struct poll_table_struct pt;
	struct aio_kiocb *iocb;
	bool queued;
	int error;
};

struct __aio_sigset {
	const sigset_t *sigmask;
	size_t sigsetsize;
};

struct xa_limit {
	u32 max;
	u32 min;
};

enum {
	PERCPU_REF_INIT_ATOMIC = 1,
	PERCPU_REF_INIT_DEAD = 2,
	PERCPU_REF_ALLOW_REINIT = 4,
};

struct __kernel_sockaddr_storage {
	union {
		struct {
			__kernel_sa_family_t ss_family;
			char __data[126];
		};
		void *__align;
	};
};

struct user_msghdr {
	void *msg_name;
	int msg_namelen;
	struct iovec *msg_iov;
	__kernel_size_t msg_iovlen;
	void *msg_control;
	__kernel_size_t msg_controllen;
	unsigned int msg_flags;
};

struct scm_fp_list {
	short int count;
	short int max;
	struct user_struct *user;
	struct file *fp[253];
};

struct unix_skb_parms {
	struct pid *pid;
	kuid_t uid;
	kgid_t gid;
	struct scm_fp_list *fp;
	u32 consumed;
};

struct trace_event_raw_io_uring_create {
	struct trace_entry ent;
	int fd;
	void *ctx;
	u32 sq_entries;
	u32 cq_entries;
	u32 flags;
	char __data[0];
};

struct trace_event_raw_io_uring_register {
	struct trace_entry ent;
	void *ctx;
	unsigned int opcode;
	unsigned int nr_files;
	unsigned int nr_bufs;
	bool eventfd;
	long int ret;
	char __data[0];
};

struct trace_event_raw_io_uring_file_get {
	struct trace_entry ent;
	void *ctx;
	int fd;
	char __data[0];
};

struct io_wq_work;

struct trace_event_raw_io_uring_queue_async_work {
	struct trace_entry ent;
	void *ctx;
	int rw;
	void *req;
	struct io_wq_work *work;
	unsigned int flags;
	char __data[0];
};

struct io_wq_work_node {
	struct io_wq_work_node *next;
};

struct io_wq_work {
	struct io_wq_work_node list;
	struct io_identity *identity;
	unsigned int flags;
};

struct trace_event_raw_io_uring_defer {
	struct trace_entry ent;
	void *ctx;
	void *req;
	long long unsigned int data;
	char __data[0];
};

struct trace_event_raw_io_uring_link {
	struct trace_entry ent;
	void *ctx;
	void *req;
	void *target_req;
	char __data[0];
};

struct trace_event_raw_io_uring_cqring_wait {
	struct trace_entry ent;
	void *ctx;
	int min_events;
	char __data[0];
};

struct trace_event_raw_io_uring_fail_link {
	struct trace_entry ent;
	void *req;
	void *link;
	char __data[0];
};

struct trace_event_raw_io_uring_complete {
	struct trace_entry ent;
	void *ctx;
	u64 user_data;
	long int res;
	char __data[0];
};

struct trace_event_raw_io_uring_submit_sqe {
	struct trace_entry ent;
	void *ctx;
	u8 opcode;
	u64 user_data;
	bool force_nonblock;
	bool sq_thread;
	char __data[0];
};

struct trace_event_raw_io_uring_poll_arm {
	struct trace_entry ent;
	void *ctx;
	u8 opcode;
	u64 user_data;
	int mask;
	int events;
	char __data[0];
};

struct trace_event_raw_io_uring_poll_wake {
	struct trace_entry ent;
	void *ctx;
	u8 opcode;
	u64 user_data;
	int mask;
	char __data[0];
};

struct trace_event_raw_io_uring_task_add {
	struct trace_entry ent;
	void *ctx;
	u8 opcode;
	u64 user_data;
	int mask;
	char __data[0];
};

struct trace_event_raw_io_uring_task_run {
	struct trace_entry ent;
	void *ctx;
	u8 opcode;
	u64 user_data;
	char __data[0];
};

struct trace_event_data_offsets_io_uring_create {};

struct trace_event_data_offsets_io_uring_register {};

struct trace_event_data_offsets_io_uring_file_get {};

struct trace_event_data_offsets_io_uring_queue_async_work {};

struct trace_event_data_offsets_io_uring_defer {};

struct trace_event_data_offsets_io_uring_link {};

struct trace_event_data_offsets_io_uring_cqring_wait {};

struct trace_event_data_offsets_io_uring_fail_link {};

struct trace_event_data_offsets_io_uring_complete {};

struct trace_event_data_offsets_io_uring_submit_sqe {};

struct trace_event_data_offsets_io_uring_poll_arm {};

struct trace_event_data_offsets_io_uring_poll_wake {};

struct trace_event_data_offsets_io_uring_task_add {};

struct trace_event_data_offsets_io_uring_task_run {};

typedef void (*btf_trace_io_uring_create)(void *, int, void *, u32, u32, u32);

typedef void (*btf_trace_io_uring_register)(void *, void *, unsigned int, unsigned int, unsigned int, bool, long int);

typedef void (*btf_trace_io_uring_file_get)(void *, void *, int);

typedef void (*btf_trace_io_uring_queue_async_work)(void *, void *, int, void *, struct io_wq_work *, unsigned int);

typedef void (*btf_trace_io_uring_defer)(void *, void *, void *, long long unsigned int);

typedef void (*btf_trace_io_uring_link)(void *, void *, void *, void *);

typedef void (*btf_trace_io_uring_cqring_wait)(void *, void *, int);

typedef void (*btf_trace_io_uring_fail_link)(void *, void *, void *);

typedef void (*btf_trace_io_uring_complete)(void *, void *, u64, long int);

typedef void (*btf_trace_io_uring_submit_sqe)(void *, void *, u8, u64, bool, bool);

typedef void (*btf_trace_io_uring_poll_arm)(void *, void *, u8, u64, int, int);

typedef void (*btf_trace_io_uring_poll_wake)(void *, void *, u8, u64, int);

typedef void (*btf_trace_io_uring_task_add)(void *, void *, u8, u64, int);

typedef void (*btf_trace_io_uring_task_run)(void *, void *, u8, u64);

struct io_uring_sqe {
	__u8 opcode;
	__u8 flags;
	__u16 ioprio;
	__s32 fd;
	union {
		__u64 off;
		__u64 addr2;
	};
	union {
		__u64 addr;
		__u64 splice_off_in;
	};
	__u32 len;
	union {
		__kernel_rwf_t rw_flags;
		__u32 fsync_flags;
		__u16 poll_events;
		__u32 poll32_events;
		__u32 sync_range_flags;
		__u32 msg_flags;
		__u32 timeout_flags;
		__u32 accept_flags;
		__u32 cancel_flags;
		__u32 open_flags;
		__u32 statx_flags;
		__u32 fadvise_advice;
		__u32 splice_flags;
	};
	__u64 user_data;
	union {
		struct {
			union {
				__u16 buf_index;
				__u16 buf_group;
			};
			__u16 personality;
			__s32 splice_fd_in;
		};
		__u64 __pad2[3];
	};
};

enum {
	IOSQE_FIXED_FILE_BIT = 0,
	IOSQE_IO_DRAIN_BIT = 1,
	IOSQE_IO_LINK_BIT = 2,
	IOSQE_IO_HARDLINK_BIT = 3,
	IOSQE_ASYNC_BIT = 4,
	IOSQE_BUFFER_SELECT_BIT = 5,
};

enum {
	IORING_OP_NOP = 0,
	IORING_OP_READV = 1,
	IORING_OP_WRITEV = 2,
	IORING_OP_FSYNC = 3,
	IORING_OP_READ_FIXED = 4,
	IORING_OP_WRITE_FIXED = 5,
	IORING_OP_POLL_ADD = 6,
	IORING_OP_POLL_REMOVE = 7,
	IORING_OP_SYNC_FILE_RANGE = 8,
	IORING_OP_SENDMSG = 9,
	IORING_OP_RECVMSG = 10,
	IORING_OP_TIMEOUT = 11,
	IORING_OP_TIMEOUT_REMOVE = 12,
	IORING_OP_ACCEPT = 13,
	IORING_OP_ASYNC_CANCEL = 14,
	IORING_OP_LINK_TIMEOUT = 15,
	IORING_OP_CONNECT = 16,
	IORING_OP_FALLOCATE = 17,
	IORING_OP_OPENAT = 18,
	IORING_OP_CLOSE = 19,
	IORING_OP_FILES_UPDATE = 20,
	IORING_OP_STATX = 21,
	IORING_OP_READ = 22,
	IORING_OP_WRITE = 23,
	IORING_OP_FADVISE = 24,
	IORING_OP_MADVISE = 25,
	IORING_OP_SEND = 26,
	IORING_OP_RECV = 27,
	IORING_OP_OPENAT2 = 28,
	IORING_OP_EPOLL_CTL = 29,
	IORING_OP_SPLICE = 30,
	IORING_OP_PROVIDE_BUFFERS = 31,
	IORING_OP_REMOVE_BUFFERS = 32,
	IORING_OP_TEE = 33,
	IORING_OP_LAST = 34,
};

struct io_uring_cqe {
	__u64 user_data;
	__s32 res;
	__u32 flags;
};

enum {
	IORING_CQE_BUFFER_SHIFT = 16,
};

struct io_sqring_offsets {
	__u32 head;
	__u32 tail;
	__u32 ring_mask;
	__u32 ring_entries;
	__u32 flags;
	__u32 dropped;
	__u32 array;
	__u32 resv1;
	__u64 resv2;
};

struct io_cqring_offsets {
	__u32 head;
	__u32 tail;
	__u32 ring_mask;
	__u32 ring_entries;
	__u32 overflow;
	__u32 cqes;
	__u32 flags;
	__u32 resv1;
	__u64 resv2;
};

struct io_uring_params {
	__u32 sq_entries;
	__u32 cq_entries;
	__u32 flags;
	__u32 sq_thread_cpu;
	__u32 sq_thread_idle;
	__u32 features;
	__u32 wq_fd;
	__u32 resv[3];
	struct io_sqring_offsets sq_off;
	struct io_cqring_offsets cq_off;
};

enum {
	IORING_REGISTER_BUFFERS = 0,
	IORING_UNREGISTER_BUFFERS = 1,
	IORING_REGISTER_FILES = 2,
	IORING_UNREGISTER_FILES = 3,
	IORING_REGISTER_EVENTFD = 4,
	IORING_UNREGISTER_EVENTFD = 5,
	IORING_REGISTER_FILES_UPDATE = 6,
	IORING_REGISTER_EVENTFD_ASYNC = 7,
	IORING_REGISTER_PROBE = 8,
	IORING_REGISTER_PERSONALITY = 9,
	IORING_UNREGISTER_PERSONALITY = 10,
	IORING_REGISTER_RESTRICTIONS = 11,
	IORING_REGISTER_ENABLE_RINGS = 12,
	IORING_REGISTER_LAST = 13,
};

struct io_uring_files_update {
	__u32 offset;
	__u32 resv;
	__u64 fds;
};

struct io_uring_probe_op {
	__u8 op;
	__u8 resv;
	__u16 flags;
	__u32 resv2;
};

struct io_uring_probe {
	__u8 last_op;
	__u8 ops_len;
	__u16 resv;
	__u32 resv2[3];
	struct io_uring_probe_op ops[0];
};

struct io_uring_restriction {
	__u16 opcode;
	union {
		__u8 register_op;
		__u8 sqe_op;
		__u8 sqe_flags;
	};
	__u8 resv;
	__u32 resv2[3];
};

enum {
	IORING_RESTRICTION_REGISTER_OP = 0,
	IORING_RESTRICTION_SQE_OP = 1,
	IORING_RESTRICTION_SQE_FLAGS_ALLOWED = 2,
	IORING_RESTRICTION_SQE_FLAGS_REQUIRED = 3,
	IORING_RESTRICTION_LAST = 4,
};

enum {
	IO_WQ_WORK_CANCEL = 1,
	IO_WQ_WORK_HASHED = 2,
	IO_WQ_WORK_UNBOUND = 4,
	IO_WQ_WORK_NO_CANCEL = 8,
	IO_WQ_WORK_CONCURRENT = 16,
	IO_WQ_WORK_FILES = 32,
	IO_WQ_WORK_FS = 64,
	IO_WQ_WORK_MM = 128,
	IO_WQ_WORK_CREDS = 256,
	IO_WQ_WORK_BLKCG = 512,
	IO_WQ_WORK_FSIZE = 1024,
	IO_WQ_HASH_SHIFT = 24,
};

enum io_wq_cancel {
	IO_WQ_CANCEL_OK = 0,
	IO_WQ_CANCEL_RUNNING = 1,
	IO_WQ_CANCEL_NOTFOUND = 2,
};

typedef void free_work_fn(struct io_wq_work *);

typedef struct io_wq_work *io_wq_work_fn(struct io_wq_work *);

struct io_wq_data {
	struct user_struct *user;
	io_wq_work_fn *do_work;
	free_work_fn *free_work;
};

struct io_uring {
	u32 head;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	u32 tail;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct io_rings {
	struct io_uring sq;
	struct io_uring cq;
	u32 sq_ring_mask;
	u32 cq_ring_mask;
	u32 sq_ring_entries;
	u32 cq_ring_entries;
	u32 sq_dropped;
	u32 sq_flags;
	u32 cq_flags;
	u32 cq_overflow;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct io_uring_cqe cqes[0];
};

struct io_mapped_ubuf {
	u64 ubuf;
	size_t len;
	struct bio_vec *bvec;
	unsigned int nr_bvecs;
	long unsigned int acct_pages;
};

struct fixed_file_table {
	struct file **files;
};

struct fixed_file_data;

struct fixed_file_ref_node {
	struct percpu_ref refs;
	struct list_head node;
	struct list_head file_list;
	struct fixed_file_data *file_data;
	struct llist_node llist;
	bool done;
};

struct io_ring_ctx;

struct fixed_file_data {
	struct fixed_file_table *table;
	struct io_ring_ctx *ctx;
	struct fixed_file_ref_node *node;
	struct percpu_ref refs;
	struct completion done;
	struct list_head ref_list;
	spinlock_t lock;
};

struct io_wq;

struct io_restriction {
	long unsigned int register_op[1];
	long unsigned int sqe_op[1];
	u8 sqe_flags_allowed;
	u8 sqe_flags_required;
	bool registered;
};

struct io_sq_data;

struct io_kiocb;

struct io_ring_ctx {
	struct {
		struct percpu_ref refs;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
	};
	struct {
		unsigned int flags;
		unsigned int compat: 1;
		unsigned int limit_mem: 1;
		unsigned int cq_overflow_flushed: 1;
		unsigned int drain_next: 1;
		unsigned int eventfd_async: 1;
		unsigned int restricted: 1;
		unsigned int sqo_dead: 1;
		u32 *sq_array;
		unsigned int cached_sq_head;
		unsigned int sq_entries;
		unsigned int sq_mask;
		unsigned int sq_thread_idle;
		unsigned int cached_sq_dropped;
		unsigned int cached_cq_overflow;
		long unsigned int sq_check_overflow;
		struct list_head defer_list;
		struct list_head timeout_list;
		struct list_head cq_overflow_list;
		struct io_uring_sqe *sq_sqes;
		long: 64;
		long: 64;
		long: 64;
	};
	struct io_rings *rings;
	struct io_wq *io_wq;
	struct task_struct *sqo_task;
	struct mm_struct *mm_account;
	struct io_sq_data *sq_data;
	struct wait_queue_head sqo_sq_wait;
	struct wait_queue_entry sqo_wait_entry;
	struct list_head sqd_list;
	struct fixed_file_data *file_data;
	unsigned int nr_user_files;
	unsigned int nr_user_bufs;
	struct io_mapped_ubuf *user_bufs;
	struct user_struct *user;
	const struct cred *creds;
	struct completion ref_comp;
	struct completion sq_thread_comp;
	struct io_kiocb *fallback_req;
	struct socket *ring_sock;
	struct xarray io_buffers;
	struct xarray personalities;
	u32 pers_next;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct {
		unsigned int cached_cq_tail;
		unsigned int cq_entries;
		unsigned int cq_mask;
		atomic_t cq_timeouts;
		unsigned int cq_last_tm_flush;
		long unsigned int cq_check_overflow;
		struct wait_queue_head cq_wait;
		struct fasync_struct *cq_fasync;
		struct eventfd_ctx *cq_ev_fd;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
		long: 64;
	};
	struct {
		struct mutex uring_lock;
		wait_queue_head_t wait;
		long: 64;
	};
	struct {
		spinlock_t completion_lock;
		struct list_head iopoll_list;
		struct hlist_head *cancel_hash;
		unsigned int cancel_hash_bits;
		bool poll_multi_file;
		spinlock_t inflight_lock;
		struct list_head inflight_list;
	};
	struct delayed_work file_put_work;
	struct llist_head file_put_llist;
	struct work_struct exit_work;
	struct io_restriction restrictions;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct io_buffer {
	struct list_head list;
	__u64 addr;
	__u32 len;
	__u16 bid;
};

struct io_sq_data {
	refcount_t refs;
	struct mutex lock;
	struct list_head ctx_list;
	struct list_head ctx_new_list;
	struct mutex ctx_lock;
	struct task_struct *thread;
	struct wait_queue_head wait;
};

struct io_rw {
	struct kiocb kiocb;
	u64 addr;
	u64 len;
};

struct io_poll_iocb {
	struct file *file;
	union {
		struct wait_queue_head *head;
		u64 addr;
	};
	__poll_t events;
	bool done;
	bool canceled;
	struct wait_queue_entry wait;
};

struct io_accept {
	struct file *file;
	struct sockaddr *addr;
	int *addr_len;
	int flags;
	long unsigned int nofile;
};

struct io_sync {
	struct file *file;
	loff_t len;
	loff_t off;
	int flags;
	int mode;
};

struct io_cancel {
	struct file *file;
	u64 addr;
};

struct io_timeout {
	struct file *file;
	u32 off;
	u32 target_seq;
	struct list_head list;
};

struct io_timeout_rem {
	struct file *file;
	u64 addr;
};

struct io_connect {
	struct file *file;
	struct sockaddr *addr;
	int addr_len;
};

struct io_sr_msg {
	struct file *file;
	union {
		struct user_msghdr *umsg;
		void *buf;
	};
	int msg_flags;
	int bgid;
	size_t len;
	struct io_buffer *kbuf;
};

struct io_open {
	struct file *file;
	int dfd;
	bool ignore_nonblock;
	struct filename *filename;
	struct open_how how;
	long unsigned int nofile;
};

struct io_close {
	struct file *file;
	struct file *put_file;
	int fd;
};

struct io_files_update {
	struct file *file;
	u64 arg;
	u32 nr_args;
	u32 offset;
};

struct io_fadvise {
	struct file *file;
	u64 offset;
	u32 len;
	u32 advice;
};

struct io_madvise {
	struct file *file;
	u64 addr;
	u32 len;
	u32 advice;
};

struct io_epoll {
	struct file *file;
	int epfd;
	int op;
	int fd;
	struct epoll_event event;
};

struct io_splice {
	struct file *file_out;
	struct file *file_in;
	loff_t off_out;
	loff_t off_in;
	u64 len;
	unsigned int flags;
};

struct io_provide_buf {
	struct file *file;
	__u64 addr;
	__u32 len;
	__u32 bgid;
	__u16 nbufs;
	__u16 bid;
};

struct io_statx {
	struct file *file;
	int dfd;
	unsigned int mask;
	unsigned int flags;
	const char *filename;
	struct statx *buffer;
};

struct io_completion {
	struct file *file;
	struct list_head list;
	u32 cflags;
};

struct async_poll;

struct io_kiocb {
	union {
		struct file *file;
		struct io_rw rw;
		struct io_poll_iocb poll;
		struct io_accept accept;
		struct io_sync sync;
		struct io_cancel cancel;
		struct io_timeout timeout;
		struct io_timeout_rem timeout_rem;
		struct io_connect connect;
		struct io_sr_msg sr_msg;
		struct io_open open;
		struct io_close close;
		struct io_files_update files_update;
		struct io_fadvise fadvise;
		struct io_madvise madvise;
		struct io_epoll epoll;
		struct io_splice splice;
		struct io_provide_buf pbuf;
		struct io_statx statx;
		struct io_completion compl;
	};
	void *async_data;
	u8 opcode;
	u8 iopoll_completed;
	u16 buf_index;
	u32 result;
	struct io_ring_ctx *ctx;
	unsigned int flags;
	refcount_t refs;
	struct task_struct *task;
	u64 user_data;
	struct list_head link_list;
	struct list_head inflight_entry;
	struct percpu_ref *fixed_file_refs;
	struct callback_head task_work;
	struct hlist_node hash_node;
	struct async_poll *apoll;
	struct io_wq_work work;
};

struct io_timeout_data {
	struct io_kiocb *req;
	struct hrtimer timer;
	struct timespec64 ts;
	enum hrtimer_mode mode;
};

struct io_async_connect {
	struct __kernel_sockaddr_storage address;
};

struct io_async_msghdr {
	struct iovec fast_iov[8];
	struct iovec *iov;
	struct sockaddr *uaddr;
	struct msghdr msg;
	struct __kernel_sockaddr_storage addr;
};

struct io_async_rw {
	struct iovec fast_iov[8];
	const struct iovec *free_iovec;
	struct iov_iter iter;
	size_t bytes_done;
	struct wait_page_queue wpq;
};

enum {
	REQ_F_FIXED_FILE_BIT = 0,
	REQ_F_IO_DRAIN_BIT = 1,
	REQ_F_LINK_BIT = 2,
	REQ_F_HARDLINK_BIT = 3,
	REQ_F_FORCE_ASYNC_BIT = 4,
	REQ_F_BUFFER_SELECT_BIT = 5,
	REQ_F_LINK_HEAD_BIT = 6,
	REQ_F_FAIL_LINK_BIT = 7,
	REQ_F_INFLIGHT_BIT = 8,
	REQ_F_CUR_POS_BIT = 9,
	REQ_F_NOWAIT_BIT = 10,
	REQ_F_LINK_TIMEOUT_BIT = 11,
	REQ_F_ISREG_BIT = 12,
	REQ_F_NEED_CLEANUP_BIT = 13,
	REQ_F_POLLED_BIT = 14,
	REQ_F_BUFFER_SELECTED_BIT = 15,
	REQ_F_NO_FILE_TABLE_BIT = 16,
	REQ_F_WORK_INITIALIZED_BIT = 17,
	REQ_F_LTIMEOUT_ACTIVE_BIT = 18,
	__REQ_F_LAST_BIT = 19,
};

enum {
	REQ_F_FIXED_FILE = 1,
	REQ_F_IO_DRAIN = 2,
	REQ_F_LINK = 4,
	REQ_F_HARDLINK = 8,
	REQ_F_FORCE_ASYNC = 16,
	REQ_F_BUFFER_SELECT = 32,
	REQ_F_LINK_HEAD = 64,
	REQ_F_FAIL_LINK = 128,
	REQ_F_INFLIGHT = 256,
	REQ_F_CUR_POS = 512,
	REQ_F_NOWAIT = 1024,
	REQ_F_LINK_TIMEOUT = 2048,
	REQ_F_ISREG = 4096,
	REQ_F_NEED_CLEANUP = 8192,
	REQ_F_POLLED = 16384,
	REQ_F_BUFFER_SELECTED = 32768,
	REQ_F_NO_FILE_TABLE = 65536,
	REQ_F_WORK_INITIALIZED = 131072,
	REQ_F_LTIMEOUT_ACTIVE = 262144,
};

struct async_poll {
	struct io_poll_iocb poll;
	struct io_poll_iocb *double_poll;
};

struct io_defer_entry {
	struct list_head list;
	struct io_kiocb *req;
	u32 seq;
};

struct io_comp_state {
	unsigned int nr;
	struct list_head list;
	struct io_ring_ctx *ctx;
};

struct io_submit_state {
	struct blk_plug plug;
	void *reqs[8];
	unsigned int free_reqs;
	struct io_comp_state comp;
	struct file *file;
	unsigned int fd;
	unsigned int has_refs;
	unsigned int ios_left;
};

struct io_op_def {
	unsigned int needs_file: 1;
	unsigned int needs_file_no_error: 1;
	unsigned int hash_reg_file: 1;
	unsigned int unbound_nonreg_file: 1;
	unsigned int not_supported: 1;
	unsigned int pollin: 1;
	unsigned int pollout: 1;
	unsigned int buffer_select: 1;
	unsigned int needs_async_data: 1;
	short unsigned int async_size;
	unsigned int work_flags;
};

enum io_mem_account {
	ACCT_LOCKED = 0,
	ACCT_PINNED = 1,
};

struct req_batch {
	void *reqs[8];
	int to_free;
	struct task_struct *task;
	int task_refs;
};

struct io_poll_table {
	struct poll_table_struct pt;
	struct io_kiocb *req;
	int nr_entries;
	int error;
};

enum sq_ret {
	SQT_IDLE = 1,
	SQT_SPIN = 2,
	SQT_DID_WORK = 4,
};

struct io_wait_queue {
	struct wait_queue_entry wq;
	struct io_ring_ctx *ctx;
	unsigned int to_wait;
	unsigned int nr_timeouts;
};

struct io_file_put {
	struct list_head list;
	struct file *file;
};

struct io_task_cancel {
	struct task_struct *task;
	struct files_struct *files;
};

struct io_identify;

struct io_wq_work_list {
	struct io_wq_work_node *first;
	struct io_wq_work_node *last;
};

typedef bool work_cancel_fn(struct io_wq_work *, void *);

enum {
	IO_WORKER_F_UP = 1,
	IO_WORKER_F_RUNNING = 2,
	IO_WORKER_F_FREE = 4,
	IO_WORKER_F_FIXED = 8,
	IO_WORKER_F_BOUND = 16,
};

enum {
	IO_WQ_BIT_EXIT = 0,
	IO_WQ_BIT_CANCEL = 1,
	IO_WQ_BIT_ERROR = 2,
};

enum {
	IO_WQE_FLAG_STALLED = 1,
};

struct io_wqe;

struct io_worker {
	refcount_t ref;
	unsigned int flags;
	struct hlist_nulls_node nulls_node;
	struct list_head all_list;
	struct task_struct *task;
	struct io_wqe *wqe;
	struct io_wq_work *cur_work;
	spinlock_t lock;
	struct callback_head rcu;
	struct mm_struct *mm;
	const struct cred *cur_creds;
	const struct cred *saved_creds;
	struct files_struct *restore_files;
	struct nsproxy *restore_nsproxy;
	struct fs_struct *restore_fs;
};

struct io_wqe_acct {
	unsigned int nr_workers;
	unsigned int max_workers;
	atomic_t nr_running;
};

struct io_wq;

struct io_wqe {
	struct {
		raw_spinlock_t lock;
		struct io_wq_work_list work_list;
		long unsigned int hash_map;
		unsigned int flags;
		long: 32;
		long: 64;
		long: 64;
		long: 64;
	};
	int node;
	struct io_wqe_acct acct[2];
	struct hlist_nulls_head free_list;
	struct list_head all_list;
	struct io_wq *wq;
	struct io_wq_work *hash_tail[64];
};

enum {
	IO_WQ_ACCT_BOUND = 0,
	IO_WQ_ACCT_UNBOUND = 1,
};

struct io_wq {
	struct io_wqe **wqes;
	long unsigned int state;
	free_work_fn *free_work;
	io_wq_work_fn *do_work;
	struct task_struct *manager;
	struct user_struct *user;
	refcount_t refs;
	struct completion done;
	struct hlist_node cpuhp_node;
	refcount_t use_refs;
};

struct io_cb_cancel_data {
	work_cancel_fn *fn;
	void *data;
	int nr_running;
	int nr_pending;
	bool cancel_all;
};

struct flock64 {
	short int l_type;
	short int l_whence;
	__kernel_loff_t l_start;
	__kernel_loff_t l_len;
	__kernel_pid_t l_pid;
};

struct trace_event_raw_locks_get_lock_context {
	struct trace_entry ent;
	long unsigned int i_ino;
	dev_t s_dev;
	unsigned char type;
	struct file_lock_context *ctx;
	char __data[0];
};

struct trace_event_raw_filelock_lock {
	struct trace_entry ent;
	struct file_lock *fl;
	long unsigned int i_ino;
	dev_t s_dev;
	struct file_lock *fl_blocker;
	fl_owner_t fl_owner;
	unsigned int fl_pid;
	unsigned int fl_flags;
	unsigned char fl_type;
	loff_t fl_start;
	loff_t fl_end;
	int ret;
	char __data[0];
};

struct trace_event_raw_filelock_lease {
	struct trace_entry ent;
	struct file_lock *fl;
	long unsigned int i_ino;
	dev_t s_dev;
	struct file_lock *fl_blocker;
	fl_owner_t fl_owner;
	unsigned int fl_flags;
	unsigned char fl_type;
	long unsigned int fl_break_time;
	long unsigned int fl_downgrade_time;
	char __data[0];
};

struct trace_event_raw_generic_add_lease {
	struct trace_entry ent;
	long unsigned int i_ino;
	int wcount;
	int rcount;
	int icount;
	dev_t s_dev;
	fl_owner_t fl_owner;
	unsigned int fl_flags;
	unsigned char fl_type;
	char __data[0];
};

struct trace_event_raw_leases_conflict {
	struct trace_entry ent;
	void *lease;
	void *breaker;
	unsigned int l_fl_flags;
	unsigned int b_fl_flags;
	unsigned char l_fl_type;
	unsigned char b_fl_type;
	bool conflict;
	char __data[0];
};

struct trace_event_data_offsets_locks_get_lock_context {};

struct trace_event_data_offsets_filelock_lock {};

struct trace_event_data_offsets_filelock_lease {};

struct trace_event_data_offsets_generic_add_lease {};

struct trace_event_data_offsets_leases_conflict {};

typedef void (*btf_trace_locks_get_lock_context)(void *, struct inode *, int, struct file_lock_context *);

typedef void (*btf_trace_posix_lock_inode)(void *, struct inode *, struct file_lock *, int);

typedef void (*btf_trace_fcntl_setlk)(void *, struct inode *, struct file_lock *, int);

typedef void (*btf_trace_locks_remove_posix)(void *, struct inode *, struct file_lock *, int);

typedef void (*btf_trace_flock_lock_inode)(void *, struct inode *, struct file_lock *, int);

typedef void (*btf_trace_break_lease_noblock)(void *, struct inode *, struct file_lock *);

typedef void (*btf_trace_break_lease_block)(void *, struct inode *, struct file_lock *);

typedef void (*btf_trace_break_lease_unblock)(void *, struct inode *, struct file_lock *);

typedef void (*btf_trace_generic_delete_lease)(void *, struct inode *, struct file_lock *);

typedef void (*btf_trace_time_out_leases)(void *, struct inode *, struct file_lock *);

typedef void (*btf_trace_generic_add_lease)(void *, struct inode *, struct file_lock *);

typedef void (*btf_trace_leases_conflict)(void *, bool, struct file_lock *, struct file_lock *);

struct file_lock_list_struct {
	spinlock_t lock;
	struct hlist_head hlist;
};

struct locks_iterator {
	int li_cpu;
	loff_t li_pos;
};

typedef unsigned int __kernel_uid_t;

typedef unsigned int __kernel_gid_t;

struct elf_prpsinfo {
	char pr_state;
	char pr_sname;
	char pr_zomb;
	char pr_nice;
	long unsigned int pr_flag;
	__kernel_uid_t pr_uid;
	__kernel_gid_t pr_gid;
	pid_t pr_pid;
	pid_t pr_ppid;
	pid_t pr_pgrp;
	pid_t pr_sid;
	char pr_fname[16];
	char pr_psargs[80];
};

struct core_vma_metadata {
	long unsigned int start;
	long unsigned int end;
	long unsigned int flags;
	long unsigned int dump_size;
};

struct arch_elf_state {};

struct memelfnote {
	const char *name;
	int type;
	unsigned int datasz;
	void *data;
};

struct elf_thread_core_info {
	struct elf_thread_core_info *next;
	struct task_struct *task;
	struct elf_prstatus prstatus;
	struct memelfnote notes[0];
};

struct elf_note_info {
	struct elf_thread_core_info *thread;
	struct memelfnote psinfo;
	struct memelfnote signote;
	struct memelfnote auxv;
	struct memelfnote files;
	siginfo_t csigdata;
	size_t size;
	int thread_notes;
};

struct mb_cache_entry {
	struct list_head e_list;
	struct hlist_bl_node e_hash_list;
	atomic_t e_refcnt;
	u32 e_key;
	u32 e_referenced: 1;
	u32 e_reusable: 1;
	u64 e_value;
};

struct mb_cache {
	struct hlist_bl_head *c_hash;
	int c_bucket_bits;
	long unsigned int c_max_entries;
	spinlock_t c_list_lock;
	struct list_head c_list;
	long unsigned int c_entry_count;
	struct shrinker c_shrink;
	struct work_struct c_shrink_work;
};

struct posix_acl_xattr_entry {
	__le16 e_tag;
	__le16 e_perm;
	__le32 e_id;
};

struct posix_acl_xattr_header {
	__le32 a_version;
};

struct lock_manager {
	struct list_head list;
	bool block_opens;
};

struct net_generic {
	union {
		struct {
			unsigned int len;
			struct callback_head rcu;
		} s;
		void *ptr[0];
	};
};

struct rpc_timer {
	struct list_head list;
	long unsigned int expires;
	struct delayed_work dwork;
};

struct rpc_wait_queue {
	spinlock_t lock;
	struct list_head tasks[4];
	unsigned char maxpriority;
	unsigned char priority;
	unsigned char nr;
	short unsigned int qlen;
	struct rpc_timer timer_list;
	const char *name;
};

struct nfs_seqid_counter {
	ktime_t create_time;
	int owner_id;
	int flags;
	u32 counter;
	spinlock_t lock;
	struct list_head list;
	struct rpc_wait_queue wait;
};

struct nfs4_stateid_struct {
	union {
		char data[16];
		struct {
			__be32 seqid;
			char other[12];
		};
	};
	enum {
		NFS4_INVALID_STATEID_TYPE = 0,
		NFS4_SPECIAL_STATEID_TYPE = 1,
		NFS4_OPEN_STATEID_TYPE = 2,
		NFS4_LOCK_STATEID_TYPE = 3,
		NFS4_DELEGATION_STATEID_TYPE = 4,
		NFS4_LAYOUT_STATEID_TYPE = 5,
		NFS4_PNFS_DS_STATEID_TYPE = 6,
		NFS4_REVOKED_STATEID_TYPE = 7,
	} type;
};

typedef struct nfs4_stateid_struct nfs4_stateid;

struct nfs4_state;

struct nfs4_lock_state {
	struct list_head ls_locks;
	struct nfs4_state *ls_state;
	long unsigned int ls_flags;
	struct nfs_seqid_counter ls_seqid;
	nfs4_stateid ls_stateid;
	refcount_t ls_count;
	fl_owner_t ls_owner;
};

struct xdr_buf {
	struct kvec head[1];
	struct kvec tail[1];
	struct bio_vec *bvec;
	struct page **pages;
	unsigned int page_base;
	unsigned int page_len;
	unsigned int flags;
	unsigned int buflen;
	unsigned int len;
};

struct rpc_rqst;

struct xdr_stream {
	__be32 *p;
	struct xdr_buf *buf;
	__be32 *end;
	struct kvec *iov;
	struct kvec scratch;
	struct page **page_ptr;
	unsigned int nwords;
	struct rpc_rqst *rqst;
};

struct rpc_xprt;

struct rpc_task;

struct rpc_cred;

struct rpc_rqst {
	struct rpc_xprt *rq_xprt;
	struct xdr_buf rq_snd_buf;
	struct xdr_buf rq_rcv_buf;
	struct rpc_task *rq_task;
	struct rpc_cred *rq_cred;
	__be32 rq_xid;
	int rq_cong;
	u32 rq_seqno;
	int rq_enc_pages_num;
	struct page **rq_enc_pages;
	void (*rq_release_snd_buf)(struct rpc_rqst *);
	union {
		struct list_head rq_list;
		struct rb_node rq_recv;
	};
	struct list_head rq_xmit;
	struct list_head rq_xmit2;
	void *rq_buffer;
	size_t rq_callsize;
	void *rq_rbuffer;
	size_t rq_rcvsize;
	size_t rq_xmit_bytes_sent;
	size_t rq_reply_bytes_recvd;
	struct xdr_buf rq_private_buf;
	long unsigned int rq_majortimeo;
	long unsigned int rq_minortimeo;
	long unsigned int rq_timeout;
	ktime_t rq_rtt;
	unsigned int rq_retries;
	unsigned int rq_connect_cookie;
	atomic_t rq_pin;
	u32 rq_bytes_sent;
	ktime_t rq_xtime;
	int rq_ntrans;
	struct list_head rq_bc_list;
	long unsigned int rq_bc_pa_state;
	struct list_head rq_bc_pa_list;
};

typedef void (*kxdreproc_t)(struct rpc_rqst *, struct xdr_stream *, const void *);

typedef int (*kxdrdproc_t)(struct rpc_rqst *, struct xdr_stream *, void *);

struct rpc_procinfo;

struct rpc_message {
	const struct rpc_procinfo *rpc_proc;
	void *rpc_argp;
	void *rpc_resp;
	const struct cred *rpc_cred;
};

struct rpc_procinfo {
	u32 p_proc;
	kxdreproc_t p_encode;
	kxdrdproc_t p_decode;
	unsigned int p_arglen;
	unsigned int p_replen;
	unsigned int p_timer;
	u32 p_statidx;
	const char *p_name;
};

struct rpc_wait {
	struct list_head list;
	struct list_head links;
	struct list_head timer_list;
};

struct rpc_call_ops;

struct rpc_clnt;

struct rpc_task {
	atomic_t tk_count;
	int tk_status;
	struct list_head tk_task;
	void (*tk_callback)(struct rpc_task *);
	void (*tk_action)(struct rpc_task *);
	long unsigned int tk_timeout;
	long unsigned int tk_runstate;
	struct rpc_wait_queue *tk_waitqueue;
	union {
		struct work_struct tk_work;
		struct rpc_wait tk_wait;
	} u;
	int tk_rpc_status;
	struct rpc_message tk_msg;
	void *tk_calldata;
	const struct rpc_call_ops *tk_ops;
	struct rpc_clnt *tk_client;
	struct rpc_xprt *tk_xprt;
	struct rpc_cred *tk_op_cred;
	struct rpc_rqst *tk_rqstp;
	struct workqueue_struct *tk_workqueue;
	ktime_t tk_start;
	pid_t tk_owner;
	short unsigned int tk_flags;
	short unsigned int tk_timeouts;
	short unsigned int tk_pid;
	unsigned char tk_priority: 2;
	unsigned char tk_garb_retry: 2;
	unsigned char tk_cred_retry: 2;
	unsigned char tk_rebind_retry: 2;
};

struct rpc_call_ops {
	void (*rpc_call_prepare)(struct rpc_task *, void *);
	void (*rpc_call_done)(struct rpc_task *, void *);
	void (*rpc_count_stats)(struct rpc_task *, void *);
	void (*rpc_release)(void *);
};

struct rpc_pipe_dir_head {
	struct list_head pdh_entries;
	struct dentry *pdh_dentry;
};

struct rpc_rtt {
	long unsigned int timeo;
	long unsigned int srtt[5];
	long unsigned int sdrtt[5];
	int ntimeouts[5];
};

struct rpc_timeout {
	long unsigned int to_initval;
	long unsigned int to_maxval;
	long unsigned int to_increment;
	unsigned int to_retries;
	unsigned char to_exponential;
};

struct rpc_xprt_switch;

struct rpc_xprt_iter_ops;

struct rpc_xprt_iter {
	struct rpc_xprt_switch *xpi_xpswitch;
	struct rpc_xprt *xpi_cursor;
	const struct rpc_xprt_iter_ops *xpi_ops;
};

struct rpc_auth;

struct rpc_stat;

struct rpc_iostats;

struct rpc_program;

struct rpc_clnt {
	atomic_t cl_count;
	unsigned int cl_clid;
	struct list_head cl_clients;
	struct list_head cl_tasks;
	spinlock_t cl_lock;
	struct rpc_xprt *cl_xprt;
	const struct rpc_procinfo *cl_procinfo;
	u32 cl_prog;
	u32 cl_vers;
	u32 cl_maxproc;
	struct rpc_auth *cl_auth;
	struct rpc_stat *cl_stats;
	struct rpc_iostats *cl_metrics;
	unsigned int cl_softrtry: 1;
	unsigned int cl_softerr: 1;
	unsigned int cl_discrtry: 1;
	unsigned int cl_noretranstimeo: 1;
	unsigned int cl_autobind: 1;
	unsigned int cl_chatty: 1;
	struct rpc_rtt *cl_rtt;
	const struct rpc_timeout *cl_timeout;
	atomic_t cl_swapper;
	int cl_nodelen;
	char cl_nodename[65];
	struct rpc_pipe_dir_head cl_pipedir_objects;
	struct rpc_clnt *cl_parent;
	struct rpc_rtt cl_rtt_default;
	struct rpc_timeout cl_timeout_default;
	const struct rpc_program *cl_program;
	const char *cl_principal;
	union {
		struct rpc_xprt_iter cl_xpi;
		struct work_struct cl_work;
	};
	const struct cred *cl_cred;
};

struct rpc_xprt_ops;

struct svc_xprt;

struct svc_serv;

struct rpc_xprt {
	struct kref kref;
	const struct rpc_xprt_ops *ops;
	const struct rpc_timeout *timeout;
	struct __kernel_sockaddr_storage addr;
	size_t addrlen;
	int prot;
	long unsigned int cong;
	long unsigned int cwnd;
	size_t max_payload;
	struct rpc_wait_queue binding;
	struct rpc_wait_queue sending;
	struct rpc_wait_queue pending;
	struct rpc_wait_queue backlog;
	struct list_head free;
	unsigned int max_reqs;
	unsigned int min_reqs;
	unsigned int num_reqs;
	long unsigned int state;
	unsigned char resvport: 1;
	unsigned char reuseport: 1;
	atomic_t swapper;
	unsigned int bind_index;
	struct list_head xprt_switch;
	long unsigned int bind_timeout;
	long unsigned int reestablish_timeout;
	unsigned int connect_cookie;
	struct work_struct task_cleanup;
	struct timer_list timer;
	long unsigned int last_used;
	long unsigned int idle_timeout;
	long unsigned int connect_timeout;
	long unsigned int max_reconnect_timeout;
	atomic_long_t queuelen;
	spinlock_t transport_lock;
	spinlock_t reserve_lock;
	spinlock_t queue_lock;
	u32 xid;
	struct rpc_task *snd_task;
	struct list_head xmit_queue;
	struct svc_xprt *bc_xprt;
	struct svc_serv *bc_serv;
	unsigned int bc_alloc_max;
	unsigned int bc_alloc_count;
	atomic_t bc_slot_count;
	spinlock_t bc_pa_lock;
	struct list_head bc_pa_list;
	struct rb_root recv_queue;
	struct {
		long unsigned int bind_count;
		long unsigned int connect_count;
		long unsigned int connect_start;
		long unsigned int connect_time;
		long unsigned int sends;
		long unsigned int recvs;
		long unsigned int bad_xids;
		long unsigned int max_slots;
		long long unsigned int req_u;
		long long unsigned int bklog_u;
		long long unsigned int sending_u;
		long long unsigned int pending_u;
	} stat;
	struct net *xprt_net;
	const char *servername;
	const char *address_strings[6];
	struct callback_head rcu;
};

struct rpc_credops;

struct rpc_cred {
	struct hlist_node cr_hash;
	struct list_head cr_lru;
	struct callback_head cr_rcu;
	struct rpc_auth *cr_auth;
	const struct rpc_credops *cr_ops;
	long unsigned int cr_expire;
	long unsigned int cr_flags;
	refcount_t cr_count;
	const struct cred *cr_cred;
};

typedef u32 rpc_authflavor_t;

struct auth_cred {
	const struct cred *cred;
	const char *principal;
};

struct rpc_authops;

struct rpc_cred_cache;

struct rpc_auth {
	unsigned int au_cslack;
	unsigned int au_rslack;
	unsigned int au_verfsize;
	unsigned int au_ralign;
	long unsigned int au_flags;
	const struct rpc_authops *au_ops;
	rpc_authflavor_t au_flavor;
	refcount_t au_count;
	struct rpc_cred_cache *au_credcache;
};

struct rpc_credops {
	const char *cr_name;
	int (*cr_init)(struct rpc_auth *, struct rpc_cred *);
	void (*crdestroy)(struct rpc_cred *);
	int (*crmatch)(struct auth_cred *, struct rpc_cred *, int);
	int (*crmarshal)(struct rpc_task *, struct xdr_stream *);
	int (*crrefresh)(struct rpc_task *);
	int (*crvalidate)(struct rpc_task *, struct xdr_stream *);
	int (*crwrap_req)(struct rpc_task *, struct xdr_stream *);
	int (*crunwrap_resp)(struct rpc_task *, struct xdr_stream *);
	int (*crkey_timeout)(struct rpc_cred *);
	char * (*crstringify_acceptor)(struct rpc_cred *);
	bool (*crneed_reencode)(struct rpc_task *);
};

struct rpc_auth_create_args;

struct rpcsec_gss_info;

struct rpc_authops {
	struct module *owner;
	rpc_authflavor_t au_flavor;
	char *au_name;
	struct rpc_auth * (*create)(const struct rpc_auth_create_args *, struct rpc_clnt *);
	void (*destroy)(struct rpc_auth *);
	int (*hash_cred)(struct auth_cred *, unsigned int);
	struct rpc_cred * (*lookup_cred)(struct rpc_auth *, struct auth_cred *, int);
	struct rpc_cred * (*crcreate)(struct rpc_auth *, struct auth_cred *, int, gfp_t);
	rpc_authflavor_t (*info2flavor)(struct rpcsec_gss_info *);
	int (*flavor2info)(rpc_authflavor_t, struct rpcsec_gss_info *);
	int (*key_timeout)(struct rpc_auth *, struct rpc_cred *);
};

struct rpc_auth_create_args {
	rpc_authflavor_t pseudoflavor;
	const char *target_name;
};

struct rpcsec_gss_oid {
	unsigned int len;
	u8 data[32];
};

struct rpcsec_gss_info {
	struct rpcsec_gss_oid oid;
	u32 qop;
	u32 service;
};

struct rpc_xprt_ops {
	void (*set_buffer_size)(struct rpc_xprt *, size_t, size_t);
	int (*reserve_xprt)(struct rpc_xprt *, struct rpc_task *);
	void (*release_xprt)(struct rpc_xprt *, struct rpc_task *);
	void (*alloc_slot)(struct rpc_xprt *, struct rpc_task *);
	void (*free_slot)(struct rpc_xprt *, struct rpc_rqst *);
	void (*rpcbind)(struct rpc_task *);
	void (*set_port)(struct rpc_xprt *, short unsigned int);
	void (*connect)(struct rpc_xprt *, struct rpc_task *);
	int (*buf_alloc)(struct rpc_task *);
	void (*buf_free)(struct rpc_task *);
	void (*prepare_request)(struct rpc_rqst *);
	int (*send_request)(struct rpc_rqst *);
	void (*wait_for_reply_request)(struct rpc_task *);
	void (*timer)(struct rpc_xprt *, struct rpc_task *);
	void (*release_request)(struct rpc_task *);
	void (*close)(struct rpc_xprt *);
	void (*destroy)(struct rpc_xprt *);
	void (*set_connect_timeout)(struct rpc_xprt *, long unsigned int, long unsigned int);
	void (*print_stats)(struct rpc_xprt *, struct seq_file *);
	int (*enable_swap)(struct rpc_xprt *);
	void (*disable_swap)(struct rpc_xprt *);
	void (*inject_disconnect)(struct rpc_xprt *);
	int (*bc_setup)(struct rpc_xprt *, unsigned int);
	size_t (*bc_maxpayload)(struct rpc_xprt *);
	unsigned int (*bc_num_slots)(struct rpc_xprt *);
	void (*bc_free_rqst)(struct rpc_rqst *);
	void (*bc_destroy)(struct rpc_xprt *, unsigned int);
};

struct rpc_xprt_switch {
	spinlock_t xps_lock;
	struct kref xps_kref;
	unsigned int xps_nxprts;
	unsigned int xps_nactive;
	atomic_long_t xps_queuelen;
	struct list_head xps_xprt_list;
	struct net *xps_net;
	const struct rpc_xprt_iter_ops *xps_iter_ops;
	struct callback_head xps_rcu;
};

struct rpc_stat {
	const struct rpc_program *program;
	unsigned int netcnt;
	unsigned int netudpcnt;
	unsigned int nettcpcnt;
	unsigned int nettcpconn;
	unsigned int netreconn;
	unsigned int rpccnt;
	unsigned int rpcretrans;
	unsigned int rpcauthrefresh;
	unsigned int rpcgarbage;
};

struct rpc_version;

struct rpc_program {
	const char *name;
	u32 number;
	unsigned int nrvers;
	const struct rpc_version **version;
	struct rpc_stat *stats;
	const char *pipe_dir_name;
};

struct rpc_xprt_iter_ops {
	void (*xpi_rewind)(struct rpc_xprt_iter *);
	struct rpc_xprt * (*xpi_xprt)(struct rpc_xprt_iter *);
	struct rpc_xprt * (*xpi_next)(struct rpc_xprt_iter *);
};

struct rpc_version {
	u32 number;
	unsigned int nrprocs;
	const struct rpc_procinfo *procs;
	unsigned int *counts;
};

struct nfs_fh {
	short unsigned int size;
	unsigned char data[128];
};

enum nfs3_stable_how {
	NFS_UNSTABLE = 0,
	NFS_DATA_SYNC = 1,
	NFS_FILE_SYNC = 2,
	NFS_INVALID_STABLE_HOW = 4294967295,
};

struct nfs4_label {
	uint32_t lfs;
	uint32_t pi;
	u32 len;
	char *label;
};

typedef struct {
	char data[8];
} nfs4_verifier;

struct nfs4_string {
	unsigned int len;
	char *data;
};

struct nfs_fsid {
	uint64_t major;
	uint64_t minor;
};

struct nfs4_threshold {
	__u32 bm;
	__u32 l_type;
	__u64 rd_sz;
	__u64 wr_sz;
	__u64 rd_io_sz;
	__u64 wr_io_sz;
};

struct nfs_fattr {
	unsigned int valid;
	umode_t mode;
	__u32 nlink;
	kuid_t uid;
	kgid_t gid;
	dev_t rdev;
	__u64 size;
	union {
		struct {
			__u32 blocksize;
			__u32 blocks;
		} nfs2;
		struct {
			__u64 used;
		} nfs3;
	} du;
	struct nfs_fsid fsid;
	__u64 fileid;
	__u64 mounted_on_fileid;
	struct timespec64 atime;
	struct timespec64 mtime;
	struct timespec64 ctime;
	__u64 change_attr;
	__u64 pre_change_attr;
	__u64 pre_size;
	struct timespec64 pre_mtime;
	struct timespec64 pre_ctime;
	long unsigned int time_start;
	long unsigned int gencount;
	struct nfs4_string *owner_name;
	struct nfs4_string *group_name;
	struct nfs4_threshold *mdsthreshold;
	struct nfs4_label *label;
};

struct nfs_fsinfo {
	struct nfs_fattr *fattr;
	__u32 rtmax;
	__u32 rtpref;
	__u32 rtmult;
	__u32 wtmax;
	__u32 wtpref;
	__u32 wtmult;
	__u32 dtpref;
	__u64 maxfilesize;
	struct timespec64 time_delta;
	__u32 lease_time;
	__u32 nlayouttypes;
	__u32 layouttype[8];
	__u32 blksize;
	__u32 clone_blksize;
	__u32 xattr_support;
};

struct nfs_fsstat {
	struct nfs_fattr *fattr;
	__u64 tbytes;
	__u64 fbytes;
	__u64 abytes;
	__u64 tfiles;
	__u64 ffiles;
	__u64 afiles;
};

struct nfs_pathconf {
	struct nfs_fattr *fattr;
	__u32 max_link;
	__u32 max_namelen;
};

struct nfs4_change_info {
	u32 atomic;
	u64 before;
	u64 after;
};

struct nfs4_slot;

struct nfs4_sequence_args {
	struct nfs4_slot *sa_slot;
	u8 sa_cache_this: 1;
	u8 sa_privileged: 1;
};

struct nfs4_sequence_res {
	struct nfs4_slot *sr_slot;
	long unsigned int sr_timestamp;
	int sr_status;
	u32 sr_status_flags;
	u32 sr_highest_slotid;
	u32 sr_target_highest_slotid;
};

struct nfs_open_context;

struct nfs_lock_context {
	refcount_t count;
	struct list_head list;
	struct nfs_open_context *open_context;
	fl_owner_t lockowner;
	atomic_t io_count;
	struct callback_head callback_head;
};

struct nfs_open_context {
	struct nfs_lock_context lock_context;
	fl_owner_t flock_owner;
	struct dentry *dentry;
	const struct cred *cred;
	struct rpc_cred *ll_cred;
	struct nfs4_state *state;
	fmode_t mode;
	long unsigned int flags;
	int error;
	struct list_head list;
	struct nfs4_threshold *mdsthreshold;
	struct callback_head callback_head;
};

struct nlm_host;

struct nfs_auth_info {
	unsigned int flavor_len;
	rpc_authflavor_t flavors[12];
};

struct nfs_client;

struct nfs_iostats;

struct pnfs_layoutdriver_type;

struct nfs_server {
	struct nfs_client *nfs_client;
	struct list_head client_link;
	struct list_head master_link;
	struct rpc_clnt *client;
	struct rpc_clnt *client_acl;
	struct nlm_host *nlm_host;
	struct nfs_iostats *io_stats;
	atomic_long_t writeback;
	int flags;
	unsigned int caps;
	unsigned int rsize;
	unsigned int rpages;
	unsigned int wsize;
	unsigned int wpages;
	unsigned int wtmult;
	unsigned int dtsize;
	short unsigned int port;
	unsigned int bsize;
	unsigned int gxasize;
	unsigned int sxasize;
	unsigned int lxasize;
	unsigned int acregmin;
	unsigned int acregmax;
	unsigned int acdirmin;
	unsigned int acdirmax;
	unsigned int namelen;
	unsigned int options;
	unsigned int clone_blksize;
	struct nfs_fsid fsid;
	__u64 maxfilesize;
	struct timespec64 time_delta;
	long unsigned int mount_time;
	struct super_block *super;
	dev_t s_dev;
	struct nfs_auth_info auth_info;
	u32 pnfs_blksize;
	u32 attr_bitmask[3];
	u32 attr_bitmask_nl[3];
	u32 exclcreat_bitmask[3];
	u32 cache_consistency_bitmask[3];
	u32 acl_bitmask;
	u32 fh_expire_type;
	struct pnfs_layoutdriver_type *pnfs_curr_ld;
	struct rpc_wait_queue roc_rpcwaitq;
	void *pnfs_ld_data;
	struct rb_root state_owners;
	struct ida openowner_id;
	struct ida lockowner_id;
	struct list_head state_owners_lru;
	struct list_head layouts;
	struct list_head delegations;
	struct list_head ss_copies;
	long unsigned int mig_gen;
	long unsigned int mig_status;
	void (*destroy)(struct nfs_server *);
	atomic_t active;
	struct __kernel_sockaddr_storage mountd_address;
	size_t mountd_addrlen;
	u32 mountd_version;
	short unsigned int mountd_port;
	short unsigned int mountd_protocol;
	struct rpc_wait_queue uoc_rpcwaitq;
	unsigned int read_hdrsize;
	const struct cred *cred;
};

struct nfs_rpc_ops;

struct nfs_subversion;

struct idmap;

struct nfs4_minor_version_ops;

struct nfs4_slot_table;

struct nfs4_session;

struct nfs41_server_owner;

struct nfs41_server_scope;

struct nfs41_impl_id;

struct nfs_client {
	refcount_t cl_count;
	atomic_t cl_mds_count;
	int cl_cons_state;
	long unsigned int cl_res_state;
	long unsigned int cl_flags;
	struct __kernel_sockaddr_storage cl_addr;
	size_t cl_addrlen;
	char *cl_hostname;
	char *cl_acceptor;
	struct list_head cl_share_link;
	struct list_head cl_superblocks;
	struct rpc_clnt *cl_rpcclient;
	const struct nfs_rpc_ops *rpc_ops;
	int cl_proto;
	struct nfs_subversion *cl_nfs_mod;
	u32 cl_minorversion;
	unsigned int cl_nconnect;
	const char *cl_principal;
	struct list_head cl_ds_clients;
	u64 cl_clientid;
	nfs4_verifier cl_confirm;
	long unsigned int cl_state;
	spinlock_t cl_lock;
	long unsigned int cl_lease_time;
	long unsigned int cl_last_renewal;
	struct delayed_work cl_renewd;
	struct rpc_wait_queue cl_rpcwaitq;
	struct idmap *cl_idmap;
	const char *cl_owner_id;
	u32 cl_cb_ident;
	const struct nfs4_minor_version_ops *cl_mvops;
	long unsigned int cl_mig_gen;
	struct nfs4_slot_table *cl_slot_tbl;
	u32 cl_seqid;
	u32 cl_exchange_flags;
	struct nfs4_session *cl_session;
	bool cl_preserve_clid;
	struct nfs41_server_owner *cl_serverowner;
	struct nfs41_server_scope *cl_serverscope;
	struct nfs41_impl_id *cl_implid;
	long unsigned int cl_sp4_flags;
	wait_queue_head_t cl_lock_waitq;
	char cl_ipaddr[48];
	struct net *cl_net;
	struct list_head pending_cb_stateids;
};

struct nfs_seqid {
	struct nfs_seqid_counter *sequence;
	struct list_head list;
	struct rpc_task *task;
};

struct nfs_write_verifier {
	char data[8];
};

struct nfs_writeverf {
	struct nfs_write_verifier verifier;
	enum nfs3_stable_how committed;
};

struct nfs_pgio_args {
	struct nfs4_sequence_args seq_args;
	struct nfs_fh *fh;
	struct nfs_open_context *context;
	struct nfs_lock_context *lock_context;
	nfs4_stateid stateid;
	__u64 offset;
	__u32 count;
	unsigned int pgbase;
	struct page **pages;
	union {
		unsigned int replen;
		struct {
			const u32 *bitmask;
			u32 bitmask_store[3];
			enum nfs3_stable_how stable;
		};
	};
};

struct nfs_pgio_res {
	struct nfs4_sequence_res seq_res;
	struct nfs_fattr *fattr;
	__u64 count;
	__u32 op_status;
	union {
		struct {
			unsigned int replen;
			int eof;
		};
		struct {
			struct nfs_writeverf *verf;
			const struct nfs_server *server;
		};
	};
};

struct nfs_commitargs {
	struct nfs4_sequence_args seq_args;
	struct nfs_fh *fh;
	__u64 offset;
	__u32 count;
	const u32 *bitmask;
};

struct nfs_commitres {
	struct nfs4_sequence_res seq_res;
	__u32 op_status;
	struct nfs_fattr *fattr;
	struct nfs_writeverf *verf;
	const struct nfs_server *server;
};

struct nfs_removeargs {
	struct nfs4_sequence_args seq_args;
	const struct nfs_fh *fh;
	struct qstr name;
};

struct nfs_removeres {
	struct nfs4_sequence_res seq_res;
	struct nfs_server *server;
	struct nfs_fattr *dir_attr;
	struct nfs4_change_info cinfo;
};

struct nfs_renameargs {
	struct nfs4_sequence_args seq_args;
	const struct nfs_fh *old_dir;
	const struct nfs_fh *new_dir;
	const struct qstr *old_name;
	const struct qstr *new_name;
};

struct nfs_renameres {
	struct nfs4_sequence_res seq_res;
	struct nfs_server *server;
	struct nfs4_change_info old_cinfo;
	struct nfs_fattr *old_fattr;
	struct nfs4_change_info new_cinfo;
	struct nfs_fattr *new_fattr;
};

struct nfs_entry {
	__u64 ino;
	__u64 cookie;
	__u64 prev_cookie;
	const char *name;
	unsigned int len;
	int eof;
	struct nfs_fh *fh;
	struct nfs_fattr *fattr;
	struct nfs4_label *label;
	unsigned char d_type;
	struct nfs_server *server;
};

struct nfs4_pathname {
	unsigned int ncomponents;
	struct nfs4_string components[512];
};

struct nfs4_fs_location {
	unsigned int nservers;
	struct nfs4_string servers[10];
	struct nfs4_pathname rootpath;
};

struct nfs4_fs_locations {
	struct nfs_fattr fattr;
	const struct nfs_server *server;
	struct nfs4_pathname fs_path;
	int nlocations;
	struct nfs4_fs_location locations[10];
};

struct nfstime4 {
	u64 seconds;
	u32 nseconds;
};

struct pnfs_commit_ops;

struct pnfs_ds_commit_info {
	struct list_head commits;
	unsigned int nwritten;
	unsigned int ncommitting;
	const struct pnfs_commit_ops *ops;
};

struct pnfs_layout_segment;

struct nfs_commit_info;

struct nfs_page;

struct pnfs_commit_ops {
	void (*setup_ds_info)(struct pnfs_ds_commit_info *, struct pnfs_layout_segment *);
	void (*release_ds_info)(struct pnfs_ds_commit_info *, struct inode *);
	int (*commit_pagelist)(struct inode *, struct list_head *, int, struct nfs_commit_info *);
	void (*mark_request_commit)(struct nfs_page *, struct pnfs_layout_segment *, struct nfs_commit_info *, u32);
	void (*clear_request_commit)(struct nfs_page *, struct nfs_commit_info *);
	int (*scan_commit_lists)(struct nfs_commit_info *, int);
	void (*recover_commit_reqs)(struct list_head *, struct nfs_commit_info *);
	struct nfs_page * (*search_commit_reqs)(struct nfs_commit_info *, struct page *);
};

struct nfs41_server_owner {
	uint64_t minor_id;
	uint32_t major_id_sz;
	char major_id[1024];
};

struct nfs41_server_scope {
	uint32_t server_scope_sz;
	char server_scope[1024];
};

struct nfs41_impl_id {
	char domain[1025];
	char name[1025];
	struct nfstime4 date;
};

struct nfs_page_array {
	struct page **pagevec;
	unsigned int npages;
	struct page *page_array[8];
};

struct nfs_pgio_completion_ops;

struct nfs_rw_ops;

struct nfs_io_completion;

struct nfs_direct_req;

struct nfs_pgio_header {
	struct inode *inode;
	const struct cred *cred;
	struct list_head pages;
	struct nfs_page *req;
	struct nfs_writeverf verf;
	fmode_t rw_mode;
	struct pnfs_layout_segment *lseg;
	loff_t io_start;
	const struct rpc_call_ops *mds_ops;
	void (*release)(struct nfs_pgio_header *);
	const struct nfs_pgio_completion_ops *completion_ops;
	const struct nfs_rw_ops *rw_ops;
	struct nfs_io_completion *io_completion;
	struct nfs_direct_req *dreq;
	int pnfs_error;
	int error;
	unsigned int good_bytes;
	long unsigned int flags;
	struct rpc_task task;
	struct nfs_fattr fattr;
	struct nfs_pgio_args args;
	struct nfs_pgio_res res;
	long unsigned int timestamp;
	int (*pgio_done_cb)(struct rpc_task *, struct nfs_pgio_header *);
	__u64 mds_offset;
	struct nfs_page_array page_array;
	struct nfs_client *ds_clp;
	u32 ds_commit_idx;
	u32 pgio_mirror_idx;
};

struct nfs_pgio_completion_ops {
	void (*error_cleanup)(struct list_head *, int);
	void (*init_hdr)(struct nfs_pgio_header *);
	void (*completion)(struct nfs_pgio_header *);
	void (*reschedule_io)(struct nfs_pgio_header *);
};

struct rpc_task_setup;

struct nfs_rw_ops {
	struct nfs_pgio_header * (*rw_alloc_header)();
	void (*rw_free_header)(struct nfs_pgio_header *);
	int (*rw_done)(struct rpc_task *, struct nfs_pgio_header *, struct inode *);
	void (*rw_result)(struct rpc_task *, struct nfs_pgio_header *);
	void (*rw_initiate)(struct nfs_pgio_header *, struct rpc_message *, const struct nfs_rpc_ops *, struct rpc_task_setup *, int);
};

struct nfs_mds_commit_info {
	atomic_t rpcs_out;
	atomic_long_t ncommit;
	struct list_head list;
};

struct nfs_commit_data;

struct nfs_commit_completion_ops {
	void (*completion)(struct nfs_commit_data *);
	void (*resched_write)(struct nfs_commit_info *, struct nfs_page *);
};

struct nfs_commit_data {
	struct rpc_task task;
	struct inode *inode;
	const struct cred *cred;
	struct nfs_fattr fattr;
	struct nfs_writeverf verf;
	struct list_head pages;
	struct list_head list;
	struct nfs_direct_req *dreq;
	struct nfs_commitargs args;
	struct nfs_commitres res;
	struct nfs_open_context *context;
	struct pnfs_layout_segment *lseg;
	struct nfs_client *ds_clp;
	int ds_commit_index;
	loff_t lwb;
	const struct rpc_call_ops *mds_ops;
	const struct nfs_commit_completion_ops *completion_ops;
	int (*commit_done_cb)(struct rpc_task *, struct nfs_commit_data *);
	long unsigned int flags;
};

struct nfs_commit_info {
	struct inode *inode;
	struct nfs_mds_commit_info *mds;
	struct pnfs_ds_commit_info *ds;
	struct nfs_direct_req *dreq;
	const struct nfs_commit_completion_ops *completion_ops;
};

struct nfs_unlinkdata {
	struct nfs_removeargs args;
	struct nfs_removeres res;
	struct dentry *dentry;
	wait_queue_head_t wq;
	const struct cred *cred;
	struct nfs_fattr dir_attr;
	long int timeout;
};

struct nfs_renamedata {
	struct nfs_renameargs args;
	struct nfs_renameres res;
	const struct cred *cred;
	struct inode *old_dir;
	struct dentry *old_dentry;
	struct nfs_fattr old_fattr;
	struct inode *new_dir;
	struct dentry *new_dentry;
	struct nfs_fattr new_fattr;
	void (*complete)(struct rpc_task *, struct nfs_renamedata *);
	long int timeout;
	bool cancelled;
};

struct nlmclnt_operations;

struct nfs_access_entry;

struct nfs_client_initdata;

struct nfs_rpc_ops {
	u32 version;
	const struct dentry_operations *dentry_ops;
	const struct inode_operations *dir_inode_ops;
	const struct inode_operations *file_inode_ops;
	const struct file_operations *file_ops;
	const struct nlmclnt_operations *nlmclnt_ops;
	int (*getroot)(struct nfs_server *, struct nfs_fh *, struct nfs_fsinfo *);
	int (*submount)(struct fs_context *, struct nfs_server *);
	int (*try_get_tree)(struct fs_context *);
	int (*getattr)(struct nfs_server *, struct nfs_fh *, struct nfs_fattr *, struct nfs4_label *, struct inode *);
	int (*setattr)(struct dentry *, struct nfs_fattr *, struct iattr *);
	int (*lookup)(struct inode *, struct dentry *, struct nfs_fh *, struct nfs_fattr *, struct nfs4_label *);
	int (*lookupp)(struct inode *, struct nfs_fh *, struct nfs_fattr *, struct nfs4_label *);
	int (*access)(struct inode *, struct nfs_access_entry *);
	int (*readlink)(struct inode *, struct page *, unsigned int, unsigned int);
	int (*create)(struct inode *, struct dentry *, struct iattr *, int);
	int (*remove)(struct inode *, struct dentry *);
	void (*unlink_setup)(struct rpc_message *, struct dentry *, struct inode *);
	void (*unlink_rpc_prepare)(struct rpc_task *, struct nfs_unlinkdata *);
	int (*unlink_done)(struct rpc_task *, struct inode *);
	void (*rename_setup)(struct rpc_message *, struct dentry *, struct dentry *);
	void (*rename_rpc_prepare)(struct rpc_task *, struct nfs_renamedata *);
	int (*rename_done)(struct rpc_task *, struct inode *, struct inode *);
	int (*link)(struct inode *, struct inode *, const struct qstr *);
	int (*symlink)(struct inode *, struct dentry *, struct page *, unsigned int, struct iattr *);
	int (*mkdir)(struct inode *, struct dentry *, struct iattr *);
	int (*rmdir)(struct inode *, const struct qstr *);
	int (*readdir)(struct dentry *, const struct cred *, u64, struct page **, unsigned int, bool);
	int (*mknod)(struct inode *, struct dentry *, struct iattr *, dev_t);
	int (*statfs)(struct nfs_server *, struct nfs_fh *, struct nfs_fsstat *);
	int (*fsinfo)(struct nfs_server *, struct nfs_fh *, struct nfs_fsinfo *);
	int (*pathconf)(struct nfs_server *, struct nfs_fh *, struct nfs_pathconf *);
	int (*set_capabilities)(struct nfs_server *, struct nfs_fh *);
	int (*decode_dirent)(struct xdr_stream *, struct nfs_entry *, bool);
	int (*pgio_rpc_prepare)(struct rpc_task *, struct nfs_pgio_header *);
	void (*read_setup)(struct nfs_pgio_header *, struct rpc_message *);
	int (*read_done)(struct rpc_task *, struct nfs_pgio_header *);
	void (*write_setup)(struct nfs_pgio_header *, struct rpc_message *, struct rpc_clnt **);
	int (*write_done)(struct rpc_task *, struct nfs_pgio_header *);
	void (*commit_setup)(struct nfs_commit_data *, struct rpc_message *, struct rpc_clnt **);
	void (*commit_rpc_prepare)(struct rpc_task *, struct nfs_commit_data *);
	int (*commit_done)(struct rpc_task *, struct nfs_commit_data *);
	int (*lock)(struct file *, int, struct file_lock *);
	int (*lock_check_bounds)(const struct file_lock *);
	void (*clear_acl_cache)(struct inode *);
	void (*close_context)(struct nfs_open_context *, int);
	struct inode * (*open_context)(struct inode *, struct nfs_open_context *, int, struct iattr *, int *);
	int (*have_delegation)(struct inode *, fmode_t);
	struct nfs_client * (*alloc_client)(const struct nfs_client_initdata *);
	struct nfs_client * (*init_client)(struct nfs_client *, const struct nfs_client_initdata *);
	void (*free_client)(struct nfs_client *);
	struct nfs_server * (*create_server)(struct fs_context *);
	struct nfs_server * (*clone_server)(struct nfs_server *, struct nfs_fh *, struct nfs_fattr *, rpc_authflavor_t);
};

struct nlmclnt_operations {
	void (*nlmclnt_alloc_call)(void *);
	bool (*nlmclnt_unlock_prepare)(struct rpc_task *, void *);
	void (*nlmclnt_release_call)(void *);
};

struct nfs_access_entry {
	struct rb_node rb_node;
	struct list_head lru;
	const struct cred *cred;
	__u32 mask;
	struct callback_head callback_head;
};

struct nfs_client_initdata {
	long unsigned int init_flags;
	const char *hostname;
	const struct sockaddr *addr;
	const char *nodename;
	const char *ip_addr;
	size_t addrlen;
	struct nfs_subversion *nfs_mod;
	int proto;
	u32 minorversion;
	unsigned int nconnect;
	struct net *net;
	const struct rpc_timeout *timeparms;
	const struct cred *cred;
};

struct nfs4_state_recovery_ops;

struct nfs4_state_maintenance_ops;

struct nfs4_mig_recovery_ops;

struct nfs4_minor_version_ops {
	u32 minor_version;
	unsigned int init_caps;
	int (*init_client)(struct nfs_client *);
	void (*shutdown_client)(struct nfs_client *);
	bool (*match_stateid)(const nfs4_stateid *, const nfs4_stateid *);
	int (*find_root_sec)(struct nfs_server *, struct nfs_fh *, struct nfs_fsinfo *);
	void (*free_lock_state)(struct nfs_server *, struct nfs4_lock_state *);
	int (*test_and_free_expired)(struct nfs_server *, nfs4_stateid *, const struct cred *);
	struct nfs_seqid * (*alloc_seqid)(struct nfs_seqid_counter *, gfp_t);
	void (*session_trunk)(struct rpc_clnt *, struct rpc_xprt *, void *);
	const struct rpc_call_ops *call_sync_ops;
	const struct nfs4_state_recovery_ops *reboot_recovery_ops;
	const struct nfs4_state_recovery_ops *nograce_recovery_ops;
	const struct nfs4_state_maintenance_ops *state_renewal_ops;
	const struct nfs4_mig_recovery_ops *mig_recovery_ops;
};

struct nfs4_state_owner;

struct nfs4_state {
	struct list_head open_states;
	struct list_head inode_states;
	struct list_head lock_states;
	struct nfs4_state_owner *owner;
	struct inode *inode;
	long unsigned int flags;
	spinlock_t state_lock;
	seqlock_t seqlock;
	nfs4_stateid stateid;
	nfs4_stateid open_stateid;
	unsigned int n_rdonly;
	unsigned int n_wronly;
	unsigned int n_rdwr;
	fmode_t state;
	refcount_t count;
	wait_queue_head_t waitq;
	struct callback_head callback_head;
};

struct nfs4_ssc_client_ops;

struct nfs_ssc_client_ops;

struct nfs_ssc_client_ops_tbl {
	const struct nfs4_ssc_client_ops *ssc_nfs4_ops;
	const struct nfs_ssc_client_ops *ssc_nfs_ops;
};

struct nfs4_ssc_client_ops {
	struct file * (*sco_open)(struct vfsmount *, struct nfs_fh *, nfs4_stateid *);
	void (*sco_close)(struct file *);
};

struct nfs_ssc_client_ops {
	void (*sco_sb_deactive)(struct super_block *);
};

struct nfs4_state_recovery_ops {
	int owner_flag_bit;
	int state_flag_bit;
	int (*recover_open)(struct nfs4_state_owner *, struct nfs4_state *);
	int (*recover_lock)(struct nfs4_state *, struct file_lock *);
	int (*establish_clid)(struct nfs_client *, const struct cred *);
	int (*reclaim_complete)(struct nfs_client *, const struct cred *);
	int (*detect_trunking)(struct nfs_client *, struct nfs_client **, const struct cred *);
};

struct nfs4_state_maintenance_ops {
	int (*sched_state_renewal)(struct nfs_client *, const struct cred *, unsigned int);
	const struct cred * (*get_state_renewal_cred)(struct nfs_client *);
	int (*renew_lease)(struct nfs_client *, const struct cred *);
};

struct nfs4_mig_recovery_ops {
	int (*get_locations)(struct inode *, struct nfs4_fs_locations *, struct page *, const struct cred *);
	int (*fsid_present)(struct inode *, const struct cred *);
};

struct nfs4_state_owner {
	struct nfs_server *so_server;
	struct list_head so_lru;
	long unsigned int so_expires;
	struct rb_node so_server_node;
	const struct cred *so_cred;
	spinlock_t so_lock;
	atomic_t so_count;
	long unsigned int so_flags;
	struct list_head so_states;
	struct nfs_seqid_counter so_seqid;
	seqcount_spinlock_t so_reclaim_seqcount;
	struct mutex so_delegreturn_mutex;
};

struct core_name {
	char *corename;
	int used;
	int size;
};

struct trace_event_raw_iomap_readpage_class {
	struct trace_entry ent;
	dev_t dev;
	u64 ino;
	int nr_pages;
	char __data[0];
};

struct trace_event_raw_iomap_range_class {
	struct trace_entry ent;
	dev_t dev;
	u64 ino;
	loff_t size;
	long unsigned int offset;
	unsigned int length;
	char __data[0];
};

struct trace_event_raw_iomap_class {
	struct trace_entry ent;
	dev_t dev;
	u64 ino;
	u64 addr;
	loff_t offset;
	u64 length;
	u16 type;
	u16 flags;
	dev_t bdev;
	char __data[0];
};

struct trace_event_raw_iomap_apply {
	struct trace_entry ent;
	dev_t dev;
	u64 ino;
	loff_t pos;
	loff_t length;
	unsigned int flags;
	const void *ops;
	void *actor;
	long unsigned int caller;
	char __data[0];
};

struct trace_event_data_offsets_iomap_readpage_class {};

struct trace_event_data_offsets_iomap_range_class {};

struct trace_event_data_offsets_iomap_class {};

struct trace_event_data_offsets_iomap_apply {};

typedef void (*btf_trace_iomap_readpage)(void *, struct inode *, int);

typedef void (*btf_trace_iomap_readahead)(void *, struct inode *, int);

typedef void (*btf_trace_iomap_writepage)(void *, struct inode *, long unsigned int, unsigned int);

typedef void (*btf_trace_iomap_releasepage)(void *, struct inode *, long unsigned int, unsigned int);

typedef void (*btf_trace_iomap_invalidatepage)(void *, struct inode *, long unsigned int, unsigned int);

typedef void (*btf_trace_iomap_dio_invalidate_fail)(void *, struct inode *, long unsigned int, unsigned int);

typedef void (*btf_trace_iomap_apply_dstmap)(void *, struct inode *, struct iomap *);

typedef void (*btf_trace_iomap_apply_srcmap)(void *, struct inode *, struct iomap *);

typedef void (*btf_trace_iomap_apply)(void *, struct inode *, loff_t, loff_t, unsigned int, const void *, void *, long unsigned int);

struct iomap_ops {
	int (*iomap_begin)(struct inode *, loff_t, loff_t, unsigned int, struct iomap *, struct iomap *);
	int (*iomap_end)(struct inode *, loff_t, loff_t, ssize_t, unsigned int, struct iomap *);
};

typedef loff_t (*iomap_actor_t)(struct inode *, loff_t, loff_t, void *, struct iomap *, struct iomap *);

struct iomap_ioend {
	struct list_head io_list;
	u16 io_type;
	u16 io_flags;
	struct inode *io_inode;
	size_t io_size;
	loff_t io_offset;
	void *io_private;
	struct bio *io_bio;
	struct bio io_inline_bio;
};

struct iomap_writepage_ctx;

struct iomap_writeback_ops {
	int (*map_blocks)(struct iomap_writepage_ctx *, struct inode *, loff_t);
	int (*prepare_ioend)(struct iomap_ioend *, int);
	void (*discard_page)(struct page *, loff_t);
};

struct iomap_writepage_ctx {
	struct iomap iomap;
	struct iomap_ioend *ioend;
	const struct iomap_writeback_ops *ops;
};

struct iomap_page {
	atomic_t read_bytes_pending;
	atomic_t write_bytes_pending;
	spinlock_t uptodate_lock;
	long unsigned int uptodate[0];
};

struct iomap_readpage_ctx {
	struct page *cur_page;
	bool cur_page_in_bio;
	struct bio *bio;
	struct readahead_control *rac;
};

enum {
	IOMAP_WRITE_F_UNSHARE = 1,
};

struct iomap_dio_ops {
	int (*end_io)(struct kiocb *, ssize_t, int, unsigned int);
	blk_qc_t (*submit_io)(struct inode *, struct iomap *, struct bio *, loff_t);
};

struct iomap_dio {
	struct kiocb *iocb;
	const struct iomap_dio_ops *dops;
	loff_t i_size;
	loff_t size;
	atomic_t ref;
	unsigned int flags;
	int error;
	bool wait_for_completion;
	union {
		struct {
			struct iov_iter *iter;
			struct task_struct *waiter;
			struct request_queue *last_queue;
			blk_qc_t cookie;
		} submit;
		struct {
			struct work_struct work;
		} aio;
	};
};

struct fiemap_ctx {
	struct fiemap_extent_info *fi;
	struct iomap prev;
};

struct iomap_swapfile_info {
	struct iomap iomap;
	struct swap_info_struct *sis;
	uint64_t lowest_ppage;
	uint64_t highest_ppage;
	long unsigned int nr_pages;
	int nr_extents;
};

struct proc_maps_private {
	struct inode *inode;
	struct task_struct *task;
	struct mm_struct *mm;
	struct vm_area_struct *tail_vma;
};

struct mem_size_stats {
	long unsigned int resident;
	long unsigned int shared_clean;
	long unsigned int shared_dirty;
	long unsigned int private_clean;
	long unsigned int private_dirty;
	long unsigned int referenced;
	long unsigned int anonymous;
	long unsigned int lazyfree;
	long unsigned int anonymous_thp;
	long unsigned int shmem_thp;
	long unsigned int file_thp;
	long unsigned int swap;
	long unsigned int shared_hugetlb;
	long unsigned int private_hugetlb;
	u64 pss;
	u64 pss_anon;
	u64 pss_file;
	u64 pss_shmem;
	u64 pss_locked;
	u64 swap_pss;
	bool check_shmem_swap;
};

enum clear_refs_types {
	CLEAR_REFS_ALL = 1,
	CLEAR_REFS_ANON = 2,
	CLEAR_REFS_MAPPED = 3,
	CLEAR_REFS_SOFT_DIRTY = 4,
	CLEAR_REFS_MM_HIWATER_RSS = 5,
	CLEAR_REFS_LAST = 6,
};

struct clear_refs_private {
	enum clear_refs_types type;
};

typedef struct {
	u64 pme;
} pagemap_entry_t;

struct pagemapread {
	int pos;
	int len;
	pagemap_entry_t *buffer;
	bool show_pfn;
};

struct pde_opener {
	struct list_head lh;
	struct file *file;
	bool closing;
	struct completion *c;
};

enum {
	BIAS = 2147483648,
};

struct proc_fs_context {
	struct pid_namespace *pid_ns;
	unsigned int mask;
	enum proc_hidepid hidepid;
	int gid;
	enum proc_pidonly pidonly;
};

enum proc_param {
	Opt_gid___2 = 0,
	Opt_hidepid = 1,
	Opt_subset = 2,
};

struct genradix_root;

struct __genradix {
	struct genradix_root *root;
};

struct syscall_info {
	__u64 sp;
	struct seccomp_data data;
};

typedef struct dentry *instantiate_t(struct dentry *, struct task_struct *, const void *);

struct pid_entry {
	const char *name;
	unsigned int len;
	umode_t mode;
	const struct inode_operations *iop;
	const struct file_operations *fop;
	union proc_op op;
};

struct limit_names {
	const char *name;
	const char *unit;
};

struct map_files_info {
	long unsigned int start;
	long unsigned int end;
	fmode_t mode;
};

struct timers_private {
	struct pid *pid;
	struct task_struct *task;
	struct sighand_struct *sighand;
	struct pid_namespace *ns;
	long unsigned int flags;
};

struct tgid_iter {
	unsigned int tgid;
	struct task_struct *task;
};

struct fd_data {
	fmode_t mode;
	unsigned int fd;
};

struct sysctl_alias {
	const char *kernel_param;
	const char *sysctl_param;
};

struct seq_net_private {
	struct net *net;
};

struct bpf_iter_aux_info;

struct vmcore {
	struct list_head list;
	long long unsigned int paddr;
	long long unsigned int size;
	loff_t offset;
};

typedef struct elf64_note Elf64_Nhdr;

struct kernfs_iattrs {
	kuid_t ia_uid;
	kgid_t ia_gid;
	struct timespec64 ia_atime;
	struct timespec64 ia_mtime;
	struct timespec64 ia_ctime;
	struct simple_xattrs xattrs;
	atomic_t nr_user_xattrs;
	atomic_t user_xattr_size;
};

struct kernfs_super_info {
	struct super_block *sb;
	struct kernfs_root *root;
	const void *ns;
	struct list_head node;
};

enum kernfs_node_flag {
	KERNFS_ACTIVATED = 16,
	KERNFS_NS = 32,
	KERNFS_HAS_SEQ_SHOW = 64,
	KERNFS_HAS_MMAP = 128,
	KERNFS_LOCKDEP = 256,
	KERNFS_SUICIDAL = 1024,
	KERNFS_SUICIDED = 2048,
	KERNFS_EMPTY_DIR = 4096,
	KERNFS_HAS_RELEASE = 8192,
};

struct kernfs_open_node {
	atomic_t refcnt;
	atomic_t event;
	wait_queue_head_t poll;
	struct list_head files;
};

struct config_group;

struct config_item_type;

struct config_item {
	char *ci_name;
	char ci_namebuf[20];
	struct kref ci_kref;
	struct list_head ci_entry;
	struct config_item *ci_parent;
	struct config_group *ci_group;
	const struct config_item_type *ci_type;
	struct dentry *ci_dentry;
};

struct configfs_subsystem;

struct config_group {
	struct config_item cg_item;
	struct list_head cg_children;
	struct configfs_subsystem *cg_subsys;
	struct list_head default_groups;
	struct list_head group_entry;
};

struct configfs_item_operations;

struct configfs_group_operations;

struct configfs_attribute;

struct configfs_bin_attribute;

struct config_item_type {
	struct module *ct_owner;
	struct configfs_item_operations *ct_item_ops;
	struct configfs_group_operations *ct_group_ops;
	struct configfs_attribute **ct_attrs;
	struct configfs_bin_attribute **ct_bin_attrs;
};

struct configfs_item_operations {
	void (*release)(struct config_item *);
	int (*allow_link)(struct config_item *, struct config_item *);
	void (*drop_link)(struct config_item *, struct config_item *);
};

struct configfs_group_operations {
	struct config_item * (*make_item)(struct config_group *, const char *);
	struct config_group * (*make_group)(struct config_group *, const char *);
	int (*commit_item)(struct config_item *);
	void (*disconnect_notify)(struct config_group *, struct config_item *);
	void (*drop_item)(struct config_group *, struct config_item *);
};

struct configfs_attribute {
	const char *ca_name;
	struct module *ca_owner;
	umode_t ca_mode;
	ssize_t (*show)(struct config_item *, char *);
	ssize_t (*store)(struct config_item *, const char *, size_t);
};

struct configfs_bin_attribute {
	struct configfs_attribute cb_attr;
	void *cb_private;
	size_t cb_max_size;
	ssize_t (*read)(struct config_item *, void *, size_t);
	ssize_t (*write)(struct config_item *, const void *, size_t);
};

struct configfs_subsystem {
	struct config_group su_group;
	struct mutex su_mutex;
};

struct configfs_fragment {
	atomic_t frag_count;
	struct rw_semaphore frag_sem;
	bool frag_dead;
};

struct configfs_dirent {
	atomic_t s_count;
	int s_dependent_count;
	struct list_head s_sibling;
	struct list_head s_children;
	int s_links;
	void *s_element;
	int s_type;
	umode_t s_mode;
	struct dentry *s_dentry;
	struct iattr *s_iattr;
	struct configfs_fragment *s_frag;
};

struct configfs_buffer {
	size_t count;
	loff_t pos;
	char *page;
	struct configfs_item_operations *ops;
	struct mutex mutex;
	int needs_read_fill;
	bool read_in_progress;
	bool write_in_progress;
	char *bin_buffer;
	int bin_buffer_size;
	int cb_max_size;
	struct config_item *item;
	struct module *owner;
	union {
		struct configfs_attribute *attr;
		struct configfs_bin_attribute *bin_attr;
	};
};

struct pts_mount_opts {
	int setuid;
	int setgid;
	kuid_t uid;
	kgid_t gid;
	umode_t mode;
	umode_t ptmxmode;
	int reserve;
	int max;
};

enum {
	Opt_uid___2 = 0,
	Opt_gid___3 = 1,
	Opt_mode___2 = 2,
	Opt_ptmxmode = 3,
	Opt_newinstance = 4,
	Opt_max = 5,
	Opt_err = 6,
};

struct pts_fs_info {
	struct ida allocated_ptys;
	struct pts_mount_opts mount_opts;
	struct super_block *sb;
	struct dentry *ptmx_dentry;
};

typedef unsigned int tid_t;

struct transaction_chp_stats_s {
	long unsigned int cs_chp_time;
	__u32 cs_forced_to_close;
	__u32 cs_written;
	__u32 cs_dropped;
};

struct journal_s;

typedef struct journal_s journal_t;

struct journal_head;

struct transaction_s;

typedef struct transaction_s transaction_t;

struct transaction_s {
	journal_t *t_journal;
	tid_t t_tid;
	enum {
		T_RUNNING = 0,
		T_LOCKED = 1,
		T_SWITCH = 2,
		T_FLUSH = 3,
		T_COMMIT = 4,
		T_COMMIT_DFLUSH = 5,
		T_COMMIT_JFLUSH = 6,
		T_COMMIT_CALLBACK = 7,
		T_FINISHED = 8,
	} t_state;
	long unsigned int t_log_start;
	int t_nr_buffers;
	struct journal_head *t_reserved_list;
	struct journal_head *t_buffers;
	struct journal_head *t_forget;
	struct journal_head *t_checkpoint_list;
	struct journal_head *t_checkpoint_io_list;
	struct journal_head *t_shadow_list;
	struct list_head t_inode_list;
	spinlock_t t_handle_lock;
	long unsigned int t_max_wait;
	long unsigned int t_start;
	long unsigned int t_requested;
	struct transaction_chp_stats_s t_chp_stats;
	atomic_t t_updates;
	atomic_t t_outstanding_credits;
	atomic_t t_outstanding_revokes;
	atomic_t t_handle_count;
	transaction_t *t_cpnext;
	transaction_t *t_cpprev;
	long unsigned int t_expires;
	ktime_t t_start_time;
	unsigned int t_synchronous_commit: 1;
	int t_need_data_flush;
	struct list_head t_private_list;
};

struct jbd2_buffer_trigger_type;

struct journal_head {
	struct buffer_head *b_bh;
	spinlock_t b_state_lock;
	int b_jcount;
	unsigned int b_jlist;
	unsigned int b_modified;
	char *b_frozen_data;
	char *b_committed_data;
	transaction_t *b_transaction;
	transaction_t *b_next_transaction;
	struct journal_head *b_tnext;
	struct journal_head *b_tprev;
	transaction_t *b_cp_transaction;
	struct journal_head *b_cpnext;
	struct journal_head *b_cpprev;
	struct jbd2_buffer_trigger_type *b_triggers;
	struct jbd2_buffer_trigger_type *b_frozen_triggers;
};

struct jbd2_buffer_trigger_type {
	void (*t_frozen)(struct jbd2_buffer_trigger_type *, struct buffer_head *, void *, size_t);
	void (*t_abort)(struct jbd2_buffer_trigger_type *, struct buffer_head *);
};

struct crypto_alg;

struct crypto_tfm {
	u32 crt_flags;
	int node;
	void (*exit)(struct crypto_tfm *);
	struct crypto_alg *__crt_alg;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	void *__crt_ctx[0];
};

struct cipher_alg {
	unsigned int cia_min_keysize;
	unsigned int cia_max_keysize;
	int (*cia_setkey)(struct crypto_tfm *, const u8 *, unsigned int);
	void (*cia_encrypt)(struct crypto_tfm *, u8 *, const u8 *);
	void (*cia_decrypt)(struct crypto_tfm *, u8 *, const u8 *);
};

struct compress_alg {
	int (*coa_compress)(struct crypto_tfm *, const u8 *, unsigned int, u8 *, unsigned int *);
	int (*coa_decompress)(struct crypto_tfm *, const u8 *, unsigned int, u8 *, unsigned int *);
};

struct crypto_type;

struct crypto_alg {
	struct list_head cra_list;
	struct list_head cra_users;
	u32 cra_flags;
	unsigned int cra_blocksize;
	unsigned int cra_ctxsize;
	unsigned int cra_alignmask;
	int cra_priority;
	refcount_t cra_refcnt;
	char cra_name[128];
	char cra_driver_name[128];
	const struct crypto_type *cra_type;
	union {
		struct cipher_alg cipher;
		struct compress_alg compress;
	} cra_u;
	int (*cra_init)(struct crypto_tfm *);
	void (*cra_exit)(struct crypto_tfm *);
	void (*cra_destroy)(struct crypto_alg *);
	struct module *cra_module;
};

struct crypto_instance;

struct crypto_type {
	unsigned int (*ctxsize)(struct crypto_alg *, u32, u32);
	unsigned int (*extsize)(struct crypto_alg *);
	int (*init)(struct crypto_tfm *, u32, u32);
	int (*init_tfm)(struct crypto_tfm *);
	void (*show)(struct seq_file *, struct crypto_alg *);
	int (*report)(struct sk_buff *, struct crypto_alg *);
	void (*free)(struct crypto_instance *);
	unsigned int type;
	unsigned int maskclear;
	unsigned int maskset;
	unsigned int tfmsize;
};

struct crypto_shash {
	unsigned int descsize;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct crypto_tfm base;
};

struct jbd2_journal_handle;

typedef struct jbd2_journal_handle handle_t;

struct jbd2_journal_handle {
	union {
		transaction_t *h_transaction;
		journal_t *h_journal;
	};
	handle_t *h_rsv_handle;
	int h_total_credits;
	int h_revoke_credits;
	int h_revoke_credits_requested;
	int h_ref;
	int h_err;
	unsigned int h_sync: 1;
	unsigned int h_jdata: 1;
	unsigned int h_reserved: 1;
	unsigned int h_aborted: 1;
	unsigned int h_type: 8;
	unsigned int h_line_no: 16;
	long unsigned int h_start_jiffies;
	unsigned int h_requested_credits;
	unsigned int saved_alloc_context;
};

struct transaction_run_stats_s {
	long unsigned int rs_wait;
	long unsigned int rs_request_delay;
	long unsigned int rs_running;
	long unsigned int rs_locked;
	long unsigned int rs_flushing;
	long unsigned int rs_logging;
	__u32 rs_handle_count;
	__u32 rs_blocks;
	__u32 rs_blocks_logged;
};

struct transaction_stats_s {
	long unsigned int ts_tid;
	long unsigned int ts_requested;
	struct transaction_run_stats_s run;
};

enum passtype {
	PASS_SCAN = 0,
	PASS_REVOKE = 1,
	PASS_REPLAY = 2,
};

struct journal_superblock_s;

typedef struct journal_superblock_s journal_superblock_t;

struct jbd2_revoke_table_s;

struct jbd2_inode;

struct journal_s {
	long unsigned int j_flags;
	int j_errno;
	struct mutex j_abort_mutex;
	struct buffer_head *j_sb_buffer;
	journal_superblock_t *j_superblock;
	int j_format_version;
	rwlock_t j_state_lock;
	int j_barrier_count;
	struct mutex j_barrier;
	transaction_t *j_running_transaction;
	transaction_t *j_committing_transaction;
	transaction_t *j_checkpoint_transactions;
	wait_queue_head_t j_wait_transaction_locked;
	wait_queue_head_t j_wait_done_commit;
	wait_queue_head_t j_wait_commit;
	wait_queue_head_t j_wait_updates;
	wait_queue_head_t j_wait_reserved;
	wait_queue_head_t j_fc_wait;
	struct mutex j_checkpoint_mutex;
	struct buffer_head *j_chkpt_bhs[64];
	long unsigned int j_head;
	long unsigned int j_tail;
	long unsigned int j_free;
	long unsigned int j_first;
	long unsigned int j_last;
	long unsigned int j_fc_first;
	long unsigned int j_fc_off;
	long unsigned int j_fc_last;
	struct block_device *j_dev;
	int j_blocksize;
	long long unsigned int j_blk_offset;
	char j_devname[56];
	struct block_device *j_fs_dev;
	unsigned int j_total_len;
	atomic_t j_reserved_credits;
	spinlock_t j_list_lock;
	struct inode *j_inode;
	tid_t j_tail_sequence;
	tid_t j_transaction_sequence;
	tid_t j_commit_sequence;
	tid_t j_commit_request;
	__u8 j_uuid[16];
	struct task_struct *j_task;
	int j_max_transaction_buffers;
	int j_revoke_records_per_block;
	long unsigned int j_commit_interval;
	struct timer_list j_commit_timer;
	spinlock_t j_revoke_lock;
	struct jbd2_revoke_table_s *j_revoke;
	struct jbd2_revoke_table_s *j_revoke_table[2];
	struct buffer_head **j_wbuf;
	struct buffer_head **j_fc_wbuf;
	int j_wbufsize;
	int j_fc_wbufsize;
	pid_t j_last_sync_writer;
	u64 j_average_commit_time;
	u32 j_min_batch_time;
	u32 j_max_batch_time;
	void (*j_commit_callback)(journal_t *, transaction_t *);
	int (*j_submit_inode_data_buffers)(struct jbd2_inode *);
	int (*j_finish_inode_data_buffers)(struct jbd2_inode *);
	spinlock_t j_history_lock;
	struct proc_dir_entry *j_proc_entry;
	struct transaction_stats_s j_stats;
	unsigned int j_failed_commit;
	void *j_private;
	struct crypto_shash *j_chksum_driver;
	__u32 j_csum_seed;
	void (*j_fc_cleanup_callback)(struct journal_s *, int);
	int (*j_fc_replay_callback)(struct journal_s *, struct buffer_head *, enum passtype, int, tid_t);
};

struct journal_header_s {
	__be32 h_magic;
	__be32 h_blocktype;
	__be32 h_sequence;
};

typedef struct journal_header_s journal_header_t;

struct journal_superblock_s {
	journal_header_t s_header;
	__be32 s_blocksize;
	__be32 s_maxlen;
	__be32 s_first;
	__be32 s_sequence;
	__be32 s_start;
	__be32 s_errno;
	__be32 s_feature_compat;
	__be32 s_feature_incompat;
	__be32 s_feature_ro_compat;
	__u8 s_uuid[16];
	__be32 s_nr_users;
	__be32 s_dynsuper;
	__be32 s_max_transaction;
	__be32 s_max_trans_data;
	__u8 s_checksum_type;
	__u8 s_padding2[3];
	__be32 s_num_fc_blks;
	__u32 s_padding[41];
	__be32 s_checksum;
	__u8 s_users[768];
};

enum jbd_state_bits {
	BH_JBD = 16,
	BH_JWrite = 17,
	BH_Freed = 18,
	BH_Revoked = 19,
	BH_RevokeValid = 20,
	BH_JBDDirty = 21,
	BH_JournalHead = 22,
	BH_Shadow = 23,
	BH_Verified = 24,
	BH_JBDPrivateStart = 25,
};

struct jbd2_inode {
	transaction_t *i_transaction;
	transaction_t *i_next_transaction;
	struct list_head i_list;
	struct inode *i_vfs_inode;
	long unsigned int i_flags;
	loff_t i_dirty_start;
	loff_t i_dirty_end;
};

struct bgl_lock {
	spinlock_t lock;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct blockgroup_lock {
	struct bgl_lock locks[32];
};

struct fscrypt_dummy_policy {};

typedef int ext4_grpblk_t;

typedef long long unsigned int ext4_fsblk_t;

typedef __u32 ext4_lblk_t;

typedef unsigned int ext4_group_t;

struct ext4_allocation_request {
	struct inode *inode;
	unsigned int len;
	ext4_lblk_t logical;
	ext4_lblk_t lleft;
	ext4_lblk_t lright;
	ext4_fsblk_t goal;
	ext4_fsblk_t pleft;
	ext4_fsblk_t pright;
	unsigned int flags;
};

struct ext4_system_blocks {
	struct rb_root root;
	struct callback_head rcu;
};

struct ext4_group_desc {
	__le32 bg_block_bitmap_lo;
	__le32 bg_inode_bitmap_lo;
	__le32 bg_inode_table_lo;
	__le16 bg_free_blocks_count_lo;
	__le16 bg_free_inodes_count_lo;
	__le16 bg_used_dirs_count_lo;
	__le16 bg_flags;
	__le32 bg_exclude_bitmap_lo;
	__le16 bg_block_bitmap_csum_lo;
	__le16 bg_inode_bitmap_csum_lo;
	__le16 bg_itable_unused_lo;
	__le16 bg_checksum;
	__le32 bg_block_bitmap_hi;
	__le32 bg_inode_bitmap_hi;
	__le32 bg_inode_table_hi;
	__le16 bg_free_blocks_count_hi;
	__le16 bg_free_inodes_count_hi;
	__le16 bg_used_dirs_count_hi;
	__le16 bg_itable_unused_hi;
	__le32 bg_exclude_bitmap_hi;
	__le16 bg_block_bitmap_csum_hi;
	__le16 bg_inode_bitmap_csum_hi;
	__u32 bg_reserved;
};

struct flex_groups {
	atomic64_t free_clusters;
	atomic_t free_inodes;
	atomic_t used_dirs;
};

struct extent_status {
	struct rb_node rb_node;
	ext4_lblk_t es_lblk;
	ext4_lblk_t es_len;
	ext4_fsblk_t es_pblk;
};

struct ext4_es_tree {
	struct rb_root root;
	struct extent_status *cache_es;
};

struct ext4_es_stats {
	long unsigned int es_stats_shrunk;
	struct percpu_counter es_stats_cache_hits;
	struct percpu_counter es_stats_cache_misses;
	u64 es_stats_scan_time;
	u64 es_stats_max_scan_time;
	struct percpu_counter es_stats_all_cnt;
	struct percpu_counter es_stats_shk_cnt;
};

struct ext4_pending_tree {
	struct rb_root root;
};

struct ext4_fc_stats {
	unsigned int fc_ineligible_reason_count[10];
	long unsigned int fc_num_commits;
	long unsigned int fc_ineligible_commits;
	long unsigned int fc_numblks;
};

struct ext4_fc_alloc_region {
	ext4_lblk_t lblk;
	ext4_fsblk_t pblk;
	int ino;
	int len;
};

struct ext4_fc_replay_state {
	int fc_replay_num_tags;
	int fc_replay_expected_off;
	int fc_current_pass;
	int fc_cur_tag;
	int fc_crc;
	struct ext4_fc_alloc_region *fc_regions;
	int fc_regions_size;
	int fc_regions_used;
	int fc_regions_valid;
	int *fc_modified_inodes;
	int fc_modified_inodes_used;
	int fc_modified_inodes_size;
};

struct ext4_inode_info {
	__le32 i_data[15];
	__u32 i_dtime;
	ext4_fsblk_t i_file_acl;
	ext4_group_t i_block_group;
	ext4_lblk_t i_dir_start_lookup;
	long unsigned int i_flags;
	struct rw_semaphore xattr_sem;
	struct list_head i_orphan;
	struct list_head i_fc_list;
	ext4_lblk_t i_fc_lblk_start;
	ext4_lblk_t i_fc_lblk_len;
	atomic_t i_fc_updates;
	wait_queue_head_t i_fc_wait;
	struct mutex i_fc_lock;
	loff_t i_disksize;
	struct rw_semaphore i_data_sem;
	struct rw_semaphore i_mmap_sem;
	struct inode vfs_inode;
	struct jbd2_inode *jinode;
	spinlock_t i_raw_lock;
	struct timespec64 i_crtime;
	atomic_t i_prealloc_active;
	struct list_head i_prealloc_list;
	spinlock_t i_prealloc_lock;
	struct ext4_es_tree i_es_tree;
	rwlock_t i_es_lock;
	struct list_head i_es_list;
	unsigned int i_es_all_nr;
	unsigned int i_es_shk_nr;
	ext4_lblk_t i_es_shrink_lblk;
	ext4_group_t i_last_alloc_group;
	unsigned int i_reserved_data_blocks;
	struct ext4_pending_tree i_pending_tree;
	__u16 i_extra_isize;
	u16 i_inline_off;
	u16 i_inline_size;
	spinlock_t i_completed_io_lock;
	struct list_head i_rsv_conversion_list;
	struct work_struct i_rsv_conversion_work;
	atomic_t i_unwritten;
	spinlock_t i_block_reservation_lock;
	tid_t i_sync_tid;
	tid_t i_datasync_tid;
	__u32 i_csum_seed;
	kprojid_t i_projid;
};

struct ext4_super_block {
	__le32 s_inodes_count;
	__le32 s_blocks_count_lo;
	__le32 s_r_blocks_count_lo;
	__le32 s_free_blocks_count_lo;
	__le32 s_free_inodes_count;
	__le32 s_first_data_block;
	__le32 s_log_block_size;
	__le32 s_log_cluster_size;
	__le32 s_blocks_per_group;
	__le32 s_clusters_per_group;
	__le32 s_inodes_per_group;
	__le32 s_mtime;
	__le32 s_wtime;
	__le16 s_mnt_count;
	__le16 s_max_mnt_count;
	__le16 s_magic;
	__le16 s_state;
	__le16 s_errors;
	__le16 s_minor_rev_level;
	__le32 s_lastcheck;
	__le32 s_checkinterval;
	__le32 s_creator_os;
	__le32 s_rev_level;
	__le16 s_def_resuid;
	__le16 s_def_resgid;
	__le32 s_first_ino;
	__le16 s_inode_size;
	__le16 s_block_group_nr;
	__le32 s_feature_compat;
	__le32 s_feature_incompat;
	__le32 s_feature_ro_compat;
	__u8 s_uuid[16];
	char s_volume_name[16];
	char s_last_mounted[64];
	__le32 s_algorithm_usage_bitmap;
	__u8 s_prealloc_blocks;
	__u8 s_prealloc_dir_blocks;
	__le16 s_reserved_gdt_blocks;
	__u8 s_journal_uuid[16];
	__le32 s_journal_inum;
	__le32 s_journal_dev;
	__le32 s_last_orphan;
	__le32 s_hash_seed[4];
	__u8 s_def_hash_version;
	__u8 s_jnl_backup_type;
	__le16 s_desc_size;
	__le32 s_default_mount_opts;
	__le32 s_first_meta_bg;
	__le32 s_mkfs_time;
	__le32 s_jnl_blocks[17];
	__le32 s_blocks_count_hi;
	__le32 s_r_blocks_count_hi;
	__le32 s_free_blocks_count_hi;
	__le16 s_min_extra_isize;
	__le16 s_want_extra_isize;
	__le32 s_flags;
	__le16 s_raid_stride;
	__le16 s_mmp_update_interval;
	__le64 s_mmp_block;
	__le32 s_raid_stripe_width;
	__u8 s_log_groups_per_flex;
	__u8 s_checksum_type;
	__u8 s_encryption_level;
	__u8 s_reserved_pad;
	__le64 s_kbytes_written;
	__le32 s_snapshot_inum;
	__le32 s_snapshot_id;
	__le64 s_snapshot_r_blocks_count;
	__le32 s_snapshot_list;
	__le32 s_error_count;
	__le32 s_first_error_time;
	__le32 s_first_error_ino;
	__le64 s_first_error_block;
	__u8 s_first_error_func[32];
	__le32 s_first_error_line;
	__le32 s_last_error_time;
	__le32 s_last_error_ino;
	__le32 s_last_error_line;
	__le64 s_last_error_block;
	__u8 s_last_error_func[32];
	__u8 s_mount_opts[64];
	__le32 s_usr_quota_inum;
	__le32 s_grp_quota_inum;
	__le32 s_overhead_clusters;
	__le32 s_backup_bgs[2];
	__u8 s_encrypt_algos[4];
	__u8 s_encrypt_pw_salt[16];
	__le32 s_lpf_ino;
	__le32 s_prj_quota_inum;
	__le32 s_checksum_seed;
	__u8 s_wtime_hi;
	__u8 s_mtime_hi;
	__u8 s_mkfs_time_hi;
	__u8 s_lastcheck_hi;
	__u8 s_first_error_time_hi;
	__u8 s_last_error_time_hi;
	__u8 s_first_error_errcode;
	__u8 s_last_error_errcode;
	__le16 s_encoding;
	__le16 s_encoding_flags;
	__le32 s_reserved[95];
	__le32 s_checksum;
};

struct mb_cache;

struct ext4_group_info;

struct ext4_locality_group;

struct ext4_li_request;

struct ext4_sb_info {
	long unsigned int s_desc_size;
	long unsigned int s_inodes_per_block;
	long unsigned int s_blocks_per_group;
	long unsigned int s_clusters_per_group;
	long unsigned int s_inodes_per_group;
	long unsigned int s_itb_per_group;
	long unsigned int s_gdb_count;
	long unsigned int s_desc_per_block;
	ext4_group_t s_groups_count;
	ext4_group_t s_blockfile_groups;
	long unsigned int s_overhead;
	unsigned int s_cluster_ratio;
	unsigned int s_cluster_bits;
	loff_t s_bitmap_maxbytes;
	struct buffer_head *s_sbh;
	struct ext4_super_block *s_es;
	struct buffer_head **s_group_desc;
	unsigned int s_mount_opt;
	unsigned int s_mount_opt2;
	long unsigned int s_mount_flags;
	unsigned int s_def_mount_opt;
	ext4_fsblk_t s_sb_block;
	atomic64_t s_resv_clusters;
	kuid_t s_resuid;
	kgid_t s_resgid;
	short unsigned int s_mount_state;
	short unsigned int s_pad;
	int s_addr_per_block_bits;
	int s_desc_per_block_bits;
	int s_inode_size;
	int s_first_ino;
	unsigned int s_inode_readahead_blks;
	unsigned int s_inode_goal;
	u32 s_hash_seed[4];
	int s_def_hash_version;
	int s_hash_unsigned;
	struct percpu_counter s_freeclusters_counter;
	struct percpu_counter s_freeinodes_counter;
	struct percpu_counter s_dirs_counter;
	struct percpu_counter s_dirtyclusters_counter;
	struct percpu_counter s_sra_exceeded_retry_limit;
	struct blockgroup_lock *s_blockgroup_lock;
	struct proc_dir_entry *s_proc;
	struct kobject s_kobj;
	struct completion s_kobj_unregister;
	struct super_block *s_sb;
	struct buffer_head *s_mmp_bh;
	struct journal_s *s_journal;
	struct list_head s_orphan;
	struct mutex s_orphan_lock;
	long unsigned int s_ext4_flags;
	long unsigned int s_commit_interval;
	u32 s_max_batch_time;
	u32 s_min_batch_time;
	struct block_device *s_journal_bdev;
	unsigned int s_want_extra_isize;
	struct ext4_system_blocks *s_system_blks;
	struct ext4_group_info ***s_group_info;
	struct inode *s_buddy_cache;
	spinlock_t s_md_lock;
	short unsigned int *s_mb_offsets;
	unsigned int *s_mb_maxs;
	unsigned int s_group_info_size;
	unsigned int s_mb_free_pending;
	struct list_head s_freed_data_list;
	long unsigned int s_stripe;
	unsigned int s_mb_stream_request;
	unsigned int s_mb_max_to_scan;
	unsigned int s_mb_min_to_scan;
	unsigned int s_mb_stats;
	unsigned int s_mb_order2_reqs;
	unsigned int s_mb_group_prealloc;
	unsigned int s_mb_max_inode_prealloc;
	unsigned int s_max_dir_size_kb;
	long unsigned int s_mb_last_group;
	long unsigned int s_mb_last_start;
	unsigned int s_mb_prefetch;
	unsigned int s_mb_prefetch_limit;
	atomic_t s_bal_reqs;
	atomic_t s_bal_success;
	atomic_t s_bal_allocated;
	atomic_t s_bal_ex_scanned;
	atomic_t s_bal_goals;
	atomic_t s_bal_breaks;
	atomic_t s_bal_2orders;
	spinlock_t s_bal_lock;
	long unsigned int s_mb_buddies_generated;
	long long unsigned int s_mb_generation_time;
	atomic_t s_mb_lost_chunks;
	atomic_t s_mb_preallocated;
	atomic_t s_mb_discarded;
	atomic_t s_lock_busy;
	struct ext4_locality_group *s_locality_groups;
	long unsigned int s_sectors_written_start;
	u64 s_kbytes_written;
	unsigned int s_extent_max_zeroout_kb;
	unsigned int s_log_groups_per_flex;
	struct flex_groups **s_flex_groups;
	ext4_group_t s_flex_groups_allocated;
	struct workqueue_struct *rsv_conversion_wq;
	struct timer_list s_err_report;
	struct ext4_li_request *s_li_request;
	unsigned int s_li_wait_mult;
	struct task_struct *s_mmp_tsk;
	atomic_t s_last_trim_minblks;
	struct crypto_shash *s_chksum_driver;
	__u32 s_csum_seed;
	struct shrinker s_es_shrinker;
	struct list_head s_es_list;
	long int s_es_nr_inode;
	struct ext4_es_stats s_es_stats;
	struct mb_cache *s_ea_block_cache;
	struct mb_cache *s_ea_inode_cache;
	long: 64;
	spinlock_t s_es_lock;
	struct ratelimit_state s_err_ratelimit_state;
	struct ratelimit_state s_warning_ratelimit_state;
	struct ratelimit_state s_msg_ratelimit_state;
	atomic_t s_warning_count;
	atomic_t s_msg_count;
	struct fscrypt_dummy_policy s_dummy_enc_policy;
	struct percpu_rw_semaphore s_writepages_rwsem;
	struct dax_device *s_daxdev;
	errseq_t s_bdev_wb_err;
	spinlock_t s_bdev_wb_lock;
	atomic_t s_fc_subtid;
	atomic_t s_fc_ineligible_updates;
	struct list_head s_fc_q[2];
	struct list_head s_fc_dentry_q[2];
	unsigned int s_fc_bytes;
	spinlock_t s_fc_lock;
	struct buffer_head *s_fc_bh;
	struct ext4_fc_stats s_fc_stats;
	u64 s_fc_avg_commit_time;
	struct ext4_fc_replay_state s_fc_replay_state;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct ext4_group_info {
	long unsigned int bb_state;
	struct rb_root bb_free_root;
	ext4_grpblk_t bb_first_free;
	ext4_grpblk_t bb_free;
	ext4_grpblk_t bb_fragments;
	ext4_grpblk_t bb_largest_free_order;
	struct list_head bb_prealloc_list;
	struct rw_semaphore alloc_sem;
	ext4_grpblk_t bb_counters[0];
};

struct ext4_locality_group {
	struct mutex lg_mutex;
	struct list_head lg_prealloc_list[10];
	spinlock_t lg_prealloc_lock;
};

enum ext4_li_mode {
	EXT4_LI_MODE_PREFETCH_BBITMAP = 0,
	EXT4_LI_MODE_ITABLE = 1,
};

struct ext4_li_request {
	struct super_block *lr_super;
	enum ext4_li_mode lr_mode;
	ext4_group_t lr_first_not_zeroed;
	ext4_group_t lr_next_group;
	struct list_head lr_request;
	long unsigned int lr_next_sched;
	long unsigned int lr_timeout;
};

struct shash_desc {
	struct crypto_shash *tfm;
	void *__ctx[0];
};

struct ext4_map_blocks {
	ext4_fsblk_t m_pblk;
	ext4_lblk_t m_lblk;
	unsigned int m_len;
	unsigned int m_flags;
};

struct ext4_system_zone {
	struct rb_node node;
	ext4_fsblk_t start_blk;
	unsigned int count;
	u32 ino;
};

struct fscrypt_str {
	unsigned char *name;
	u32 len;
};

enum {
	EXT4_INODE_SECRM = 0,
	EXT4_INODE_UNRM = 1,
	EXT4_INODE_COMPR = 2,
	EXT4_INODE_SYNC = 3,
	EXT4_INODE_IMMUTABLE = 4,
	EXT4_INODE_APPEND = 5,
	EXT4_INODE_NODUMP = 6,
	EXT4_INODE_NOATIME = 7,
	EXT4_INODE_DIRTY = 8,
	EXT4_INODE_COMPRBLK = 9,
	EXT4_INODE_NOCOMPR = 10,
	EXT4_INODE_ENCRYPT = 11,
	EXT4_INODE_INDEX = 12,
	EXT4_INODE_IMAGIC = 13,
	EXT4_INODE_JOURNAL_DATA = 14,
	EXT4_INODE_NOTAIL = 15,
	EXT4_INODE_DIRSYNC = 16,
	EXT4_INODE_TOPDIR = 17,
	EXT4_INODE_HUGE_FILE = 18,
	EXT4_INODE_EXTENTS = 19,
	EXT4_INODE_VERITY = 20,
	EXT4_INODE_EA_INODE = 21,
	EXT4_INODE_DAX = 25,
	EXT4_INODE_INLINE_DATA = 28,
	EXT4_INODE_PROJINHERIT = 29,
	EXT4_INODE_CASEFOLD = 30,
	EXT4_INODE_RESERVED = 31,
};

enum {
	EXT4_FC_REASON_OK = 0,
	EXT4_FC_REASON_INELIGIBLE = 1,
	EXT4_FC_REASON_ALREADY_COMMITTED = 2,
	EXT4_FC_REASON_FC_START_FAILED = 3,
	EXT4_FC_REASON_FC_FAILED = 4,
	EXT4_FC_REASON_XATTR = 0,
	EXT4_FC_REASON_CROSS_RENAME = 1,
	EXT4_FC_REASON_JOURNAL_FLAG_CHANGE = 2,
	EXT4_FC_REASON_NOMEM = 3,
	EXT4_FC_REASON_SWAP_BOOT = 4,
	EXT4_FC_REASON_RESIZE = 5,
	EXT4_FC_REASON_RENAME_DIR = 6,
	EXT4_FC_REASON_FALLOC_RANGE = 7,
	EXT4_FC_REASON_INODE_JOURNAL_DATA = 8,
	EXT4_FC_COMMIT_FAILED = 9,
	EXT4_FC_REASON_MAX = 10,
};

struct ext4_dir_entry_hash {
	__le32 hash;
	__le32 minor_hash;
};

struct ext4_dir_entry_2 {
	__le32 inode;
	__le16 rec_len;
	__u8 name_len;
	__u8 file_type;
	char name[255];
};

struct fname;

struct dir_private_info {
	struct rb_root root;
	struct rb_node *curr_node;
	struct fname *extra_fname;
	loff_t last_pos;
	__u32 curr_hash;
	__u32 curr_minor_hash;
	__u32 next_hash;
};

struct fname {
	__u32 hash;
	__u32 minor_hash;
	struct rb_node rb_hash;
	struct fname *next;
	__u32 inode;
	__u8 name_len;
	__u8 file_type;
	char name[0];
};

enum SHIFT_DIRECTION {
	SHIFT_LEFT = 0,
	SHIFT_RIGHT = 1,
};

struct ext4_io_end_vec {
	struct list_head list;
	loff_t offset;
	ssize_t size;
};

struct ext4_io_end {
	struct list_head list;
	handle_t *handle;
	struct inode *inode;
	struct bio *bio;
	unsigned int flag;
	atomic_t count;
	struct list_head list_vec;
};

typedef struct ext4_io_end ext4_io_end_t;

enum {
	ES_WRITTEN_B = 0,
	ES_UNWRITTEN_B = 1,
	ES_DELAYED_B = 2,
	ES_HOLE_B = 3,
	ES_REFERENCED_B = 4,
	ES_FLAGS = 5,
};

enum {
	EXT4_STATE_JDATA = 0,
	EXT4_STATE_NEW = 1,
	EXT4_STATE_XATTR = 2,
	EXT4_STATE_NO_EXPAND = 3,
	EXT4_STATE_DA_ALLOC_CLOSE = 4,
	EXT4_STATE_EXT_MIGRATE = 5,
	EXT4_STATE_NEWENTRY = 6,
	EXT4_STATE_MAY_INLINE_DATA = 7,
	EXT4_STATE_EXT_PRECACHED = 8,
	EXT4_STATE_LUSTRE_EA_INODE = 9,
	EXT4_STATE_VERITY_IN_PROGRESS = 10,
	EXT4_STATE_FC_COMMITTING = 11,
};

struct ext4_iloc {
	struct buffer_head *bh;
	long unsigned int offset;
	ext4_group_t block_group;
};

struct ext4_extent_tail {
	__le32 et_checksum;
};

struct ext4_extent {
	__le32 ee_block;
	__le16 ee_len;
	__le16 ee_start_hi;
	__le32 ee_start_lo;
};

struct ext4_extent_idx {
	__le32 ei_block;
	__le32 ei_leaf_lo;
	__le16 ei_leaf_hi;
	__u16 ei_unused;
};

struct ext4_extent_header {
	__le16 eh_magic;
	__le16 eh_entries;
	__le16 eh_max;
	__le16 eh_depth;
	__le32 eh_generation;
};

struct ext4_ext_path {
	ext4_fsblk_t p_block;
	__u16 p_depth;
	__u16 p_maxdepth;
	struct ext4_extent *p_ext;
	struct ext4_extent_idx *p_idx;
	struct ext4_extent_header *p_hdr;
	struct buffer_head *p_bh;
};

struct partial_cluster {
	ext4_fsblk_t pclu;
	ext4_lblk_t lblk;
	enum {
		initial = 0,
		tofree = 1,
		nofree = 2,
	} state;
};

struct pending_reservation {
	struct rb_node rb_node;
	ext4_lblk_t lclu;
};

struct rsvd_count {
	int ndelonly;
	bool first_do_lblk_found;
	ext4_lblk_t first_do_lblk;
	ext4_lblk_t last_do_lblk;
	struct extent_status *left_es;
	bool partial;
	ext4_lblk_t lclu;
};

enum {
	EXT4_MF_MNTDIR_SAMPLED = 0,
	EXT4_MF_FS_ABORTED = 1,
	EXT4_MF_FC_INELIGIBLE = 2,
	EXT4_MF_FC_COMMITTING = 3,
};

struct fsverity_info;

struct fsmap {
	__u32 fmr_device;
	__u32 fmr_flags;
	__u64 fmr_physical;
	__u64 fmr_owner;
	__u64 fmr_offset;
	__u64 fmr_length;
	__u64 fmr_reserved[3];
};

struct ext4_fsmap {
	struct list_head fmr_list;
	dev_t fmr_device;
	uint32_t fmr_flags;
	uint64_t fmr_physical;
	uint64_t fmr_owner;
	uint64_t fmr_length;
};

struct ext4_fsmap_head {
	uint32_t fmh_iflags;
	uint32_t fmh_oflags;
	unsigned int fmh_count;
	unsigned int fmh_entries;
	struct ext4_fsmap fmh_keys[2];
};

typedef int (*ext4_fsmap_format_t)(struct ext4_fsmap *, void *);

struct ext4_getfsmap_info {
	struct ext4_fsmap_head *gfi_head;
	ext4_fsmap_format_t gfi_formatter;
	void *gfi_format_arg;
	ext4_fsblk_t gfi_next_fsblk;
	u32 gfi_dev;
	ext4_group_t gfi_agno;
	struct ext4_fsmap gfi_low;
	struct ext4_fsmap gfi_high;
	struct ext4_fsmap gfi_lastfree;
	struct list_head gfi_meta_list;
	bool gfi_last;
};

struct ext4_getfsmap_dev {
	int (*gfd_fn)(struct super_block *, struct ext4_fsmap *, struct ext4_getfsmap_info *);
	u32 gfd_dev;
};

struct dx_hash_info {
	u32 hash;
	u32 minor_hash;
	int hash_version;
	u32 *seed;
};

struct fscrypt_info;

typedef unsigned int __kernel_mode_t;

typedef __kernel_mode_t mode_t;

struct ext4_inode {
	__le16 i_mode;
	__le16 i_uid;
	__le32 i_size_lo;
	__le32 i_atime;
	__le32 i_ctime;
	__le32 i_mtime;
	__le32 i_dtime;
	__le16 i_gid;
	__le16 i_links_count;
	__le32 i_blocks_lo;
	__le32 i_flags;
	union {
		struct {
			__le32 l_i_version;
		} linux1;
		struct {
			__u32 h_i_translator;
		} hurd1;
		struct {
			__u32 m_i_reserved1;
		} masix1;
	} osd1;
	__le32 i_block[15];
	__le32 i_generation;
	__le32 i_file_acl_lo;
	__le32 i_size_high;
	__le32 i_obso_faddr;
	union {
		struct {
			__le16 l_i_blocks_high;
			__le16 l_i_file_acl_high;
			__le16 l_i_uid_high;
			__le16 l_i_gid_high;
			__le16 l_i_checksum_lo;
			__le16 l_i_reserved;
		} linux2;
		struct {
			__le16 h_i_reserved1;
			__u16 h_i_mode_high;
			__u16 h_i_uid_high;
			__u16 h_i_gid_high;
			__u32 h_i_author;
		} hurd2;
		struct {
			__le16 h_i_reserved1;
			__le16 m_i_file_acl_high;
			__u32 m_i_reserved2[2];
		} masix2;
	} osd2;
	__le16 i_extra_isize;
	__le16 i_checksum_hi;
	__le32 i_ctime_extra;
	__le32 i_mtime_extra;
	__le32 i_atime_extra;
	__le32 i_crtime;
	__le32 i_crtime_extra;
	__le32 i_version_hi;
	__le32 i_projid;
};

struct orlov_stats {
	__u64 free_clusters;
	__u32 free_inodes;
	__u32 used_dirs;
};

typedef struct {
	__le32 *p;
	__le32 key;
	struct buffer_head *bh;
} Indirect;

struct ext4_filename {
	const struct qstr *usr_fname;
	struct fscrypt_str disk_name;
	struct dx_hash_info hinfo;
};

struct ext4_xattr_ibody_header {
	__le32 h_magic;
};

struct ext4_xattr_entry {
	__u8 e_name_len;
	__u8 e_name_index;
	__le16 e_value_offs;
	__le32 e_value_inum;
	__le32 e_value_size;
	__le32 e_hash;
	char e_name[0];
};

struct ext4_xattr_info {
	const char *name;
	const void *value;
	size_t value_len;
	int name_index;
	int in_inode;
};

struct ext4_xattr_search {
	struct ext4_xattr_entry *first;
	void *base;
	void *end;
	struct ext4_xattr_entry *here;
	int not_found;
};

struct ext4_xattr_ibody_find {
	struct ext4_xattr_search s;
	struct ext4_iloc iloc;
};

typedef short unsigned int __kernel_uid16_t;

typedef short unsigned int __kernel_gid16_t;

typedef __kernel_uid16_t uid16_t;

typedef __kernel_gid16_t gid16_t;

struct ext4_io_submit {
	struct writeback_control *io_wbc;
	struct bio *io_bio;
	ext4_io_end_t *io_end;
	sector_t io_next_block;
};

typedef enum {
	EXT4_IGET_NORMAL = 0,
	EXT4_IGET_SPECIAL = 1,
	EXT4_IGET_HANDLE = 2,
} ext4_iget_flags;

struct ext4_xattr_inode_array {
	unsigned int count;
	struct inode *inodes[0];
};

struct mpage_da_data {
	struct inode *inode;
	struct writeback_control *wbc;
	long unsigned int first_page;
	long unsigned int next_page;
	long unsigned int last_page;
	struct ext4_map_blocks map;
	struct ext4_io_submit io_submit;
	unsigned int do_map: 1;
	unsigned int scanned_until_end: 1;
};

struct fstrim_range {
	__u64 start;
	__u64 len;
	__u64 minlen;
};

struct ext4_new_group_input {
	__u32 group;
	__u64 block_bitmap;
	__u64 inode_bitmap;
	__u64 inode_table;
	__u32 blocks_count;
	__u16 reserved_blocks;
	__u16 unused;
};

struct ext4_new_group_data {
	__u32 group;
	__u64 block_bitmap;
	__u64 inode_bitmap;
	__u64 inode_table;
	__u32 blocks_count;
	__u16 reserved_blocks;
	__u16 mdata_blocks;
	__u32 free_clusters_count;
};

struct move_extent {
	__u32 reserved;
	__u32 donor_fd;
	__u64 orig_start;
	__u64 donor_start;
	__u64 len;
	__u64 moved_len;
};

struct fsmap_head {
	__u32 fmh_iflags;
	__u32 fmh_oflags;
	__u32 fmh_count;
	__u32 fmh_entries;
	__u64 fmh_reserved[6];
	struct fsmap fmh_keys[2];
	struct fsmap fmh_recs[0];
};

struct getfsmap_info {
	struct super_block *gi_sb;
	struct fsmap_head *gi_data;
	unsigned int gi_idx;
	__u32 gi_last_flags;
};

enum blk_default_limits {
	BLK_MAX_SEGMENTS = 128,
	BLK_SAFE_MAX_SECTORS = 255,
	BLK_DEF_MAX_SECTORS = 2560,
	BLK_MAX_SEGMENT_SIZE = 65536,
	BLK_SEG_BOUNDARY_MASK = 4294967295,
};

struct ext4_free_data {
	struct list_head efd_list;
	struct rb_node efd_node;
	ext4_group_t efd_group;
	ext4_grpblk_t efd_start_cluster;
	ext4_grpblk_t efd_count;
	tid_t efd_tid;
};

struct ext4_prealloc_space {
	struct list_head pa_inode_list;
	struct list_head pa_group_list;
	union {
		struct list_head pa_tmp_list;
		struct callback_head pa_rcu;
	} u;
	spinlock_t pa_lock;
	atomic_t pa_count;
	unsigned int pa_deleted;
	ext4_fsblk_t pa_pstart;
	ext4_lblk_t pa_lstart;
	ext4_grpblk_t pa_len;
	ext4_grpblk_t pa_free;
	short unsigned int pa_type;
	spinlock_t *pa_obj_lock;
	struct inode *pa_inode;
};

enum {
	MB_INODE_PA = 0,
	MB_GROUP_PA = 1,
};

struct ext4_free_extent {
	ext4_lblk_t fe_logical;
	ext4_grpblk_t fe_start;
	ext4_group_t fe_group;
	ext4_grpblk_t fe_len;
};

struct ext4_allocation_context {
	struct inode *ac_inode;
	struct super_block *ac_sb;
	struct ext4_free_extent ac_o_ex;
	struct ext4_free_extent ac_g_ex;
	struct ext4_free_extent ac_b_ex;
	struct ext4_free_extent ac_f_ex;
	__u16 ac_groups_scanned;
	__u16 ac_found;
	__u16 ac_tail;
	__u16 ac_buddy;
	__u16 ac_flags;
	__u8 ac_status;
	__u8 ac_criteria;
	__u8 ac_2order;
	__u8 ac_op;
	struct page *ac_bitmap_page;
	struct page *ac_buddy_page;
	struct ext4_prealloc_space *ac_pa;
	struct ext4_locality_group *ac_lg;
};

struct ext4_buddy {
	struct page *bd_buddy_page;
	void *bd_buddy;
	struct page *bd_bitmap_page;
	void *bd_bitmap;
	struct ext4_group_info *bd_info;
	struct super_block *bd_sb;
	__u16 bd_blkbits;
	ext4_group_t bd_group;
};

typedef int (*ext4_mballoc_query_range_fn)(struct super_block *, ext4_group_t, ext4_grpblk_t, ext4_grpblk_t, void *);

struct sg {
	struct ext4_group_info info;
	ext4_grpblk_t counters[18];
};

struct migrate_struct {
	ext4_lblk_t first_block;
	ext4_lblk_t last_block;
	ext4_lblk_t curr_block;
	ext4_fsblk_t first_pblock;
	ext4_fsblk_t last_pblock;
};

struct mmp_struct {
	__le32 mmp_magic;
	__le32 mmp_seq;
	__le64 mmp_time;
	char mmp_nodename[64];
	char mmp_bdevname[32];
	__le16 mmp_check_interval;
	__le16 mmp_pad1;
	__le32 mmp_pad2[226];
	__le32 mmp_checksum;
};

struct fscrypt_name {
	const struct qstr *usr_fname;
	struct fscrypt_str disk_name;
	u32 hash;
	u32 minor_hash;
	struct fscrypt_str crypto_buf;
	bool is_nokey_name;
};

struct ext4_dir_entry {
	__le32 inode;
	__le16 rec_len;
	__le16 name_len;
	char name[255];
};

struct ext4_dir_entry_tail {
	__le32 det_reserved_zero1;
	__le16 det_rec_len;
	__u8 det_reserved_zero2;
	__u8 det_reserved_ft;
	__le32 det_checksum;
};

typedef enum {
	EITHER = 0,
	INDEX = 1,
	DIRENT = 2,
	DIRENT_HTREE = 3,
} dirblock_type_t;

struct fake_dirent {
	__le32 inode;
	__le16 rec_len;
	u8 name_len;
	u8 file_type;
};

struct dx_countlimit {
	__le16 limit;
	__le16 count;
};

struct dx_entry {
	__le32 hash;
	__le32 block;
};

struct dx_root_info {
	__le32 reserved_zero;
	u8 hash_version;
	u8 info_length;
	u8 indirect_levels;
	u8 unused_flags;
};

struct dx_root {
	struct fake_dirent dot;
	char dot_name[4];
	struct fake_dirent dotdot;
	char dotdot_name[4];
	struct dx_root_info info;
	struct dx_entry entries[0];
};

struct dx_node {
	struct fake_dirent fake;
	struct dx_entry entries[0];
};

struct dx_frame {
	struct buffer_head *bh;
	struct dx_entry *entries;
	struct dx_entry *at;
};

struct dx_map_entry {
	u32 hash;
	u16 offs;
	u16 size;
};

struct dx_tail {
	u32 dt_reserved;
	__le32 dt_checksum;
};

struct ext4_renament {
	struct inode *dir;
	struct dentry *dentry;
	struct inode *inode;
	bool is_dir;
	int dir_nlink_delta;
	ext4_lblk_t lblk;
	struct buffer_head *bh;
	struct ext4_dir_entry_2 *de;
	int inlined;
	struct buffer_head *dir_bh;
	struct ext4_dir_entry_2 *parent_de;
	int dir_inlined;
};

enum bio_post_read_step {
	STEP_INITIAL = 0,
	STEP_DECRYPT = 1,
	STEP_VERITY = 2,
	STEP_MAX = 3,
};

struct bio_post_read_ctx {
	struct bio *bio;
	struct work_struct work;
	unsigned int cur_step;
	unsigned int enabled_steps;
};

enum {
	BLOCK_BITMAP = 0,
	INODE_BITMAP = 1,
	INODE_TABLE = 2,
	GROUP_TABLE_COUNT = 3,
};

struct ext4_rcu_ptr {
	struct callback_head rcu;
	void *ptr;
};

struct ext4_new_flex_group_data {
	struct ext4_new_group_data *groups;
	__u16 *bg_flags;
	ext4_group_t count;
};

enum stat_group {
	STAT_READ = 0,
	STAT_WRITE = 1,
	STAT_DISCARD = 2,
	STAT_FLUSH = 3,
	NR_STAT_GROUPS = 4,
};

struct ext4_lazy_init {
	long unsigned int li_state;
	struct list_head li_request_list;
	struct mutex li_list_mtx;
};

struct ext4_journal_cb_entry {
	struct list_head jce_list;
	void (*jce_func)(struct super_block *, struct ext4_journal_cb_entry *, int);
};

struct trace_event_raw_ext4_other_inode_update_time {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ino_t orig_ino;
	uid_t uid;
	gid_t gid;
	__u16 mode;
	char __data[0];
};

struct trace_event_raw_ext4_free_inode {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	uid_t uid;
	gid_t gid;
	__u64 blocks;
	__u16 mode;
	char __data[0];
};

struct trace_event_raw_ext4_request_inode {
	struct trace_entry ent;
	dev_t dev;
	ino_t dir;
	__u16 mode;
	char __data[0];
};

struct trace_event_raw_ext4_allocate_inode {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ino_t dir;
	__u16 mode;
	char __data[0];
};

struct trace_event_raw_ext4_evict_inode {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	int nlink;
	char __data[0];
};

struct trace_event_raw_ext4_drop_inode {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	int drop;
	char __data[0];
};

struct trace_event_raw_ext4_nfs_commit_metadata {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	char __data[0];
};

struct trace_event_raw_ext4_mark_inode_dirty {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	long unsigned int ip;
	char __data[0];
};

struct trace_event_raw_ext4_begin_ordered_truncate {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	loff_t new_size;
	char __data[0];
};

struct trace_event_raw_ext4__write_begin {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	loff_t pos;
	unsigned int len;
	unsigned int flags;
	char __data[0];
};

struct trace_event_raw_ext4__write_end {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	loff_t pos;
	unsigned int len;
	unsigned int copied;
	char __data[0];
};

struct trace_event_raw_ext4_writepages {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	long int nr_to_write;
	long int pages_skipped;
	loff_t range_start;
	loff_t range_end;
	long unsigned int writeback_index;
	int sync_mode;
	char for_kupdate;
	char range_cyclic;
	char __data[0];
};

struct trace_event_raw_ext4_da_write_pages {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	long unsigned int first_page;
	long int nr_to_write;
	int sync_mode;
	char __data[0];
};

struct trace_event_raw_ext4_da_write_pages_extent {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u64 lblk;
	__u32 len;
	__u32 flags;
	char __data[0];
};

struct trace_event_raw_ext4_writepages_result {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	int ret;
	int pages_written;
	long int pages_skipped;
	long unsigned int writeback_index;
	int sync_mode;
	char __data[0];
};

struct trace_event_raw_ext4__page_op {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	long unsigned int index;
	char __data[0];
};

struct trace_event_raw_ext4_invalidatepage_op {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	long unsigned int index;
	unsigned int offset;
	unsigned int length;
	char __data[0];
};

struct trace_event_raw_ext4_discard_blocks {
	struct trace_entry ent;
	dev_t dev;
	__u64 blk;
	__u64 count;
	char __data[0];
};

struct trace_event_raw_ext4__mb_new_pa {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u64 pa_pstart;
	__u64 pa_lstart;
	__u32 pa_len;
	char __data[0];
};

struct trace_event_raw_ext4_mb_release_inode_pa {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u64 block;
	__u32 count;
	char __data[0];
};

struct trace_event_raw_ext4_mb_release_group_pa {
	struct trace_entry ent;
	dev_t dev;
	__u64 pa_pstart;
	__u32 pa_len;
	char __data[0];
};

struct trace_event_raw_ext4_discard_preallocations {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	unsigned int len;
	unsigned int needed;
	char __data[0];
};

struct trace_event_raw_ext4_mb_discard_preallocations {
	struct trace_entry ent;
	dev_t dev;
	int needed;
	char __data[0];
};

struct trace_event_raw_ext4_request_blocks {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	unsigned int len;
	__u32 logical;
	__u32 lleft;
	__u32 lright;
	__u64 goal;
	__u64 pleft;
	__u64 pright;
	unsigned int flags;
	char __data[0];
};

struct trace_event_raw_ext4_allocate_blocks {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u64 block;
	unsigned int len;
	__u32 logical;
	__u32 lleft;
	__u32 lright;
	__u64 goal;
	__u64 pleft;
	__u64 pright;
	unsigned int flags;
	char __data[0];
};

struct trace_event_raw_ext4_free_blocks {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u64 block;
	long unsigned int count;
	int flags;
	__u16 mode;
	char __data[0];
};

struct trace_event_raw_ext4_sync_file_enter {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ino_t parent;
	int datasync;
	char __data[0];
};

struct trace_event_raw_ext4_sync_file_exit {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	int ret;
	char __data[0];
};

struct trace_event_raw_ext4_sync_fs {
	struct trace_entry ent;
	dev_t dev;
	int wait;
	char __data[0];
};

struct trace_event_raw_ext4_alloc_da_blocks {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	unsigned int data_blocks;
	char __data[0];
};

struct trace_event_raw_ext4_mballoc_alloc {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u32 orig_logical;
	int orig_start;
	__u32 orig_group;
	int orig_len;
	__u32 goal_logical;
	int goal_start;
	__u32 goal_group;
	int goal_len;
	__u32 result_logical;
	int result_start;
	__u32 result_group;
	int result_len;
	__u16 found;
	__u16 groups;
	__u16 buddy;
	__u16 flags;
	__u16 tail;
	__u8 cr;
	char __data[0];
};

struct trace_event_raw_ext4_mballoc_prealloc {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u32 orig_logical;
	int orig_start;
	__u32 orig_group;
	int orig_len;
	__u32 result_logical;
	int result_start;
	__u32 result_group;
	int result_len;
	char __data[0];
};

struct trace_event_raw_ext4__mballoc {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	int result_start;
	__u32 result_group;
	int result_len;
	char __data[0];
};

struct trace_event_raw_ext4_forget {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u64 block;
	int is_metadata;
	__u16 mode;
	char __data[0];
};

struct trace_event_raw_ext4_da_update_reserve_space {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u64 i_blocks;
	int used_blocks;
	int reserved_data_blocks;
	int quota_claim;
	__u16 mode;
	char __data[0];
};

struct trace_event_raw_ext4_da_reserve_space {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u64 i_blocks;
	int reserved_data_blocks;
	__u16 mode;
	char __data[0];
};

struct trace_event_raw_ext4_da_release_space {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u64 i_blocks;
	int freed_blocks;
	int reserved_data_blocks;
	__u16 mode;
	char __data[0];
};

struct trace_event_raw_ext4__bitmap_load {
	struct trace_entry ent;
	dev_t dev;
	__u32 group;
	char __data[0];
};

struct trace_event_raw_ext4_read_block_bitmap_load {
	struct trace_entry ent;
	dev_t dev;
	__u32 group;
	bool prefetch;
	char __data[0];
};

struct trace_event_raw_ext4_direct_IO_enter {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	loff_t pos;
	long unsigned int len;
	int rw;
	char __data[0];
};

struct trace_event_raw_ext4_direct_IO_exit {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	loff_t pos;
	long unsigned int len;
	int rw;
	int ret;
	char __data[0];
};

struct trace_event_raw_ext4__fallocate_mode {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	loff_t offset;
	loff_t len;
	int mode;
	char __data[0];
};

struct trace_event_raw_ext4_fallocate_exit {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	loff_t pos;
	unsigned int blocks;
	int ret;
	char __data[0];
};

struct trace_event_raw_ext4_unlink_enter {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ino_t parent;
	loff_t size;
	char __data[0];
};

struct trace_event_raw_ext4_unlink_exit {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	int ret;
	char __data[0];
};

struct trace_event_raw_ext4__truncate {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u64 blocks;
	char __data[0];
};

struct trace_event_raw_ext4_ext_convert_to_initialized_enter {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t m_lblk;
	unsigned int m_len;
	ext4_lblk_t u_lblk;
	unsigned int u_len;
	ext4_fsblk_t u_pblk;
	char __data[0];
};

struct trace_event_raw_ext4_ext_convert_to_initialized_fastpath {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t m_lblk;
	unsigned int m_len;
	ext4_lblk_t u_lblk;
	unsigned int u_len;
	ext4_fsblk_t u_pblk;
	ext4_lblk_t i_lblk;
	unsigned int i_len;
	ext4_fsblk_t i_pblk;
	char __data[0];
};

struct trace_event_raw_ext4__map_blocks_enter {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t lblk;
	unsigned int len;
	unsigned int flags;
	char __data[0];
};

struct trace_event_raw_ext4__map_blocks_exit {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	unsigned int flags;
	ext4_fsblk_t pblk;
	ext4_lblk_t lblk;
	unsigned int len;
	unsigned int mflags;
	int ret;
	char __data[0];
};

struct trace_event_raw_ext4_ext_load_extent {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_fsblk_t pblk;
	ext4_lblk_t lblk;
	char __data[0];
};

struct trace_event_raw_ext4_load_inode {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	char __data[0];
};

struct trace_event_raw_ext4_journal_start {
	struct trace_entry ent;
	dev_t dev;
	long unsigned int ip;
	int blocks;
	int rsv_blocks;
	int revoke_creds;
	char __data[0];
};

struct trace_event_raw_ext4_journal_start_reserved {
	struct trace_entry ent;
	dev_t dev;
	long unsigned int ip;
	int blocks;
	char __data[0];
};

struct trace_event_raw_ext4__trim {
	struct trace_entry ent;
	int dev_major;
	int dev_minor;
	__u32 group;
	int start;
	int len;
	char __data[0];
};

struct trace_event_raw_ext4_ext_handle_unwritten_extents {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	int flags;
	ext4_lblk_t lblk;
	ext4_fsblk_t pblk;
	unsigned int len;
	unsigned int allocated;
	ext4_fsblk_t newblk;
	char __data[0];
};

struct trace_event_raw_ext4_get_implied_cluster_alloc_exit {
	struct trace_entry ent;
	dev_t dev;
	unsigned int flags;
	ext4_lblk_t lblk;
	ext4_fsblk_t pblk;
	unsigned int len;
	int ret;
	char __data[0];
};

struct trace_event_raw_ext4_ext_put_in_cache {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t lblk;
	unsigned int len;
	ext4_fsblk_t start;
	char __data[0];
};

struct trace_event_raw_ext4_ext_in_cache {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t lblk;
	int ret;
	char __data[0];
};

struct trace_event_raw_ext4_find_delalloc_range {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t from;
	ext4_lblk_t to;
	int reverse;
	int found;
	ext4_lblk_t found_blk;
	char __data[0];
};

struct trace_event_raw_ext4_get_reserved_cluster_alloc {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t lblk;
	unsigned int len;
	char __data[0];
};

struct trace_event_raw_ext4_ext_show_extent {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_fsblk_t pblk;
	ext4_lblk_t lblk;
	short unsigned int len;
	char __data[0];
};

struct trace_event_raw_ext4_remove_blocks {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t from;
	ext4_lblk_t to;
	ext4_fsblk_t ee_pblk;
	ext4_lblk_t ee_lblk;
	short unsigned int ee_len;
	ext4_fsblk_t pc_pclu;
	ext4_lblk_t pc_lblk;
	int pc_state;
	char __data[0];
};

struct trace_event_raw_ext4_ext_rm_leaf {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t start;
	ext4_lblk_t ee_lblk;
	ext4_fsblk_t ee_pblk;
	short int ee_len;
	ext4_fsblk_t pc_pclu;
	ext4_lblk_t pc_lblk;
	int pc_state;
	char __data[0];
};

struct trace_event_raw_ext4_ext_rm_idx {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_fsblk_t pblk;
	char __data[0];
};

struct trace_event_raw_ext4_ext_remove_space {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t start;
	ext4_lblk_t end;
	int depth;
	char __data[0];
};

struct trace_event_raw_ext4_ext_remove_space_done {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t start;
	ext4_lblk_t end;
	int depth;
	ext4_fsblk_t pc_pclu;
	ext4_lblk_t pc_lblk;
	int pc_state;
	short unsigned int eh_entries;
	char __data[0];
};

struct trace_event_raw_ext4__es_extent {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t lblk;
	ext4_lblk_t len;
	ext4_fsblk_t pblk;
	char status;
	char __data[0];
};

struct trace_event_raw_ext4_es_remove_extent {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	loff_t lblk;
	loff_t len;
	char __data[0];
};

struct trace_event_raw_ext4_es_find_extent_range_enter {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t lblk;
	char __data[0];
};

struct trace_event_raw_ext4_es_find_extent_range_exit {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t lblk;
	ext4_lblk_t len;
	ext4_fsblk_t pblk;
	char status;
	char __data[0];
};

struct trace_event_raw_ext4_es_lookup_extent_enter {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t lblk;
	char __data[0];
};

struct trace_event_raw_ext4_es_lookup_extent_exit {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t lblk;
	ext4_lblk_t len;
	ext4_fsblk_t pblk;
	char status;
	int found;
	char __data[0];
};

struct trace_event_raw_ext4__es_shrink_enter {
	struct trace_entry ent;
	dev_t dev;
	int nr_to_scan;
	int cache_cnt;
	char __data[0];
};

struct trace_event_raw_ext4_es_shrink_scan_exit {
	struct trace_entry ent;
	dev_t dev;
	int nr_shrunk;
	int cache_cnt;
	char __data[0];
};

struct trace_event_raw_ext4_collapse_range {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	loff_t offset;
	loff_t len;
	char __data[0];
};

struct trace_event_raw_ext4_insert_range {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	loff_t offset;
	loff_t len;
	char __data[0];
};

struct trace_event_raw_ext4_es_shrink {
	struct trace_entry ent;
	dev_t dev;
	int nr_shrunk;
	long long unsigned int scan_time;
	int nr_skipped;
	int retried;
	char __data[0];
};

struct trace_event_raw_ext4_es_insert_delayed_block {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t lblk;
	ext4_lblk_t len;
	ext4_fsblk_t pblk;
	char status;
	bool allocated;
	char __data[0];
};

struct trace_event_raw_ext4_fsmap_class {
	struct trace_entry ent;
	dev_t dev;
	dev_t keydev;
	u32 agno;
	u64 bno;
	u64 len;
	u64 owner;
	char __data[0];
};

struct trace_event_raw_ext4_getfsmap_class {
	struct trace_entry ent;
	dev_t dev;
	dev_t keydev;
	u64 block;
	u64 len;
	u64 owner;
	u64 flags;
	char __data[0];
};

struct trace_event_raw_ext4_shutdown {
	struct trace_entry ent;
	dev_t dev;
	unsigned int flags;
	char __data[0];
};

struct trace_event_raw_ext4_error {
	struct trace_entry ent;
	dev_t dev;
	const char *function;
	unsigned int line;
	char __data[0];
};

struct trace_event_raw_ext4_prefetch_bitmaps {
	struct trace_entry ent;
	dev_t dev;
	__u32 group;
	__u32 next;
	__u32 ios;
	char __data[0];
};

struct trace_event_raw_ext4_lazy_itable_init {
	struct trace_entry ent;
	dev_t dev;
	__u32 group;
	char __data[0];
};

struct trace_event_raw_ext4_fc_replay_scan {
	struct trace_entry ent;
	dev_t dev;
	int error;
	int off;
	char __data[0];
};

struct trace_event_raw_ext4_fc_replay {
	struct trace_entry ent;
	dev_t dev;
	int tag;
	int ino;
	int priv1;
	int priv2;
	char __data[0];
};

struct trace_event_raw_ext4_fc_commit_start {
	struct trace_entry ent;
	dev_t dev;
	char __data[0];
};

struct trace_event_raw_ext4_fc_commit_stop {
	struct trace_entry ent;
	dev_t dev;
	int nblks;
	int reason;
	int num_fc;
	int num_fc_ineligible;
	int nblks_agg;
	char __data[0];
};

struct trace_event_raw_ext4_fc_stats {
	struct trace_entry ent;
	dev_t dev;
	unsigned int fc_ineligible_rc[10];
	long unsigned int fc_commits;
	long unsigned int fc_ineligible_commits;
	long unsigned int fc_numblks;
	char __data[0];
};

struct trace_event_raw_ext4_fc_track_create {
	struct trace_entry ent;
	dev_t dev;
	int ino;
	int error;
	char __data[0];
};

struct trace_event_raw_ext4_fc_track_link {
	struct trace_entry ent;
	dev_t dev;
	int ino;
	int error;
	char __data[0];
};

struct trace_event_raw_ext4_fc_track_unlink {
	struct trace_entry ent;
	dev_t dev;
	int ino;
	int error;
	char __data[0];
};

struct trace_event_raw_ext4_fc_track_inode {
	struct trace_entry ent;
	dev_t dev;
	int ino;
	int error;
	char __data[0];
};

struct trace_event_raw_ext4_fc_track_range {
	struct trace_entry ent;
	dev_t dev;
	int ino;
	long int start;
	long int end;
	int error;
	char __data[0];
};

struct trace_event_data_offsets_ext4_other_inode_update_time {};

struct trace_event_data_offsets_ext4_free_inode {};

struct trace_event_data_offsets_ext4_request_inode {};

struct trace_event_data_offsets_ext4_allocate_inode {};

struct trace_event_data_offsets_ext4_evict_inode {};

struct trace_event_data_offsets_ext4_drop_inode {};

struct trace_event_data_offsets_ext4_nfs_commit_metadata {};

struct trace_event_data_offsets_ext4_mark_inode_dirty {};

struct trace_event_data_offsets_ext4_begin_ordered_truncate {};

struct trace_event_data_offsets_ext4__write_begin {};

struct trace_event_data_offsets_ext4__write_end {};

struct trace_event_data_offsets_ext4_writepages {};

struct trace_event_data_offsets_ext4_da_write_pages {};

struct trace_event_data_offsets_ext4_da_write_pages_extent {};

struct trace_event_data_offsets_ext4_writepages_result {};

struct trace_event_data_offsets_ext4__page_op {};

struct trace_event_data_offsets_ext4_invalidatepage_op {};

struct trace_event_data_offsets_ext4_discard_blocks {};

struct trace_event_data_offsets_ext4__mb_new_pa {};

struct trace_event_data_offsets_ext4_mb_release_inode_pa {};

struct trace_event_data_offsets_ext4_mb_release_group_pa {};

struct trace_event_data_offsets_ext4_discard_preallocations {};

struct trace_event_data_offsets_ext4_mb_discard_preallocations {};

struct trace_event_data_offsets_ext4_request_blocks {};

struct trace_event_data_offsets_ext4_allocate_blocks {};

struct trace_event_data_offsets_ext4_free_blocks {};

struct trace_event_data_offsets_ext4_sync_file_enter {};

struct trace_event_data_offsets_ext4_sync_file_exit {};

struct trace_event_data_offsets_ext4_sync_fs {};

struct trace_event_data_offsets_ext4_alloc_da_blocks {};

struct trace_event_data_offsets_ext4_mballoc_alloc {};

struct trace_event_data_offsets_ext4_mballoc_prealloc {};

struct trace_event_data_offsets_ext4__mballoc {};

struct trace_event_data_offsets_ext4_forget {};

struct trace_event_data_offsets_ext4_da_update_reserve_space {};

struct trace_event_data_offsets_ext4_da_reserve_space {};

struct trace_event_data_offsets_ext4_da_release_space {};

struct trace_event_data_offsets_ext4__bitmap_load {};

struct trace_event_data_offsets_ext4_read_block_bitmap_load {};

struct trace_event_data_offsets_ext4_direct_IO_enter {};

struct trace_event_data_offsets_ext4_direct_IO_exit {};

struct trace_event_data_offsets_ext4__fallocate_mode {};

struct trace_event_data_offsets_ext4_fallocate_exit {};

struct trace_event_data_offsets_ext4_unlink_enter {};

struct trace_event_data_offsets_ext4_unlink_exit {};

struct trace_event_data_offsets_ext4__truncate {};

struct trace_event_data_offsets_ext4_ext_convert_to_initialized_enter {};

struct trace_event_data_offsets_ext4_ext_convert_to_initialized_fastpath {};

struct trace_event_data_offsets_ext4__map_blocks_enter {};

struct trace_event_data_offsets_ext4__map_blocks_exit {};

struct trace_event_data_offsets_ext4_ext_load_extent {};

struct trace_event_data_offsets_ext4_load_inode {};

struct trace_event_data_offsets_ext4_journal_start {};

struct trace_event_data_offsets_ext4_journal_start_reserved {};

struct trace_event_data_offsets_ext4__trim {};

struct trace_event_data_offsets_ext4_ext_handle_unwritten_extents {};

struct trace_event_data_offsets_ext4_get_implied_cluster_alloc_exit {};

struct trace_event_data_offsets_ext4_ext_put_in_cache {};

struct trace_event_data_offsets_ext4_ext_in_cache {};

struct trace_event_data_offsets_ext4_find_delalloc_range {};

struct trace_event_data_offsets_ext4_get_reserved_cluster_alloc {};

struct trace_event_data_offsets_ext4_ext_show_extent {};

struct trace_event_data_offsets_ext4_remove_blocks {};

struct trace_event_data_offsets_ext4_ext_rm_leaf {};

struct trace_event_data_offsets_ext4_ext_rm_idx {};

struct trace_event_data_offsets_ext4_ext_remove_space {};

struct trace_event_data_offsets_ext4_ext_remove_space_done {};

struct trace_event_data_offsets_ext4__es_extent {};

struct trace_event_data_offsets_ext4_es_remove_extent {};

struct trace_event_data_offsets_ext4_es_find_extent_range_enter {};

struct trace_event_data_offsets_ext4_es_find_extent_range_exit {};

struct trace_event_data_offsets_ext4_es_lookup_extent_enter {};

struct trace_event_data_offsets_ext4_es_lookup_extent_exit {};

struct trace_event_data_offsets_ext4__es_shrink_enter {};

struct trace_event_data_offsets_ext4_es_shrink_scan_exit {};

struct trace_event_data_offsets_ext4_collapse_range {};

struct trace_event_data_offsets_ext4_insert_range {};

struct trace_event_data_offsets_ext4_es_shrink {};

struct trace_event_data_offsets_ext4_es_insert_delayed_block {};

struct trace_event_data_offsets_ext4_fsmap_class {};

struct trace_event_data_offsets_ext4_getfsmap_class {};

struct trace_event_data_offsets_ext4_shutdown {};

struct trace_event_data_offsets_ext4_error {};

struct trace_event_data_offsets_ext4_prefetch_bitmaps {};

struct trace_event_data_offsets_ext4_lazy_itable_init {};

struct trace_event_data_offsets_ext4_fc_replay_scan {};

struct trace_event_data_offsets_ext4_fc_replay {};

struct trace_event_data_offsets_ext4_fc_commit_start {};

struct trace_event_data_offsets_ext4_fc_commit_stop {};

struct trace_event_data_offsets_ext4_fc_stats {};

struct trace_event_data_offsets_ext4_fc_track_create {};

struct trace_event_data_offsets_ext4_fc_track_link {};

struct trace_event_data_offsets_ext4_fc_track_unlink {};

struct trace_event_data_offsets_ext4_fc_track_inode {};

struct trace_event_data_offsets_ext4_fc_track_range {};

typedef void (*btf_trace_ext4_other_inode_update_time)(void *, struct inode *, ino_t);

typedef void (*btf_trace_ext4_free_inode)(void *, struct inode *);

typedef void (*btf_trace_ext4_request_inode)(void *, struct inode *, int);

typedef void (*btf_trace_ext4_allocate_inode)(void *, struct inode *, struct inode *, int);

typedef void (*btf_trace_ext4_evict_inode)(void *, struct inode *);

typedef void (*btf_trace_ext4_drop_inode)(void *, struct inode *, int);

typedef void (*btf_trace_ext4_nfs_commit_metadata)(void *, struct inode *);

typedef void (*btf_trace_ext4_mark_inode_dirty)(void *, struct inode *, long unsigned int);

typedef void (*btf_trace_ext4_begin_ordered_truncate)(void *, struct inode *, loff_t);

typedef void (*btf_trace_ext4_write_begin)(void *, struct inode *, loff_t, unsigned int, unsigned int);

typedef void (*btf_trace_ext4_da_write_begin)(void *, struct inode *, loff_t, unsigned int, unsigned int);

typedef void (*btf_trace_ext4_write_end)(void *, struct inode *, loff_t, unsigned int, unsigned int);

typedef void (*btf_trace_ext4_journalled_write_end)(void *, struct inode *, loff_t, unsigned int, unsigned int);

typedef void (*btf_trace_ext4_da_write_end)(void *, struct inode *, loff_t, unsigned int, unsigned int);

typedef void (*btf_trace_ext4_writepages)(void *, struct inode *, struct writeback_control *);

typedef void (*btf_trace_ext4_da_write_pages)(void *, struct inode *, long unsigned int, struct writeback_control *);

typedef void (*btf_trace_ext4_da_write_pages_extent)(void *, struct inode *, struct ext4_map_blocks *);

typedef void (*btf_trace_ext4_writepages_result)(void *, struct inode *, struct writeback_control *, int, int);

typedef void (*btf_trace_ext4_writepage)(void *, struct page *);

typedef void (*btf_trace_ext4_readpage)(void *, struct page *);

typedef void (*btf_trace_ext4_releasepage)(void *, struct page *);

typedef void (*btf_trace_ext4_invalidatepage)(void *, struct page *, unsigned int, unsigned int);

typedef void (*btf_trace_ext4_journalled_invalidatepage)(void *, struct page *, unsigned int, unsigned int);

typedef void (*btf_trace_ext4_discard_blocks)(void *, struct super_block *, long long unsigned int, long long unsigned int);

typedef void (*btf_trace_ext4_mb_new_inode_pa)(void *, struct ext4_allocation_context *, struct ext4_prealloc_space *);

typedef void (*btf_trace_ext4_mb_new_group_pa)(void *, struct ext4_allocation_context *, struct ext4_prealloc_space *);

typedef void (*btf_trace_ext4_mb_release_inode_pa)(void *, struct ext4_prealloc_space *, long long unsigned int, unsigned int);

typedef void (*btf_trace_ext4_mb_release_group_pa)(void *, struct super_block *, struct ext4_prealloc_space *);

typedef void (*btf_trace_ext4_discard_preallocations)(void *, struct inode *, unsigned int, unsigned int);

typedef void (*btf_trace_ext4_mb_discard_preallocations)(void *, struct super_block *, int);

typedef void (*btf_trace_ext4_request_blocks)(void *, struct ext4_allocation_request *);

typedef void (*btf_trace_ext4_allocate_blocks)(void *, struct ext4_allocation_request *, long long unsigned int);

typedef void (*btf_trace_ext4_free_blocks)(void *, struct inode *, __u64, long unsigned int, int);

typedef void (*btf_trace_ext4_sync_file_enter)(void *, struct file *, int);

typedef void (*btf_trace_ext4_sync_file_exit)(void *, struct inode *, int);

typedef void (*btf_trace_ext4_sync_fs)(void *, struct super_block *, int);

typedef void (*btf_trace_ext4_alloc_da_blocks)(void *, struct inode *);

typedef void (*btf_trace_ext4_mballoc_alloc)(void *, struct ext4_allocation_context *);

typedef void (*btf_trace_ext4_mballoc_prealloc)(void *, struct ext4_allocation_context *);

typedef void (*btf_trace_ext4_mballoc_discard)(void *, struct super_block *, struct inode *, ext4_group_t, ext4_grpblk_t, ext4_grpblk_t);

typedef void (*btf_trace_ext4_mballoc_free)(void *, struct super_block *, struct inode *, ext4_group_t, ext4_grpblk_t, ext4_grpblk_t);

typedef void (*btf_trace_ext4_forget)(void *, struct inode *, int, __u64);

typedef void (*btf_trace_ext4_da_update_reserve_space)(void *, struct inode *, int, int);

typedef void (*btf_trace_ext4_da_reserve_space)(void *, struct inode *);

typedef void (*btf_trace_ext4_da_release_space)(void *, struct inode *, int);

typedef void (*btf_trace_ext4_mb_bitmap_load)(void *, struct super_block *, long unsigned int);

typedef void (*btf_trace_ext4_mb_buddy_bitmap_load)(void *, struct super_block *, long unsigned int);

typedef void (*btf_trace_ext4_load_inode_bitmap)(void *, struct super_block *, long unsigned int);

typedef void (*btf_trace_ext4_read_block_bitmap_load)(void *, struct super_block *, long unsigned int, bool);

typedef void (*btf_trace_ext4_direct_IO_enter)(void *, struct inode *, loff_t, long unsigned int, int);

typedef void (*btf_trace_ext4_direct_IO_exit)(void *, struct inode *, loff_t, long unsigned int, int, int);

typedef void (*btf_trace_ext4_fallocate_enter)(void *, struct inode *, loff_t, loff_t, int);

typedef void (*btf_trace_ext4_punch_hole)(void *, struct inode *, loff_t, loff_t, int);

typedef void (*btf_trace_ext4_zero_range)(void *, struct inode *, loff_t, loff_t, int);

typedef void (*btf_trace_ext4_fallocate_exit)(void *, struct inode *, loff_t, unsigned int, int);

typedef void (*btf_trace_ext4_unlink_enter)(void *, struct inode *, struct dentry *);

typedef void (*btf_trace_ext4_unlink_exit)(void *, struct dentry *, int);

typedef void (*btf_trace_ext4_truncate_enter)(void *, struct inode *);

typedef void (*btf_trace_ext4_truncate_exit)(void *, struct inode *);

typedef void (*btf_trace_ext4_ext_convert_to_initialized_enter)(void *, struct inode *, struct ext4_map_blocks *, struct ext4_extent *);

typedef void (*btf_trace_ext4_ext_convert_to_initialized_fastpath)(void *, struct inode *, struct ext4_map_blocks *, struct ext4_extent *, struct ext4_extent *);

typedef void (*btf_trace_ext4_ext_map_blocks_enter)(void *, struct inode *, ext4_lblk_t, unsigned int, unsigned int);

typedef void (*btf_trace_ext4_ind_map_blocks_enter)(void *, struct inode *, ext4_lblk_t, unsigned int, unsigned int);

typedef void (*btf_trace_ext4_ext_map_blocks_exit)(void *, struct inode *, unsigned int, struct ext4_map_blocks *, int);

typedef void (*btf_trace_ext4_ind_map_blocks_exit)(void *, struct inode *, unsigned int, struct ext4_map_blocks *, int);

typedef void (*btf_trace_ext4_ext_load_extent)(void *, struct inode *, ext4_lblk_t, ext4_fsblk_t);

typedef void (*btf_trace_ext4_load_inode)(void *, struct super_block *, long unsigned int);

typedef void (*btf_trace_ext4_journal_start)(void *, struct super_block *, int, int, int, long unsigned int);

typedef void (*btf_trace_ext4_journal_start_reserved)(void *, struct super_block *, int, long unsigned int);

typedef void (*btf_trace_ext4_trim_extent)(void *, struct super_block *, ext4_group_t, ext4_grpblk_t, ext4_grpblk_t);

typedef void (*btf_trace_ext4_trim_all_free)(void *, struct super_block *, ext4_group_t, ext4_grpblk_t, ext4_grpblk_t);

typedef void (*btf_trace_ext4_ext_handle_unwritten_extents)(void *, struct inode *, struct ext4_map_blocks *, int, unsigned int, ext4_fsblk_t);

typedef void (*btf_trace_ext4_get_implied_cluster_alloc_exit)(void *, struct super_block *, struct ext4_map_blocks *, int);

typedef void (*btf_trace_ext4_ext_put_in_cache)(void *, struct inode *, ext4_lblk_t, unsigned int, ext4_fsblk_t);

typedef void (*btf_trace_ext4_ext_in_cache)(void *, struct inode *, ext4_lblk_t, int);

typedef void (*btf_trace_ext4_find_delalloc_range)(void *, struct inode *, ext4_lblk_t, ext4_lblk_t, int, int, ext4_lblk_t);

typedef void (*btf_trace_ext4_get_reserved_cluster_alloc)(void *, struct inode *, ext4_lblk_t, unsigned int);

typedef void (*btf_trace_ext4_ext_show_extent)(void *, struct inode *, ext4_lblk_t, ext4_fsblk_t, short unsigned int);

typedef void (*btf_trace_ext4_remove_blocks)(void *, struct inode *, struct ext4_extent *, ext4_lblk_t, ext4_fsblk_t, struct partial_cluster *);

typedef void (*btf_trace_ext4_ext_rm_leaf)(void *, struct inode *, ext4_lblk_t, struct ext4_extent *, struct partial_cluster *);

typedef void (*btf_trace_ext4_ext_rm_idx)(void *, struct inode *, ext4_fsblk_t);

typedef void (*btf_trace_ext4_ext_remove_space)(void *, struct inode *, ext4_lblk_t, ext4_lblk_t, int);

typedef void (*btf_trace_ext4_ext_remove_space_done)(void *, struct inode *, ext4_lblk_t, ext4_lblk_t, int, struct partial_cluster *, __le16);

typedef void (*btf_trace_ext4_es_insert_extent)(void *, struct inode *, struct extent_status *);

typedef void (*btf_trace_ext4_es_cache_extent)(void *, struct inode *, struct extent_status *);

typedef void (*btf_trace_ext4_es_remove_extent)(void *, struct inode *, ext4_lblk_t, ext4_lblk_t);

typedef void (*btf_trace_ext4_es_find_extent_range_enter)(void *, struct inode *, ext4_lblk_t);

typedef void (*btf_trace_ext4_es_find_extent_range_exit)(void *, struct inode *, struct extent_status *);

typedef void (*btf_trace_ext4_es_lookup_extent_enter)(void *, struct inode *, ext4_lblk_t);

typedef void (*btf_trace_ext4_es_lookup_extent_exit)(void *, struct inode *, struct extent_status *, int);

typedef void (*btf_trace_ext4_es_shrink_count)(void *, struct super_block *, int, int);

typedef void (*btf_trace_ext4_es_shrink_scan_enter)(void *, struct super_block *, int, int);

typedef void (*btf_trace_ext4_es_shrink_scan_exit)(void *, struct super_block *, int, int);

typedef void (*btf_trace_ext4_collapse_range)(void *, struct inode *, loff_t, loff_t);

typedef void (*btf_trace_ext4_insert_range)(void *, struct inode *, loff_t, loff_t);

typedef void (*btf_trace_ext4_es_shrink)(void *, struct super_block *, int, u64, int, int);

typedef void (*btf_trace_ext4_es_insert_delayed_block)(void *, struct inode *, struct extent_status *, bool);

typedef void (*btf_trace_ext4_fsmap_low_key)(void *, struct super_block *, u32, u32, u64, u64, u64);

typedef void (*btf_trace_ext4_fsmap_high_key)(void *, struct super_block *, u32, u32, u64, u64, u64);

typedef void (*btf_trace_ext4_fsmap_mapping)(void *, struct super_block *, u32, u32, u64, u64, u64);

typedef void (*btf_trace_ext4_getfsmap_low_key)(void *, struct super_block *, struct ext4_fsmap *);

typedef void (*btf_trace_ext4_getfsmap_high_key)(void *, struct super_block *, struct ext4_fsmap *);

typedef void (*btf_trace_ext4_getfsmap_mapping)(void *, struct super_block *, struct ext4_fsmap *);

typedef void (*btf_trace_ext4_shutdown)(void *, struct super_block *, long unsigned int);

typedef void (*btf_trace_ext4_error)(void *, struct super_block *, const char *, unsigned int);

typedef void (*btf_trace_ext4_prefetch_bitmaps)(void *, struct super_block *, ext4_group_t, ext4_group_t, unsigned int);

typedef void (*btf_trace_ext4_lazy_itable_init)(void *, struct super_block *, ext4_group_t);

typedef void (*btf_trace_ext4_fc_replay_scan)(void *, struct super_block *, int, int);

typedef void (*btf_trace_ext4_fc_replay)(void *, struct super_block *, int, int, int, int);

typedef void (*btf_trace_ext4_fc_commit_start)(void *, struct super_block *);

typedef void (*btf_trace_ext4_fc_commit_stop)(void *, struct super_block *, int, int);

typedef void (*btf_trace_ext4_fc_stats)(void *, struct super_block *);

typedef void (*btf_trace_ext4_fc_track_create)(void *, struct inode *, struct dentry *, int);

typedef void (*btf_trace_ext4_fc_track_link)(void *, struct inode *, struct dentry *, int);

typedef void (*btf_trace_ext4_fc_track_unlink)(void *, struct inode *, struct dentry *, int);

typedef void (*btf_trace_ext4_fc_track_inode)(void *, struct inode *, int);

typedef void (*btf_trace_ext4_fc_track_range)(void *, struct inode *, long int, long int, int);

enum {
	Opt_bsd_df = 0,
	Opt_minix_df = 1,
	Opt_grpid = 2,
	Opt_nogrpid = 3,
	Opt_resgid = 4,
	Opt_resuid = 5,
	Opt_sb = 6,
	Opt_err_cont = 7,
	Opt_err_panic = 8,
	Opt_err_ro = 9,
	Opt_nouid32 = 10,
	Opt_debug = 11,
	Opt_removed = 12,
	Opt_user_xattr = 13,
	Opt_nouser_xattr = 14,
	Opt_acl = 15,
	Opt_noacl = 16,
	Opt_auto_da_alloc = 17,
	Opt_noauto_da_alloc = 18,
	Opt_noload = 19,
	Opt_commit = 20,
	Opt_min_batch_time = 21,
	Opt_max_batch_time = 22,
	Opt_journal_dev = 23,
	Opt_journal_path = 24,
	Opt_journal_checksum = 25,
	Opt_journal_async_commit = 26,
	Opt_abort = 27,
	Opt_data_journal = 28,
	Opt_data_ordered = 29,
	Opt_data_writeback = 30,
	Opt_data_err_abort = 31,
	Opt_data_err_ignore = 32,
	Opt_test_dummy_encryption = 33,
	Opt_inlinecrypt = 34,
	Opt_usrjquota = 35,
	Opt_grpjquota = 36,
	Opt_offusrjquota = 37,
	Opt_offgrpjquota = 38,
	Opt_jqfmt_vfsold = 39,
	Opt_jqfmt_vfsv0 = 40,
	Opt_jqfmt_vfsv1 = 41,
	Opt_quota = 42,
	Opt_noquota = 43,
	Opt_barrier = 44,
	Opt_nobarrier = 45,
	Opt_err___2 = 46,
	Opt_usrquota = 47,
	Opt_grpquota = 48,
	Opt_prjquota = 49,
	Opt_i_version = 50,
	Opt_dax = 51,
	Opt_dax_always = 52,
	Opt_dax_inode = 53,
	Opt_dax_never = 54,
	Opt_stripe = 55,
	Opt_delalloc = 56,
	Opt_nodelalloc = 57,
	Opt_warn_on_error = 58,
	Opt_nowarn_on_error = 59,
	Opt_mblk_io_submit = 60,
	Opt_lazytime = 61,
	Opt_nolazytime = 62,
	Opt_debug_want_extra_isize = 63,
	Opt_nomblk_io_submit = 64,
	Opt_block_validity = 65,
	Opt_noblock_validity = 66,
	Opt_inode_readahead_blks = 67,
	Opt_journal_ioprio = 68,
	Opt_dioread_nolock = 69,
	Opt_dioread_lock = 70,
	Opt_discard = 71,
	Opt_nodiscard = 72,
	Opt_init_itable = 73,
	Opt_noinit_itable = 74,
	Opt_max_dir_size_kb = 75,
	Opt_nojournal_checksum = 76,
	Opt_nombcache = 77,
	Opt_prefetch_block_bitmaps = 78,
};

struct mount_opts {
	int token;
	int mount_opt;
	int flags;
};

struct ext4_mount_options {
	long unsigned int s_mount_opt;
	long unsigned int s_mount_opt2;
	kuid_t s_resuid;
	kgid_t s_resgid;
	long unsigned int s_commit_interval;
	u32 s_min_batch_time;
	u32 s_max_batch_time;
};

enum {
	attr_noop = 0,
	attr_delayed_allocation_blocks = 1,
	attr_session_write_kbytes = 2,
	attr_lifetime_write_kbytes = 3,
	attr_reserved_clusters = 4,
	attr_sra_exceeded_retry_limit = 5,
	attr_inode_readahead = 6,
	attr_trigger_test_error = 7,
	attr_first_error_time = 8,
	attr_last_error_time = 9,
	attr_feature = 10,
	attr_pointer_ui = 11,
	attr_pointer_ul = 12,
	attr_pointer_u64 = 13,
	attr_pointer_u8 = 14,
	attr_pointer_string = 15,
	attr_pointer_atomic = 16,
	attr_journal_task = 17,
};

enum {
	ptr_explicit = 0,
	ptr_ext4_sb_info_offset = 1,
	ptr_ext4_super_block_offset = 2,
};

struct ext4_attr {
	struct attribute attr;
	short int attr_id;
	short int attr_ptr;
	short unsigned int attr_size;
	union {
		int offset;
		void *explicit_ptr;
	} u;
};

struct ext4_xattr_header {
	__le32 h_magic;
	__le32 h_refcount;
	__le32 h_blocks;
	__le32 h_hash;
	__le32 h_checksum;
	__u32 h_reserved[3];
};

struct ext4_xattr_block_find {
	struct ext4_xattr_search s;
	struct buffer_head *bh;
};

struct ext4_fc_tl {
	__le16 fc_tag;
	__le16 fc_len;
};

struct ext4_fc_head {
	__le32 fc_features;
	__le32 fc_tid;
};

struct ext4_fc_add_range {
	__le32 fc_ino;
	__u8 fc_ex[12];
};

struct ext4_fc_del_range {
	__le32 fc_ino;
	__le32 fc_lblk;
	__le32 fc_len;
};

struct ext4_fc_dentry_info {
	__le32 fc_parent_ino;
	__le32 fc_ino;
	u8 fc_dname[0];
};

struct ext4_fc_inode {
	__le32 fc_ino;
	__u8 fc_raw_inode[0];
};

struct ext4_fc_tail {
	__le32 fc_tid;
	__le32 fc_crc;
};

struct ext4_fc_dentry_update {
	int fcd_op;
	int fcd_parent;
	int fcd_ino;
	struct qstr fcd_name;
	unsigned char fcd_iname[32];
	struct list_head fcd_list;
};

struct __track_dentry_update_args {
	struct dentry *dentry;
	int op;
};

struct __track_range_args {
	ext4_lblk_t start;
	ext4_lblk_t end;
};

struct dentry_info_args {
	int parent_ino;
	int dname_len;
	int ino;
	int inode_len;
	char *dname;
};

typedef struct {
	__le16 e_tag;
	__le16 e_perm;
	__le32 e_id;
} ext4_acl_entry;

typedef struct {
	__le32 a_version;
} ext4_acl_header;

struct commit_header {
	__be32 h_magic;
	__be32 h_blocktype;
	__be32 h_sequence;
	unsigned char h_chksum_type;
	unsigned char h_chksum_size;
	unsigned char h_padding[2];
	__be32 h_chksum[8];
	__be64 h_commit_sec;
	__be32 h_commit_nsec;
};

struct journal_block_tag3_s {
	__be32 t_blocknr;
	__be32 t_flags;
	__be32 t_blocknr_high;
	__be32 t_checksum;
};

typedef struct journal_block_tag3_s journal_block_tag3_t;

struct journal_block_tag_s {
	__be32 t_blocknr;
	__be16 t_checksum;
	__be16 t_flags;
	__be32 t_blocknr_high;
};

typedef struct journal_block_tag_s journal_block_tag_t;

struct jbd2_journal_block_tail {
	__be32 t_checksum;
};

struct jbd2_journal_revoke_header_s {
	journal_header_t r_header;
	__be32 r_count;
};

typedef struct jbd2_journal_revoke_header_s jbd2_journal_revoke_header_t;

struct recovery_info {
	tid_t start_transaction;
	tid_t end_transaction;
	int nr_replays;
	int nr_revokes;
	int nr_revoke_hits;
};

struct jbd2_revoke_table_s {
	int hash_size;
	int hash_shift;
	struct list_head *hash_table;
};

struct jbd2_revoke_record_s {
	struct list_head hash;
	tid_t sequence;
	long long unsigned int blocknr;
};

struct trace_event_raw_jbd2_checkpoint {
	struct trace_entry ent;
	dev_t dev;
	int result;
	char __data[0];
};

struct trace_event_raw_jbd2_commit {
	struct trace_entry ent;
	dev_t dev;
	char sync_commit;
	int transaction;
	char __data[0];
};

struct trace_event_raw_jbd2_end_commit {
	struct trace_entry ent;
	dev_t dev;
	char sync_commit;
	int transaction;
	int head;
	char __data[0];
};

struct trace_event_raw_jbd2_submit_inode_data {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	char __data[0];
};

struct trace_event_raw_jbd2_handle_start_class {
	struct trace_entry ent;
	dev_t dev;
	long unsigned int tid;
	unsigned int type;
	unsigned int line_no;
	int requested_blocks;
	char __data[0];
};

struct trace_event_raw_jbd2_handle_extend {
	struct trace_entry ent;
	dev_t dev;
	long unsigned int tid;
	unsigned int type;
	unsigned int line_no;
	int buffer_credits;
	int requested_blocks;
	char __data[0];
};

struct trace_event_raw_jbd2_handle_stats {
	struct trace_entry ent;
	dev_t dev;
	long unsigned int tid;
	unsigned int type;
	unsigned int line_no;
	int interval;
	int sync;
	int requested_blocks;
	int dirtied_blocks;
	char __data[0];
};

struct trace_event_raw_jbd2_run_stats {
	struct trace_entry ent;
	dev_t dev;
	long unsigned int tid;
	long unsigned int wait;
	long unsigned int request_delay;
	long unsigned int running;
	long unsigned int locked;
	long unsigned int flushing;
	long unsigned int logging;
	__u32 handle_count;
	__u32 blocks;
	__u32 blocks_logged;
	char __data[0];
};

struct trace_event_raw_jbd2_checkpoint_stats {
	struct trace_entry ent;
	dev_t dev;
	long unsigned int tid;
	long unsigned int chp_time;
	__u32 forced_to_close;
	__u32 written;
	__u32 dropped;
	char __data[0];
};

struct trace_event_raw_jbd2_update_log_tail {
	struct trace_entry ent;
	dev_t dev;
	tid_t tail_sequence;
	tid_t first_tid;
	long unsigned int block_nr;
	long unsigned int freed;
	char __data[0];
};

struct trace_event_raw_jbd2_write_superblock {
	struct trace_entry ent;
	dev_t dev;
	int write_op;
	char __data[0];
};

struct trace_event_raw_jbd2_lock_buffer_stall {
	struct trace_entry ent;
	dev_t dev;
	long unsigned int stall_ms;
	char __data[0];
};

struct trace_event_data_offsets_jbd2_checkpoint {};

struct trace_event_data_offsets_jbd2_commit {};

struct trace_event_data_offsets_jbd2_end_commit {};

struct trace_event_data_offsets_jbd2_submit_inode_data {};

struct trace_event_data_offsets_jbd2_handle_start_class {};

struct trace_event_data_offsets_jbd2_handle_extend {};

struct trace_event_data_offsets_jbd2_handle_stats {};

struct trace_event_data_offsets_jbd2_run_stats {};

struct trace_event_data_offsets_jbd2_checkpoint_stats {};

struct trace_event_data_offsets_jbd2_update_log_tail {};

struct trace_event_data_offsets_jbd2_write_superblock {};

struct trace_event_data_offsets_jbd2_lock_buffer_stall {};

typedef void (*btf_trace_jbd2_checkpoint)(void *, journal_t *, int);

typedef void (*btf_trace_jbd2_start_commit)(void *, journal_t *, transaction_t *);

typedef void (*btf_trace_jbd2_commit_locking)(void *, journal_t *, transaction_t *);

typedef void (*btf_trace_jbd2_commit_flushing)(void *, journal_t *, transaction_t *);

typedef void (*btf_trace_jbd2_commit_logging)(void *, journal_t *, transaction_t *);

typedef void (*btf_trace_jbd2_drop_transaction)(void *, journal_t *, transaction_t *);

typedef void (*btf_trace_jbd2_end_commit)(void *, journal_t *, transaction_t *);

typedef void (*btf_trace_jbd2_submit_inode_data)(void *, struct inode *);

typedef void (*btf_trace_jbd2_handle_start)(void *, dev_t, long unsigned int, unsigned int, unsigned int, int);

typedef void (*btf_trace_jbd2_handle_restart)(void *, dev_t, long unsigned int, unsigned int, unsigned int, int);

typedef void (*btf_trace_jbd2_handle_extend)(void *, dev_t, long unsigned int, unsigned int, unsigned int, int, int);

typedef void (*btf_trace_jbd2_handle_stats)(void *, dev_t, long unsigned int, unsigned int, unsigned int, int, int, int, int);

typedef void (*btf_trace_jbd2_run_stats)(void *, dev_t, long unsigned int, struct transaction_run_stats_s *);

typedef void (*btf_trace_jbd2_checkpoint_stats)(void *, dev_t, long unsigned int, struct transaction_chp_stats_s *);

typedef void (*btf_trace_jbd2_update_log_tail)(void *, journal_t *, tid_t, long unsigned int, long unsigned int);

typedef void (*btf_trace_jbd2_write_superblock)(void *, journal_t *, int);

typedef void (*btf_trace_jbd2_lock_buffer_stall)(void *, dev_t, long unsigned int);

struct jbd2_stats_proc_session {
	journal_t *journal;
	struct transaction_stats_s *stats;
	int start;
	int max;
};

struct ramfs_mount_opts {
	umode_t mode;
};

struct ramfs_fs_info {
	struct ramfs_mount_opts mount_opts;
};

enum ramfs_param {
	Opt_mode___3 = 0,
};

enum hugetlbfs_size_type {
	NO_SIZE = 0,
	SIZE_STD = 1,
	SIZE_PERCENT = 2,
};

struct hugetlbfs_fs_context {
	struct hstate *hstate;
	long long unsigned int max_size_opt;
	long long unsigned int min_size_opt;
	long int max_hpages;
	long int nr_inodes;
	long int min_hpages;
	enum hugetlbfs_size_type max_val_type;
	enum hugetlbfs_size_type min_val_type;
	kuid_t uid;
	kgid_t gid;
	umode_t mode;
};

enum hugetlb_param {
	Opt_gid___4 = 0,
	Opt_min_size = 1,
	Opt_mode___4 = 2,
	Opt_nr_inodes___2 = 3,
	Opt_pagesize = 4,
	Opt_size___2 = 5,
	Opt_uid___3 = 6,
};

typedef u16 wchar_t;

struct nls_table {
	const char *charset;
	const char *alias;
	int (*uni2char)(wchar_t, unsigned char *, int);
	int (*char2uni)(const unsigned char *, int, wchar_t *);
	const unsigned char *charset2lower;
	const unsigned char *charset2upper;
	struct module *owner;
	struct nls_table *next;
};

struct fat_mount_options {
	kuid_t fs_uid;
	kgid_t fs_gid;
	short unsigned int fs_fmask;
	short unsigned int fs_dmask;
	short unsigned int codepage;
	int time_offset;
	char *iocharset;
	short unsigned int shortname;
	unsigned char name_check;
	unsigned char errors;
	unsigned char nfs;
	short unsigned int allow_utime;
	unsigned int quiet: 1;
	unsigned int showexec: 1;
	unsigned int sys_immutable: 1;
	unsigned int dotsOK: 1;
	unsigned int isvfat: 1;
	unsigned int utf8: 1;
	unsigned int unicode_xlate: 1;
	unsigned int numtail: 1;
	unsigned int flush: 1;
	unsigned int nocase: 1;
	unsigned int usefree: 1;
	unsigned int tz_set: 1;
	unsigned int rodir: 1;
	unsigned int discard: 1;
	unsigned int dos1xfloppy: 1;
};

struct fatent_operations;

struct msdos_sb_info {
	short unsigned int sec_per_clus;
	short unsigned int cluster_bits;
	unsigned int cluster_size;
	unsigned char fats;
	unsigned char fat_bits;
	short unsigned int fat_start;
	long unsigned int fat_length;
	long unsigned int dir_start;
	short unsigned int dir_entries;
	long unsigned int data_start;
	long unsigned int max_cluster;
	long unsigned int root_cluster;
	long unsigned int fsinfo_sector;
	struct mutex fat_lock;
	struct mutex nfs_build_inode_lock;
	struct mutex s_lock;
	unsigned int prev_free;
	unsigned int free_clusters;
	unsigned int free_clus_valid;
	struct fat_mount_options options;
	struct nls_table *nls_disk;
	struct nls_table *nls_io;
	const void *dir_ops;
	int dir_per_block;
	int dir_per_block_bits;
	unsigned int vol_id;
	int fatent_shift;
	const struct fatent_operations *fatent_ops;
	struct inode *fat_inode;
	struct inode *fsinfo_inode;
	struct ratelimit_state ratelimit;
	spinlock_t inode_hash_lock;
	struct hlist_head inode_hashtable[256];
	spinlock_t dir_hash_lock;
	struct hlist_head dir_hashtable[256];
	unsigned int dirty;
	struct callback_head rcu;
};

struct fat_entry;

struct fatent_operations {
	void (*ent_blocknr)(struct super_block *, int, int *, sector_t *);
	void (*ent_set_ptr)(struct fat_entry *, int);
	int (*ent_bread)(struct super_block *, struct fat_entry *, int, sector_t);
	int (*ent_get)(struct fat_entry *);
	void (*ent_put)(struct fat_entry *, int);
	int (*ent_next)(struct fat_entry *);
};

struct msdos_inode_info {
	spinlock_t cache_lru_lock;
	struct list_head cache_lru;
	int nr_caches;
	unsigned int cache_valid_id;
	loff_t mmu_private;
	int i_start;
	int i_logstart;
	int i_attrs;
	loff_t i_pos;
	struct hlist_node i_fat_hash;
	struct hlist_node i_dir_hash;
	struct rw_semaphore truncate_lock;
	struct inode vfs_inode;
};

struct fat_entry {
	int entry;
	union {
		u8 *ent12_p[2];
		__le16 *ent16_p;
		__le32 *ent32_p;
	} u;
	int nr_bhs;
	struct buffer_head *bhs[2];
	struct inode *fat_inode;
};

struct fat_cache {
	struct list_head cache_list;
	int nr_contig;
	int fcluster;
	int dcluster;
};

struct fat_cache_id {
	unsigned int id;
	int nr_contig;
	int fcluster;
	int dcluster;
};

enum utf16_endian {
	UTF16_HOST_ENDIAN = 0,
	UTF16_LITTLE_ENDIAN = 1,
	UTF16_BIG_ENDIAN = 2,
};

struct __fat_dirent {
	long int d_ino;
	__kernel_off_t d_off;
	short unsigned int d_reclen;
	char d_name[256];
};

struct msdos_dir_entry {
	__u8 name[11];
	__u8 attr;
	__u8 lcase;
	__u8 ctime_cs;
	__le16 ctime;
	__le16 cdate;
	__le16 adate;
	__le16 starthi;
	__le16 time;
	__le16 date;
	__le16 start;
	__le32 size;
};

struct msdos_dir_slot {
	__u8 id;
	__u8 name0_4[10];
	__u8 attr;
	__u8 reserved;
	__u8 alias_checksum;
	__u8 name5_10[12];
	__le16 start;
	__u8 name11_12[4];
};

struct fat_slot_info {
	loff_t i_pos;
	loff_t slot_off;
	int nr_slots;
	struct msdos_dir_entry *de;
	struct buffer_head *bh;
};

typedef long long unsigned int llu;

enum {
	PARSE_INVALID = 1,
	PARSE_NOT_LONGNAME = 2,
	PARSE_EOF = 3,
};

struct fat_ioctl_filldir_callback {
	struct dir_context ctx;
	void *dirent;
	int result;
	const char *longname;
	int long_len;
	const char *shortname;
	int short_len;
};

struct fatent_ra {
	sector_t cur;
	sector_t limit;
	unsigned int ra_blocks;
	sector_t ra_advance;
	sector_t ra_next;
	sector_t ra_limit;
};

struct fat_boot_sector {
	__u8 ignored[3];
	__u8 system_id[8];
	__u8 sector_size[2];
	__u8 sec_per_clus;
	__le16 reserved;
	__u8 fats;
	__u8 dir_entries[2];
	__u8 sectors[2];
	__u8 media;
	__le16 fat_length;
	__le16 secs_track;
	__le16 heads;
	__le32 hidden;
	__le32 total_sect;
	union {
		struct {
			__u8 drive_number;
			__u8 state;
			__u8 signature;
			__u8 vol_id[4];
			__u8 vol_label[11];
			__u8 fs_type[8];
		} fat16;
		struct {
			__le32 length;
			__le16 flags;
			__u8 version[2];
			__le32 root_cluster;
			__le16 info_sector;
			__le16 backup_boot;
			__le16 reserved2[6];
			__u8 drive_number;
			__u8 state;
			__u8 signature;
			__u8 vol_id[4];
			__u8 vol_label[11];
			__u8 fs_type[8];
		} fat32;
	};
};

struct fat_boot_fsinfo {
	__le32 signature1;
	__le32 reserved1[120];
	__le32 signature2;
	__le32 free_clusters;
	__le32 next_cluster;
	__le32 reserved2[4];
};

struct fat_bios_param_block {
	u16 fat_sector_size;
	u8 fat_sec_per_clus;
	u16 fat_reserved;
	u8 fat_fats;
	u16 fat_dir_entries;
	u16 fat_sectors;
	u16 fat_fat_length;
	u32 fat_total_sect;
	u8 fat16_state;
	u32 fat16_vol_id;
	u32 fat32_length;
	u32 fat32_root_cluster;
	u16 fat32_info_sector;
	u8 fat32_state;
	u32 fat32_vol_id;
};

struct fat_floppy_defaults {
	unsigned int nr_sectors;
	unsigned int sec_per_clus;
	unsigned int dir_entries;
	unsigned int media;
	unsigned int fat_length;
};

enum {
	Opt_check_n = 0,
	Opt_check_r = 1,
	Opt_check_s = 2,
	Opt_uid___4 = 3,
	Opt_gid___5 = 4,
	Opt_umask = 5,
	Opt_dmask = 6,
	Opt_fmask = 7,
	Opt_allow_utime = 8,
	Opt_codepage = 9,
	Opt_usefree = 10,
	Opt_nocase = 11,
	Opt_quiet = 12,
	Opt_showexec = 13,
	Opt_debug___2 = 14,
	Opt_immutable = 15,
	Opt_dots = 16,
	Opt_nodots = 17,
	Opt_charset = 18,
	Opt_shortname_lower = 19,
	Opt_shortname_win95 = 20,
	Opt_shortname_winnt = 21,
	Opt_shortname_mixed = 22,
	Opt_utf8_no = 23,
	Opt_utf8_yes = 24,
	Opt_uni_xl_no = 25,
	Opt_uni_xl_yes = 26,
	Opt_nonumtail_no = 27,
	Opt_nonumtail_yes = 28,
	Opt_obsolete = 29,
	Opt_flush = 30,
	Opt_tz_utc = 31,
	Opt_rodir = 32,
	Opt_err_cont___2 = 33,
	Opt_err_panic___2 = 34,
	Opt_err_ro___2 = 35,
	Opt_discard___2 = 36,
	Opt_nfs = 37,
	Opt_time_offset = 38,
	Opt_nfs_stale_rw = 39,
	Opt_nfs_nostale_ro = 40,
	Opt_err___3 = 41,
	Opt_dos1xfloppy = 42,
};

struct fat_fid {
	u32 i_gen;
	u32 i_pos_low;
	u16 i_pos_hi;
	u16 parent_i_pos_hi;
	u32 parent_i_pos_low;
	u32 parent_i_gen;
};

struct shortname_info {
	unsigned char lower: 1;
	unsigned char upper: 1;
	unsigned char valid: 1;
};

struct in_addr {
	__be32 s_addr;
};

struct sockaddr_in {
	__kernel_sa_family_t sin_family;
	__be16 sin_port;
	struct in_addr sin_addr;
	unsigned char __pad[8];
};

struct sockaddr_in6 {
	short unsigned int sin6_family;
	__be16 sin6_port;
	__be32 sin6_flowinfo;
	struct in6_addr sin6_addr;
	__u32 sin6_scope_id;
};

enum rpc_auth_flavors {
	RPC_AUTH_NULL = 0,
	RPC_AUTH_UNIX = 1,
	RPC_AUTH_SHORT = 2,
	RPC_AUTH_DES = 3,
	RPC_AUTH_KRB = 4,
	RPC_AUTH_GSS = 6,
	RPC_AUTH_MAXFLAVOR = 8,
	RPC_AUTH_GSS_KRB5 = 390003,
	RPC_AUTH_GSS_KRB5I = 390004,
	RPC_AUTH_GSS_KRB5P = 390005,
	RPC_AUTH_GSS_LKEY = 390006,
	RPC_AUTH_GSS_LKEYI = 390007,
	RPC_AUTH_GSS_LKEYP = 390008,
	RPC_AUTH_GSS_SPKM = 390009,
	RPC_AUTH_GSS_SPKMI = 390010,
	RPC_AUTH_GSS_SPKMP = 390011,
};

struct xdr_netobj {
	unsigned int len;
	u8 *data;
};

struct rpc_task_setup {
	struct rpc_task *task;
	struct rpc_clnt *rpc_client;
	struct rpc_xprt *rpc_xprt;
	struct rpc_cred *rpc_op_cred;
	const struct rpc_message *rpc_message;
	const struct rpc_call_ops *callback_ops;
	void *callback_data;
	struct workqueue_struct *workqueue;
	short unsigned int flags;
	signed char priority;
};

enum rpc_display_format_t {
	RPC_DISPLAY_ADDR = 0,
	RPC_DISPLAY_PORT = 1,
	RPC_DISPLAY_PROTO = 2,
	RPC_DISPLAY_HEX_ADDR = 3,
	RPC_DISPLAY_HEX_PORT = 4,
	RPC_DISPLAY_NETID = 5,
	RPC_DISPLAY_MAX = 6,
};

enum xprt_transports {
	XPRT_TRANSPORT_UDP = 17,
	XPRT_TRANSPORT_TCP = 6,
	XPRT_TRANSPORT_BC_TCP = 2147483654,
	XPRT_TRANSPORT_RDMA = 256,
	XPRT_TRANSPORT_BC_RDMA = 2147483904,
	XPRT_TRANSPORT_LOCAL = 257,
};

struct svc_xprt_class;

struct svc_xprt_ops;

struct svc_xprt {
	struct svc_xprt_class *xpt_class;
	const struct svc_xprt_ops *xpt_ops;
	struct kref xpt_ref;
	struct list_head xpt_list;
	struct list_head xpt_ready;
	long unsigned int xpt_flags;
	struct svc_serv *xpt_server;
	atomic_t xpt_reserved;
	atomic_t xpt_nr_rqsts;
	struct mutex xpt_mutex;
	spinlock_t xpt_lock;
	void *xpt_auth_cache;
	struct list_head xpt_deferred;
	struct __kernel_sockaddr_storage xpt_local;
	size_t xpt_locallen;
	struct __kernel_sockaddr_storage xpt_remote;
	size_t xpt_remotelen;
	char xpt_remotebuf[58];
	struct list_head xpt_users;
	struct net *xpt_net;
	const struct cred *xpt_cred;
	struct rpc_xprt *xpt_bc_xprt;
	struct rpc_xprt_switch *xpt_bc_xps;
};

struct svc_program;

struct svc_stat;

struct svc_pool;

struct svc_serv_ops;

struct svc_serv {
	struct svc_program *sv_program;
	struct svc_stat *sv_stats;
	spinlock_t sv_lock;
	unsigned int sv_nrthreads;
	unsigned int sv_maxconn;
	unsigned int sv_max_payload;
	unsigned int sv_max_mesg;
	unsigned int sv_xdrsize;
	struct list_head sv_permsocks;
	struct list_head sv_tempsocks;
	int sv_tmpcnt;
	struct timer_list sv_temptimer;
	char *sv_name;
	unsigned int sv_nrpools;
	struct svc_pool *sv_pools;
	const struct svc_serv_ops *sv_ops;
	struct list_head sv_cb_list;
	spinlock_t sv_cb_lock;
	wait_queue_head_t sv_cb_waitq;
	bool sv_bc_enabled;
};

struct svc_stat {
	struct svc_program *program;
	unsigned int netcnt;
	unsigned int netudpcnt;
	unsigned int nettcpcnt;
	unsigned int nettcpconn;
	unsigned int rpccnt;
	unsigned int rpcbadfmt;
	unsigned int rpcbadauth;
	unsigned int rpcbadclnt;
};

struct svc_version;

struct svc_rqst;

struct svc_process_info;

struct svc_program {
	struct svc_program *pg_next;
	u32 pg_prog;
	unsigned int pg_lovers;
	unsigned int pg_hivers;
	unsigned int pg_nvers;
	const struct svc_version **pg_vers;
	char *pg_name;
	char *pg_class;
	struct svc_stat *pg_stats;
	int (*pg_authenticate)(struct svc_rqst *);
	__be32 (*pg_init_request)(struct svc_rqst *, const struct svc_program *, struct svc_process_info *);
	int (*pg_rpcbind_set)(struct net *, const struct svc_program *, u32, int, short unsigned int, short unsigned int);
};

struct rpc_pipe_msg {
	struct list_head list;
	void *data;
	size_t len;
	size_t copied;
	int errno;
};

struct rpc_pipe_ops {
	ssize_t (*upcall)(struct file *, struct rpc_pipe_msg *, char *, size_t);
	ssize_t (*downcall)(struct file *, const char *, size_t);
	void (*release_pipe)(struct inode *);
	int (*open_pipe)(struct inode *);
	void (*destroy_msg)(struct rpc_pipe_msg *);
};

struct rpc_pipe {
	struct list_head pipe;
	struct list_head in_upcall;
	struct list_head in_downcall;
	int pipelen;
	int nreaders;
	int nwriters;
	int flags;
	struct delayed_work queue_timeout;
	const struct rpc_pipe_ops *ops;
	spinlock_t lock;
	struct dentry *dentry;
};

struct rpc_iostats {
	spinlock_t om_lock;
	long unsigned int om_ops;
	long unsigned int om_ntrans;
	long unsigned int om_timeouts;
	long long unsigned int om_bytes_sent;
	long long unsigned int om_bytes_recv;
	ktime_t om_queue;
	ktime_t om_rtt;
	ktime_t om_execute;
	long unsigned int om_error_status;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct rpc_create_args {
	struct net *net;
	int protocol;
	struct sockaddr *address;
	size_t addrsize;
	struct sockaddr *saddress;
	const struct rpc_timeout *timeout;
	const char *servername;
	const char *nodename;
	const struct rpc_program *program;
	u32 prognumber;
	u32 version;
	rpc_authflavor_t authflavor;
	u32 nconnect;
	long unsigned int flags;
	char *client_name;
	struct svc_xprt *bc_xprt;
	const struct cred *cred;
};

enum pnfs_iomode {
	IOMODE_READ = 1,
	IOMODE_RW = 2,
	IOMODE_ANY = 3,
};

struct nfs4_deviceid {
	char data[16];
};

struct gss_api_mech;

struct gss_ctx {
	struct gss_api_mech *mech_type;
	void *internal_ctx_id;
	unsigned int slack;
	unsigned int align;
};

struct gss_api_ops;

struct pf_desc;

struct gss_api_mech {
	struct list_head gm_list;
	struct module *gm_owner;
	struct rpcsec_gss_oid gm_oid;
	char *gm_name;
	const struct gss_api_ops *gm_ops;
	int gm_pf_num;
	struct pf_desc *gm_pfs;
	const char *gm_upcall_enctypes;
};

struct auth_domain;

struct pf_desc {
	u32 pseudoflavor;
	u32 qop;
	u32 service;
	char *name;
	char *auth_domain_name;
	struct auth_domain *domain;
	bool datatouch;
};

struct auth_ops;

struct auth_domain {
	struct kref ref;
	struct hlist_node hash;
	char *name;
	struct auth_ops *flavour;
	struct callback_head callback_head;
};

struct gss_api_ops {
	int (*gss_import_sec_context)(const void *, size_t, struct gss_ctx *, time64_t *, gfp_t);
	u32 (*gss_get_mic)(struct gss_ctx *, struct xdr_buf *, struct xdr_netobj *);
	u32 (*gss_verify_mic)(struct gss_ctx *, struct xdr_buf *, struct xdr_netobj *);
	u32 (*gss_wrap)(struct gss_ctx *, int, struct xdr_buf *, struct page **);
	u32 (*gss_unwrap)(struct gss_ctx *, int, int, struct xdr_buf *);
	void (*gss_delete_sec_context)(void *);
};

struct nfs4_xdr_opaque_data;

struct nfs4_xdr_opaque_ops {
	void (*encode)(struct xdr_stream *, const void *, const struct nfs4_xdr_opaque_data *);
	void (*free)(struct nfs4_xdr_opaque_data *);
};

struct nfs4_xdr_opaque_data {
	const struct nfs4_xdr_opaque_ops *ops;
	void *data;
};

struct nfs4_layoutdriver_data {
	struct page **pages;
	__u32 pglen;
	__u32 len;
};

struct pnfs_layout_range {
	u32 iomode;
	u64 offset;
	u64 length;
};

struct nfs4_layoutget_res {
	struct nfs4_sequence_res seq_res;
	int status;
	__u32 return_on_close;
	struct pnfs_layout_range range;
	__u32 type;
	nfs4_stateid stateid;
	struct nfs4_layoutdriver_data *layoutp;
};

struct pnfs_device {
	struct nfs4_deviceid dev_id;
	unsigned int layout_type;
	unsigned int mincount;
	unsigned int maxcount;
	struct page **pages;
	unsigned int pgbase;
	unsigned int pglen;
	unsigned char nocache: 1;
};

struct nfs4_layoutcommit_args {
	struct nfs4_sequence_args seq_args;
	nfs4_stateid stateid;
	__u64 lastbytewritten;
	struct inode *inode;
	const u32 *bitmask;
	size_t layoutupdate_len;
	struct page *layoutupdate_page;
	struct page **layoutupdate_pages;
	__be32 *start_p;
};

struct nfs4_layoutcommit_res {
	struct nfs4_sequence_res seq_res;
	struct nfs_fattr *fattr;
	const struct nfs_server *server;
	int status;
};

struct nfs4_layoutcommit_data {
	struct rpc_task task;
	struct nfs_fattr fattr;
	struct list_head lseg_list;
	const struct cred *cred;
	struct inode *inode;
	struct nfs4_layoutcommit_args args;
	struct nfs4_layoutcommit_res res;
};

struct pnfs_layout_hdr;

struct nfs4_layoutreturn_args {
	struct nfs4_sequence_args seq_args;
	struct pnfs_layout_hdr *layout;
	struct inode *inode;
	struct pnfs_layout_range range;
	nfs4_stateid stateid;
	__u32 layout_type;
	struct nfs4_xdr_opaque_data *ld_private;
};

struct pnfs_layout_hdr {
	refcount_t plh_refcount;
	atomic_t plh_outstanding;
	struct list_head plh_layouts;
	struct list_head plh_bulk_destroy;
	struct list_head plh_segs;
	struct list_head plh_return_segs;
	long unsigned int plh_block_lgets;
	long unsigned int plh_retry_timestamp;
	long unsigned int plh_flags;
	nfs4_stateid plh_stateid;
	u32 plh_barrier;
	u32 plh_return_seq;
	enum pnfs_iomode plh_return_iomode;
	loff_t plh_lwb;
	const struct cred *plh_lc_cred;
	struct inode *plh_inode;
	struct callback_head plh_rcu;
};

struct nfs42_layoutstat_devinfo;

struct nfs42_layoutstat_args {
	struct nfs4_sequence_args seq_args;
	struct nfs_fh *fh;
	struct inode *inode;
	nfs4_stateid stateid;
	int num_dev;
	struct nfs42_layoutstat_devinfo *devinfo;
};

struct nfs42_layoutstat_devinfo {
	struct nfs4_deviceid dev_id;
	__u64 offset;
	__u64 length;
	__u64 read_count;
	__u64 read_bytes;
	__u64 write_count;
	__u64 write_bytes;
	__u32 layout_type;
	struct nfs4_xdr_opaque_data ld_private;
};

struct pnfs_layout_segment {
	struct list_head pls_list;
	struct list_head pls_lc_list;
	struct list_head pls_commits;
	struct pnfs_layout_range pls_range;
	refcount_t pls_refcount;
	u32 pls_seq;
	long unsigned int pls_flags;
	struct pnfs_layout_hdr *pls_layout;
};

struct nfs_page {
	struct list_head wb_list;
	struct page *wb_page;
	struct nfs_lock_context *wb_lock_context;
	long unsigned int wb_index;
	unsigned int wb_offset;
	unsigned int wb_pgbase;
	unsigned int wb_bytes;
	struct kref wb_kref;
	long unsigned int wb_flags;
	struct nfs_write_verifier wb_verf;
	struct nfs_page *wb_this_page;
	struct nfs_page *wb_head;
	short unsigned int wb_nio;
};

struct nfs_subversion {
	struct module *owner;
	struct file_system_type *nfs_fs;
	const struct rpc_version *rpc_vers;
	const struct nfs_rpc_ops *rpc_ops;
	const struct super_operations *sops;
	const struct xattr_handler **xattr;
	struct list_head list;
};

struct nfs_iostats {
	long long unsigned int bytes[8];
	long unsigned int events[27];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

enum pnfs_try_status {
	PNFS_ATTEMPTED = 0,
	PNFS_NOT_ATTEMPTED = 1,
	PNFS_TRY_AGAIN = 2,
};

struct nfs_pageio_ops;

struct nfs4_deviceid_node;

struct pnfs_layoutdriver_type {
	struct list_head pnfs_tblid;
	const u32 id;
	const char *name;
	struct module *owner;
	unsigned int flags;
	unsigned int max_deviceinfo_size;
	unsigned int max_layoutget_response;
	int (*set_layoutdriver)(struct nfs_server *, const struct nfs_fh *);
	int (*clear_layoutdriver)(struct nfs_server *);
	struct pnfs_layout_hdr * (*alloc_layout_hdr)(struct inode *, gfp_t);
	void (*free_layout_hdr)(struct pnfs_layout_hdr *);
	struct pnfs_layout_segment * (*alloc_lseg)(struct pnfs_layout_hdr *, struct nfs4_layoutget_res *, gfp_t);
	void (*free_lseg)(struct pnfs_layout_segment *);
	void (*add_lseg)(struct pnfs_layout_hdr *, struct pnfs_layout_segment *, struct list_head *);
	void (*return_range)(struct pnfs_layout_hdr *, struct pnfs_layout_range *);
	const struct nfs_pageio_ops *pg_read_ops;
	const struct nfs_pageio_ops *pg_write_ops;
	struct pnfs_ds_commit_info * (*get_ds_info)(struct inode *);
	int (*sync)(struct inode *, bool);
	enum pnfs_try_status (*read_pagelist)(struct nfs_pgio_header *);
	enum pnfs_try_status (*write_pagelist)(struct nfs_pgio_header *, int);
	void (*free_deviceid_node)(struct nfs4_deviceid_node *);
	struct nfs4_deviceid_node * (*alloc_deviceid_node)(struct nfs_server *, struct pnfs_device *, gfp_t);
	int (*prepare_layoutreturn)(struct nfs4_layoutreturn_args *);
	void (*cleanup_layoutcommit)(struct nfs4_layoutcommit_data *);
	int (*prepare_layoutcommit)(struct nfs4_layoutcommit_args *);
	int (*prepare_layoutstats)(struct nfs42_layoutstat_args *);
};

struct svc_cred {
	kuid_t cr_uid;
	kgid_t cr_gid;
	struct group_info *cr_group_info;
	u32 cr_flavor;
	char *cr_raw_principal;
	char *cr_principal;
	char *cr_targ_princ;
	struct gss_api_mech *cr_gss_mech;
};

struct cache_deferred_req;

struct cache_req {
	struct cache_deferred_req * (*defer)(struct cache_req *);
	int thread_wait;
};

struct svc_cacherep;

struct svc_procedure;

struct svc_deferred_req;

struct svc_rqst {
	struct list_head rq_all;
	struct callback_head rq_rcu_head;
	struct svc_xprt *rq_xprt;
	struct __kernel_sockaddr_storage rq_addr;
	size_t rq_addrlen;
	struct __kernel_sockaddr_storage rq_daddr;
	size_t rq_daddrlen;
	struct svc_serv *rq_server;
	struct svc_pool *rq_pool;
	const struct svc_procedure *rq_procinfo;
	struct auth_ops *rq_authop;
	struct svc_cred rq_cred;
	void *rq_xprt_ctxt;
	struct svc_deferred_req *rq_deferred;
	size_t rq_xprt_hlen;
	struct xdr_buf rq_arg;
	struct xdr_buf rq_res;
	struct page *rq_pages[260];
	struct page **rq_respages;
	struct page **rq_next_page;
	struct page **rq_page_end;
	struct kvec rq_vec[259];
	struct bio_vec rq_bvec[259];
	__be32 rq_xid;
	u32 rq_prog;
	u32 rq_vers;
	u32 rq_proc;
	u32 rq_prot;
	int rq_cachetype;
	long unsigned int rq_flags;
	ktime_t rq_qtime;
	void *rq_argp;
	void *rq_resp;
	void *rq_auth_data;
	int rq_auth_slack;
	int rq_reserved;
	ktime_t rq_stime;
	struct cache_req rq_chandle;
	struct auth_domain *rq_client;
	struct auth_domain *rq_gssclient;
	struct svc_cacherep *rq_cacherep;
	struct task_struct *rq_task;
	spinlock_t rq_lock;
	struct net *rq_bc_net;
	void **rq_lease_breaker;
};

struct nlmclnt_initdata {
	const char *hostname;
	const struct sockaddr *address;
	size_t addrlen;
	short unsigned int protocol;
	u32 nfs_version;
	int noresvport;
	struct net *net;
	const struct nlmclnt_operations *nlmclnt_ops;
	const struct cred *cred;
};

struct cache_head {
	struct hlist_node cache_list;
	time64_t expiry_time;
	time64_t last_refresh;
	struct kref ref;
	long unsigned int flags;
};

struct cache_detail {
	struct module *owner;
	int hash_size;
	struct hlist_head *hash_table;
	spinlock_t hash_lock;
	char *name;
	void (*cache_put)(struct kref *);
	int (*cache_upcall)(struct cache_detail *, struct cache_head *);
	void (*cache_request)(struct cache_detail *, struct cache_head *, char **, int *);
	int (*cache_parse)(struct cache_detail *, char *, int);
	int (*cache_show)(struct seq_file *, struct cache_detail *, struct cache_head *);
	void (*warn_no_listener)(struct cache_detail *, int);
	struct cache_head * (*alloc)();
	void (*flush)();
	int (*match)(struct cache_head *, struct cache_head *);
	void (*init)(struct cache_head *, struct cache_head *);
	void (*update)(struct cache_head *, struct cache_head *);
	time64_t flush_time;
	struct list_head others;
	time64_t nextcheck;
	int entries;
	struct list_head queue;
	atomic_t writers;
	time64_t last_close;
	time64_t last_warn;
	union {
		struct proc_dir_entry *procfs;
		struct dentry *pipefs;
	};
	struct net *net;
};

struct cache_deferred_req {
	struct hlist_node hash;
	struct list_head recent;
	struct cache_head *item;
	void *owner;
	void (*revisit)(struct cache_deferred_req *, int);
};

struct auth_ops {
	char *name;
	struct module *owner;
	int flavour;
	int (*accept)(struct svc_rqst *, __be32 *);
	int (*release)(struct svc_rqst *);
	void (*domain_release)(struct auth_domain *);
	int (*set_client)(struct svc_rqst *);
};

struct svc_pool_stats {
	atomic_long_t packets;
	long unsigned int sockets_queued;
	atomic_long_t threads_woken;
	atomic_long_t threads_timedout;
};

struct svc_pool {
	unsigned int sp_id;
	spinlock_t sp_lock;
	struct list_head sp_sockets;
	unsigned int sp_nrthreads;
	struct list_head sp_all_threads;
	struct svc_pool_stats sp_stats;
	long unsigned int sp_flags;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct svc_serv_ops {
	void (*svo_shutdown)(struct svc_serv *, struct net *);
	int (*svo_function)(void *);
	void (*svo_enqueue_xprt)(struct svc_xprt *);
	int (*svo_setup)(struct svc_serv *, struct svc_pool *, int);
	struct module *svo_module;
};

struct svc_procedure {
	__be32 (*pc_func)(struct svc_rqst *);
	int (*pc_decode)(struct svc_rqst *, __be32 *);
	int (*pc_encode)(struct svc_rqst *, __be32 *);
	void (*pc_release)(struct svc_rqst *);
	unsigned int pc_argsize;
	unsigned int pc_ressize;
	unsigned int pc_cachetype;
	unsigned int pc_xdrressize;
};

struct svc_deferred_req {
	u32 prot;
	struct svc_xprt *xprt;
	struct __kernel_sockaddr_storage addr;
	size_t addrlen;
	struct __kernel_sockaddr_storage daddr;
	size_t daddrlen;
	struct cache_deferred_req handle;
	size_t xprt_hlen;
	int argslen;
	__be32 args[0];
};

struct svc_process_info {
	union {
		int (*dispatch)(struct svc_rqst *, __be32 *);
		struct {
			unsigned int lovers;
			unsigned int hivers;
		} mismatch;
	};
};

struct svc_version {
	u32 vs_vers;
	u32 vs_nproc;
	const struct svc_procedure *vs_proc;
	unsigned int *vs_count;
	u32 vs_xdrsize;
	bool vs_hidden;
	bool vs_rpcb_optnl;
	bool vs_need_cong_ctrl;
	int (*vs_dispatch)(struct svc_rqst *, __be32 *);
};

struct svc_xprt_ops {
	struct svc_xprt * (*xpo_create)(struct svc_serv *, struct net *, struct sockaddr *, int, int);
	struct svc_xprt * (*xpo_accept)(struct svc_xprt *);
	int (*xpo_has_wspace)(struct svc_xprt *);
	int (*xpo_recvfrom)(struct svc_rqst *);
	int (*xpo_sendto)(struct svc_rqst *);
	int (*xpo_read_payload)(struct svc_rqst *, unsigned int, unsigned int);
	void (*xpo_release_rqst)(struct svc_rqst *);
	void (*xpo_detach)(struct svc_xprt *);
	void (*xpo_free)(struct svc_xprt *);
	void (*xpo_secure_port)(struct svc_rqst *);
	void (*xpo_kill_temp_xprt)(struct svc_xprt *);
};

struct svc_xprt_class {
	const char *xcl_name;
	struct module *xcl_owner;
	const struct svc_xprt_ops *xcl_ops;
	struct list_head xcl_list;
	u32 xcl_max_payload;
	int xcl_ident;
};

enum nfs_stat_bytecounters {
	NFSIOS_NORMALREADBYTES = 0,
	NFSIOS_NORMALWRITTENBYTES = 1,
	NFSIOS_DIRECTREADBYTES = 2,
	NFSIOS_DIRECTWRITTENBYTES = 3,
	NFSIOS_SERVERREADBYTES = 4,
	NFSIOS_SERVERWRITTENBYTES = 5,
	NFSIOS_READPAGES = 6,
	NFSIOS_WRITEPAGES = 7,
	__NFSIOS_BYTESMAX = 8,
};

enum nfs_stat_eventcounters {
	NFSIOS_INODEREVALIDATE = 0,
	NFSIOS_DENTRYREVALIDATE = 1,
	NFSIOS_DATAINVALIDATE = 2,
	NFSIOS_ATTRINVALIDATE = 3,
	NFSIOS_VFSOPEN = 4,
	NFSIOS_VFSLOOKUP = 5,
	NFSIOS_VFSACCESS = 6,
	NFSIOS_VFSUPDATEPAGE = 7,
	NFSIOS_VFSREADPAGE = 8,
	NFSIOS_VFSREADPAGES = 9,
	NFSIOS_VFSWRITEPAGE = 10,
	NFSIOS_VFSWRITEPAGES = 11,
	NFSIOS_VFSGETDENTS = 12,
	NFSIOS_VFSSETATTR = 13,
	NFSIOS_VFSFLUSH = 14,
	NFSIOS_VFSFSYNC = 15,
	NFSIOS_VFSLOCK = 16,
	NFSIOS_VFSRELEASE = 17,
	NFSIOS_CONGESTIONWAIT = 18,
	NFSIOS_SETATTRTRUNC = 19,
	NFSIOS_EXTENDWRITE = 20,
	NFSIOS_SILLYRENAME = 21,
	NFSIOS_SHORTREAD = 22,
	NFSIOS_SHORTWRITE = 23,
	NFSIOS_DELAY = 24,
	NFSIOS_PNFS_READ = 25,
	NFSIOS_PNFS_WRITE = 26,
	__NFSIOS_COUNTSMAX = 27,
};

struct nfs_pageio_descriptor;

struct nfs_pgio_mirror;

struct nfs_pageio_ops {
	void (*pg_init)(struct nfs_pageio_descriptor *, struct nfs_page *);
	size_t (*pg_test)(struct nfs_pageio_descriptor *, struct nfs_page *, struct nfs_page *);
	int (*pg_doio)(struct nfs_pageio_descriptor *);
	unsigned int (*pg_get_mirror_count)(struct nfs_pageio_descriptor *, struct nfs_page *);
	void (*pg_cleanup)(struct nfs_pageio_descriptor *);
	struct nfs_pgio_mirror * (*pg_get_mirror)(struct nfs_pageio_descriptor *, u32);
	u32 (*pg_set_mirror)(struct nfs_pageio_descriptor *, u32);
};

struct nfs_pgio_mirror {
	struct list_head pg_list;
	long unsigned int pg_bytes_written;
	size_t pg_count;
	size_t pg_bsize;
	unsigned int pg_base;
	unsigned char pg_recoalesce: 1;
};

struct nfs_pageio_descriptor {
	struct inode *pg_inode;
	const struct nfs_pageio_ops *pg_ops;
	const struct nfs_rw_ops *pg_rw_ops;
	int pg_ioflags;
	int pg_error;
	const struct rpc_call_ops *pg_rpc_callops;
	const struct nfs_pgio_completion_ops *pg_completion_ops;
	struct pnfs_layout_segment *pg_lseg;
	struct nfs_io_completion *pg_io_completion;
	struct nfs_direct_req *pg_dreq;
	unsigned int pg_bsize;
	u32 pg_mirror_count;
	struct nfs_pgio_mirror *pg_mirrors;
	struct nfs_pgio_mirror pg_mirrors_static[1];
	struct nfs_pgio_mirror *pg_mirrors_dynamic;
	u32 pg_mirror_idx;
	short unsigned int pg_maxretrans;
	unsigned char pg_moreio: 1;
};

struct nfs_clone_mount {
	struct super_block *sb;
	struct dentry *dentry;
	struct nfs_fattr *fattr;
	unsigned int inherited_bsize;
};

struct nfs_fs_context {
	bool internal;
	bool skip_reconfig_option_check;
	bool need_mount;
	bool sloppy;
	unsigned int flags;
	unsigned int rsize;
	unsigned int wsize;
	unsigned int timeo;
	unsigned int retrans;
	unsigned int acregmin;
	unsigned int acregmax;
	unsigned int acdirmin;
	unsigned int acdirmax;
	unsigned int namlen;
	unsigned int options;
	unsigned int bsize;
	struct nfs_auth_info auth_info;
	rpc_authflavor_t selected_flavor;
	char *client_address;
	unsigned int version;
	unsigned int minorversion;
	char *fscache_uniq;
	short unsigned int protofamily;
	short unsigned int mountfamily;
	struct {
		union {
			struct sockaddr address;
			struct __kernel_sockaddr_storage _address;
		};
		size_t addrlen;
		char *hostname;
		u32 version;
		int port;
		short unsigned int protocol;
	} mount_server;
	struct {
		union {
			struct sockaddr address;
			struct __kernel_sockaddr_storage _address;
		};
		size_t addrlen;
		char *hostname;
		char *export_path;
		int port;
		short unsigned int protocol;
		short unsigned int nconnect;
		short unsigned int export_path_len;
	} nfs_server;
	struct nfs_fh *mntfh;
	struct nfs_server *server;
	struct nfs_subversion *nfs_mod;
	struct nfs_clone_mount clone_data;
};

struct nfs4_deviceid_node {
	struct hlist_node node;
	struct hlist_node tmpnode;
	const struct pnfs_layoutdriver_type *ld;
	const struct nfs_client *nfs_client;
	long unsigned int flags;
	long unsigned int timestamp_unavailable;
	struct nfs4_deviceid deviceid;
	struct callback_head rcu;
	atomic_t ref;
};

struct bl_dev_msg {
	int32_t status;
	uint32_t major;
	uint32_t minor;
};

struct nfs_netns_client;

struct nfs_net {
	struct cache_detail *nfs_dns_resolve;
	struct rpc_pipe *bl_device_pipe;
	struct bl_dev_msg bl_mount_reply;
	wait_queue_head_t bl_wq;
	struct mutex bl_mutex;
	struct list_head nfs_client_list;
	struct list_head nfs_volume_list;
	struct idr cb_ident_idr;
	short unsigned int nfs_callback_tcpport;
	short unsigned int nfs_callback_tcpport6;
	int cb_users[3];
	struct nfs_netns_client *nfs_client;
	spinlock_t nfs_client_lock;
	ktime_t boot_time;
	struct proc_dir_entry *proc_nfsfs;
};

struct nfs_netns_client {
	struct kobject kobject;
	struct net *net;
	const char *identifier;
};

struct nfs_open_dir_context {
	struct list_head list;
	const struct cred *cred;
	long unsigned int attr_gencount;
	__u64 dir_cookie;
	__u64 dup_cookie;
	signed char duped;
};

struct nfs4_cached_acl;

struct nfs_delegation;

struct nfs4_xattr_cache;

struct nfs_inode {
	__u64 fileid;
	struct nfs_fh fh;
	long unsigned int flags;
	long unsigned int cache_validity;
	long unsigned int read_cache_jiffies;
	long unsigned int attrtimeo;
	long unsigned int attrtimeo_timestamp;
	long unsigned int attr_gencount;
	long unsigned int cache_change_attribute;
	struct rb_root access_cache;
	struct list_head access_cache_entry_lru;
	struct list_head access_cache_inode_lru;
	__be32 cookieverf[2];
	atomic_long_t nrequests;
	struct nfs_mds_commit_info commit_info;
	struct list_head open_files;
	struct rw_semaphore rmdir_sem;
	struct mutex commit_mutex;
	long unsigned int page_index;
	struct nfs4_cached_acl *nfs4_acl;
	struct list_head open_states;
	struct nfs_delegation *delegation;
	struct rw_semaphore rwsem;
	struct pnfs_layout_hdr *layout;
	__u64 write_io;
	__u64 read_io;
	struct inode vfs_inode;
	struct nfs4_xattr_cache *xattr_cache;
};

struct nfs_delegation {
	struct list_head super_list;
	const struct cred *cred;
	struct inode *inode;
	nfs4_stateid stateid;
	fmode_t type;
	long unsigned int pagemod_limit;
	__u64 change_attr;
	long unsigned int flags;
	refcount_t refcount;
	spinlock_t lock;
	struct callback_head rcu;
};

struct nfs_cache_array_entry {
	u64 cookie;
	u64 ino;
	struct qstr string;
	unsigned char d_type;
};

struct nfs_cache_array {
	int size;
	int eof_index;
	u64 last_cookie;
	struct nfs_cache_array_entry array[0];
};

typedef struct {
	struct file *file;
	struct page *page;
	struct dir_context *ctx;
	long unsigned int page_index;
	u64 *dir_cookie;
	u64 last_cookie;
	loff_t current_index;
	loff_t prev_index;
	long unsigned int dir_verifier;
	long unsigned int timestamp;
	long unsigned int gencount;
	unsigned int cache_entry_index;
	bool plus;
	bool eof;
} nfs_readdir_descriptor_t;

enum layoutdriver_policy_flags {
	PNFS_LAYOUTRET_ON_SETATTR = 1,
	PNFS_LAYOUTRET_ON_ERROR = 2,
	PNFS_READ_WHOLE_PAGE = 4,
	PNFS_LAYOUTGET_ON_OPEN = 8,
};

struct nfs_find_desc {
	struct nfs_fh *fh;
	struct nfs_fattr *fattr;
};

struct nfs4_sessionid {
	unsigned char data[16];
};

struct nfs4_channel_attrs {
	u32 max_rqst_sz;
	u32 max_resp_sz;
	u32 max_resp_sz_cached;
	u32 max_ops;
	u32 max_reqs;
};

struct nfs4_slot {
	struct nfs4_slot_table *table;
	struct nfs4_slot *next;
	long unsigned int generation;
	u32 slot_nr;
	u32 seq_nr;
	u32 seq_nr_last_acked;
	u32 seq_nr_highest_sent;
	unsigned int privileged: 1;
	unsigned int seq_done: 1;
};

struct nfs4_slot_table {
	struct nfs4_session *session;
	struct nfs4_slot *slots;
	long unsigned int used_slots[16];
	spinlock_t slot_tbl_lock;
	struct rpc_wait_queue slot_tbl_waitq;
	wait_queue_head_t slot_waitq;
	u32 max_slots;
	u32 max_slotid;
	u32 highest_used_slotid;
	u32 target_highest_slotid;
	u32 server_highest_slotid;
	s32 d_target_highest_slotid;
	s32 d2_target_highest_slotid;
	long unsigned int generation;
	struct completion complete;
	long unsigned int slot_tbl_state;
};

struct nfs4_session {
	struct nfs4_sessionid sess_id;
	u32 flags;
	long unsigned int session_state;
	u32 hash_alg;
	u32 ssv_len;
	struct nfs4_channel_attrs fc_attrs;
	struct nfs4_slot_table fc_slot_table;
	struct nfs4_channel_attrs bc_attrs;
	struct nfs4_slot_table bc_slot_table;
	struct nfs_client *clp;
};

struct nfs_mount_request {
	struct sockaddr *sap;
	size_t salen;
	char *hostname;
	char *dirpath;
	u32 version;
	short unsigned int protocol;
	struct nfs_fh *fh;
	int noresvport;
	unsigned int *auth_flav_len;
	rpc_authflavor_t *auth_flavs;
	struct net *net;
};

struct proc_nfs_info {
	int flag;
	const char *str;
	const char *nostr;
};

struct pnfs_commit_bucket {
	struct list_head written;
	struct list_head committing;
	struct pnfs_layout_segment *lseg;
	struct nfs_writeverf direct_verf;
};

struct pnfs_commit_array {
	struct list_head cinfo_list;
	struct list_head lseg_list;
	struct pnfs_layout_segment *lseg;
	struct callback_head rcu;
	refcount_t refcount;
	unsigned int nbuckets;
	struct pnfs_commit_bucket buckets[0];
};

enum {
	NFS_IOHDR_ERROR = 0,
	NFS_IOHDR_EOF = 1,
	NFS_IOHDR_REDO = 2,
	NFS_IOHDR_STAT = 3,
	NFS_IOHDR_RESEND_PNFS = 4,
	NFS_IOHDR_RESEND_MDS = 5,
};

struct nfs_direct_req {
	struct kref kref;
	struct nfs_open_context *ctx;
	struct nfs_lock_context *l_ctx;
	struct kiocb *iocb;
	struct inode *inode;
	atomic_t io_count;
	spinlock_t lock;
	loff_t io_start;
	ssize_t count;
	ssize_t max_count;
	ssize_t bytes_left;
	ssize_t error;
	struct completion completion;
	struct nfs_mds_commit_info mds_cinfo;
	struct pnfs_ds_commit_info ds_cinfo;
	struct work_struct work;
	int flags;
};

enum {
	PG_BUSY = 0,
	PG_MAPPED = 1,
	PG_CLEAN = 2,
	PG_COMMIT_TO_DS = 3,
	PG_INODE_REF = 4,
	PG_HEADLOCK = 5,
	PG_TEARDOWN = 6,
	PG_UNLOCKPAGE = 7,
	PG_UPTODATE = 8,
	PG_WB_END = 9,
	PG_REMOVE = 10,
	PG_CONTENDED1 = 11,
	PG_CONTENDED2 = 12,
};

struct nfs_readdesc {
	struct nfs_pageio_descriptor *pgio;
	struct nfs_open_context *ctx;
};

struct nfs_io_completion {
	void (*complete)(void *);
	void *data;
	struct kref refcount;
};

enum {
	MOUNTPROC_NULL = 0,
	MOUNTPROC_MNT = 1,
	MOUNTPROC_DUMP = 2,
	MOUNTPROC_UMNT = 3,
	MOUNTPROC_UMNTALL = 4,
	MOUNTPROC_EXPORT = 5,
};

enum {
	MOUNTPROC3_NULL = 0,
	MOUNTPROC3_MNT = 1,
	MOUNTPROC3_DUMP = 2,
	MOUNTPROC3_UMNT = 3,
	MOUNTPROC3_UMNTALL = 4,
	MOUNTPROC3_EXPORT = 5,
};

enum mountstat {
	MNT_OK = 0,
	MNT_EPERM = 1,
	MNT_ENOENT = 2,
	MNT_EACCES = 13,
	MNT_EINVAL = 22,
};

enum mountstat3 {
	MNT3_OK = 0,
	MNT3ERR_PERM = 1,
	MNT3ERR_NOENT = 2,
	MNT3ERR_IO = 5,
	MNT3ERR_ACCES = 13,
	MNT3ERR_NOTDIR = 20,
	MNT3ERR_INVAL = 22,
	MNT3ERR_NAMETOOLONG = 63,
	MNT3ERR_NOTSUPP = 10004,
	MNT3ERR_SERVERFAULT = 10006,
};

struct mountres {
	int errno;
	struct nfs_fh *fh;
	unsigned int *auth_count;
	rpc_authflavor_t *auth_flavors;
};

enum nfs_stat {
	NFS_OK = 0,
	NFSERR_PERM = 1,
	NFSERR_NOENT = 2,
	NFSERR_IO = 5,
	NFSERR_NXIO = 6,
	NFSERR_EAGAIN = 11,
	NFSERR_ACCES = 13,
	NFSERR_EXIST = 17,
	NFSERR_XDEV = 18,
	NFSERR_NODEV = 19,
	NFSERR_NOTDIR = 20,
	NFSERR_ISDIR = 21,
	NFSERR_INVAL = 22,
	NFSERR_FBIG = 27,
	NFSERR_NOSPC = 28,
	NFSERR_ROFS = 30,
	NFSERR_MLINK = 31,
	NFSERR_OPNOTSUPP = 45,
	NFSERR_NAMETOOLONG = 63,
	NFSERR_NOTEMPTY = 66,
	NFSERR_DQUOT = 69,
	NFSERR_STALE = 70,
	NFSERR_REMOTE = 71,
	NFSERR_WFLUSH = 99,
	NFSERR_BADHANDLE = 10001,
	NFSERR_NOT_SYNC = 10002,
	NFSERR_BAD_COOKIE = 10003,
	NFSERR_NOTSUPP = 10004,
	NFSERR_TOOSMALL = 10005,
	NFSERR_SERVERFAULT = 10006,
	NFSERR_BADTYPE = 10007,
	NFSERR_JUKEBOX = 10008,
	NFSERR_SAME = 10009,
	NFSERR_DENIED = 10010,
	NFSERR_EXPIRED = 10011,
	NFSERR_LOCKED = 10012,
	NFSERR_GRACE = 10013,
	NFSERR_FHEXPIRED = 10014,
	NFSERR_SHARE_DENIED = 10015,
	NFSERR_WRONGSEC = 10016,
	NFSERR_CLID_INUSE = 10017,
	NFSERR_RESOURCE = 10018,
	NFSERR_MOVED = 10019,
	NFSERR_NOFILEHANDLE = 10020,
	NFSERR_MINOR_VERS_MISMATCH = 10021,
	NFSERR_STALE_CLIENTID = 10022,
	NFSERR_STALE_STATEID = 10023,
	NFSERR_OLD_STATEID = 10024,
	NFSERR_BAD_STATEID = 10025,
	NFSERR_BAD_SEQID = 10026,
	NFSERR_NOT_SAME = 10027,
	NFSERR_LOCK_RANGE = 10028,
	NFSERR_SYMLINK = 10029,
	NFSERR_RESTOREFH = 10030,
	NFSERR_LEASE_MOVED = 10031,
	NFSERR_ATTRNOTSUPP = 10032,
	NFSERR_NO_GRACE = 10033,
	NFSERR_RECLAIM_BAD = 10034,
	NFSERR_RECLAIM_CONFLICT = 10035,
	NFSERR_BAD_XDR = 10036,
	NFSERR_LOCKS_HELD = 10037,
	NFSERR_OPENMODE = 10038,
	NFSERR_BADOWNER = 10039,
	NFSERR_BADCHAR = 10040,
	NFSERR_BADNAME = 10041,
	NFSERR_BAD_RANGE = 10042,
	NFSERR_LOCK_NOTSUPP = 10043,
	NFSERR_OP_ILLEGAL = 10044,
	NFSERR_DEADLOCK = 10045,
	NFSERR_FILE_OPEN = 10046,
	NFSERR_ADMIN_REVOKED = 10047,
	NFSERR_CB_PATH_DOWN = 10048,
};

struct trace_event_raw_nfs_inode_event {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	u64 version;
	char __data[0];
};

struct trace_event_raw_nfs_inode_event_done {
	struct trace_entry ent;
	long unsigned int error;
	dev_t dev;
	u32 fhandle;
	unsigned char type;
	u64 fileid;
	u64 version;
	loff_t size;
	long unsigned int nfsi_flags;
	long unsigned int cache_validity;
	char __data[0];
};

struct trace_event_raw_nfs_access_exit {
	struct trace_entry ent;
	long unsigned int error;
	dev_t dev;
	u32 fhandle;
	unsigned char type;
	u64 fileid;
	u64 version;
	loff_t size;
	long unsigned int nfsi_flags;
	long unsigned int cache_validity;
	unsigned int mask;
	unsigned int permitted;
	char __data[0];
};

struct trace_event_raw_nfs_lookup_event {
	struct trace_entry ent;
	long unsigned int flags;
	dev_t dev;
	u64 dir;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_nfs_lookup_event_done {
	struct trace_entry ent;
	long unsigned int error;
	long unsigned int flags;
	dev_t dev;
	u64 dir;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_nfs_atomic_open_enter {
	struct trace_entry ent;
	long unsigned int flags;
	unsigned int fmode;
	dev_t dev;
	u64 dir;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_nfs_atomic_open_exit {
	struct trace_entry ent;
	long unsigned int error;
	long unsigned int flags;
	unsigned int fmode;
	dev_t dev;
	u64 dir;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_nfs_create_enter {
	struct trace_entry ent;
	long unsigned int flags;
	dev_t dev;
	u64 dir;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_nfs_create_exit {
	struct trace_entry ent;
	long unsigned int error;
	long unsigned int flags;
	dev_t dev;
	u64 dir;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_nfs_directory_event {
	struct trace_entry ent;
	dev_t dev;
	u64 dir;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_nfs_directory_event_done {
	struct trace_entry ent;
	long unsigned int error;
	dev_t dev;
	u64 dir;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_nfs_link_enter {
	struct trace_entry ent;
	dev_t dev;
	u64 fileid;
	u64 dir;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_nfs_link_exit {
	struct trace_entry ent;
	long unsigned int error;
	dev_t dev;
	u64 fileid;
	u64 dir;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_nfs_rename_event {
	struct trace_entry ent;
	dev_t dev;
	u64 old_dir;
	u64 new_dir;
	u32 __data_loc_old_name;
	u32 __data_loc_new_name;
	char __data[0];
};

struct trace_event_raw_nfs_rename_event_done {
	struct trace_entry ent;
	dev_t dev;
	long unsigned int error;
	u64 old_dir;
	u32 __data_loc_old_name;
	u64 new_dir;
	u32 __data_loc_new_name;
	char __data[0];
};

struct trace_event_raw_nfs_sillyrename_unlink {
	struct trace_entry ent;
	dev_t dev;
	long unsigned int error;
	u64 dir;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_nfs_initiate_read {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	loff_t offset;
	u32 count;
	char __data[0];
};

struct trace_event_raw_nfs_readpage_done {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	loff_t offset;
	u32 arg_count;
	u32 res_count;
	bool eof;
	int status;
	char __data[0];
};

struct trace_event_raw_nfs_readpage_short {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	loff_t offset;
	u32 arg_count;
	u32 res_count;
	bool eof;
	int status;
	char __data[0];
};

struct trace_event_raw_nfs_pgio_error {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	loff_t offset;
	u32 arg_count;
	u32 res_count;
	loff_t pos;
	int status;
	char __data[0];
};

struct trace_event_raw_nfs_initiate_write {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	loff_t offset;
	u32 count;
	enum nfs3_stable_how stable;
	char __data[0];
};

struct trace_event_raw_nfs_writeback_done {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	loff_t offset;
	u32 arg_count;
	u32 res_count;
	int status;
	enum nfs3_stable_how stable;
	char verifier[8];
	char __data[0];
};

struct trace_event_raw_nfs_page_error_class {
	struct trace_entry ent;
	const void *req;
	long unsigned int index;
	unsigned int offset;
	unsigned int pgbase;
	unsigned int bytes;
	int error;
	char __data[0];
};

struct trace_event_raw_nfs_initiate_commit {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	loff_t offset;
	u32 count;
	char __data[0];
};

struct trace_event_raw_nfs_commit_done {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	loff_t offset;
	int status;
	enum nfs3_stable_how stable;
	char verifier[8];
	char __data[0];
};

struct trace_event_raw_nfs_fh_to_dentry {
	struct trace_entry ent;
	int error;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	char __data[0];
};

struct trace_event_raw_nfs_xdr_status {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	u32 xid;
	int version;
	long unsigned int error;
	u32 __data_loc_program;
	u32 __data_loc_procedure;
	char __data[0];
};

struct trace_event_data_offsets_nfs_inode_event {};

struct trace_event_data_offsets_nfs_inode_event_done {};

struct trace_event_data_offsets_nfs_access_exit {};

struct trace_event_data_offsets_nfs_lookup_event {
	u32 name;
};

struct trace_event_data_offsets_nfs_lookup_event_done {
	u32 name;
};

struct trace_event_data_offsets_nfs_atomic_open_enter {
	u32 name;
};

struct trace_event_data_offsets_nfs_atomic_open_exit {
	u32 name;
};

struct trace_event_data_offsets_nfs_create_enter {
	u32 name;
};

struct trace_event_data_offsets_nfs_create_exit {
	u32 name;
};

struct trace_event_data_offsets_nfs_directory_event {
	u32 name;
};

struct trace_event_data_offsets_nfs_directory_event_done {
	u32 name;
};

struct trace_event_data_offsets_nfs_link_enter {
	u32 name;
};

struct trace_event_data_offsets_nfs_link_exit {
	u32 name;
};

struct trace_event_data_offsets_nfs_rename_event {
	u32 old_name;
	u32 new_name;
};

struct trace_event_data_offsets_nfs_rename_event_done {
	u32 old_name;
	u32 new_name;
};

struct trace_event_data_offsets_nfs_sillyrename_unlink {
	u32 name;
};

struct trace_event_data_offsets_nfs_initiate_read {};

struct trace_event_data_offsets_nfs_readpage_done {};

struct trace_event_data_offsets_nfs_readpage_short {};

struct trace_event_data_offsets_nfs_pgio_error {};

struct trace_event_data_offsets_nfs_initiate_write {};

struct trace_event_data_offsets_nfs_writeback_done {};

struct trace_event_data_offsets_nfs_page_error_class {};

struct trace_event_data_offsets_nfs_initiate_commit {};

struct trace_event_data_offsets_nfs_commit_done {};

struct trace_event_data_offsets_nfs_fh_to_dentry {};

struct trace_event_data_offsets_nfs_xdr_status {
	u32 program;
	u32 procedure;
};

typedef void (*btf_trace_nfs_set_inode_stale)(void *, const struct inode *);

typedef void (*btf_trace_nfs_refresh_inode_enter)(void *, const struct inode *);

typedef void (*btf_trace_nfs_refresh_inode_exit)(void *, const struct inode *, int);

typedef void (*btf_trace_nfs_revalidate_inode_enter)(void *, const struct inode *);

typedef void (*btf_trace_nfs_revalidate_inode_exit)(void *, const struct inode *, int);

typedef void (*btf_trace_nfs_invalidate_mapping_enter)(void *, const struct inode *);

typedef void (*btf_trace_nfs_invalidate_mapping_exit)(void *, const struct inode *, int);

typedef void (*btf_trace_nfs_getattr_enter)(void *, const struct inode *);

typedef void (*btf_trace_nfs_getattr_exit)(void *, const struct inode *, int);

typedef void (*btf_trace_nfs_setattr_enter)(void *, const struct inode *);

typedef void (*btf_trace_nfs_setattr_exit)(void *, const struct inode *, int);

typedef void (*btf_trace_nfs_writeback_page_enter)(void *, const struct inode *);

typedef void (*btf_trace_nfs_writeback_page_exit)(void *, const struct inode *, int);

typedef void (*btf_trace_nfs_writeback_inode_enter)(void *, const struct inode *);

typedef void (*btf_trace_nfs_writeback_inode_exit)(void *, const struct inode *, int);

typedef void (*btf_trace_nfs_fsync_enter)(void *, const struct inode *);

typedef void (*btf_trace_nfs_fsync_exit)(void *, const struct inode *, int);

typedef void (*btf_trace_nfs_access_enter)(void *, const struct inode *);

typedef void (*btf_trace_nfs_access_exit)(void *, const struct inode *, unsigned int, unsigned int, int);

typedef void (*btf_trace_nfs_lookup_enter)(void *, const struct inode *, const struct dentry *, unsigned int);

typedef void (*btf_trace_nfs_lookup_exit)(void *, const struct inode *, const struct dentry *, unsigned int, int);

typedef void (*btf_trace_nfs_lookup_revalidate_enter)(void *, const struct inode *, const struct dentry *, unsigned int);

typedef void (*btf_trace_nfs_lookup_revalidate_exit)(void *, const struct inode *, const struct dentry *, unsigned int, int);

typedef void (*btf_trace_nfs_atomic_open_enter)(void *, const struct inode *, const struct nfs_open_context *, unsigned int);

typedef void (*btf_trace_nfs_atomic_open_exit)(void *, const struct inode *, const struct nfs_open_context *, unsigned int, int);

typedef void (*btf_trace_nfs_create_enter)(void *, const struct inode *, const struct dentry *, unsigned int);

typedef void (*btf_trace_nfs_create_exit)(void *, const struct inode *, const struct dentry *, unsigned int, int);

typedef void (*btf_trace_nfs_mknod_enter)(void *, const struct inode *, const struct dentry *);

typedef void (*btf_trace_nfs_mknod_exit)(void *, const struct inode *, const struct dentry *, int);

typedef void (*btf_trace_nfs_mkdir_enter)(void *, const struct inode *, const struct dentry *);

typedef void (*btf_trace_nfs_mkdir_exit)(void *, const struct inode *, const struct dentry *, int);

typedef void (*btf_trace_nfs_rmdir_enter)(void *, const struct inode *, const struct dentry *);

typedef void (*btf_trace_nfs_rmdir_exit)(void *, const struct inode *, const struct dentry *, int);

typedef void (*btf_trace_nfs_remove_enter)(void *, const struct inode *, const struct dentry *);

typedef void (*btf_trace_nfs_remove_exit)(void *, const struct inode *, const struct dentry *, int);

typedef void (*btf_trace_nfs_unlink_enter)(void *, const struct inode *, const struct dentry *);

typedef void (*btf_trace_nfs_unlink_exit)(void *, const struct inode *, const struct dentry *, int);

typedef void (*btf_trace_nfs_symlink_enter)(void *, const struct inode *, const struct dentry *);

typedef void (*btf_trace_nfs_symlink_exit)(void *, const struct inode *, const struct dentry *, int);

typedef void (*btf_trace_nfs_link_enter)(void *, const struct inode *, const struct inode *, const struct dentry *);

typedef void (*btf_trace_nfs_link_exit)(void *, const struct inode *, const struct inode *, const struct dentry *, int);

typedef void (*btf_trace_nfs_rename_enter)(void *, const struct inode *, const struct dentry *, const struct inode *, const struct dentry *);

typedef void (*btf_trace_nfs_rename_exit)(void *, const struct inode *, const struct dentry *, const struct inode *, const struct dentry *, int);

typedef void (*btf_trace_nfs_sillyrename_rename)(void *, const struct inode *, const struct dentry *, const struct inode *, const struct dentry *, int);

typedef void (*btf_trace_nfs_sillyrename_unlink)(void *, const struct nfs_unlinkdata *, int);

typedef void (*btf_trace_nfs_initiate_read)(void *, const struct nfs_pgio_header *);

typedef void (*btf_trace_nfs_readpage_done)(void *, const struct rpc_task *, const struct nfs_pgio_header *);

typedef void (*btf_trace_nfs_readpage_short)(void *, const struct rpc_task *, const struct nfs_pgio_header *);

typedef void (*btf_trace_nfs_pgio_error)(void *, const struct nfs_pgio_header *, int, loff_t);

typedef void (*btf_trace_nfs_initiate_write)(void *, const struct nfs_pgio_header *);

typedef void (*btf_trace_nfs_writeback_done)(void *, const struct rpc_task *, const struct nfs_pgio_header *);

typedef void (*btf_trace_nfs_write_error)(void *, const struct nfs_page *, int);

typedef void (*btf_trace_nfs_comp_error)(void *, const struct nfs_page *, int);

typedef void (*btf_trace_nfs_commit_error)(void *, const struct nfs_page *, int);

typedef void (*btf_trace_nfs_initiate_commit)(void *, const struct nfs_commit_data *);

typedef void (*btf_trace_nfs_commit_done)(void *, const struct rpc_task *, const struct nfs_commit_data *);

typedef void (*btf_trace_nfs_fh_to_dentry)(void *, const struct super_block *, const struct nfs_fh *, u64, int);

typedef void (*btf_trace_nfs_xdr_status)(void *, const struct xdr_stream *, int);

enum {
	FILEID_HIGH_OFF = 0,
	FILEID_LOW_OFF = 1,
	FILE_I_TYPE_OFF = 2,
	EMBED_FH_OFF = 3,
};

typedef s32 compat_int_t;

typedef u32 compat_uint_t;

typedef u32 compat_uptr_t;

struct nfs2_fh {
	char data[32];
};

struct nfs3_fh {
	short unsigned int size;
	unsigned char data[64];
};

struct nfs_mount_data {
	int version;
	int fd;
	struct nfs2_fh old_root;
	int flags;
	int rsize;
	int wsize;
	int timeo;
	int retrans;
	int acregmin;
	int acregmax;
	int acdirmin;
	int acdirmax;
	struct sockaddr_in addr;
	char hostname[256];
	int namlen;
	unsigned int bsize;
	struct nfs3_fh root;
	int pseudoflavor;
	char context[257];
};

struct nfs_string {
	unsigned int len;
	const char *data;
};

struct nfs4_mount_data {
	int version;
	int flags;
	int rsize;
	int wsize;
	int timeo;
	int retrans;
	int acregmin;
	int acregmax;
	int acdirmin;
	int acdirmax;
	struct nfs_string client_addr;
	struct nfs_string mnt_path;
	struct nfs_string hostname;
	unsigned int host_addrlen;
	struct sockaddr *host_addr;
	int proto;
	int auth_flavourlen;
	int *auth_flavours;
};

enum nfs_param {
	Opt_ac = 0,
	Opt_acdirmax = 1,
	Opt_acdirmin = 2,
	Opt_acl___2 = 3,
	Opt_acregmax = 4,
	Opt_acregmin = 5,
	Opt_actimeo = 6,
	Opt_addr = 7,
	Opt_bg = 8,
	Opt_bsize = 9,
	Opt_clientaddr = 10,
	Opt_cto = 11,
	Opt_fg = 12,
	Opt_fscache = 13,
	Opt_fscache_flag = 14,
	Opt_hard = 15,
	Opt_intr = 16,
	Opt_local_lock = 17,
	Opt_lock = 18,
	Opt_lookupcache = 19,
	Opt_migration = 20,
	Opt_minorversion = 21,
	Opt_mountaddr = 22,
	Opt_mounthost = 23,
	Opt_mountport = 24,
	Opt_mountproto = 25,
	Opt_mountvers = 26,
	Opt_namelen = 27,
	Opt_nconnect = 28,
	Opt_port = 29,
	Opt_posix = 30,
	Opt_proto = 31,
	Opt_rdirplus = 32,
	Opt_rdma = 33,
	Opt_resvport = 34,
	Opt_retrans = 35,
	Opt_retry = 36,
	Opt_rsize = 37,
	Opt_sec = 38,
	Opt_sharecache = 39,
	Opt_sloppy = 40,
	Opt_soft = 41,
	Opt_softerr = 42,
	Opt_softreval = 43,
	Opt_source = 44,
	Opt_tcp = 45,
	Opt_timeo = 46,
	Opt_udp = 47,
	Opt_v = 48,
	Opt_vers = 49,
	Opt_wsize = 50,
};

enum {
	Opt_local_lock_all = 0,
	Opt_local_lock_flock = 1,
	Opt_local_lock_none = 2,
	Opt_local_lock_posix = 3,
};

enum {
	Opt_lookupcache_all = 0,
	Opt_lookupcache_none = 1,
	Opt_lookupcache_positive = 2,
};

enum {
	Opt_vers_2 = 0,
	Opt_vers_3 = 1,
	Opt_vers_4 = 2,
	Opt_vers_4_0 = 3,
	Opt_vers_4_1 = 4,
	Opt_vers_4_2 = 5,
};

enum {
	Opt_xprt_rdma = 0,
	Opt_xprt_rdma6 = 1,
	Opt_xprt_tcp = 2,
	Opt_xprt_tcp6 = 3,
	Opt_xprt_udp = 4,
	Opt_xprt_udp6 = 5,
	nr__Opt_xprt = 6,
};

enum {
	Opt_sec_krb5 = 0,
	Opt_sec_krb5i = 1,
	Opt_sec_krb5p = 2,
	Opt_sec_lkey = 3,
	Opt_sec_lkeyi = 4,
	Opt_sec_lkeyp = 5,
	Opt_sec_none = 6,
	Opt_sec_spkm = 7,
	Opt_sec_spkmi = 8,
	Opt_sec_spkmp = 9,
	Opt_sec_sys = 10,
	nr__Opt_sec = 11,
};

struct compat_nfs_string {
	compat_uint_t len;
	compat_uptr_t data;
};

struct compat_nfs4_mount_data_v1 {
	compat_int_t version;
	compat_int_t flags;
	compat_int_t rsize;
	compat_int_t wsize;
	compat_int_t timeo;
	compat_int_t retrans;
	compat_int_t acregmin;
	compat_int_t acregmax;
	compat_int_t acdirmin;
	compat_int_t acdirmax;
	struct compat_nfs_string client_addr;
	struct compat_nfs_string mnt_path;
	struct compat_nfs_string hostname;
	compat_uint_t host_addrlen;
	compat_uptr_t host_addr;
	compat_int_t proto;
	compat_int_t auth_flavourlen;
	compat_uptr_t auth_flavours;
};

struct nfs2_fsstat {
	__u32 tsize;
	__u32 bsize;
	__u32 blocks;
	__u32 bfree;
	__u32 bavail;
};

struct nfs_sattrargs {
	struct nfs_fh *fh;
	struct iattr *sattr;
};

struct nfs_diropargs {
	struct nfs_fh *fh;
	const char *name;
	unsigned int len;
};

struct nfs_createargs {
	struct nfs_fh *fh;
	const char *name;
	unsigned int len;
	struct iattr *sattr;
};

struct nfs_linkargs {
	struct nfs_fh *fromfh;
	struct nfs_fh *tofh;
	const char *toname;
	unsigned int tolen;
};

struct nfs_symlinkargs {
	struct nfs_fh *fromfh;
	const char *fromname;
	unsigned int fromlen;
	struct page **pages;
	unsigned int pathlen;
	struct iattr *sattr;
};

struct nfs_readdirargs {
	struct nfs_fh *fh;
	__u32 cookie;
	unsigned int count;
	struct page **pages;
};

struct nfs_diropok {
	struct nfs_fh *fh;
	struct nfs_fattr *fattr;
};

struct nfs_readlinkargs {
	struct nfs_fh *fh;
	unsigned int pgbase;
	unsigned int pglen;
	struct page **pages;
};

struct nfs_createdata {
	struct nfs_createargs arg;
	struct nfs_diropok res;
	struct nfs_fh fhandle;
	struct nfs_fattr fattr;
};

enum nfs_ftype {
	NFNON = 0,
	NFREG = 1,
	NFDIR = 2,
	NFBLK = 3,
	NFCHR = 4,
	NFLNK = 5,
	NFSOCK = 6,
	NFBAD = 7,
	NFFIFO = 8,
};

enum nfs2_ftype {
	NF2NON = 0,
	NF2REG = 1,
	NF2DIR = 2,
	NF2BLK = 3,
	NF2CHR = 4,
	NF2LNK = 5,
	NF2SOCK = 6,
	NF2BAD = 7,
	NF2FIFO = 8,
};

enum nfs3_createmode {
	NFS3_CREATE_UNCHECKED = 0,
	NFS3_CREATE_GUARDED = 1,
	NFS3_CREATE_EXCLUSIVE = 2,
};

enum nfs3_ftype {
	NF3NON = 0,
	NF3REG = 1,
	NF3DIR = 2,
	NF3BLK = 3,
	NF3CHR = 4,
	NF3LNK = 5,
	NF3SOCK = 6,
	NF3FIFO = 7,
	NF3BAD = 8,
};

struct nfs3_sattrargs {
	struct nfs_fh *fh;
	struct iattr *sattr;
	unsigned int guard;
	struct timespec64 guardtime;
};

struct nfs3_diropargs {
	struct nfs_fh *fh;
	const char *name;
	unsigned int len;
};

struct nfs3_accessargs {
	struct nfs_fh *fh;
	__u32 access;
};

struct nfs3_createargs {
	struct nfs_fh *fh;
	const char *name;
	unsigned int len;
	struct iattr *sattr;
	enum nfs3_createmode createmode;
	__be32 verifier[2];
};

struct nfs3_mkdirargs {
	struct nfs_fh *fh;
	const char *name;
	unsigned int len;
	struct iattr *sattr;
};

struct nfs3_symlinkargs {
	struct nfs_fh *fromfh;
	const char *fromname;
	unsigned int fromlen;
	struct page **pages;
	unsigned int pathlen;
	struct iattr *sattr;
};

struct nfs3_mknodargs {
	struct nfs_fh *fh;
	const char *name;
	unsigned int len;
	enum nfs3_ftype type;
	struct iattr *sattr;
	dev_t rdev;
};

struct nfs3_linkargs {
	struct nfs_fh *fromfh;
	struct nfs_fh *tofh;
	const char *toname;
	unsigned int tolen;
};

struct nfs3_readdirargs {
	struct nfs_fh *fh;
	__u64 cookie;
	__be32 verf[2];
	bool plus;
	unsigned int count;
	struct page **pages;
};

struct nfs3_diropres {
	struct nfs_fattr *dir_attr;
	struct nfs_fh *fh;
	struct nfs_fattr *fattr;
};

struct nfs3_accessres {
	struct nfs_fattr *fattr;
	__u32 access;
};

struct nfs3_readlinkargs {
	struct nfs_fh *fh;
	unsigned int pgbase;
	unsigned int pglen;
	struct page **pages;
};

struct nfs3_linkres {
	struct nfs_fattr *dir_attr;
	struct nfs_fattr *fattr;
};

struct nfs3_readdirres {
	struct nfs_fattr *dir_attr;
	__be32 *verf;
	bool plus;
};

struct nfs3_createdata {
	struct rpc_message msg;
	union {
		struct nfs3_createargs create;
		struct nfs3_mkdirargs mkdir;
		struct nfs3_symlinkargs symlink;
		struct nfs3_mknodargs mknod;
	} arg;
	struct nfs3_diropres res;
	struct nfs_fh fh;
	struct nfs_fattr fattr;
	struct nfs_fattr dir_attr;
};

enum nfsstat4 {
	NFS4_OK = 0,
	NFS4ERR_PERM = 1,
	NFS4ERR_NOENT = 2,
	NFS4ERR_IO = 5,
	NFS4ERR_NXIO = 6,
	NFS4ERR_ACCESS = 13,
	NFS4ERR_EXIST = 17,
	NFS4ERR_XDEV = 18,
	NFS4ERR_NOTDIR = 20,
	NFS4ERR_ISDIR = 21,
	NFS4ERR_INVAL = 22,
	NFS4ERR_FBIG = 27,
	NFS4ERR_NOSPC = 28,
	NFS4ERR_ROFS = 30,
	NFS4ERR_MLINK = 31,
	NFS4ERR_NAMETOOLONG = 63,
	NFS4ERR_NOTEMPTY = 66,
	NFS4ERR_DQUOT = 69,
	NFS4ERR_STALE = 70,
	NFS4ERR_BADHANDLE = 10001,
	NFS4ERR_BAD_COOKIE = 10003,
	NFS4ERR_NOTSUPP = 10004,
	NFS4ERR_TOOSMALL = 10005,
	NFS4ERR_SERVERFAULT = 10006,
	NFS4ERR_BADTYPE = 10007,
	NFS4ERR_DELAY = 10008,
	NFS4ERR_SAME = 10009,
	NFS4ERR_DENIED = 10010,
	NFS4ERR_EXPIRED = 10011,
	NFS4ERR_LOCKED = 10012,
	NFS4ERR_GRACE = 10013,
	NFS4ERR_FHEXPIRED = 10014,
	NFS4ERR_SHARE_DENIED = 10015,
	NFS4ERR_WRONGSEC = 10016,
	NFS4ERR_CLID_INUSE = 10017,
	NFS4ERR_RESOURCE = 10018,
	NFS4ERR_MOVED = 10019,
	NFS4ERR_NOFILEHANDLE = 10020,
	NFS4ERR_MINOR_VERS_MISMATCH = 10021,
	NFS4ERR_STALE_CLIENTID = 10022,
	NFS4ERR_STALE_STATEID = 10023,
	NFS4ERR_OLD_STATEID = 10024,
	NFS4ERR_BAD_STATEID = 10025,
	NFS4ERR_BAD_SEQID = 10026,
	NFS4ERR_NOT_SAME = 10027,
	NFS4ERR_LOCK_RANGE = 10028,
	NFS4ERR_SYMLINK = 10029,
	NFS4ERR_RESTOREFH = 10030,
	NFS4ERR_LEASE_MOVED = 10031,
	NFS4ERR_ATTRNOTSUPP = 10032,
	NFS4ERR_NO_GRACE = 10033,
	NFS4ERR_RECLAIM_BAD = 10034,
	NFS4ERR_RECLAIM_CONFLICT = 10035,
	NFS4ERR_BADXDR = 10036,
	NFS4ERR_LOCKS_HELD = 10037,
	NFS4ERR_OPENMODE = 10038,
	NFS4ERR_BADOWNER = 10039,
	NFS4ERR_BADCHAR = 10040,
	NFS4ERR_BADNAME = 10041,
	NFS4ERR_BAD_RANGE = 10042,
	NFS4ERR_LOCK_NOTSUPP = 10043,
	NFS4ERR_OP_ILLEGAL = 10044,
	NFS4ERR_DEADLOCK = 10045,
	NFS4ERR_FILE_OPEN = 10046,
	NFS4ERR_ADMIN_REVOKED = 10047,
	NFS4ERR_CB_PATH_DOWN = 10048,
	NFS4ERR_BADIOMODE = 10049,
	NFS4ERR_BADLAYOUT = 10050,
	NFS4ERR_BAD_SESSION_DIGEST = 10051,
	NFS4ERR_BADSESSION = 10052,
	NFS4ERR_BADSLOT = 10053,
	NFS4ERR_COMPLETE_ALREADY = 10054,
	NFS4ERR_CONN_NOT_BOUND_TO_SESSION = 10055,
	NFS4ERR_DELEG_ALREADY_WANTED = 10056,
	NFS4ERR_BACK_CHAN_BUSY = 10057,
	NFS4ERR_LAYOUTTRYLATER = 10058,
	NFS4ERR_LAYOUTUNAVAILABLE = 10059,
	NFS4ERR_NOMATCHING_LAYOUT = 10060,
	NFS4ERR_RECALLCONFLICT = 10061,
	NFS4ERR_UNKNOWN_LAYOUTTYPE = 10062,
	NFS4ERR_SEQ_MISORDERED = 10063,
	NFS4ERR_SEQUENCE_POS = 10064,
	NFS4ERR_REQ_TOO_BIG = 10065,
	NFS4ERR_REP_TOO_BIG = 10066,
	NFS4ERR_REP_TOO_BIG_TO_CACHE = 10067,
	NFS4ERR_RETRY_UNCACHED_REP = 10068,
	NFS4ERR_UNSAFE_COMPOUND = 10069,
	NFS4ERR_TOO_MANY_OPS = 10070,
	NFS4ERR_OP_NOT_IN_SESSION = 10071,
	NFS4ERR_HASH_ALG_UNSUPP = 10072,
	NFS4ERR_CLIENTID_BUSY = 10074,
	NFS4ERR_PNFS_IO_HOLE = 10075,
	NFS4ERR_SEQ_FALSE_RETRY = 10076,
	NFS4ERR_BAD_HIGH_SLOT = 10077,
	NFS4ERR_DEADSESSION = 10078,
	NFS4ERR_ENCR_ALG_UNSUPP = 10079,
	NFS4ERR_PNFS_NO_LAYOUT = 10080,
	NFS4ERR_NOT_ONLY_OP = 10081,
	NFS4ERR_WRONG_CRED = 10082,
	NFS4ERR_WRONG_TYPE = 10083,
	NFS4ERR_DIRDELEG_UNAVAIL = 10084,
	NFS4ERR_REJECT_DELEG = 10085,
	NFS4ERR_RETURNCONFLICT = 10086,
	NFS4ERR_DELEG_REVOKED = 10087,
	NFS4ERR_PARTNER_NOTSUPP = 10088,
	NFS4ERR_PARTNER_NO_AUTH = 10089,
	NFS4ERR_UNION_NOTSUPP = 10090,
	NFS4ERR_OFFLOAD_DENIED = 10091,
	NFS4ERR_WRONG_LFS = 10092,
	NFS4ERR_BADLABEL = 10093,
	NFS4ERR_OFFLOAD_NO_REQS = 10094,
	NFS4ERR_NOXATTR = 10095,
	NFS4ERR_XATTR2BIG = 10096,
};

enum nfs_ftype4 {
	NF4BAD = 0,
	NF4REG = 1,
	NF4DIR = 2,
	NF4BLK = 3,
	NF4CHR = 4,
	NF4LNK = 5,
	NF4SOCK = 6,
	NF4FIFO = 7,
	NF4ATTRDIR = 8,
	NF4NAMEDATTR = 9,
};

enum open_claim_type4 {
	NFS4_OPEN_CLAIM_NULL = 0,
	NFS4_OPEN_CLAIM_PREVIOUS = 1,
	NFS4_OPEN_CLAIM_DELEGATE_CUR = 2,
	NFS4_OPEN_CLAIM_DELEGATE_PREV = 3,
	NFS4_OPEN_CLAIM_FH = 4,
	NFS4_OPEN_CLAIM_DELEG_CUR_FH = 5,
	NFS4_OPEN_CLAIM_DELEG_PREV_FH = 6,
};

enum createmode4 {
	NFS4_CREATE_UNCHECKED = 0,
	NFS4_CREATE_GUARDED = 1,
	NFS4_CREATE_EXCLUSIVE = 2,
	NFS4_CREATE_EXCLUSIVE4_1 = 3,
};

enum {
	NFSPROC4_CLNT_NULL = 0,
	NFSPROC4_CLNT_READ = 1,
	NFSPROC4_CLNT_WRITE = 2,
	NFSPROC4_CLNT_COMMIT = 3,
	NFSPROC4_CLNT_OPEN = 4,
	NFSPROC4_CLNT_OPEN_CONFIRM = 5,
	NFSPROC4_CLNT_OPEN_NOATTR = 6,
	NFSPROC4_CLNT_OPEN_DOWNGRADE = 7,
	NFSPROC4_CLNT_CLOSE = 8,
	NFSPROC4_CLNT_SETATTR = 9,
	NFSPROC4_CLNT_FSINFO = 10,
	NFSPROC4_CLNT_RENEW = 11,
	NFSPROC4_CLNT_SETCLIENTID = 12,
	NFSPROC4_CLNT_SETCLIENTID_CONFIRM = 13,
	NFSPROC4_CLNT_LOCK = 14,
	NFSPROC4_CLNT_LOCKT = 15,
	NFSPROC4_CLNT_LOCKU = 16,
	NFSPROC4_CLNT_ACCESS = 17,
	NFSPROC4_CLNT_GETATTR = 18,
	NFSPROC4_CLNT_LOOKUP = 19,
	NFSPROC4_CLNT_LOOKUP_ROOT = 20,
	NFSPROC4_CLNT_REMOVE = 21,
	NFSPROC4_CLNT_RENAME = 22,
	NFSPROC4_CLNT_LINK = 23,
	NFSPROC4_CLNT_SYMLINK = 24,
	NFSPROC4_CLNT_CREATE = 25,
	NFSPROC4_CLNT_PATHCONF = 26,
	NFSPROC4_CLNT_STATFS = 27,
	NFSPROC4_CLNT_READLINK = 28,
	NFSPROC4_CLNT_READDIR = 29,
	NFSPROC4_CLNT_SERVER_CAPS = 30,
	NFSPROC4_CLNT_DELEGRETURN = 31,
	NFSPROC4_CLNT_GETACL = 32,
	NFSPROC4_CLNT_SETACL = 33,
	NFSPROC4_CLNT_FS_LOCATIONS = 34,
	NFSPROC4_CLNT_RELEASE_LOCKOWNER = 35,
	NFSPROC4_CLNT_SECINFO = 36,
	NFSPROC4_CLNT_FSID_PRESENT = 37,
	NFSPROC4_CLNT_EXCHANGE_ID = 38,
	NFSPROC4_CLNT_CREATE_SESSION = 39,
	NFSPROC4_CLNT_DESTROY_SESSION = 40,
	NFSPROC4_CLNT_SEQUENCE = 41,
	NFSPROC4_CLNT_GET_LEASE_TIME = 42,
	NFSPROC4_CLNT_RECLAIM_COMPLETE = 43,
	NFSPROC4_CLNT_LAYOUTGET = 44,
	NFSPROC4_CLNT_GETDEVICEINFO = 45,
	NFSPROC4_CLNT_LAYOUTCOMMIT = 46,
	NFSPROC4_CLNT_LAYOUTRETURN = 47,
	NFSPROC4_CLNT_SECINFO_NO_NAME = 48,
	NFSPROC4_CLNT_TEST_STATEID = 49,
	NFSPROC4_CLNT_FREE_STATEID = 50,
	NFSPROC4_CLNT_GETDEVICELIST = 51,
	NFSPROC4_CLNT_BIND_CONN_TO_SESSION = 52,
	NFSPROC4_CLNT_DESTROY_CLIENTID = 53,
	NFSPROC4_CLNT_SEEK = 54,
	NFSPROC4_CLNT_ALLOCATE = 55,
	NFSPROC4_CLNT_DEALLOCATE = 56,
	NFSPROC4_CLNT_LAYOUTSTATS = 57,
	NFSPROC4_CLNT_CLONE = 58,
	NFSPROC4_CLNT_COPY = 59,
	NFSPROC4_CLNT_OFFLOAD_CANCEL = 60,
	NFSPROC4_CLNT_LOOKUPP = 61,
	NFSPROC4_CLNT_LAYOUTERROR = 62,
	NFSPROC4_CLNT_COPY_NOTIFY = 63,
	NFSPROC4_CLNT_GETXATTR = 64,
	NFSPROC4_CLNT_SETXATTR = 65,
	NFSPROC4_CLNT_LISTXATTRS = 66,
	NFSPROC4_CLNT_REMOVEXATTR = 67,
	NFSPROC4_CLNT_READ_PLUS = 68,
};

enum state_protect_how4 {
	SP4_NONE = 0,
	SP4_MACH_CRED = 1,
	SP4_SSV = 2,
};

enum pnfs_notify_deviceid_type4 {
	NOTIFY_DEVICEID4_CHANGE = 2,
	NOTIFY_DEVICEID4_DELETE = 4,
};

struct nfs4_op_map {
	union {
		long unsigned int longs[2];
		u32 words[4];
	} u;
};

struct nfs4_get_lease_time_args {
	struct nfs4_sequence_args la_seq_args;
};

struct nfs4_get_lease_time_res {
	struct nfs4_sequence_res lr_seq_res;
	struct nfs_fsinfo *lr_fsinfo;
};

struct nfs4_layoutget_args {
	struct nfs4_sequence_args seq_args;
	__u32 type;
	struct pnfs_layout_range range;
	__u64 minlength;
	__u32 maxcount;
	struct inode *inode;
	struct nfs_open_context *ctx;
	nfs4_stateid stateid;
	struct nfs4_layoutdriver_data layout;
};

struct nfs4_layoutget {
	struct nfs4_layoutget_args args;
	struct nfs4_layoutget_res res;
	const struct cred *cred;
	gfp_t gfp_flags;
};

struct nfs4_getdeviceinfo_args {
	struct nfs4_sequence_args seq_args;
	struct pnfs_device *pdev;
	__u32 notify_types;
};

struct nfs4_getdeviceinfo_res {
	struct nfs4_sequence_res seq_res;
	struct pnfs_device *pdev;
	__u32 notification;
};

struct nfs4_layoutreturn_res {
	struct nfs4_sequence_res seq_res;
	u32 lrs_present;
	nfs4_stateid stateid;
};

struct nfs4_layoutreturn {
	struct nfs4_layoutreturn_args args;
	struct nfs4_layoutreturn_res res;
	const struct cred *cred;
	struct nfs_client *clp;
	struct inode *inode;
	int rpc_status;
	struct nfs4_xdr_opaque_data ld_private;
};

struct stateowner_id {
	__u64 create_time;
	__u32 uniquifier;
};

struct nfs_openargs {
	struct nfs4_sequence_args seq_args;
	const struct nfs_fh *fh;
	struct nfs_seqid *seqid;
	int open_flags;
	fmode_t fmode;
	u32 share_access;
	u32 access;
	__u64 clientid;
	struct stateowner_id id;
	union {
		struct {
			struct iattr *attrs;
			nfs4_verifier verifier;
		};
		nfs4_stateid delegation;
		fmode_t delegation_type;
	} u;
	const struct qstr *name;
	const struct nfs_server *server;
	const u32 *bitmask;
	const u32 *open_bitmap;
	enum open_claim_type4 claim;
	enum createmode4 createmode;
	const struct nfs4_label *label;
	umode_t umask;
	struct nfs4_layoutget_args *lg_args;
};

struct nfs_openres {
	struct nfs4_sequence_res seq_res;
	nfs4_stateid stateid;
	struct nfs_fh fh;
	struct nfs4_change_info cinfo;
	__u32 rflags;
	struct nfs_fattr *f_attr;
	struct nfs4_label *f_label;
	struct nfs_seqid *seqid;
	const struct nfs_server *server;
	fmode_t delegation_type;
	nfs4_stateid delegation;
	long unsigned int pagemod_limit;
	__u32 do_recall;
	__u32 attrset[3];
	struct nfs4_string *owner;
	struct nfs4_string *group_owner;
	__u32 access_request;
	__u32 access_supported;
	__u32 access_result;
	struct nfs4_layoutget_res *lg_res;
};

struct nfs_open_confirmargs {
	struct nfs4_sequence_args seq_args;
	const struct nfs_fh *fh;
	nfs4_stateid *stateid;
	struct nfs_seqid *seqid;
};

struct nfs_open_confirmres {
	struct nfs4_sequence_res seq_res;
	nfs4_stateid stateid;
	struct nfs_seqid *seqid;
};

struct nfs_closeargs {
	struct nfs4_sequence_args seq_args;
	struct nfs_fh *fh;
	nfs4_stateid stateid;
	struct nfs_seqid *seqid;
	fmode_t fmode;
	u32 share_access;
	const u32 *bitmask;
	u32 bitmask_store[3];
	struct nfs4_layoutreturn_args *lr_args;
};

struct nfs_closeres {
	struct nfs4_sequence_res seq_res;
	nfs4_stateid stateid;
	struct nfs_fattr *fattr;
	struct nfs_seqid *seqid;
	const struct nfs_server *server;
	struct nfs4_layoutreturn_res *lr_res;
	int lr_ret;
};

struct nfs_lowner {
	__u64 clientid;
	__u64 id;
	dev_t s_dev;
};

struct nfs_lock_args {
	struct nfs4_sequence_args seq_args;
	struct nfs_fh *fh;
	struct file_lock *fl;
	struct nfs_seqid *lock_seqid;
	nfs4_stateid lock_stateid;
	struct nfs_seqid *open_seqid;
	nfs4_stateid open_stateid;
	struct nfs_lowner lock_owner;
	unsigned char block: 1;
	unsigned char reclaim: 1;
	unsigned char new_lock: 1;
	unsigned char new_lock_owner: 1;
};

struct nfs_lock_res {
	struct nfs4_sequence_res seq_res;
	nfs4_stateid stateid;
	struct nfs_seqid *lock_seqid;
	struct nfs_seqid *open_seqid;
};

struct nfs_locku_args {
	struct nfs4_sequence_args seq_args;
	struct nfs_fh *fh;
	struct file_lock *fl;
	struct nfs_seqid *seqid;
	nfs4_stateid stateid;
};

struct nfs_locku_res {
	struct nfs4_sequence_res seq_res;
	nfs4_stateid stateid;
	struct nfs_seqid *seqid;
};

struct nfs_lockt_args {
	struct nfs4_sequence_args seq_args;
	struct nfs_fh *fh;
	struct file_lock *fl;
	struct nfs_lowner lock_owner;
};

struct nfs_lockt_res {
	struct nfs4_sequence_res seq_res;
	struct file_lock *denied;
};

struct nfs_release_lockowner_args {
	struct nfs4_sequence_args seq_args;
	struct nfs_lowner lock_owner;
};

struct nfs_release_lockowner_res {
	struct nfs4_sequence_res seq_res;
};

struct nfs4_delegreturnargs {
	struct nfs4_sequence_args seq_args;
	const struct nfs_fh *fhandle;
	const nfs4_stateid *stateid;
	const u32 *bitmask;
	u32 bitmask_store[3];
	struct nfs4_layoutreturn_args *lr_args;
};

struct nfs4_delegreturnres {
	struct nfs4_sequence_res seq_res;
	struct nfs_fattr *fattr;
	struct nfs_server *server;
	struct nfs4_layoutreturn_res *lr_res;
	int lr_ret;
};

struct nfs_setattrargs {
	struct nfs4_sequence_args seq_args;
	struct nfs_fh *fh;
	nfs4_stateid stateid;
	struct iattr *iap;
	const struct nfs_server *server;
	const u32 *bitmask;
	const struct nfs4_label *label;
};

struct nfs_setaclargs {
	struct nfs4_sequence_args seq_args;
	struct nfs_fh *fh;
	size_t acl_len;
	struct page **acl_pages;
};

struct nfs_setaclres {
	struct nfs4_sequence_res seq_res;
};

struct nfs_getaclargs {
	struct nfs4_sequence_args seq_args;
	struct nfs_fh *fh;
	size_t acl_len;
	struct page **acl_pages;
};

struct nfs_getaclres {
	struct nfs4_sequence_res seq_res;
	size_t acl_len;
	size_t acl_data_offset;
	int acl_flags;
	struct page *acl_scratch;
};

struct nfs_setattrres {
	struct nfs4_sequence_res seq_res;
	struct nfs_fattr *fattr;
	struct nfs4_label *label;
	const struct nfs_server *server;
};

typedef u64 clientid4;

struct nfs4_accessargs {
	struct nfs4_sequence_args seq_args;
	const struct nfs_fh *fh;
	const u32 *bitmask;
	u32 access;
};

struct nfs4_accessres {
	struct nfs4_sequence_res seq_res;
	const struct nfs_server *server;
	struct nfs_fattr *fattr;
	u32 supported;
	u32 access;
};

struct nfs4_create_arg {
	struct nfs4_sequence_args seq_args;
	u32 ftype;
	union {
		struct {
			struct page **pages;
			unsigned int len;
		} symlink;
		struct {
			u32 specdata1;
			u32 specdata2;
		} device;
	} u;
	const struct qstr *name;
	const struct nfs_server *server;
	const struct iattr *attrs;
	const struct nfs_fh *dir_fh;
	const u32 *bitmask;
	const struct nfs4_label *label;
	umode_t umask;
};

struct nfs4_create_res {
	struct nfs4_sequence_res seq_res;
	const struct nfs_server *server;
	struct nfs_fh *fh;
	struct nfs_fattr *fattr;
	struct nfs4_label *label;
	struct nfs4_change_info dir_cinfo;
};

struct nfs4_fsinfo_arg {
	struct nfs4_sequence_args seq_args;
	const struct nfs_fh *fh;
	const u32 *bitmask;
};

struct nfs4_fsinfo_res {
	struct nfs4_sequence_res seq_res;
	struct nfs_fsinfo *fsinfo;
};

struct nfs4_getattr_arg {
	struct nfs4_sequence_args seq_args;
	const struct nfs_fh *fh;
	const u32 *bitmask;
};

struct nfs4_getattr_res {
	struct nfs4_sequence_res seq_res;
	const struct nfs_server *server;
	struct nfs_fattr *fattr;
	struct nfs4_label *label;
};

struct nfs4_link_arg {
	struct nfs4_sequence_args seq_args;
	const struct nfs_fh *fh;
	const struct nfs_fh *dir_fh;
	const struct qstr *name;
	const u32 *bitmask;
};

struct nfs4_link_res {
	struct nfs4_sequence_res seq_res;
	const struct nfs_server *server;
	struct nfs_fattr *fattr;
	struct nfs4_label *label;
	struct nfs4_change_info cinfo;
	struct nfs_fattr *dir_attr;
};

struct nfs4_lookup_arg {
	struct nfs4_sequence_args seq_args;
	const struct nfs_fh *dir_fh;
	const struct qstr *name;
	const u32 *bitmask;
};

struct nfs4_lookup_res {
	struct nfs4_sequence_res seq_res;
	const struct nfs_server *server;
	struct nfs_fattr *fattr;
	struct nfs_fh *fh;
	struct nfs4_label *label;
};

struct nfs4_lookupp_arg {
	struct nfs4_sequence_args seq_args;
	const struct nfs_fh *fh;
	const u32 *bitmask;
};

struct nfs4_lookupp_res {
	struct nfs4_sequence_res seq_res;
	const struct nfs_server *server;
	struct nfs_fattr *fattr;
	struct nfs_fh *fh;
	struct nfs4_label *label;
};

struct nfs4_lookup_root_arg {
	struct nfs4_sequence_args seq_args;
	const u32 *bitmask;
};

struct nfs4_pathconf_arg {
	struct nfs4_sequence_args seq_args;
	const struct nfs_fh *fh;
	const u32 *bitmask;
};

struct nfs4_pathconf_res {
	struct nfs4_sequence_res seq_res;
	struct nfs_pathconf *pathconf;
};

struct nfs4_readdir_arg {
	struct nfs4_sequence_args seq_args;
	const struct nfs_fh *fh;
	u64 cookie;
	nfs4_verifier verifier;
	u32 count;
	struct page **pages;
	unsigned int pgbase;
	const u32 *bitmask;
	bool plus;
};

struct nfs4_readdir_res {
	struct nfs4_sequence_res seq_res;
	nfs4_verifier verifier;
	unsigned int pgbase;
};

struct nfs4_readlink {
	struct nfs4_sequence_args seq_args;
	const struct nfs_fh *fh;
	unsigned int pgbase;
	unsigned int pglen;
	struct page **pages;
};

struct nfs4_readlink_res {
	struct nfs4_sequence_res seq_res;
};

struct nfs4_setclientid {
	const nfs4_verifier *sc_verifier;
	u32 sc_prog;
	unsigned int sc_netid_len;
	char sc_netid[6];
	unsigned int sc_uaddr_len;
	char sc_uaddr[58];
	struct nfs_client *sc_clnt;
	struct rpc_cred *sc_cred;
};

struct nfs4_setclientid_res {
	u64 clientid;
	nfs4_verifier confirm;
};

struct nfs4_statfs_arg {
	struct nfs4_sequence_args seq_args;
	const struct nfs_fh *fh;
	const u32 *bitmask;
};

struct nfs4_statfs_res {
	struct nfs4_sequence_res seq_res;
	struct nfs_fsstat *fsstat;
};

struct nfs4_server_caps_arg {
	struct nfs4_sequence_args seq_args;
	struct nfs_fh *fhandle;
	const u32 *bitmask;
};

struct nfs4_server_caps_res {
	struct nfs4_sequence_res seq_res;
	u32 attr_bitmask[3];
	u32 exclcreat_bitmask[3];
	u32 acl_bitmask;
	u32 has_links;
	u32 has_symlinks;
	u32 fh_expire_type;
};

struct nfs4_fs_locations_arg {
	struct nfs4_sequence_args seq_args;
	const struct nfs_fh *dir_fh;
	const struct nfs_fh *fh;
	const struct qstr *name;
	struct page *page;
	const u32 *bitmask;
	clientid4 clientid;
	unsigned char migration: 1;
	unsigned char renew: 1;
};

struct nfs4_fs_locations_res {
	struct nfs4_sequence_res seq_res;
	struct nfs4_fs_locations *fs_locations;
	unsigned char migration: 1;
	unsigned char renew: 1;
};

struct nfs4_secinfo4 {
	u32 flavor;
	struct rpcsec_gss_info flavor_info;
};

struct nfs4_secinfo_flavors {
	unsigned int num_flavors;
	struct nfs4_secinfo4 flavors[0];
};

struct nfs4_secinfo_arg {
	struct nfs4_sequence_args seq_args;
	const struct nfs_fh *dir_fh;
	const struct qstr *name;
};

struct nfs4_secinfo_res {
	struct nfs4_sequence_res seq_res;
	struct nfs4_secinfo_flavors *flavors;
};

struct nfs4_fsid_present_arg {
	struct nfs4_sequence_args seq_args;
	const struct nfs_fh *fh;
	clientid4 clientid;
	unsigned char renew: 1;
};

struct nfs4_fsid_present_res {
	struct nfs4_sequence_res seq_res;
	struct nfs_fh *fh;
	unsigned char renew: 1;
};

struct nfs41_state_protection {
	u32 how;
	struct nfs4_op_map enforce;
	struct nfs4_op_map allow;
};

struct nfs41_exchange_id_args {
	struct nfs_client *client;
	nfs4_verifier verifier;
	u32 flags;
	struct nfs41_state_protection state_protect;
};

struct nfs41_bind_conn_to_session_args {
	struct nfs_client *client;
	struct nfs4_sessionid sessionid;
	u32 dir;
	bool use_conn_in_rdma_mode;
	int retries;
};

struct nfs41_bind_conn_to_session_res {
	struct nfs4_sessionid sessionid;
	u32 dir;
	bool use_conn_in_rdma_mode;
};

struct nfs41_exchange_id_res {
	u64 clientid;
	u32 seqid;
	u32 flags;
	struct nfs41_server_owner *server_owner;
	struct nfs41_server_scope *server_scope;
	struct nfs41_impl_id *impl_id;
	struct nfs41_state_protection state_protect;
};

struct nfs41_create_session_args {
	struct nfs_client *client;
	u64 clientid;
	uint32_t seqid;
	uint32_t flags;
	uint32_t cb_program;
	struct nfs4_channel_attrs fc_attrs;
	struct nfs4_channel_attrs bc_attrs;
};

struct nfs41_create_session_res {
	struct nfs4_sessionid sessionid;
	uint32_t seqid;
	uint32_t flags;
	struct nfs4_channel_attrs fc_attrs;
	struct nfs4_channel_attrs bc_attrs;
};

struct nfs41_reclaim_complete_args {
	struct nfs4_sequence_args seq_args;
	unsigned char one_fs: 1;
};

struct nfs41_reclaim_complete_res {
	struct nfs4_sequence_res seq_res;
};

struct nfs41_secinfo_no_name_args {
	struct nfs4_sequence_args seq_args;
	int style;
};

struct nfs41_test_stateid_args {
	struct nfs4_sequence_args seq_args;
	nfs4_stateid *stateid;
};

struct nfs41_test_stateid_res {
	struct nfs4_sequence_res seq_res;
	unsigned int status;
};

struct nfs41_free_stateid_args {
	struct nfs4_sequence_args seq_args;
	nfs4_stateid stateid;
};

struct nfs41_free_stateid_res {
	struct nfs4_sequence_res seq_res;
	unsigned int status;
};

struct nfs4_cached_acl {
	int cached;
	size_t len;
	char data[0];
};

enum nfs4_client_state {
	NFS4CLNT_MANAGER_RUNNING = 0,
	NFS4CLNT_CHECK_LEASE = 1,
	NFS4CLNT_LEASE_EXPIRED = 2,
	NFS4CLNT_RECLAIM_REBOOT = 3,
	NFS4CLNT_RECLAIM_NOGRACE = 4,
	NFS4CLNT_DELEGRETURN = 5,
	NFS4CLNT_SESSION_RESET = 6,
	NFS4CLNT_LEASE_CONFIRM = 7,
	NFS4CLNT_SERVER_SCOPE_MISMATCH = 8,
	NFS4CLNT_PURGE_STATE = 9,
	NFS4CLNT_BIND_CONN_TO_SESSION = 10,
	NFS4CLNT_MOVED = 11,
	NFS4CLNT_LEASE_MOVED = 12,
	NFS4CLNT_DELEGATION_EXPIRED = 13,
	NFS4CLNT_RUN_MANAGER = 14,
	NFS4CLNT_RECALL_RUNNING = 15,
	NFS4CLNT_RECALL_ANY_LAYOUT_READ = 16,
	NFS4CLNT_RECALL_ANY_LAYOUT_RW = 17,
	NFS4CLNT_DELEGRETURN_DELAYED = 18,
};

enum {
	NFS_OWNER_RECLAIM_REBOOT = 0,
	NFS_OWNER_RECLAIM_NOGRACE = 1,
};

enum {
	LK_STATE_IN_USE = 0,
	NFS_DELEGATED_STATE = 1,
	NFS_OPEN_STATE = 2,
	NFS_O_RDONLY_STATE = 3,
	NFS_O_WRONLY_STATE = 4,
	NFS_O_RDWR_STATE = 5,
	NFS_STATE_RECLAIM_REBOOT = 6,
	NFS_STATE_RECLAIM_NOGRACE = 7,
	NFS_STATE_POSIX_LOCKS = 8,
	NFS_STATE_RECOVERY_FAILED = 9,
	NFS_STATE_MAY_NOTIFY_LOCK = 10,
	NFS_STATE_CHANGE_WAIT = 11,
	NFS_CLNT_DST_SSC_COPY_STATE = 12,
	NFS_CLNT_SRC_SSC_COPY_STATE = 13,
	NFS_SRV_SSC_COPY_STATE = 14,
};

struct nfs4_exception {
	struct nfs4_state *state;
	struct inode *inode;
	nfs4_stateid *stateid;
	long int timeout;
	unsigned char task_is_privileged: 1;
	unsigned char delay: 1;
	unsigned char recovering: 1;
	unsigned char retry: 1;
	bool interruptible;
};

struct nfs4_opendata {
	struct kref kref;
	struct nfs_openargs o_arg;
	struct nfs_openres o_res;
	struct nfs_open_confirmargs c_arg;
	struct nfs_open_confirmres c_res;
	struct nfs4_string owner_name;
	struct nfs4_string group_name;
	struct nfs4_label *a_label;
	struct nfs_fattr f_attr;
	struct nfs4_label *f_label;
	struct dentry *dir;
	struct dentry *dentry;
	struct nfs4_state_owner *owner;
	struct nfs4_state *state;
	struct iattr attrs;
	struct nfs4_layoutget *lgp;
	long unsigned int timestamp;
	bool rpc_done;
	bool file_created;
	bool is_recover;
	bool cancelled;
	int rpc_status;
};

struct nfs4_add_xprt_data {
	struct nfs_client *clp;
	const struct cred *cred;
};

enum {
	NFS_DELEGATION_NEED_RECLAIM = 0,
	NFS_DELEGATION_RETURN = 1,
	NFS_DELEGATION_RETURN_IF_CLOSED = 2,
	NFS_DELEGATION_REFERENCED = 3,
	NFS_DELEGATION_RETURNING = 4,
	NFS_DELEGATION_REVOKED = 5,
	NFS_DELEGATION_TEST_EXPIRED = 6,
	NFS_DELEGATION_INODE_FREEING = 7,
	NFS_DELEGATION_RETURN_DELAYED = 8,
};

struct cb_notify_lock_args {
	struct nfs_fh cbnl_fh;
	struct nfs_lowner cbnl_owner;
	bool cbnl_valid;
};

enum {
	NFS_LAYOUT_RO_FAILED = 0,
	NFS_LAYOUT_RW_FAILED = 1,
	NFS_LAYOUT_BULK_RECALL = 2,
	NFS_LAYOUT_RETURN = 3,
	NFS_LAYOUT_RETURN_LOCK = 4,
	NFS_LAYOUT_RETURN_REQUESTED = 5,
	NFS_LAYOUT_INVALID_STID = 6,
	NFS_LAYOUT_FIRST_LAYOUTGET = 7,
	NFS_LAYOUT_INODE_FREEING = 8,
	NFS_LAYOUT_HASHED = 9,
};

enum nfs4_slot_tbl_state {
	NFS4_SLOT_TBL_DRAINING = 0,
};

enum nfs4_session_state {
	NFS4_SESSION_INITING = 0,
	NFS4_SESSION_ESTABLISHED = 1,
};

struct nfs4_call_sync_data {
	const struct nfs_server *seq_server;
	struct nfs4_sequence_args *seq_args;
	struct nfs4_sequence_res *seq_res;
};

struct nfs4_open_createattrs {
	struct nfs4_label *label;
	struct iattr *sattr;
	const __u32 verf[2];
};

struct nfs4_closedata {
	struct inode *inode;
	struct nfs4_state *state;
	struct nfs_closeargs arg;
	struct nfs_closeres res;
	struct {
		struct nfs4_layoutreturn_args arg;
		struct nfs4_layoutreturn_res res;
		struct nfs4_xdr_opaque_data ld_private;
		u32 roc_barrier;
		bool roc;
	} lr;
	struct nfs_fattr fattr;
	long unsigned int timestamp;
};

struct nfs4_createdata {
	struct rpc_message msg;
	struct nfs4_create_arg arg;
	struct nfs4_create_res res;
	struct nfs_fh fh;
	struct nfs_fattr fattr;
	struct nfs4_label *label;
};

struct nfs4_renewdata {
	struct nfs_client *client;
	long unsigned int timestamp;
};

struct nfs4_delegreturndata {
	struct nfs4_delegreturnargs args;
	struct nfs4_delegreturnres res;
	struct nfs_fh fh;
	nfs4_stateid stateid;
	long unsigned int timestamp;
	struct {
		struct nfs4_layoutreturn_args arg;
		struct nfs4_layoutreturn_res res;
		struct nfs4_xdr_opaque_data ld_private;
		u32 roc_barrier;
		bool roc;
	} lr;
	struct nfs_fattr fattr;
	int rpc_status;
	struct inode *inode;
};

struct nfs4_unlockdata {
	struct nfs_locku_args arg;
	struct nfs_locku_res res;
	struct nfs4_lock_state *lsp;
	struct nfs_open_context *ctx;
	struct nfs_lock_context *l_ctx;
	struct file_lock fl;
	struct nfs_server *server;
	long unsigned int timestamp;
};

struct nfs4_lockdata {
	struct nfs_lock_args arg;
	struct nfs_lock_res res;
	struct nfs4_lock_state *lsp;
	struct nfs_open_context *ctx;
	struct file_lock fl;
	long unsigned int timestamp;
	int rpc_status;
	int cancelled;
	struct nfs_server *server;
};

struct nfs4_lock_waiter {
	struct task_struct *task;
	struct inode *inode;
	struct nfs_lowner *owner;
};

struct nfs_release_lockowner_data {
	struct nfs4_lock_state *lsp;
	struct nfs_server *server;
	struct nfs_release_lockowner_args args;
	struct nfs_release_lockowner_res res;
	long unsigned int timestamp;
};

struct rpc_bind_conn_calldata {
	struct nfs_client *clp;
	const struct cred *cred;
};

struct nfs41_exchange_id_data {
	struct nfs41_exchange_id_res res;
	struct nfs41_exchange_id_args args;
};

struct nfs4_get_lease_time_data {
	struct nfs4_get_lease_time_args *args;
	struct nfs4_get_lease_time_res *res;
	struct nfs_client *clp;
};

struct nfs4_sequence_data {
	struct nfs_client *clp;
	struct nfs4_sequence_args args;
	struct nfs4_sequence_res res;
};

struct nfs4_reclaim_complete_data {
	struct nfs_client *clp;
	struct nfs41_reclaim_complete_args arg;
	struct nfs41_reclaim_complete_res res;
};

struct nfs_free_stateid_data {
	struct nfs_server *server;
	struct nfs41_free_stateid_args args;
	struct nfs41_free_stateid_res res;
};

enum opentype4 {
	NFS4_OPEN_NOCREATE = 0,
	NFS4_OPEN_CREATE = 1,
};

enum limit_by4 {
	NFS4_LIMIT_SIZE = 1,
	NFS4_LIMIT_BLOCKS = 2,
};

enum open_delegation_type4 {
	NFS4_OPEN_DELEGATE_NONE = 0,
	NFS4_OPEN_DELEGATE_READ = 1,
	NFS4_OPEN_DELEGATE_WRITE = 2,
	NFS4_OPEN_DELEGATE_NONE_EXT = 3,
};

enum why_no_delegation4 {
	WND4_NOT_WANTED = 0,
	WND4_CONTENTION = 1,
	WND4_RESOURCE = 2,
	WND4_NOT_SUPP_FTYPE = 3,
	WND4_WRITE_DELEG_NOT_SUPP_FTYPE = 4,
	WND4_NOT_SUPP_UPGRADE = 5,
	WND4_NOT_SUPP_DOWNGRADE = 6,
	WND4_CANCELLED = 7,
	WND4_IS_DIR = 8,
};

enum lock_type4 {
	NFS4_UNLOCK_LT = 0,
	NFS4_READ_LT = 1,
	NFS4_WRITE_LT = 2,
	NFS4_READW_LT = 3,
	NFS4_WRITEW_LT = 4,
};

enum pnfs_layoutreturn_type {
	RETURN_FILE = 1,
	RETURN_FSID = 2,
	RETURN_ALL = 3,
};

enum data_content4 {
	NFS4_CONTENT_DATA = 0,
	NFS4_CONTENT_HOLE = 1,
};

struct nfs42_netaddr {
	char netid[5];
	char addr[58];
	u32 netid_len;
	u32 addr_len;
};

enum netloc_type4 {
	NL4_NAME = 1,
	NL4_URL = 2,
	NL4_NETADDR = 3,
};

struct nl4_server {
	enum netloc_type4 nl4_type;
	union {
		struct {
			int nl4_str_sz;
			char nl4_str[1025];
		};
		struct nfs42_netaddr nl4_addr;
	} u;
};

enum nfs4_setxattr_options {
	SETXATTR4_EITHER = 0,
	SETXATTR4_CREATE = 1,
	SETXATTR4_REPLACE = 2,
};

struct nfs42_layoutstat_res {
	struct nfs4_sequence_res seq_res;
	int num_dev;
	int rpc_status;
};

struct nfs42_device_error {
	struct nfs4_deviceid dev_id;
	int status;
	enum nfs_opnum4 opnum;
};

struct nfs42_layout_error {
	__u64 offset;
	__u64 length;
	nfs4_stateid stateid;
	struct nfs42_device_error errors[1];
};

struct nfs42_layouterror_args {
	struct nfs4_sequence_args seq_args;
	struct inode *inode;
	unsigned int num_errors;
	struct nfs42_layout_error errors[5];
};

struct nfs42_layouterror_res {
	struct nfs4_sequence_res seq_res;
	unsigned int num_errors;
	int rpc_status;
};

struct nfs42_clone_args {
	struct nfs4_sequence_args seq_args;
	struct nfs_fh *src_fh;
	struct nfs_fh *dst_fh;
	nfs4_stateid src_stateid;
	nfs4_stateid dst_stateid;
	__u64 src_offset;
	__u64 dst_offset;
	__u64 count;
	const u32 *dst_bitmask;
};

struct nfs42_clone_res {
	struct nfs4_sequence_res seq_res;
	unsigned int rpc_status;
	struct nfs_fattr *dst_fattr;
	const struct nfs_server *server;
};

struct nfs42_falloc_args {
	struct nfs4_sequence_args seq_args;
	struct nfs_fh *falloc_fh;
	nfs4_stateid falloc_stateid;
	u64 falloc_offset;
	u64 falloc_length;
	const u32 *falloc_bitmask;
};

struct nfs42_falloc_res {
	struct nfs4_sequence_res seq_res;
	unsigned int status;
	struct nfs_fattr *falloc_fattr;
	const struct nfs_server *falloc_server;
};

struct nfs42_copy_args {
	struct nfs4_sequence_args seq_args;
	struct nfs_fh *src_fh;
	nfs4_stateid src_stateid;
	u64 src_pos;
	struct nfs_fh *dst_fh;
	nfs4_stateid dst_stateid;
	u64 dst_pos;
	u64 count;
	bool sync;
	struct nl4_server *cp_src;
};

struct nfs42_write_res {
	nfs4_stateid stateid;
	u64 count;
	struct nfs_writeverf verifier;
};

struct nfs42_copy_res {
	struct nfs4_sequence_res seq_res;
	struct nfs42_write_res write_res;
	bool consecutive;
	bool synchronous;
	struct nfs_commitres commit_res;
};

struct nfs42_offload_status_args {
	struct nfs4_sequence_args osa_seq_args;
	struct nfs_fh *osa_src_fh;
	nfs4_stateid osa_stateid;
};

struct nfs42_offload_status_res {
	struct nfs4_sequence_res osr_seq_res;
	uint64_t osr_count;
	int osr_status;
};

struct nfs42_copy_notify_args {
	struct nfs4_sequence_args cna_seq_args;
	struct nfs_fh *cna_src_fh;
	nfs4_stateid cna_src_stateid;
	struct nl4_server cna_dst;
};

struct nfs42_copy_notify_res {
	struct nfs4_sequence_res cnr_seq_res;
	struct nfstime4 cnr_lease_time;
	nfs4_stateid cnr_stateid;
	struct nl4_server cnr_src;
};

struct nfs42_seek_args {
	struct nfs4_sequence_args seq_args;
	struct nfs_fh *sa_fh;
	nfs4_stateid sa_stateid;
	u64 sa_offset;
	u32 sa_what;
};

struct nfs42_seek_res {
	struct nfs4_sequence_res seq_res;
	unsigned int status;
	u32 sr_eof;
	u64 sr_offset;
};

struct nfs42_setxattrargs {
	struct nfs4_sequence_args seq_args;
	struct nfs_fh *fh;
	const char *xattr_name;
	u32 xattr_flags;
	size_t xattr_len;
	struct page **xattr_pages;
};

struct nfs42_setxattrres {
	struct nfs4_sequence_res seq_res;
	struct nfs4_change_info cinfo;
};

struct nfs42_getxattrargs {
	struct nfs4_sequence_args seq_args;
	struct nfs_fh *fh;
	const char *xattr_name;
	size_t xattr_len;
	struct page **xattr_pages;
};

struct nfs42_getxattrres {
	struct nfs4_sequence_res seq_res;
	size_t xattr_len;
};

struct nfs42_listxattrsargs {
	struct nfs4_sequence_args seq_args;
	struct nfs_fh *fh;
	u32 count;
	u64 cookie;
	struct page **xattr_pages;
};

struct nfs42_listxattrsres {
	struct nfs4_sequence_res seq_res;
	struct page *scratch;
	void *xattr_buf;
	size_t xattr_len;
	u64 cookie;
	bool eof;
	size_t copied;
};

struct nfs42_removexattrargs {
	struct nfs4_sequence_args seq_args;
	struct nfs_fh *fh;
	const char *xattr_name;
};

struct nfs42_removexattrres {
	struct nfs4_sequence_res seq_res;
	struct nfs4_change_info cinfo;
};

struct compound_hdr {
	int32_t status;
	uint32_t nops;
	__be32 *nops_p;
	uint32_t taglen;
	char *tag;
	uint32_t replen;
	u32 minorversion;
};

struct nfs4_copy_state {
	struct list_head copies;
	struct list_head src_copies;
	nfs4_stateid stateid;
	struct completion completion;
	uint64_t count;
	struct nfs_writeverf verf;
	int error;
	int flags;
	struct nfs4_state *parent_src_state;
	struct nfs4_state *parent_dst_state;
};

struct nfs_referral_count {
	struct list_head list;
	const struct task_struct *task;
	unsigned int referral_count;
};

struct rpc_pipe_dir_object_ops;

struct rpc_pipe_dir_object {
	struct list_head pdo_head;
	const struct rpc_pipe_dir_object_ops *pdo_ops;
	void *pdo_data;
};

struct rpc_pipe_dir_object_ops {
	int (*create)(struct dentry *, struct rpc_pipe_dir_object *);
	void (*destroy)(struct dentry *, struct rpc_pipe_dir_object *);
};

struct rpc_inode {
	struct inode vfs_inode;
	void *private;
	struct rpc_pipe *pipe;
	wait_queue_head_t waitq;
};

struct idmap_legacy_upcalldata;

struct idmap {
	struct rpc_pipe_dir_object idmap_pdo;
	struct rpc_pipe *idmap_pipe;
	struct idmap_legacy_upcalldata *idmap_upcall_data;
	struct mutex idmap_mutex;
	struct user_namespace *user_ns;
};

struct user_key_payload {
	struct callback_head rcu;
	short unsigned int datalen;
	long: 48;
	char data[0];
};

struct request_key_auth {
	struct callback_head rcu;
	struct key *target_key;
	struct key *dest_keyring;
	const struct cred *cred;
	void *callout_info;
	size_t callout_len;
	pid_t pid;
	char op[8];
};

struct idmap_msg {
	__u8 im_type;
	__u8 im_conv;
	char im_name[128];
	__u32 im_id;
	__u8 im_status;
};

struct idmap_legacy_upcalldata {
	struct rpc_pipe_msg pipe_msg;
	struct idmap_msg idmap_msg;
	struct key *authkey;
	struct idmap *idmap;
};

enum {
	Opt_find_uid = 0,
	Opt_find_gid = 1,
	Opt_find_user = 2,
	Opt_find_group = 3,
	Opt_find_err = 4,
};

enum nfs4_callback_procnum {
	CB_NULL = 0,
	CB_COMPOUND = 1,
};

struct nfs_callback_data {
	unsigned int users;
	struct svc_serv *serv;
};

enum rpc_accept_stat {
	RPC_SUCCESS = 0,
	RPC_PROG_UNAVAIL = 1,
	RPC_PROG_MISMATCH = 2,
	RPC_PROC_UNAVAIL = 3,
	RPC_GARBAGE_ARGS = 4,
	RPC_SYSTEM_ERR = 5,
	RPC_DROP_REPLY = 60000,
};

enum rpc_auth_stat {
	RPC_AUTH_OK = 0,
	RPC_AUTH_BADCRED = 1,
	RPC_AUTH_REJECTEDCRED = 2,
	RPC_AUTH_BADVERF = 3,
	RPC_AUTH_REJECTEDVERF = 4,
	RPC_AUTH_TOOWEAK = 5,
	RPCSEC_GSS_CREDPROBLEM = 13,
	RPCSEC_GSS_CTXPROBLEM = 14,
};

enum nfs4_callback_opnum {
	OP_CB_GETATTR = 3,
	OP_CB_RECALL = 4,
	OP_CB_LAYOUTRECALL = 5,
	OP_CB_NOTIFY = 6,
	OP_CB_PUSH_DELEG = 7,
	OP_CB_RECALL_ANY = 8,
	OP_CB_RECALLABLE_OBJ_AVAIL = 9,
	OP_CB_RECALL_SLOT = 10,
	OP_CB_SEQUENCE = 11,
	OP_CB_WANTS_CANCELLED = 12,
	OP_CB_NOTIFY_LOCK = 13,
	OP_CB_NOTIFY_DEVICEID = 14,
	OP_CB_OFFLOAD = 15,
	OP_CB_ILLEGAL = 10044,
};

struct cb_process_state {
	__be32 drc_status;
	struct nfs_client *clp;
	struct nfs4_slot *slot;
	u32 minorversion;
	struct net *net;
};

struct cb_compound_hdr_arg {
	unsigned int taglen;
	const char *tag;
	unsigned int minorversion;
	unsigned int cb_ident;
	unsigned int nops;
};

struct cb_compound_hdr_res {
	__be32 *status;
	unsigned int taglen;
	const char *tag;
	__be32 *nops;
};

struct cb_getattrargs {
	struct nfs_fh fh;
	uint32_t bitmap[2];
};

struct cb_getattrres {
	__be32 status;
	uint32_t bitmap[2];
	uint64_t size;
	uint64_t change_attr;
	struct timespec64 ctime;
	struct timespec64 mtime;
};

struct cb_recallargs {
	struct nfs_fh fh;
	nfs4_stateid stateid;
	uint32_t truncate;
};

struct referring_call {
	uint32_t rc_sequenceid;
	uint32_t rc_slotid;
};

struct referring_call_list {
	struct nfs4_sessionid rcl_sessionid;
	uint32_t rcl_nrefcalls;
	struct referring_call *rcl_refcalls;
};

struct cb_sequenceargs {
	struct sockaddr *csa_addr;
	struct nfs4_sessionid csa_sessionid;
	uint32_t csa_sequenceid;
	uint32_t csa_slotid;
	uint32_t csa_highestslotid;
	uint32_t csa_cachethis;
	uint32_t csa_nrclists;
	struct referring_call_list *csa_rclists;
};

struct cb_sequenceres {
	__be32 csr_status;
	struct nfs4_sessionid csr_sessionid;
	uint32_t csr_sequenceid;
	uint32_t csr_slotid;
	uint32_t csr_highestslotid;
	uint32_t csr_target_highestslotid;
};

struct cb_recallanyargs {
	uint32_t craa_objs_to_keep;
	uint32_t craa_type_mask;
};

struct cb_recallslotargs {
	uint32_t crsa_target_highest_slotid;
};

struct cb_layoutrecallargs {
	uint32_t cbl_recall_type;
	uint32_t cbl_layout_type;
	uint32_t cbl_layoutchanged;
	union {
		struct {
			struct nfs_fh cbl_fh;
			struct pnfs_layout_range cbl_range;
			nfs4_stateid cbl_stateid;
		};
		struct nfs_fsid cbl_fsid;
	};
};

struct cb_devicenotifyitem {
	uint32_t cbd_notify_type;
	uint32_t cbd_layout_type;
	struct nfs4_deviceid cbd_dev_id;
	uint32_t cbd_immediate;
};

struct cb_devicenotifyargs {
	uint32_t ndevs;
	struct cb_devicenotifyitem *devs;
};

struct cb_offloadargs {
	struct nfs_fh coa_fh;
	nfs4_stateid coa_stateid;
	uint32_t error;
	uint64_t wr_count;
	struct nfs_writeverf wr_writeverf;
};

struct callback_op {
	__be32 (*process_op)(void *, void *, struct cb_process_state *);
	__be32 (*decode_args)(struct svc_rqst *, struct xdr_stream *, void *);
	__be32 (*encode_res)(struct svc_rqst *, struct xdr_stream *, const void *);
	long int res_maxsize;
};

struct xprt_create {
	int ident;
	struct net *net;
	struct sockaddr *srcaddr;
	struct sockaddr *dstaddr;
	size_t addrlen;
	const char *servername;
	struct svc_xprt *bc_xprt;
	struct rpc_xprt_switch *bc_xps;
	unsigned int flags;
};

struct nfs4_ds_server {
	struct list_head list;
	struct rpc_clnt *rpc_clnt;
};

enum pnfs_update_layout_reason {
	PNFS_UPDATE_LAYOUT_UNKNOWN = 0,
	PNFS_UPDATE_LAYOUT_NO_PNFS = 1,
	PNFS_UPDATE_LAYOUT_RD_ZEROLEN = 2,
	PNFS_UPDATE_LAYOUT_MDSTHRESH = 3,
	PNFS_UPDATE_LAYOUT_NOMEM = 4,
	PNFS_UPDATE_LAYOUT_BULK_RECALL = 5,
	PNFS_UPDATE_LAYOUT_IO_TEST_FAIL = 6,
	PNFS_UPDATE_LAYOUT_FOUND_CACHED = 7,
	PNFS_UPDATE_LAYOUT_RETURN = 8,
	PNFS_UPDATE_LAYOUT_RETRY = 9,
	PNFS_UPDATE_LAYOUT_BLOCKED = 10,
	PNFS_UPDATE_LAYOUT_INVALID_OPEN = 11,
	PNFS_UPDATE_LAYOUT_SEND_LAYOUTGET = 12,
	PNFS_UPDATE_LAYOUT_EXIT = 13,
};

struct trace_event_raw_nfs4_clientid_event {
	struct trace_entry ent;
	u32 __data_loc_dstaddr;
	long unsigned int error;
	char __data[0];
};

struct trace_event_raw_nfs4_sequence_done {
	struct trace_entry ent;
	unsigned int session;
	unsigned int slot_nr;
	unsigned int seq_nr;
	unsigned int highest_slotid;
	unsigned int target_highest_slotid;
	unsigned int status_flags;
	long unsigned int error;
	char __data[0];
};

struct trace_event_raw_nfs4_cb_sequence {
	struct trace_entry ent;
	unsigned int session;
	unsigned int slot_nr;
	unsigned int seq_nr;
	unsigned int highest_slotid;
	unsigned int cachethis;
	long unsigned int error;
	char __data[0];
};

struct trace_event_raw_nfs4_cb_seqid_err {
	struct trace_entry ent;
	unsigned int session;
	unsigned int slot_nr;
	unsigned int seq_nr;
	unsigned int highest_slotid;
	unsigned int cachethis;
	long unsigned int error;
	char __data[0];
};

struct trace_event_raw_nfs4_setup_sequence {
	struct trace_entry ent;
	unsigned int session;
	unsigned int slot_nr;
	unsigned int seq_nr;
	unsigned int highest_used_slotid;
	char __data[0];
};

struct trace_event_raw_nfs4_state_mgr {
	struct trace_entry ent;
	long unsigned int state;
	u32 __data_loc_hostname;
	char __data[0];
};

struct trace_event_raw_nfs4_state_mgr_failed {
	struct trace_entry ent;
	long unsigned int error;
	long unsigned int state;
	u32 __data_loc_hostname;
	u32 __data_loc_section;
	char __data[0];
};

struct trace_event_raw_nfs4_xdr_status {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	u32 xid;
	u32 op;
	long unsigned int error;
	char __data[0];
};

struct trace_event_raw_nfs4_cb_error_class {
	struct trace_entry ent;
	u32 xid;
	u32 cbident;
	char __data[0];
};

struct trace_event_raw_nfs4_open_event {
	struct trace_entry ent;
	long unsigned int error;
	unsigned int flags;
	unsigned int fmode;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	u64 dir;
	u32 __data_loc_name;
	int stateid_seq;
	u32 stateid_hash;
	int openstateid_seq;
	u32 openstateid_hash;
	char __data[0];
};

struct trace_event_raw_nfs4_cached_open {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	unsigned int fmode;
	int stateid_seq;
	u32 stateid_hash;
	char __data[0];
};

struct trace_event_raw_nfs4_close {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	unsigned int fmode;
	long unsigned int error;
	int stateid_seq;
	u32 stateid_hash;
	char __data[0];
};

struct trace_event_raw_nfs4_lock_event {
	struct trace_entry ent;
	long unsigned int error;
	int cmd;
	char type;
	loff_t start;
	loff_t end;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	int stateid_seq;
	u32 stateid_hash;
	char __data[0];
};

struct trace_event_raw_nfs4_set_lock {
	struct trace_entry ent;
	long unsigned int error;
	int cmd;
	char type;
	loff_t start;
	loff_t end;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	int stateid_seq;
	u32 stateid_hash;
	int lockstateid_seq;
	u32 lockstateid_hash;
	char __data[0];
};

struct trace_event_raw_nfs4_state_lock_reclaim {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	long unsigned int state_flags;
	long unsigned int lock_flags;
	int stateid_seq;
	u32 stateid_hash;
	char __data[0];
};

struct trace_event_raw_nfs4_set_delegation_event {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	unsigned int fmode;
	char __data[0];
};

struct trace_event_raw_nfs4_delegreturn_exit {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	long unsigned int error;
	int stateid_seq;
	u32 stateid_hash;
	char __data[0];
};

struct trace_event_raw_nfs4_test_stateid_event {
	struct trace_entry ent;
	long unsigned int error;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	int stateid_seq;
	u32 stateid_hash;
	char __data[0];
};

struct trace_event_raw_nfs4_lookup_event {
	struct trace_entry ent;
	dev_t dev;
	long unsigned int error;
	u64 dir;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_nfs4_lookupp {
	struct trace_entry ent;
	dev_t dev;
	u64 ino;
	long unsigned int error;
	char __data[0];
};

struct trace_event_raw_nfs4_rename {
	struct trace_entry ent;
	dev_t dev;
	long unsigned int error;
	u64 olddir;
	u32 __data_loc_oldname;
	u64 newdir;
	u32 __data_loc_newname;
	char __data[0];
};

struct trace_event_raw_nfs4_inode_event {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	long unsigned int error;
	char __data[0];
};

struct trace_event_raw_nfs4_inode_stateid_event {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	long unsigned int error;
	int stateid_seq;
	u32 stateid_hash;
	char __data[0];
};

struct trace_event_raw_nfs4_getattr_event {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	unsigned int valid;
	long unsigned int error;
	char __data[0];
};

struct trace_event_raw_nfs4_inode_callback_event {
	struct trace_entry ent;
	long unsigned int error;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	u32 __data_loc_dstaddr;
	char __data[0];
};

struct trace_event_raw_nfs4_inode_stateid_callback_event {
	struct trace_entry ent;
	long unsigned int error;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	u32 __data_loc_dstaddr;
	int stateid_seq;
	u32 stateid_hash;
	char __data[0];
};

struct trace_event_raw_nfs4_idmap_event {
	struct trace_entry ent;
	long unsigned int error;
	u32 id;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_nfs4_read_event {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	loff_t offset;
	u32 arg_count;
	u32 res_count;
	long unsigned int error;
	int stateid_seq;
	u32 stateid_hash;
	int layoutstateid_seq;
	u32 layoutstateid_hash;
	char __data[0];
};

struct trace_event_raw_nfs4_write_event {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	loff_t offset;
	u32 arg_count;
	u32 res_count;
	long unsigned int error;
	int stateid_seq;
	u32 stateid_hash;
	int layoutstateid_seq;
	u32 layoutstateid_hash;
	char __data[0];
};

struct trace_event_raw_nfs4_commit_event {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	long unsigned int error;
	loff_t offset;
	u32 count;
	int layoutstateid_seq;
	u32 layoutstateid_hash;
	char __data[0];
};

struct trace_event_raw_nfs4_layoutget {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	u32 iomode;
	u64 offset;
	u64 count;
	long unsigned int error;
	int stateid_seq;
	u32 stateid_hash;
	int layoutstateid_seq;
	u32 layoutstateid_hash;
	char __data[0];
};

struct trace_event_raw_pnfs_update_layout {
	struct trace_entry ent;
	dev_t dev;
	u64 fileid;
	u32 fhandle;
	loff_t pos;
	u64 count;
	enum pnfs_iomode iomode;
	int layoutstateid_seq;
	u32 layoutstateid_hash;
	long int lseg;
	enum pnfs_update_layout_reason reason;
	char __data[0];
};

struct trace_event_raw_pnfs_layout_event {
	struct trace_entry ent;
	dev_t dev;
	u64 fileid;
	u32 fhandle;
	loff_t pos;
	u64 count;
	enum pnfs_iomode iomode;
	int layoutstateid_seq;
	u32 layoutstateid_hash;
	long int lseg;
	char __data[0];
};

struct trace_event_raw_nfs4_flexfiles_io_event {
	struct trace_entry ent;
	long unsigned int error;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	loff_t offset;
	u32 count;
	int stateid_seq;
	u32 stateid_hash;
	u32 __data_loc_dstaddr;
	char __data[0];
};

struct trace_event_raw_ff_layout_commit_error {
	struct trace_entry ent;
	long unsigned int error;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	loff_t offset;
	u32 count;
	u32 __data_loc_dstaddr;
	char __data[0];
};

struct trace_event_data_offsets_nfs4_clientid_event {
	u32 dstaddr;
};

struct trace_event_data_offsets_nfs4_sequence_done {};

struct trace_event_data_offsets_nfs4_cb_sequence {};

struct trace_event_data_offsets_nfs4_cb_seqid_err {};

struct trace_event_data_offsets_nfs4_setup_sequence {};

struct trace_event_data_offsets_nfs4_state_mgr {
	u32 hostname;
};

struct trace_event_data_offsets_nfs4_state_mgr_failed {
	u32 hostname;
	u32 section;
};

struct trace_event_data_offsets_nfs4_xdr_status {};

struct trace_event_data_offsets_nfs4_cb_error_class {};

struct trace_event_data_offsets_nfs4_open_event {
	u32 name;
};

struct trace_event_data_offsets_nfs4_cached_open {};

struct trace_event_data_offsets_nfs4_close {};

struct trace_event_data_offsets_nfs4_lock_event {};

struct trace_event_data_offsets_nfs4_set_lock {};

struct trace_event_data_offsets_nfs4_state_lock_reclaim {};

struct trace_event_data_offsets_nfs4_set_delegation_event {};

struct trace_event_data_offsets_nfs4_delegreturn_exit {};

struct trace_event_data_offsets_nfs4_test_stateid_event {};

struct trace_event_data_offsets_nfs4_lookup_event {
	u32 name;
};

struct trace_event_data_offsets_nfs4_lookupp {};

struct trace_event_data_offsets_nfs4_rename {
	u32 oldname;
	u32 newname;
};

struct trace_event_data_offsets_nfs4_inode_event {};

struct trace_event_data_offsets_nfs4_inode_stateid_event {};

struct trace_event_data_offsets_nfs4_getattr_event {};

struct trace_event_data_offsets_nfs4_inode_callback_event {
	u32 dstaddr;
};

struct trace_event_data_offsets_nfs4_inode_stateid_callback_event {
	u32 dstaddr;
};

struct trace_event_data_offsets_nfs4_idmap_event {
	u32 name;
};

struct trace_event_data_offsets_nfs4_read_event {};

struct trace_event_data_offsets_nfs4_write_event {};

struct trace_event_data_offsets_nfs4_commit_event {};

struct trace_event_data_offsets_nfs4_layoutget {};

struct trace_event_data_offsets_pnfs_update_layout {};

struct trace_event_data_offsets_pnfs_layout_event {};

struct trace_event_data_offsets_nfs4_flexfiles_io_event {
	u32 dstaddr;
};

struct trace_event_data_offsets_ff_layout_commit_error {
	u32 dstaddr;
};

typedef void (*btf_trace_nfs4_setclientid)(void *, const struct nfs_client *, int);

typedef void (*btf_trace_nfs4_setclientid_confirm)(void *, const struct nfs_client *, int);

typedef void (*btf_trace_nfs4_renew)(void *, const struct nfs_client *, int);

typedef void (*btf_trace_nfs4_renew_async)(void *, const struct nfs_client *, int);

typedef void (*btf_trace_nfs4_exchange_id)(void *, const struct nfs_client *, int);

typedef void (*btf_trace_nfs4_create_session)(void *, const struct nfs_client *, int);

typedef void (*btf_trace_nfs4_destroy_session)(void *, const struct nfs_client *, int);

typedef void (*btf_trace_nfs4_destroy_clientid)(void *, const struct nfs_client *, int);

typedef void (*btf_trace_nfs4_bind_conn_to_session)(void *, const struct nfs_client *, int);

typedef void (*btf_trace_nfs4_sequence)(void *, const struct nfs_client *, int);

typedef void (*btf_trace_nfs4_reclaim_complete)(void *, const struct nfs_client *, int);

typedef void (*btf_trace_nfs4_sequence_done)(void *, const struct nfs4_session *, const struct nfs4_sequence_res *);

typedef void (*btf_trace_nfs4_cb_sequence)(void *, const struct cb_sequenceargs *, const struct cb_sequenceres *, __be32);

typedef void (*btf_trace_nfs4_cb_seqid_err)(void *, const struct cb_sequenceargs *, __be32);

typedef void (*btf_trace_nfs4_setup_sequence)(void *, const struct nfs4_session *, const struct nfs4_sequence_args *);

typedef void (*btf_trace_nfs4_state_mgr)(void *, const struct nfs_client *);

typedef void (*btf_trace_nfs4_state_mgr_failed)(void *, const struct nfs_client *, const char *, int);

typedef void (*btf_trace_nfs4_xdr_status)(void *, const struct xdr_stream *, u32, u32);

typedef void (*btf_trace_nfs_cb_no_clp)(void *, __be32, u32);

typedef void (*btf_trace_nfs_cb_badprinc)(void *, __be32, u32);

typedef void (*btf_trace_nfs4_open_reclaim)(void *, const struct nfs_open_context *, int, int);

typedef void (*btf_trace_nfs4_open_expired)(void *, const struct nfs_open_context *, int, int);

typedef void (*btf_trace_nfs4_open_file)(void *, const struct nfs_open_context *, int, int);

typedef void (*btf_trace_nfs4_cached_open)(void *, const struct nfs4_state *);

typedef void (*btf_trace_nfs4_close)(void *, const struct nfs4_state *, const struct nfs_closeargs *, const struct nfs_closeres *, int);

typedef void (*btf_trace_nfs4_get_lock)(void *, const struct file_lock *, const struct nfs4_state *, int, int);

typedef void (*btf_trace_nfs4_unlock)(void *, const struct file_lock *, const struct nfs4_state *, int, int);

typedef void (*btf_trace_nfs4_set_lock)(void *, const struct file_lock *, const struct nfs4_state *, const nfs4_stateid *, int, int);

typedef void (*btf_trace_nfs4_state_lock_reclaim)(void *, const struct nfs4_state *, const struct nfs4_lock_state *);

typedef void (*btf_trace_nfs4_set_delegation)(void *, const struct inode *, fmode_t);

typedef void (*btf_trace_nfs4_reclaim_delegation)(void *, const struct inode *, fmode_t);

typedef void (*btf_trace_nfs4_delegreturn_exit)(void *, const struct nfs4_delegreturnargs *, const struct nfs4_delegreturnres *, int);

typedef void (*btf_trace_nfs4_test_delegation_stateid)(void *, const struct nfs4_state *, const struct nfs4_lock_state *, int);

typedef void (*btf_trace_nfs4_test_open_stateid)(void *, const struct nfs4_state *, const struct nfs4_lock_state *, int);

typedef void (*btf_trace_nfs4_test_lock_stateid)(void *, const struct nfs4_state *, const struct nfs4_lock_state *, int);

typedef void (*btf_trace_nfs4_lookup)(void *, const struct inode *, const struct qstr *, int);

typedef void (*btf_trace_nfs4_symlink)(void *, const struct inode *, const struct qstr *, int);

typedef void (*btf_trace_nfs4_mkdir)(void *, const struct inode *, const struct qstr *, int);

typedef void (*btf_trace_nfs4_mknod)(void *, const struct inode *, const struct qstr *, int);

typedef void (*btf_trace_nfs4_remove)(void *, const struct inode *, const struct qstr *, int);

typedef void (*btf_trace_nfs4_get_fs_locations)(void *, const struct inode *, const struct qstr *, int);

typedef void (*btf_trace_nfs4_secinfo)(void *, const struct inode *, const struct qstr *, int);

typedef void (*btf_trace_nfs4_lookupp)(void *, const struct inode *, int);

typedef void (*btf_trace_nfs4_rename)(void *, const struct inode *, const struct qstr *, const struct inode *, const struct qstr *, int);

typedef void (*btf_trace_nfs4_access)(void *, const struct inode *, int);

typedef void (*btf_trace_nfs4_readlink)(void *, const struct inode *, int);

typedef void (*btf_trace_nfs4_readdir)(void *, const struct inode *, int);

typedef void (*btf_trace_nfs4_get_acl)(void *, const struct inode *, int);

typedef void (*btf_trace_nfs4_set_acl)(void *, const struct inode *, int);

typedef void (*btf_trace_nfs4_setattr)(void *, const struct inode *, const nfs4_stateid *, int);

typedef void (*btf_trace_nfs4_delegreturn)(void *, const struct inode *, const nfs4_stateid *, int);

typedef void (*btf_trace_nfs4_open_stateid_update)(void *, const struct inode *, const nfs4_stateid *, int);

typedef void (*btf_trace_nfs4_open_stateid_update_wait)(void *, const struct inode *, const nfs4_stateid *, int);

typedef void (*btf_trace_nfs4_close_stateid_update_wait)(void *, const struct inode *, const nfs4_stateid *, int);

typedef void (*btf_trace_nfs4_getattr)(void *, const struct nfs_server *, const struct nfs_fh *, const struct nfs_fattr *, int);

typedef void (*btf_trace_nfs4_lookup_root)(void *, const struct nfs_server *, const struct nfs_fh *, const struct nfs_fattr *, int);

typedef void (*btf_trace_nfs4_fsinfo)(void *, const struct nfs_server *, const struct nfs_fh *, const struct nfs_fattr *, int);

typedef void (*btf_trace_nfs4_cb_getattr)(void *, const struct nfs_client *, const struct nfs_fh *, const struct inode *, int);

typedef void (*btf_trace_nfs4_cb_recall)(void *, const struct nfs_client *, const struct nfs_fh *, const struct inode *, const nfs4_stateid *, int);

typedef void (*btf_trace_nfs4_cb_layoutrecall_file)(void *, const struct nfs_client *, const struct nfs_fh *, const struct inode *, const nfs4_stateid *, int);

typedef void (*btf_trace_nfs4_map_name_to_uid)(void *, const char *, int, u32, int);

typedef void (*btf_trace_nfs4_map_group_to_gid)(void *, const char *, int, u32, int);

typedef void (*btf_trace_nfs4_map_uid_to_name)(void *, const char *, int, u32, int);

typedef void (*btf_trace_nfs4_map_gid_to_group)(void *, const char *, int, u32, int);

typedef void (*btf_trace_nfs4_read)(void *, const struct nfs_pgio_header *, int);

typedef void (*btf_trace_nfs4_pnfs_read)(void *, const struct nfs_pgio_header *, int);

typedef void (*btf_trace_nfs4_write)(void *, const struct nfs_pgio_header *, int);

typedef void (*btf_trace_nfs4_pnfs_write)(void *, const struct nfs_pgio_header *, int);

typedef void (*btf_trace_nfs4_commit)(void *, const struct nfs_commit_data *, int);

typedef void (*btf_trace_nfs4_pnfs_commit_ds)(void *, const struct nfs_commit_data *, int);

typedef void (*btf_trace_nfs4_layoutget)(void *, const struct nfs_open_context *, const struct pnfs_layout_range *, const struct pnfs_layout_range *, const nfs4_stateid *, int);

typedef void (*btf_trace_nfs4_layoutcommit)(void *, const struct inode *, const nfs4_stateid *, int);

typedef void (*btf_trace_nfs4_layoutreturn)(void *, const struct inode *, const nfs4_stateid *, int);

typedef void (*btf_trace_nfs4_layoutreturn_on_close)(void *, const struct inode *, const nfs4_stateid *, int);

typedef void (*btf_trace_nfs4_layouterror)(void *, const struct inode *, const nfs4_stateid *, int);

typedef void (*btf_trace_nfs4_layoutstats)(void *, const struct inode *, const nfs4_stateid *, int);

typedef void (*btf_trace_pnfs_update_layout)(void *, struct inode *, loff_t, u64, enum pnfs_iomode, struct pnfs_layout_hdr *, struct pnfs_layout_segment *, enum pnfs_update_layout_reason);

typedef void (*btf_trace_pnfs_mds_fallback_pg_init_read)(void *, struct inode *, loff_t, u64, enum pnfs_iomode, struct pnfs_layout_hdr *, struct pnfs_layout_segment *);

typedef void (*btf_trace_pnfs_mds_fallback_pg_init_write)(void *, struct inode *, loff_t, u64, enum pnfs_iomode, struct pnfs_layout_hdr *, struct pnfs_layout_segment *);

typedef void (*btf_trace_pnfs_mds_fallback_pg_get_mirror_count)(void *, struct inode *, loff_t, u64, enum pnfs_iomode, struct pnfs_layout_hdr *, struct pnfs_layout_segment *);

typedef void (*btf_trace_pnfs_mds_fallback_read_done)(void *, struct inode *, loff_t, u64, enum pnfs_iomode, struct pnfs_layout_hdr *, struct pnfs_layout_segment *);

typedef void (*btf_trace_pnfs_mds_fallback_write_done)(void *, struct inode *, loff_t, u64, enum pnfs_iomode, struct pnfs_layout_hdr *, struct pnfs_layout_segment *);

typedef void (*btf_trace_pnfs_mds_fallback_read_pagelist)(void *, struct inode *, loff_t, u64, enum pnfs_iomode, struct pnfs_layout_hdr *, struct pnfs_layout_segment *);

typedef void (*btf_trace_pnfs_mds_fallback_write_pagelist)(void *, struct inode *, loff_t, u64, enum pnfs_iomode, struct pnfs_layout_hdr *, struct pnfs_layout_segment *);

typedef void (*btf_trace_ff_layout_read_error)(void *, const struct nfs_pgio_header *);

typedef void (*btf_trace_ff_layout_write_error)(void *, const struct nfs_pgio_header *);

typedef void (*btf_trace_ff_layout_commit_error)(void *, const struct nfs_commit_data *);

enum pnfs_layouttype {
	LAYOUT_NFSV4_1_FILES = 1,
	LAYOUT_OSD2_OBJECTS = 2,
	LAYOUT_BLOCK_VOLUME = 3,
	LAYOUT_FLEX_FILES = 4,
	LAYOUT_SCSI = 5,
	LAYOUT_TYPE_MAX = 6,
};

struct nfs42_layoutstat_data {
	struct inode *inode;
	struct nfs42_layoutstat_args args;
	struct nfs42_layoutstat_res res;
};

enum {
	NFS_LSEG_VALID = 0,
	NFS_LSEG_ROC = 1,
	NFS_LSEG_LAYOUTCOMMIT = 2,
	NFS_LSEG_LAYOUTRETURN = 3,
	NFS_LSEG_UNAVAILABLE = 4,
};

enum {
	NFS_DEVICEID_INVALID = 0,
	NFS_DEVICEID_UNAVAILABLE = 1,
	NFS_DEVICEID_NOCACHE = 2,
};

struct rpc_add_xprt_test {
	void (*add_xprt_test)(struct rpc_clnt *, struct rpc_xprt *, void *);
	void *data;
};

struct nfs4_pnfs_ds_addr {
	struct __kernel_sockaddr_storage da_addr;
	size_t da_addrlen;
	struct list_head da_node;
	char *da_remotestr;
};

struct nfs4_pnfs_ds {
	struct list_head ds_node;
	char *ds_remotestr;
	struct list_head ds_addrs;
	struct nfs_client *ds_clp;
	refcount_t ds_count;
	long unsigned int ds_state;
};

struct nfs42_layouterror_data {
	struct nfs42_layouterror_args args;
	struct nfs42_layouterror_res res;
	struct inode *inode;
	struct pnfs_layout_segment *lseg;
};

struct nfs42_offloadcancel_data {
	struct nfs_server *seq_server;
	struct nfs42_offload_status_args args;
	struct nfs42_offload_status_res res;
};

struct nfs4_xattr_bucket {
	spinlock_t lock;
	struct hlist_head hlist;
	struct nfs4_xattr_cache *cache;
	bool draining;
};

struct nfs4_xattr_entry;

struct nfs4_xattr_cache {
	struct kref ref;
	struct nfs4_xattr_bucket buckets[64];
	struct list_head lru;
	struct list_head dispose;
	atomic_long_t nent;
	spinlock_t listxattr_lock;
	struct inode *inode;
	struct nfs4_xattr_entry *listxattr;
};

struct nfs4_xattr_entry {
	struct kref ref;
	struct hlist_node hnode;
	struct list_head lru;
	struct list_head dispose;
	char *xattr_name;
	void *xattr_value;
	size_t xattr_size;
	struct nfs4_xattr_bucket *bucket;
	uint32_t flags;
};

enum stripetype4 {
	STRIPE_SPARSE = 1,
	STRIPE_DENSE = 2,
};

struct nfs4_file_layout_dsaddr {
	struct nfs4_deviceid_node id_node;
	u32 stripe_count;
	u8 *stripe_indices;
	u32 ds_num;
	struct nfs4_pnfs_ds *ds_list[1];
};

struct nfs4_filelayout_segment {
	struct pnfs_layout_segment generic_hdr;
	u32 stripe_type;
	u32 commit_through_mds;
	u32 stripe_unit;
	u32 first_stripe_index;
	u64 pattern_offset;
	struct nfs4_deviceid deviceid;
	struct nfs4_file_layout_dsaddr *dsaddr;
	unsigned int num_fh;
	struct nfs_fh **fh_array;
};

struct nfs4_filelayout {
	struct pnfs_layout_hdr generic_hdr;
	struct pnfs_ds_commit_info commit_info;
};

struct nfs4_ff_ds_version {
	u32 version;
	u32 minor_version;
	u32 rsize;
	u32 wsize;
	bool tightly_coupled;
};

struct nfs4_ff_layout_ds {
	struct nfs4_deviceid_node id_node;
	u32 ds_versions_cnt;
	struct nfs4_ff_ds_version *ds_versions;
	struct nfs4_pnfs_ds *ds;
};

struct nfs4_ff_layout_ds_err {
	struct list_head list;
	u64 offset;
	u64 length;
	int status;
	enum nfs_opnum4 opnum;
	nfs4_stateid stateid;
	struct nfs4_deviceid deviceid;
};

struct nfs4_ff_io_stat {
	__u64 ops_requested;
	__u64 bytes_requested;
	__u64 ops_completed;
	__u64 bytes_completed;
	__u64 bytes_not_delivered;
	ktime_t total_busy_time;
	ktime_t aggregate_completion_time;
};

struct nfs4_ff_busy_timer {
	ktime_t start_time;
	atomic_t n_ops;
};

struct nfs4_ff_layoutstat {
	struct nfs4_ff_io_stat io_stat;
	struct nfs4_ff_busy_timer busy_timer;
};

struct nfs4_ff_layout_mirror {
	struct pnfs_layout_hdr *layout;
	struct list_head mirrors;
	u32 ds_count;
	u32 efficiency;
	struct nfs4_deviceid devid;
	struct nfs4_ff_layout_ds *mirror_ds;
	u32 fh_versions_cnt;
	struct nfs_fh *fh_versions;
	nfs4_stateid stateid;
	const struct cred *ro_cred;
	const struct cred *rw_cred;
	refcount_t ref;
	spinlock_t lock;
	long unsigned int flags;
	struct nfs4_ff_layoutstat read_stat;
	struct nfs4_ff_layoutstat write_stat;
	ktime_t start_time;
	u32 report_interval;
};

struct nfs4_ff_layout_segment {
	struct pnfs_layout_segment generic_hdr;
	u64 stripe_unit;
	u32 flags;
	u32 mirror_array_cnt;
	struct nfs4_ff_layout_mirror *mirror_array[0];
};

struct nfs4_flexfile_layout {
	struct pnfs_layout_hdr generic_hdr;
	struct pnfs_ds_commit_info commit_info;
	struct list_head mirrors;
	struct list_head error_list;
	ktime_t last_report_time;
};

struct nfs4_flexfile_layoutreturn_args {
	struct list_head errors;
	struct nfs42_layoutstat_devinfo devinfo[4];
	unsigned int num_errors;
	unsigned int num_dev;
	struct page *pages[1];
};

struct getdents_callback___2 {
	struct dir_context ctx;
	char *name;
	u64 ino;
	int found;
	int sequence;
};

struct nlm_host;

struct nlm_lockowner {
	struct list_head list;
	refcount_t count;
	struct nlm_host *host;
	fl_owner_t owner;
	uint32_t pid;
};

struct nsm_handle;

struct nlm_host {
	struct hlist_node h_hash;
	struct __kernel_sockaddr_storage h_addr;
	size_t h_addrlen;
	struct __kernel_sockaddr_storage h_srcaddr;
	size_t h_srcaddrlen;
	struct rpc_clnt *h_rpcclnt;
	char *h_name;
	u32 h_version;
	short unsigned int h_proto;
	short unsigned int h_reclaiming: 1;
	short unsigned int h_server: 1;
	short unsigned int h_noresvport: 1;
	short unsigned int h_inuse: 1;
	wait_queue_head_t h_gracewait;
	struct rw_semaphore h_rwsem;
	u32 h_state;
	u32 h_nsmstate;
	u32 h_pidcount;
	refcount_t h_count;
	struct mutex h_mutex;
	long unsigned int h_nextrebind;
	long unsigned int h_expires;
	struct list_head h_lockowners;
	spinlock_t h_lock;
	struct list_head h_granted;
	struct list_head h_reclaim;
	struct nsm_handle *h_nsmhandle;
	char *h_addrbuf;
	struct net *net;
	const struct cred *h_cred;
	char nodename[65];
	const struct nlmclnt_operations *h_nlmclnt_ops;
};

enum {
	NLM_LCK_GRANTED = 0,
	NLM_LCK_DENIED = 1,
	NLM_LCK_DENIED_NOLOCKS = 2,
	NLM_LCK_BLOCKED = 3,
	NLM_LCK_DENIED_GRACE_PERIOD = 4,
	NLM_DEADLCK = 5,
	NLM_ROFS = 6,
	NLM_STALE_FH = 7,
	NLM_FBIG = 8,
	NLM_FAILED = 9,
};

struct nsm_private {
	unsigned char data[16];
};

struct nlm_lock {
	char *caller;
	unsigned int len;
	struct nfs_fh fh;
	struct xdr_netobj oh;
	u32 svid;
	struct file_lock fl;
};

struct nlm_cookie {
	unsigned char data[32];
	unsigned int len;
};

struct nlm_args {
	struct nlm_cookie cookie;
	struct nlm_lock lock;
	u32 block;
	u32 reclaim;
	u32 state;
	u32 monitor;
	u32 fsm_access;
	u32 fsm_mode;
};

struct nlm_res {
	struct nlm_cookie cookie;
	__be32 status;
	struct nlm_lock lock;
};

struct nsm_handle {
	struct list_head sm_link;
	refcount_t sm_count;
	char *sm_mon_name;
	char *sm_name;
	struct __kernel_sockaddr_storage sm_addr;
	size_t sm_addrlen;
	unsigned int sm_monitored: 1;
	unsigned int sm_sticky: 1;
	struct nsm_private sm_priv;
	char sm_addrbuf[51];
};

struct nlm_block;

struct nlm_rqst {
	refcount_t a_count;
	unsigned int a_flags;
	struct nlm_host *a_host;
	struct nlm_args a_args;
	struct nlm_res a_res;
	struct nlm_block *a_block;
	unsigned int a_retries;
	u8 a_owner[74];
	void *a_callback_data;
};

struct nlm_file;

struct nlm_block {
	struct kref b_count;
	struct list_head b_list;
	struct list_head b_flist;
	struct nlm_rqst *b_call;
	struct svc_serv *b_daemon;
	struct nlm_host *b_host;
	long unsigned int b_when;
	unsigned int b_id;
	unsigned char b_granted;
	struct nlm_file *b_file;
	struct cache_req *b_cache_req;
	struct cache_deferred_req *b_deferred_req;
	unsigned int b_flags;
};

struct nlm_share;

struct nlm_file {
	struct hlist_node f_list;
	struct nfs_fh f_handle;
	struct file *f_file;
	struct nlm_share *f_shares;
	struct list_head f_blocks;
	unsigned int f_locks;
	unsigned int f_count;
	struct mutex f_mutex;
};

struct nlm_wait {
	struct list_head b_list;
	wait_queue_head_t b_wait;
	struct nlm_host *b_host;
	struct file_lock *b_lock;
	short unsigned int b_reclaim;
	__be32 b_status;
};

struct nlm_wait;

struct nlm_reboot {
	char *mon;
	unsigned int len;
	u32 state;
	struct nsm_private priv;
};

struct lockd_net {
	unsigned int nlmsvc_users;
	long unsigned int next_gc;
	long unsigned int nrhosts;
	struct delayed_work grace_period_end;
	struct lock_manager lockd_manager;
	struct list_head nsm_handles;
};

struct nlm_lookup_host_info {
	const int server;
	const struct sockaddr *sap;
	const size_t salen;
	const short unsigned int protocol;
	const u32 version;
	const char *hostname;
	const size_t hostname_len;
	const int noresvport;
	struct net *net;
	const struct cred *cred;
};

struct ipv4_devconf {
	void *sysctl;
	int data[32];
	long unsigned int state[1];
};

struct in_ifaddr;

struct ip_mc_list;

struct in_device {
	struct net_device *dev;
	refcount_t refcnt;
	int dead;
	struct in_ifaddr *ifa_list;
	struct ip_mc_list *mc_list;
	struct ip_mc_list **mc_hash;
	int mc_count;
	spinlock_t mc_tomb_lock;
	struct ip_mc_list *mc_tomb;
	long unsigned int mr_v1_seen;
	long unsigned int mr_v2_seen;
	long unsigned int mr_maxdelay;
	long unsigned int mr_qi;
	long unsigned int mr_qri;
	unsigned char mr_qrv;
	unsigned char mr_gq_running;
	unsigned char mr_ifc_count;
	struct timer_list mr_gq_timer;
	struct timer_list mr_ifc_timer;
	struct neigh_parms *arp_parms;
	struct ipv4_devconf cnf;
	struct callback_head callback_head;
};

struct in_ifaddr {
	struct hlist_node hash;
	struct in_ifaddr *ifa_next;
	struct in_device *ifa_dev;
	struct callback_head callback_head;
	__be32 ifa_local;
	__be32 ifa_address;
	__be32 ifa_mask;
	__u32 ifa_rt_priority;
	__be32 ifa_broadcast;
	unsigned char ifa_scope;
	unsigned char ifa_prefixlen;
	__u32 ifa_flags;
	char ifa_label[16];
	__u32 ifa_valid_lft;
	__u32 ifa_preferred_lft;
	long unsigned int ifa_cstamp;
	long unsigned int ifa_tstamp;
};

struct inet6_ifaddr {
	struct in6_addr addr;
	__u32 prefix_len;
	__u32 rt_priority;
	__u32 valid_lft;
	__u32 prefered_lft;
	refcount_t refcnt;
	spinlock_t lock;
	int state;
	__u32 flags;
	__u8 dad_probes;
	__u8 stable_privacy_retry;
	__u16 scope;
	__u64 dad_nonce;
	long unsigned int cstamp;
	long unsigned int tstamp;
	struct delayed_work dad_work;
	struct inet6_dev *idev;
	struct fib6_info *rt;
	struct hlist_node addr_lst;
	struct list_head if_list;
	struct list_head tmp_list;
	struct inet6_ifaddr *ifpub;
	int regen_count;
	bool tokenized;
	struct callback_head rcu;
	struct in6_addr peer_addr;
};

struct nlmsvc_binding {
	__be32 (*fopen)(struct svc_rqst *, struct nfs_fh *, struct file **);
	void (*fclose)(struct file *);
};

typedef int (*nlm_host_match_fn_t)(void *, struct nlm_host *);

struct nlm_share {
	struct nlm_share *s_next;
	struct nlm_host *s_host;
	struct nlm_file *s_file;
	struct xdr_netobj s_owner;
	u32 s_access;
	u32 s_mode;
};

enum {
	NSMPROC_NULL = 0,
	NSMPROC_STAT = 1,
	NSMPROC_MON = 2,
	NSMPROC_UNMON = 3,
	NSMPROC_UNMON_ALL = 4,
	NSMPROC_SIMU_CRASH = 5,
	NSMPROC_NOTIFY = 6,
};

struct nsm_args {
	struct nsm_private *priv;
	u32 prog;
	u32 vers;
	u32 proc;
	char *mon_name;
	const char *nodename;
};

struct nsm_res {
	u32 status;
	u32 state;
};

typedef u32 unicode_t;

struct utf8_table {
	int cmask;
	int cval;
	int shift;
	long int lmask;
	long int lval;
};

typedef u16 uint16_t;

typedef struct {
	__u32 v32;
} jint32_t;

typedef struct {
	__u16 v16;
} jint16_t;

struct jffs2_full_dnode;

struct jffs2_full_dirent;

struct jffs2_inode_cache;

struct jffs2_inode_info {
	struct mutex sem;
	uint32_t highest_version;
	struct rb_root fragtree;
	struct jffs2_full_dnode *metadata;
	struct jffs2_full_dirent *dents;
	unsigned char *target;
	struct jffs2_inode_cache *inocache;
	uint16_t flags;
	uint8_t usercompr;
	struct inode vfs_inode;
};

struct jffs2_raw_node_ref;

struct jffs2_full_dnode {
	struct jffs2_raw_node_ref *raw;
	uint32_t ofs;
	uint32_t size;
	uint32_t frags;
};

struct jffs2_full_dirent {
	union {
		struct jffs2_raw_node_ref *raw;
		struct jffs2_inode_cache *ic;
	};
	struct jffs2_full_dirent *next;
	uint32_t version;
	uint32_t ino;
	unsigned int nhash;
	unsigned char type;
	unsigned char name[0];
};

struct jffs2_inode_cache {
	struct jffs2_full_dirent *scan_dents;
	struct jffs2_raw_node_ref *nodes;
	uint8_t class;
	uint8_t flags;
	uint16_t state;
	uint32_t ino;
	struct jffs2_inode_cache *next;
	uint32_t pino_nlink;
};

struct jffs2_mount_opts {
	bool override_compr;
	unsigned int compr;
	bool set_rp_size;
	unsigned int rp_size;
};

struct jffs2_eraseblock;

struct jffs2_inodirty;

struct jffs2_summary;

struct jffs2_sb_info {
	struct mtd_info *mtd;
	uint32_t highest_ino;
	uint32_t check_ino;
	unsigned int flags;
	struct task_struct *gc_task;
	struct completion gc_thread_start;
	struct completion gc_thread_exit;
	struct mutex alloc_sem;
	uint32_t cleanmarker_size;
	uint32_t flash_size;
	uint32_t used_size;
	uint32_t dirty_size;
	uint32_t wasted_size;
	uint32_t free_size;
	uint32_t erasing_size;
	uint32_t bad_size;
	uint32_t sector_size;
	uint32_t unchecked_size;
	uint32_t nr_free_blocks;
	uint32_t nr_erasing_blocks;
	uint8_t resv_blocks_write;
	uint8_t resv_blocks_deletion;
	uint8_t resv_blocks_gctrigger;
	uint8_t resv_blocks_gcbad;
	uint8_t resv_blocks_gcmerge;
	uint8_t vdirty_blocks_gctrigger;
	uint32_t nospc_dirty_size;
	uint32_t nr_blocks;
	struct jffs2_eraseblock *blocks;
	struct jffs2_eraseblock *nextblock;
	struct jffs2_eraseblock *gcblock;
	struct list_head clean_list;
	struct list_head very_dirty_list;
	struct list_head dirty_list;
	struct list_head erasable_list;
	struct list_head erasable_pending_wbuf_list;
	struct list_head erasing_list;
	struct list_head erase_checking_list;
	struct list_head erase_pending_list;
	struct list_head erase_complete_list;
	struct list_head free_list;
	struct list_head bad_list;
	struct list_head bad_used_list;
	spinlock_t erase_completion_lock;
	wait_queue_head_t erase_wait;
	wait_queue_head_t inocache_wq;
	int inocache_hashsize;
	struct jffs2_inode_cache **inocache_list;
	spinlock_t inocache_lock;
	struct mutex erase_free_sem;
	uint32_t wbuf_pagesize;
	unsigned char *wbuf;
	uint32_t wbuf_ofs;
	uint32_t wbuf_len;
	struct jffs2_inodirty *wbuf_inodes;
	struct rw_semaphore wbuf_sem;
	struct delayed_work wbuf_dwork;
	unsigned char *oobbuf;
	int oobavail;
	struct jffs2_summary *summary;
	struct jffs2_mount_opts mount_opts;
	void *os_priv;
};

struct jffs2_eraseblock {
	struct list_head list;
	int bad_count;
	uint32_t offset;
	uint32_t unchecked_size;
	uint32_t used_size;
	uint32_t dirty_size;
	uint32_t wasted_size;
	uint32_t free_size;
	uint32_t allocated_refs;
	struct jffs2_raw_node_ref *first_node;
	struct jffs2_raw_node_ref *last_node;
	struct jffs2_raw_node_ref *gc_node;
};

union jffs2_sum_mem;

struct jffs2_summary {
	uint32_t sum_size;
	uint32_t sum_num;
	uint32_t sum_padded;
	union jffs2_sum_mem *sum_list_head;
	union jffs2_sum_mem *sum_list_tail;
	jint32_t *sum_buf;
};

struct jffs2_raw_node_ref {
	struct jffs2_raw_node_ref *next_in_ino;
	uint32_t flash_offset;
};

struct jffs2_sum_unknown_mem {
	union jffs2_sum_mem *next;
	jint16_t nodetype;
};

struct jffs2_sum_inode_mem {
	union jffs2_sum_mem *next;
	jint16_t nodetype;
	jint32_t inode;
	jint32_t version;
	jint32_t offset;
	jint32_t totlen;
} __attribute__((packed));

struct jffs2_sum_dirent_mem {
	union jffs2_sum_mem *next;
	jint16_t nodetype;
	jint32_t totlen;
	jint32_t offset;
	jint32_t pino;
	jint32_t version;
	jint32_t ino;
	uint8_t nsize;
	uint8_t type;
	uint8_t name[0];
} __attribute__((packed));

struct jffs2_sum_xattr_mem {
	union jffs2_sum_mem *next;
	jint16_t nodetype;
	jint32_t xid;
	jint32_t version;
	jint32_t offset;
	jint32_t totlen;
} __attribute__((packed));

struct jffs2_sum_xref_mem {
	union jffs2_sum_mem *next;
	jint16_t nodetype;
	jint32_t offset;
} __attribute__((packed));

union jffs2_sum_mem {
	struct jffs2_sum_unknown_mem u;
	struct jffs2_sum_inode_mem i;
	struct jffs2_sum_dirent_mem d;
	struct jffs2_sum_xattr_mem x;
	struct jffs2_sum_xref_mem r;
};

struct jffs2_compressor {
	struct list_head list;
	int priority;
	char *name;
	char compr;
	int (*compress)(unsigned char *, unsigned char *, uint32_t *, uint32_t *);
	int (*decompress)(unsigned char *, unsigned char *, uint32_t, uint32_t);
	int usecount;
	int disabled;
	unsigned char *compr_buf;
	uint32_t compr_buf_size;
	uint32_t stat_compr_orig_size;
	uint32_t stat_compr_new_size;
	uint32_t stat_compr_blocks;
	uint32_t stat_decompr_blocks;
};

typedef struct {
	__u32 m;
} jmode_t;

struct jffs2_raw_dirent {
	jint16_t magic;
	jint16_t nodetype;
	jint32_t totlen;
	jint32_t hdr_crc;
	jint32_t pino;
	jint32_t version;
	jint32_t ino;
	jint32_t mctime;
	__u8 nsize;
	__u8 type;
	__u8 unused[2];
	jint32_t node_crc;
	jint32_t name_crc;
	__u8 name[0];
};

struct jffs2_raw_inode {
	jint16_t magic;
	jint16_t nodetype;
	jint32_t totlen;
	jint32_t hdr_crc;
	jint32_t ino;
	jint32_t version;
	jmode_t mode;
	jint16_t uid;
	jint16_t gid;
	jint32_t isize;
	jint32_t atime;
	jint32_t mtime;
	jint32_t ctime;
	jint32_t offset;
	jint32_t csize;
	jint32_t dsize;
	__u8 compr;
	__u8 usercompr;
	jint16_t flags;
	jint32_t data_crc;
	jint32_t node_crc;
	__u8 data[0];
};

union jffs2_device_node {
	jint16_t old_id;
	jint32_t new_id;
};

typedef unsigned char u_char;

struct mtd_ecc_stats {
	__u32 corrected;
	__u32 failed;
	__u32 badblocks;
	__u32 bbtblocks;
};

struct mtd_debug_info {
	struct dentry *dfs_dir;
	const char *partname;
	const char *partid;
};

struct nvmem_device;

struct mtd_part {
	struct list_head node;
	u64 offset;
	u64 size;
	u32 flags;
};

struct mtd_master {
	struct mutex partitions_lock;
	unsigned int suspended: 1;
};

struct mtd_ooblayout_ops;

struct mtd_pairing_scheme;

struct mtd_erase_region_info;

struct erase_info;

struct mtd_oob_ops;

struct otp_info;

struct mtd_info {
	u_char type;
	uint32_t flags;
	uint64_t size;
	uint32_t erasesize;
	uint32_t writesize;
	uint32_t writebufsize;
	uint32_t oobsize;
	uint32_t oobavail;
	unsigned int erasesize_shift;
	unsigned int writesize_shift;
	unsigned int erasesize_mask;
	unsigned int writesize_mask;
	unsigned int bitflip_threshold;
	const char *name;
	int index;
	const struct mtd_ooblayout_ops *ooblayout;
	const struct mtd_pairing_scheme *pairing;
	unsigned int ecc_step_size;
	unsigned int ecc_strength;
	int numeraseregions;
	struct mtd_erase_region_info *eraseregions;
	int (*_erase)(struct mtd_info *, struct erase_info *);
	int (*_point)(struct mtd_info *, loff_t, size_t, size_t *, void **, resource_size_t *);
	int (*_unpoint)(struct mtd_info *, loff_t, size_t);
	int (*_read)(struct mtd_info *, loff_t, size_t, size_t *, u_char *);
	int (*_write)(struct mtd_info *, loff_t, size_t, size_t *, const u_char *);
	int (*_panic_write)(struct mtd_info *, loff_t, size_t, size_t *, const u_char *);
	int (*_read_oob)(struct mtd_info *, loff_t, struct mtd_oob_ops *);
	int (*_write_oob)(struct mtd_info *, loff_t, struct mtd_oob_ops *);
	int (*_get_fact_prot_info)(struct mtd_info *, size_t, size_t *, struct otp_info *);
	int (*_read_fact_prot_reg)(struct mtd_info *, loff_t, size_t, size_t *, u_char *);
	int (*_get_user_prot_info)(struct mtd_info *, size_t, size_t *, struct otp_info *);
	int (*_read_user_prot_reg)(struct mtd_info *, loff_t, size_t, size_t *, u_char *);
	int (*_write_user_prot_reg)(struct mtd_info *, loff_t, size_t, size_t *, u_char *);
	int (*_lock_user_prot_reg)(struct mtd_info *, loff_t, size_t);
	int (*_writev)(struct mtd_info *, const struct kvec *, long unsigned int, loff_t, size_t *);
	void (*_sync)(struct mtd_info *);
	int (*_lock)(struct mtd_info *, loff_t, uint64_t);
	int (*_unlock)(struct mtd_info *, loff_t, uint64_t);
	int (*_is_locked)(struct mtd_info *, loff_t, uint64_t);
	int (*_block_isreserved)(struct mtd_info *, loff_t);
	int (*_block_isbad)(struct mtd_info *, loff_t);
	int (*_block_markbad)(struct mtd_info *, loff_t);
	int (*_max_bad_blocks)(struct mtd_info *, loff_t, size_t);
	int (*_suspend)(struct mtd_info *);
	void (*_resume)(struct mtd_info *);
	void (*_reboot)(struct mtd_info *);
	int (*_get_device)(struct mtd_info *);
	void (*_put_device)(struct mtd_info *);
	bool oops_panic_write;
	struct notifier_block reboot_notifier;
	struct mtd_ecc_stats ecc_stats;
	int subpage_sft;
	void *priv;
	struct module *owner;
	struct device dev;
	int usecount;
	struct mtd_debug_info dbg;
	struct nvmem_device *nvmem;
	struct mtd_info *parent;
	struct list_head partitions;
	union {
		struct mtd_part part;
		struct mtd_master master;
	};
};

struct otp_info {
	__u32 start;
	__u32 length;
	__u32 locked;
};

struct erase_info {
	uint64_t addr;
	uint64_t len;
	uint64_t fail_addr;
};

struct mtd_erase_region_info {
	uint64_t offset;
	uint32_t erasesize;
	uint32_t numblocks;
	long unsigned int *lockmap;
};

struct mtd_oob_ops {
	unsigned int mode;
	size_t len;
	size_t retlen;
	size_t ooblen;
	size_t oobretlen;
	uint32_t ooboffs;
	uint8_t *datbuf;
	uint8_t *oobbuf;
};

struct mtd_oob_region {
	u32 offset;
	u32 length;
};

struct mtd_ooblayout_ops {
	int (*ecc)(struct mtd_info *, int, struct mtd_oob_region *);
	int (*free)(struct mtd_info *, int, struct mtd_oob_region *);
};

struct mtd_pairing_info {
	int pair;
	int group;
};

struct mtd_pairing_scheme {
	int ngroups;
	int (*get_info)(struct mtd_info *, int, struct mtd_pairing_info *);
	int (*get_wunit)(struct mtd_info *, const struct mtd_pairing_info *);
};

struct jffs2_node_frag {
	struct rb_node rb;
	struct jffs2_full_dnode *node;
	uint32_t size;
	uint32_t ofs;
};

struct jffs2_tmp_dnode_info {
	struct rb_node rb;
	struct jffs2_full_dnode *fn;
	uint32_t version;
	uint32_t data_crc;
	uint32_t partial_crc;
	uint32_t csize;
	uint16_t overlapped;
};

struct jffs2_unknown_node {
	jint16_t magic;
	jint16_t nodetype;
	jint32_t totlen;
	jint32_t hdr_crc;
};

struct jffs2_raw_xattr {
	jint16_t magic;
	jint16_t nodetype;
	jint32_t totlen;
	jint32_t hdr_crc;
	jint32_t xid;
	jint32_t version;
	__u8 xprefix;
	__u8 name_len;
	jint16_t value_len;
	jint32_t data_crc;
	jint32_t node_crc;
	__u8 data[0];
};

struct jffs2_raw_xref {
	jint16_t magic;
	jint16_t nodetype;
	jint32_t totlen;
	jint32_t hdr_crc;
	jint32_t ino;
	jint32_t xid;
	jint32_t xseqno;
	jint32_t node_crc;
};

struct jffs2_raw_summary {
	jint16_t magic;
	jint16_t nodetype;
	jint32_t totlen;
	jint32_t hdr_crc;
	jint32_t sum_num;
	jint32_t cln_mkr;
	jint32_t padded;
	jint32_t sum_crc;
	jint32_t node_crc;
	jint32_t sum[0];
};

union jffs2_node_union {
	struct jffs2_raw_inode i;
	struct jffs2_raw_dirent d;
	struct jffs2_raw_xattr x;
	struct jffs2_raw_xref r;
	struct jffs2_raw_summary s;
	struct jffs2_unknown_node u;
};

struct jffs2_readinode_info {
	struct rb_root tn_root;
	struct jffs2_tmp_dnode_info *mdata_tn;
	uint32_t highest_version;
	uint32_t latest_mctime;
	uint32_t mctime_ver;
	struct jffs2_full_dirent *fds;
	struct jffs2_raw_node_ref *latest_ref;
};

struct jffs2_sum_marker {
	jint32_t offset;
	jint32_t magic;
};

enum {
	Opt_override_compr = 0,
	Opt_rp_size = 1,
};

enum {
	MTD_OPS_PLACE_OOB = 0,
	MTD_OPS_AUTO_OOB = 1,
	MTD_OPS_RAW = 2,
};

struct jffs2_inodirty {
	uint32_t ino;
	struct jffs2_inodirty *next;
};

struct jffs2_xattr_datum {
	void *always_null;
	struct jffs2_raw_node_ref *node;
	uint8_t class;
	uint8_t flags;
	uint16_t xprefix;
	struct list_head xindex;
	atomic_t refcnt;
	uint32_t xid;
	uint32_t version;
	uint32_t data_crc;
	uint32_t hashkey;
	char *xname;
	uint32_t name_len;
	char *xvalue;
	uint32_t value_len;
};

typedef unsigned char Byte;

typedef long unsigned int uLong;

struct internal_state;

struct z_stream_s {
	const Byte *next_in;
	uLong avail_in;
	uLong total_in;
	Byte *next_out;
	uLong avail_out;
	uLong total_out;
	char *msg;
	struct internal_state *state;
	void *workspace;
	int data_type;
	uLong adler;
	uLong reserved;
};

struct internal_state {
	int dummy;
};

typedef struct z_stream_s z_stream;

struct ubi_volume_info {
	int ubi_num;
	int vol_id;
	int size;
	long long int used_bytes;
	int used_ebs;
	int vol_type;
	int corrupted;
	int upd_marker;
	int alignment;
	int usable_leb_size;
	int name_len;
	const char *name;
	dev_t cdev;
};

struct ubi_device_info {
	int ubi_num;
	int leb_size;
	int leb_start;
	int min_io_size;
	int max_write_size;
	int ro_mode;
	dev_t cdev;
};

enum hash_algo {
	HASH_ALGO_MD4 = 0,
	HASH_ALGO_MD5 = 1,
	HASH_ALGO_SHA1 = 2,
	HASH_ALGO_RIPE_MD_160 = 3,
	HASH_ALGO_SHA256 = 4,
	HASH_ALGO_SHA384 = 5,
	HASH_ALGO_SHA512 = 6,
	HASH_ALGO_SHA224 = 7,
	HASH_ALGO_RIPE_MD_128 = 8,
	HASH_ALGO_RIPE_MD_256 = 9,
	HASH_ALGO_RIPE_MD_320 = 10,
	HASH_ALGO_WP_256 = 11,
	HASH_ALGO_WP_384 = 12,
	HASH_ALGO_WP_512 = 13,
	HASH_ALGO_TGR_128 = 14,
	HASH_ALGO_TGR_160 = 15,
	HASH_ALGO_TGR_192 = 16,
	HASH_ALGO_SM3_256 = 17,
	HASH_ALGO_STREEBOG_256 = 18,
	HASH_ALGO_STREEBOG_512 = 19,
	HASH_ALGO__LAST = 20,
};

struct crypto_template;

struct crypto_spawn;

struct crypto_instance {
	struct crypto_alg alg;
	struct crypto_template *tmpl;
	union {
		struct hlist_node list;
		struct crypto_spawn *spawns;
	};
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	void *__ctx[0];
};

struct crypto_spawn {
	struct list_head list;
	struct crypto_alg *alg;
	union {
		struct crypto_instance *inst;
		struct crypto_spawn *next;
	};
	const struct crypto_type *frontend;
	u32 mask;
	bool dead;
	bool registered;
};

struct rtattr;

struct crypto_template {
	struct list_head list;
	struct hlist_head instances;
	struct module *module;
	int (*create)(struct crypto_template *, struct rtattr **);
	char name[128];
};

enum {
	UBIFS_COMPR_NONE = 0,
	UBIFS_COMPR_LZO = 1,
	UBIFS_COMPR_ZLIB = 2,
	UBIFS_COMPR_ZSTD = 3,
	UBIFS_COMPR_TYPES_CNT = 4,
};

enum {
	UBIFS_INO_NODE = 0,
	UBIFS_DATA_NODE = 1,
	UBIFS_DENT_NODE = 2,
	UBIFS_XENT_NODE = 3,
	UBIFS_TRUN_NODE = 4,
	UBIFS_PAD_NODE = 5,
	UBIFS_SB_NODE = 6,
	UBIFS_MST_NODE = 7,
	UBIFS_REF_NODE = 8,
	UBIFS_IDX_NODE = 9,
	UBIFS_CS_NODE = 10,
	UBIFS_ORPH_NODE = 11,
	UBIFS_AUTH_NODE = 12,
	UBIFS_SIG_NODE = 13,
	UBIFS_NODE_TYPES_CNT = 14,
};

struct ubifs_ch {
	__le32 magic;
	__le32 crc;
	__le64 sqnum;
	__le32 len;
	__u8 node_type;
	__u8 group_type;
	__u8 padding[2];
};

struct ubifs_sb_node {
	struct ubifs_ch ch;
	__u8 padding[2];
	__u8 key_hash;
	__u8 key_fmt;
	__le32 flags;
	__le32 min_io_size;
	__le32 leb_size;
	__le32 leb_cnt;
	__le32 max_leb_cnt;
	__le64 max_bud_bytes;
	__le32 log_lebs;
	__le32 lpt_lebs;
	__le32 orph_lebs;
	__le32 jhead_cnt;
	__le32 fanout;
	__le32 lsave_cnt;
	__le32 fmt_version;
	__le16 default_compr;
	__u8 padding1[2];
	__le32 rp_uid;
	__le32 rp_gid;
	__le64 rp_size;
	__le32 time_gran;
	__u8 uuid[16];
	__le32 ro_compat_version;
	__u8 hmac[64];
	__u8 hmac_wkm[64];
	__le16 hash_algo;
	__u8 hash_mst[64];
	__u8 padding2[3774];
};

struct ubifs_mst_node {
	struct ubifs_ch ch;
	__le64 highest_inum;
	__le64 cmt_no;
	__le32 flags;
	__le32 log_lnum;
	__le32 root_lnum;
	__le32 root_offs;
	__le32 root_len;
	__le32 gc_lnum;
	__le32 ihead_lnum;
	__le32 ihead_offs;
	__le64 index_size;
	__le64 total_free;
	__le64 total_dirty;
	__le64 total_used;
	__le64 total_dead;
	__le64 total_dark;
	__le32 lpt_lnum;
	__le32 lpt_offs;
	__le32 nhead_lnum;
	__le32 nhead_offs;
	__le32 ltab_lnum;
	__le32 ltab_offs;
	__le32 lsave_lnum;
	__le32 lsave_offs;
	__le32 lscan_lnum;
	__le32 empty_lebs;
	__le32 idx_lebs;
	__le32 leb_cnt;
	__u8 hash_root_idx[64];
	__u8 hash_lpt[64];
	__u8 hmac[64];
	__u8 padding[152];
};

enum {
	DIRTY_ZNODE = 0,
	COW_ZNODE = 1,
	OBSOLETE_ZNODE = 2,
};

enum {
	COMMIT_RESTING = 0,
	COMMIT_BACKGROUND = 1,
	COMMIT_REQUIRED = 2,
	COMMIT_RUNNING_BACKGROUND = 3,
	COMMIT_RUNNING_REQUIRED = 4,
	COMMIT_BROKEN = 5,
};

union ubifs_key {
	uint8_t u8[8];
	uint32_t u32[2];
	uint64_t u64[1];
	__le32 j32[2];
};

enum {
	LPROPS_UNCAT = 0,
	LPROPS_DIRTY = 1,
	LPROPS_DIRTY_IDX = 2,
	LPROPS_FREE = 3,
	LPROPS_HEAP_CNT = 3,
	LPROPS_EMPTY = 4,
	LPROPS_FREEABLE = 5,
	LPROPS_FRDI_IDX = 6,
	LPROPS_CAT_MASK = 15,
	LPROPS_TAKEN = 16,
	LPROPS_INDEX = 32,
};

struct ubifs_lprops {
	int free;
	int dirty;
	int flags;
	int lnum;
	union {
		struct list_head list;
		int hpos;
	};
};

struct ubifs_lpt_lprops {
	int free;
	int dirty;
	unsigned int tgc: 1;
	unsigned int cmt: 1;
};

struct ubifs_lp_stats {
	int empty_lebs;
	int taken_empty_lebs;
	int idx_lebs;
	long long int total_free;
	long long int total_dirty;
	long long int total_used;
	long long int total_dead;
	long long int total_dark;
};

struct ubifs_nnode;

struct ubifs_cnode {
	struct ubifs_nnode *parent;
	struct ubifs_cnode *cnext;
	long unsigned int flags;
	int iip;
	int level;
	int num;
};

struct ubifs_pnode;

struct ubifs_nbranch {
	int lnum;
	int offs;
	union {
		struct ubifs_nnode *nnode;
		struct ubifs_pnode *pnode;
		struct ubifs_cnode *cnode;
	};
};

struct ubifs_nnode {
	struct ubifs_nnode *parent;
	struct ubifs_cnode *cnext;
	long unsigned int flags;
	int iip;
	int level;
	int num;
	struct ubifs_nbranch nbranch[4];
};

struct ubifs_pnode {
	struct ubifs_nnode *parent;
	struct ubifs_cnode *cnext;
	long unsigned int flags;
	int iip;
	int level;
	int num;
	struct ubifs_lprops lprops[4];
};

struct ubifs_lpt_heap {
	struct ubifs_lprops **arr;
	int cnt;
	int max_cnt;
};

struct ubifs_znode;

struct ubifs_zbranch {
	union ubifs_key key;
	union {
		struct ubifs_znode *znode;
		void *leaf;
	};
	int lnum;
	int offs;
	int len;
	u8 hash[0];
};

struct bu_info {
	union ubifs_key key;
	struct ubifs_zbranch zbranch[32];
	void *buf;
	int buf_len;
	int gc_seq;
	int cnt;
	int blk_cnt;
	int eof;
};

struct ubifs_budg_info {
	long long int idx_growth;
	long long int data_growth;
	long long int dd_growth;
	long long int uncommitted_idx;
	long long unsigned int old_idx_sz;
	int min_idx_lebs;
	unsigned int nospace: 1;
	unsigned int nospace_rp: 1;
	int page_budget;
	int inode_budget;
	int dent_budget;
};

struct ubifs_node_range {
	union {
		int len;
		int min_len;
	};
	int max_len;
};

struct ubi_volume_desc;

struct ubifs_mount_opts {
	unsigned int unmount_mode: 2;
	unsigned int bulk_read: 2;
	unsigned int chk_data_crc: 2;
	unsigned int override_compr: 1;
	unsigned int compr_type: 2;
};

struct ubifs_jhead;

struct ubifs_orphan;

struct ubifs_debug_info;

struct ubifs_info {
	struct super_block *vfs_sb;
	struct ubifs_sb_node *sup_node;
	ino_t highest_inum;
	long long unsigned int max_sqnum;
	long long unsigned int cmt_no;
	spinlock_t cnt_lock;
	int fmt_version;
	int ro_compat_version;
	unsigned char uuid[16];
	int lhead_lnum;
	int lhead_offs;
	int ltail_lnum;
	struct mutex log_mutex;
	int min_log_bytes;
	long long int cmt_bud_bytes;
	struct rb_root buds;
	long long int bud_bytes;
	spinlock_t buds_lock;
	int jhead_cnt;
	struct ubifs_jhead *jheads;
	long long int max_bud_bytes;
	long long int bg_bud_bytes;
	struct list_head old_buds;
	int max_bud_cnt;
	struct rw_semaphore commit_sem;
	int cmt_state;
	spinlock_t cs_lock;
	wait_queue_head_t cmt_wq;
	unsigned int big_lpt: 1;
	unsigned int space_fixup: 1;
	unsigned int double_hash: 1;
	unsigned int encrypted: 1;
	unsigned int no_chk_data_crc: 1;
	unsigned int bulk_read: 1;
	unsigned int default_compr: 2;
	unsigned int rw_incompat: 1;
	unsigned int assert_action: 2;
	unsigned int authenticated: 1;
	unsigned int superblock_need_write: 1;
	struct mutex tnc_mutex;
	struct ubifs_zbranch zroot;
	struct ubifs_znode *cnext;
	struct ubifs_znode *enext;
	int *gap_lebs;
	void *cbuf;
	void *ileb_buf;
	int ileb_len;
	int ihead_lnum;
	int ihead_offs;
	int *ilebs;
	int ileb_cnt;
	int ileb_nxt;
	struct rb_root old_idx;
	int *bottom_up_buf;
	struct ubifs_mst_node *mst_node;
	int mst_offs;
	int max_bu_buf_len;
	struct mutex bu_mutex;
	struct bu_info bu;
	struct mutex write_reserve_mutex;
	void *write_reserve_buf;
	int log_lebs;
	long long int log_bytes;
	int log_last;
	int lpt_lebs;
	int lpt_first;
	int lpt_last;
	int orph_lebs;
	int orph_first;
	int orph_last;
	int main_lebs;
	int main_first;
	long long int main_bytes;
	uint8_t key_hash_type;
	uint32_t (*key_hash)(const char *, int);
	int key_fmt;
	int key_len;
	int hash_len;
	int fanout;
	int min_io_size;
	int min_io_shift;
	int max_write_size;
	int max_write_shift;
	int leb_size;
	int leb_start;
	int half_leb_size;
	int idx_leb_size;
	int leb_cnt;
	int max_leb_cnt;
	unsigned int ro_media: 1;
	unsigned int ro_mount: 1;
	unsigned int ro_error: 1;
	atomic_long_t dirty_pg_cnt;
	atomic_long_t dirty_zn_cnt;
	atomic_long_t clean_zn_cnt;
	spinlock_t space_lock;
	struct ubifs_lp_stats lst;
	struct ubifs_budg_info bi;
	long long unsigned int calc_idx_sz;
	int ref_node_alsz;
	int mst_node_alsz;
	int min_idx_node_sz;
	int max_idx_node_sz;
	long long int max_inode_sz;
	int max_znode_sz;
	int leb_overhead;
	int dead_wm;
	int dark_wm;
	int block_cnt;
	struct ubifs_node_range ranges[14];
	struct ubi_volume_desc *ubi;
	struct ubi_device_info di;
	struct ubi_volume_info vi;
	struct rb_root orph_tree;
	struct list_head orph_list;
	struct list_head orph_new;
	struct ubifs_orphan *orph_cnext;
	struct ubifs_orphan *orph_dnext;
	spinlock_t orphan_lock;
	void *orph_buf;
	int new_orphans;
	int cmt_orphans;
	int tot_orphans;
	int max_orphans;
	int ohead_lnum;
	int ohead_offs;
	int no_orphs;
	struct task_struct *bgt;
	char bgt_name[24];
	int need_bgt;
	int need_wbuf_sync;
	int gc_lnum;
	void *sbuf;
	struct list_head idx_gc;
	int idx_gc_cnt;
	int gc_seq;
	int gced_lnum;
	struct list_head infos_list;
	struct mutex umount_mutex;
	unsigned int shrinker_run_no;
	int space_bits;
	int lpt_lnum_bits;
	int lpt_offs_bits;
	int lpt_spc_bits;
	int pcnt_bits;
	int lnum_bits;
	int nnode_sz;
	int pnode_sz;
	int ltab_sz;
	int lsave_sz;
	int pnode_cnt;
	int nnode_cnt;
	int lpt_hght;
	int pnodes_have;
	struct mutex lp_mutex;
	int lpt_lnum;
	int lpt_offs;
	int nhead_lnum;
	int nhead_offs;
	int lpt_drty_flgs;
	int dirty_nn_cnt;
	int dirty_pn_cnt;
	int check_lpt_free;
	long long int lpt_sz;
	void *lpt_nod_buf;
	void *lpt_buf;
	struct ubifs_nnode *nroot;
	struct ubifs_cnode *lpt_cnext;
	struct ubifs_lpt_heap lpt_heap[3];
	struct ubifs_lpt_heap dirty_idx;
	struct list_head uncat_list;
	struct list_head empty_list;
	struct list_head freeable_list;
	struct list_head frdi_idx_list;
	int freeable_cnt;
	int in_a_category_cnt;
	int ltab_lnum;
	int ltab_offs;
	struct ubifs_lpt_lprops *ltab;
	struct ubifs_lpt_lprops *ltab_cmt;
	int lsave_cnt;
	int lsave_lnum;
	int lsave_offs;
	int *lsave;
	int lscan_lnum;
	long long int rp_size;
	long long int report_rp_size;
	kuid_t rp_uid;
	kgid_t rp_gid;
	struct crypto_shash *hash_tfm;
	struct crypto_shash *hmac_tfm;
	int hmac_desc_len;
	char *auth_key_name;
	char *auth_hash_name;
	enum hash_algo auth_hash_algo;
	struct shash_desc *log_hash;
	unsigned int empty: 1;
	unsigned int need_recovery: 1;
	unsigned int replaying: 1;
	unsigned int mounting: 1;
	unsigned int remounting_rw: 1;
	unsigned int probing: 1;
	struct list_head replay_list;
	struct list_head replay_buds;
	long long unsigned int cs_sqnum;
	struct list_head unclean_leb_list;
	struct ubifs_mst_node *rcvrd_mst_node;
	struct rb_root size_tree;
	struct ubifs_mount_opts mount_opts;
	struct ubifs_debug_info *dbg;
};

struct ubifs_wbuf {
	struct ubifs_info *c;
	void *buf;
	int lnum;
	int offs;
	int avail;
	int used;
	int size;
	int jhead;
	int (*sync_callback)(struct ubifs_info *, int, int, int);
	struct mutex io_mutex;
	spinlock_t lock;
	struct hrtimer timer;
	unsigned int no_timer: 1;
	unsigned int need_sync: 1;
	int next_ino;
	ino_t *inodes;
};

struct ubifs_jhead {
	struct ubifs_wbuf wbuf;
	struct list_head buds_list;
	unsigned int grouped: 1;
	struct shash_desc *log_hash;
};

struct ubifs_znode {
	struct ubifs_znode *parent;
	struct ubifs_znode *cnext;
	struct ubifs_znode *cparent;
	int ciip;
	long unsigned int flags;
	time64_t time;
	int level;
	int child_cnt;
	int iip;
	int alt;
	int lnum;
	int offs;
	int len;
	struct ubifs_zbranch zbranch[0];
};

struct ubifs_orphan {
	struct rb_node rb;
	struct list_head list;
	struct list_head new_list;
	struct list_head child_list;
	struct ubifs_orphan *cnext;
	struct ubifs_orphan *dnext;
	ino_t inum;
	unsigned int new: 1;
	unsigned int cmt: 1;
	unsigned int del: 1;
};

struct ubifs_debug_info {
	struct ubifs_zbranch old_zroot;
	int old_zroot_level;
	long long unsigned int old_zroot_sqnum;
	int pc_happened;
	int pc_delay;
	long unsigned int pc_timeout;
	unsigned int pc_cnt;
	unsigned int pc_cnt_max;
	long long int chk_lpt_sz;
	long long int chk_lpt_sz2;
	long long int chk_lpt_wastage;
	int chk_lpt_lebs;
	int new_nhead_offs;
	int new_ihead_lnum;
	int new_ihead_offs;
	struct ubifs_lp_stats saved_lst;
	struct ubifs_budg_info saved_bi;
	long long int saved_free;
	int saved_idx_gc_cnt;
	unsigned int chk_gen: 1;
	unsigned int chk_index: 1;
	unsigned int chk_orph: 1;
	unsigned int chk_lprops: 1;
	unsigned int chk_fs: 1;
	unsigned int tst_rcvry: 1;
	char dfs_dir_name[10];
	struct dentry *dfs_dir;
	struct dentry *dfs_dump_lprops;
	struct dentry *dfs_dump_budg;
	struct dentry *dfs_dump_tnc;
	struct dentry *dfs_chk_gen;
	struct dentry *dfs_chk_index;
	struct dentry *dfs_chk_orph;
	struct dentry *dfs_chk_lprops;
	struct dentry *dfs_chk_fs;
	struct dentry *dfs_tst_rcvry;
	struct dentry *dfs_ro_error;
};

enum {
	UBIFS_ITYPE_REG = 0,
	UBIFS_ITYPE_DIR = 1,
	UBIFS_ITYPE_LNK = 2,
	UBIFS_ITYPE_BLK = 3,
	UBIFS_ITYPE_CHR = 4,
	UBIFS_ITYPE_FIFO = 5,
	UBIFS_ITYPE_SOCK = 6,
	UBIFS_ITYPES_CNT = 7,
};

enum {
	UBIFS_INO_KEY = 0,
	UBIFS_DATA_KEY = 1,
	UBIFS_DENT_KEY = 2,
	UBIFS_XENT_KEY = 3,
	UBIFS_KEY_TYPES_CNT = 4,
};

enum {
	UBIFS_COMPR_FL = 1,
	UBIFS_SYNC_FL = 2,
	UBIFS_IMMUTABLE_FL = 4,
	UBIFS_APPEND_FL = 8,
	UBIFS_DIRSYNC_FL = 16,
	UBIFS_XATTR_FL = 32,
	UBIFS_CRYPT_FL = 64,
};

struct ubifs_ino_node {
	struct ubifs_ch ch;
	__u8 key[16];
	__le64 creat_sqnum;
	__le64 size;
	__le64 atime_sec;
	__le64 ctime_sec;
	__le64 mtime_sec;
	__le32 atime_nsec;
	__le32 ctime_nsec;
	__le32 mtime_nsec;
	__le32 nlink;
	__le32 uid;
	__le32 gid;
	__le32 mode;
	__le32 flags;
	__le32 data_len;
	__le32 xattr_cnt;
	__le32 xattr_size;
	__u8 padding1[4];
	__le32 xattr_names;
	__le16 compr_type;
	__u8 padding2[26];
	__u8 data[0];
};

struct ubifs_dent_node {
	struct ubifs_ch ch;
	__u8 key[16];
	__le64 inum;
	__u8 padding1;
	__u8 type;
	__le16 nlen;
	__le32 cookie;
	__u8 name[0];
};

struct ubifs_data_node {
	struct ubifs_ch ch;
	__u8 key[16];
	__le32 size;
	__le16 compr_type;
	__le16 compr_size;
	__u8 data[0];
};

struct ubifs_trun_node {
	struct ubifs_ch ch;
	__le32 inum;
	__u8 padding[12];
	__le64 old_size;
	__le64 new_size;
};

struct ubifs_inode {
	struct inode vfs_inode;
	long long unsigned int creat_sqnum;
	long long unsigned int del_cmtno;
	unsigned int xattr_size;
	unsigned int xattr_cnt;
	unsigned int xattr_names;
	unsigned int dirty: 1;
	unsigned int xattr: 1;
	unsigned int bulk_read: 1;
	unsigned int compr_type: 2;
	struct mutex ui_mutex;
	struct rw_semaphore xattr_sem;
	spinlock_t ui_lock;
	loff_t synced_i_size;
	loff_t ui_size;
	int flags;
	long unsigned int last_page_read;
	long unsigned int read_in_a_row;
	int data_len;
	void *data;
};

struct ubifs_budget_req {
	unsigned int fast: 1;
	unsigned int recalculate: 1;
	unsigned int new_page: 1;
	unsigned int dirtied_page: 1;
	unsigned int new_dent: 1;
	unsigned int mod_dent: 1;
	unsigned int new_ino: 1;
	unsigned int new_ino_d: 13;
	unsigned int dirtied_ino: 4;
	char: 8;
	unsigned int dirtied_ino_d: 15;
	int idx_growth;
	int data_growth;
	int dd_growth;
};

union ubifs_dev_desc {
	__le32 new;
	__le64 huge;
};

struct ubifs_global_debug_info {
	unsigned int chk_gen: 1;
	unsigned int chk_index: 1;
	unsigned int chk_orph: 1;
	unsigned int chk_lprops: 1;
	unsigned int chk_fs: 1;
	unsigned int tst_rcvry: 1;
};

enum {
	UBI_DYNAMIC_VOLUME = 3,
	UBI_STATIC_VOLUME = 4,
};

enum {
	UBI_READONLY = 1,
	UBI_READWRITE = 2,
	UBI_EXCLUSIVE = 3,
	UBI_METAONLY = 4,
};

struct crypto_comp {
	struct crypto_tfm base;
};

enum {
	UBIFS_SIMPLE_KEY_FMT = 0,
};

enum {
	UBIFS_MST_DIRTY = 1,
	UBIFS_MST_NO_ORPHS = 2,
	UBIFS_MST_RCVRY = 4,
};

enum {
	ASSACT_REPORT = 0,
	ASSACT_RO = 1,
	ASSACT_PANIC = 2,
};

struct ubifs_unclean_leb {
	struct list_head list;
	int lnum;
	int endpt;
};

struct ubifs_bud {
	int lnum;
	int start;
	int jhead;
	struct list_head list;
	struct rb_node rb;
	struct shash_desc *log_hash;
};

struct ubifs_compressor {
	int compr_type;
	struct crypto_comp *cc;
	struct mutex *comp_mutex;
	struct mutex *decomp_mutex;
	const char *name;
	const char *capi_name;
};

struct fscrypt_operations;

enum {
	Opt_fast_unmount = 0,
	Opt_norm_unmount = 1,
	Opt_bulk_read = 2,
	Opt_no_bulk_read = 3,
	Opt_chk_data_crc = 4,
	Opt_no_chk_data_crc = 5,
	Opt_override_compr___2 = 6,
	Opt_assert = 7,
	Opt_auth_key = 8,
	Opt_auth_hash_name = 9,
	Opt_ignore = 10,
	Opt_err___4 = 11,
};

enum {
	UBIFS_KEY_HASH_R5 = 0,
	UBIFS_KEY_HASH_TEST = 1,
};

enum {
	UBIFS_FLG_BIGLPT = 2,
	UBIFS_FLG_SPACE_FIXUP = 4,
	UBIFS_FLG_DOUBLE_HASH = 8,
	UBIFS_FLG_ENCRYPTION = 16,
	UBIFS_FLG_AUTHENTICATION = 32,
};

struct ubifs_branch {
	__le32 lnum;
	__le32 offs;
	__le32 len;
	__u8 key[0];
};

struct ubifs_idx_node {
	struct ubifs_ch ch;
	__le16 child_cnt;
	__le16 level;
	__u8 branches[0];
} __attribute__((packed));

struct ubifs_cs_node {
	struct ubifs_ch ch;
	__le64 cmt_no;
};

enum {
	UBIFS_NO_NODE_GROUP = 0,
	UBIFS_IN_NODE_GROUP = 1,
	UBIFS_LAST_OF_NODE_GROUP = 2,
};

struct ubifs_pad_node {
	struct ubifs_ch ch;
	__le32 pad_len;
} __attribute__((packed));

struct ubifs_old_idx {
	struct rb_node rb;
	int lnum;
	int offs;
};

enum {
	NAME_LESS = 0,
	NAME_MATCHES = 1,
	NAME_GREATER = 2,
	NOT_ON_MEDIA = 3,
};

struct ubifs_scan_node {
	struct list_head list;
	union ubifs_key key;
	long long unsigned int sqnum;
	int type;
	int offs;
	int len;
	void *node;
};

struct ubifs_scan_leb {
	int lnum;
	int nodes_cnt;
	struct list_head nodes;
	int endpt;
	void *buf;
};

enum {
	SCANNED_GARBAGE = 0,
	SCANNED_EMPTY_SPACE = 4294967295,
	SCANNED_A_NODE = 4294967294,
	SCANNED_A_CORRUPT_NODE = 4294967293,
	SCANNED_A_BAD_PAD_NODE = 4294967292,
};

struct shash_alg {
	int (*init)(struct shash_desc *);
	int (*update)(struct shash_desc *, const u8 *, unsigned int);
	int (*final)(struct shash_desc *, u8 *);
	int (*finup)(struct shash_desc *, const u8 *, unsigned int, u8 *);
	int (*digest)(struct shash_desc *, const u8 *, unsigned int, u8 *);
	int (*export)(struct shash_desc *, void *);
	int (*import)(struct shash_desc *, const void *);
	int (*setkey)(struct crypto_shash *, const u8 *, unsigned int);
	int (*init_tfm)(struct crypto_shash *);
	void (*exit_tfm)(struct crypto_shash *);
	unsigned int descsize;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	unsigned int digestsize;
	unsigned int statesize;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct crypto_alg base;
};

struct ubifs_ref_node {
	struct ubifs_ch ch;
	__le32 lnum;
	__le32 offs;
	__le32 jhead;
	__u8 padding[28];
};

struct ubifs_auth_node {
	struct ubifs_ch ch;
	__u8 hmac[0];
};

struct replay_entry {
	int lnum;
	int offs;
	int len;
	u8 hash[0];
	unsigned int deletion: 1;
	long long unsigned int sqnum;
	struct list_head list;
	union ubifs_key key;
	union {
		struct fscrypt_name nm;
		struct {
			loff_t old_size;
			loff_t new_size;
		};
	};
};

struct bud_entry {
	struct list_head list;
	struct ubifs_bud *bud;
	long long unsigned int sqnum;
	int free;
	int dirty;
};

struct done_ref {
	struct rb_node rb;
	int lnum;
};

enum {
	DIRTY_CNODE = 0,
	OBSOLETE_CNODE = 1,
	COW_CNODE = 2,
};

struct idx_node {
	struct list_head list;
	int iip;
	union ubifs_key upper_key;
	struct ubifs_idx_node idx;
};

enum {
	LEB_FREED = 0,
	LEB_FREED_IDX = 1,
	LEB_RETAINED = 2,
};

struct ubifs_gced_idx_leb {
	struct list_head list;
	int lnum;
	int unmap;
};

struct ubifs_orph_node {
	struct ubifs_ch ch;
	__le64 cmt_no;
	__le64 inos[0];
};

struct check_orphan {
	struct rb_node rb;
	ino_t inum;
};

struct check_info {
	long unsigned int last_ino;
	long unsigned int tot_inos;
	long unsigned int missing;
	long long unsigned int leaf_cnt;
	struct ubifs_ino_node *node;
	struct rb_root root;
};

enum {
	LPT_SCAN_CONTINUE = 0,
	LPT_SCAN_ADD = 1,
	LPT_SCAN_STOP = 2,
};

typedef int (*ubifs_lpt_scan_callback)(struct ubifs_info *, const struct ubifs_lprops *, int, void *);

struct scan_data {
	int min_space;
	int pick_free;
	int lnum;
	int exclude_index;
};

enum {
	UBIFS_LPT_PNODE = 0,
	UBIFS_LPT_NNODE = 1,
	UBIFS_LPT_LTAB = 2,
	UBIFS_LPT_LSAVE = 3,
	UBIFS_LPT_NODE_CNT = 4,
	UBIFS_LPT_NOT_A_NODE = 15,
};

enum {
	LTAB_DIRTY = 1,
	LSAVE_DIRTY = 2,
};

struct lpt_scan_node {
	union {
		struct ubifs_nnode nnode;
		struct ubifs_pnode pnode;
		struct ubifs_cnode cnode;
	};
	int in_tree;
	union {
		struct ubifs_nnode *nnode;
		struct ubifs_pnode *pnode;
		struct ubifs_cnode *cnode;
	} ptr;
};

struct size_entry {
	struct rb_node rb;
	ino_t inum;
	loff_t i_size;
	loff_t d_size;
	int exists;
	struct inode *inode;
};

typedef int (*dbg_leaf_callback)(struct ubifs_info *, struct ubifs_zbranch *, void *);

typedef int (*dbg_znode_callback)(struct ubifs_info *, struct ubifs_znode *, void *);

struct fsck_inode {
	struct rb_node rb;
	ino_t inum;
	umode_t mode;
	unsigned int nlink;
	unsigned int xattr_cnt;
	int references;
	int calc_cnt;
	long long int size;
	unsigned int xattr_sz;
	long long int calc_sz;
	long long int calc_xcnt;
	long long int calc_xsz;
	unsigned int xattr_nms;
	long long int calc_xnms;
};

struct fsck_data {
	struct rb_root inodes;
};

typedef unsigned int autofs_wqt_t;

struct autofs_sb_info;

struct autofs_info {
	struct dentry *dentry;
	struct inode *inode;
	int flags;
	struct completion expire_complete;
	struct list_head active;
	struct list_head expiring;
	struct autofs_sb_info *sbi;
	long unsigned int last_used;
	int count;
	kuid_t uid;
	kgid_t gid;
	struct callback_head rcu;
};

struct autofs_wait_queue;

struct autofs_sb_info {
	u32 magic;
	int pipefd;
	struct file *pipe;
	struct pid *oz_pgrp;
	int version;
	int sub_version;
	int min_proto;
	int max_proto;
	unsigned int flags;
	long unsigned int exp_timeout;
	unsigned int type;
	struct super_block *sb;
	struct mutex wq_mutex;
	struct mutex pipe_mutex;
	spinlock_t fs_lock;
	struct autofs_wait_queue *queues;
	spinlock_t lookup_lock;
	struct list_head active_list;
	struct list_head expiring_list;
	struct callback_head rcu;
};

struct autofs_wait_queue {
	wait_queue_head_t queue;
	struct autofs_wait_queue *next;
	autofs_wqt_t wait_queue_token;
	struct qstr name;
	u32 dev;
	u64 ino;
	kuid_t uid;
	kgid_t gid;
	pid_t pid;
	pid_t tgid;
	int status;
	unsigned int wait_ctr;
};

enum {
	Opt_err___5 = 0,
	Opt_fd = 1,
	Opt_uid___5 = 2,
	Opt_gid___6 = 3,
	Opt_pgrp = 4,
	Opt_minproto = 5,
	Opt_maxproto = 6,
	Opt_indirect = 7,
	Opt_direct = 8,
	Opt_offset = 9,
	Opt_strictexpire = 10,
	Opt_ignore___2 = 11,
};

enum {
	AUTOFS_IOC_READY_CMD = 96,
	AUTOFS_IOC_FAIL_CMD = 97,
	AUTOFS_IOC_CATATONIC_CMD = 98,
	AUTOFS_IOC_PROTOVER_CMD = 99,
	AUTOFS_IOC_SETTIMEOUT_CMD = 100,
	AUTOFS_IOC_EXPIRE_CMD = 101,
};

enum autofs_notify {
	NFY_NONE = 0,
	NFY_MOUNT = 1,
	NFY_EXPIRE = 2,
};

enum {
	AUTOFS_IOC_EXPIRE_MULTI_CMD = 102,
	AUTOFS_IOC_PROTOSUBVER_CMD = 103,
	AUTOFS_IOC_ASKUMOUNT_CMD = 112,
};

struct autofs_packet_hdr {
	int proto_version;
	int type;
};

struct autofs_packet_missing {
	struct autofs_packet_hdr hdr;
	autofs_wqt_t wait_queue_token;
	int len;
	char name[256];
};

struct autofs_packet_expire {
	struct autofs_packet_hdr hdr;
	int len;
	char name[256];
};

struct autofs_packet_expire_multi {
	struct autofs_packet_hdr hdr;
	autofs_wqt_t wait_queue_token;
	int len;
	char name[256];
};

union autofs_packet_union {
	struct autofs_packet_hdr hdr;
	struct autofs_packet_missing missing;
	struct autofs_packet_expire expire;
	struct autofs_packet_expire_multi expire_multi;
};

struct autofs_v5_packet {
	struct autofs_packet_hdr hdr;
	autofs_wqt_t wait_queue_token;
	__u32 dev;
	__u64 ino;
	__u32 uid;
	__u32 gid;
	__u32 pid;
	__u32 tgid;
	__u32 len;
	char name[256];
};

typedef struct autofs_v5_packet autofs_packet_missing_indirect_t;

typedef struct autofs_v5_packet autofs_packet_expire_indirect_t;

typedef struct autofs_v5_packet autofs_packet_missing_direct_t;

typedef struct autofs_v5_packet autofs_packet_expire_direct_t;

union autofs_v5_packet_union {
	struct autofs_packet_hdr hdr;
	struct autofs_v5_packet v5_packet;
	autofs_packet_missing_indirect_t missing_indirect;
	autofs_packet_expire_indirect_t expire_indirect;
	autofs_packet_missing_direct_t missing_direct;
	autofs_packet_expire_direct_t expire_direct;
};

struct args_protover {
	__u32 version;
};

struct args_protosubver {
	__u32 sub_version;
};

struct args_openmount {
	__u32 devid;
};

struct args_ready {
	__u32 token;
};

struct args_fail {
	__u32 token;
	__s32 status;
};

struct args_setpipefd {
	__s32 pipefd;
};

struct args_timeout {
	__u64 timeout;
};

struct args_requester {
	__u32 uid;
	__u32 gid;
};

struct args_expire {
	__u32 how;
};

struct args_askumount {
	__u32 may_umount;
};

struct args_in {
	__u32 type;
};

struct args_out {
	__u32 devid;
	__u32 magic;
};

struct args_ismountpoint {
	union {
		struct args_in in;
		struct args_out out;
	};
};

struct autofs_dev_ioctl {
	__u32 ver_major;
	__u32 ver_minor;
	__u32 size;
	__s32 ioctlfd;
	union {
		struct args_protover protover;
		struct args_protosubver protosubver;
		struct args_openmount openmount;
		struct args_ready ready;
		struct args_fail fail;
		struct args_setpipefd setpipefd;
		struct args_timeout timeout;
		struct args_requester requester;
		struct args_expire expire;
		struct args_askumount askumount;
		struct args_ismountpoint ismountpoint;
	};
	char path[0];
};

enum {
	AUTOFS_DEV_IOCTL_VERSION_CMD = 113,
	AUTOFS_DEV_IOCTL_PROTOVER_CMD = 114,
	AUTOFS_DEV_IOCTL_PROTOSUBVER_CMD = 115,
	AUTOFS_DEV_IOCTL_OPENMOUNT_CMD = 116,
	AUTOFS_DEV_IOCTL_CLOSEMOUNT_CMD = 117,
	AUTOFS_DEV_IOCTL_READY_CMD = 118,
	AUTOFS_DEV_IOCTL_FAIL_CMD = 119,
	AUTOFS_DEV_IOCTL_SETPIPEFD_CMD = 120,
	AUTOFS_DEV_IOCTL_CATATONIC_CMD = 121,
	AUTOFS_DEV_IOCTL_TIMEOUT_CMD = 122,
	AUTOFS_DEV_IOCTL_REQUESTER_CMD = 123,
	AUTOFS_DEV_IOCTL_EXPIRE_CMD = 124,
	AUTOFS_DEV_IOCTL_ASKUMOUNT_CMD = 125,
	AUTOFS_DEV_IOCTL_ISMOUNTPOINT_CMD = 126,
};

typedef int (*ioctl_fn)(struct file *, struct autofs_sb_info *, struct autofs_dev_ioctl *);

enum fuse_opcode {
	FUSE_LOOKUP = 1,
	FUSE_FORGET = 2,
	FUSE_GETATTR = 3,
	FUSE_SETATTR = 4,
	FUSE_READLINK = 5,
	FUSE_SYMLINK = 6,
	FUSE_MKNOD = 8,
	FUSE_MKDIR = 9,
	FUSE_UNLINK = 10,
	FUSE_RMDIR = 11,
	FUSE_RENAME = 12,
	FUSE_LINK = 13,
	FUSE_OPEN = 14,
	FUSE_READ = 15,
	FUSE_WRITE = 16,
	FUSE_STATFS = 17,
	FUSE_RELEASE = 18,
	FUSE_FSYNC = 20,
	FUSE_SETXATTR = 21,
	FUSE_GETXATTR = 22,
	FUSE_LISTXATTR = 23,
	FUSE_REMOVEXATTR = 24,
	FUSE_FLUSH = 25,
	FUSE_INIT = 26,
	FUSE_OPENDIR = 27,
	FUSE_READDIR = 28,
	FUSE_RELEASEDIR = 29,
	FUSE_FSYNCDIR = 30,
	FUSE_GETLK = 31,
	FUSE_SETLK = 32,
	FUSE_SETLKW = 33,
	FUSE_ACCESS = 34,
	FUSE_CREATE = 35,
	FUSE_INTERRUPT = 36,
	FUSE_BMAP = 37,
	FUSE_DESTROY = 38,
	FUSE_IOCTL = 39,
	FUSE_POLL = 40,
	FUSE_NOTIFY_REPLY = 41,
	FUSE_BATCH_FORGET = 42,
	FUSE_FALLOCATE = 43,
	FUSE_READDIRPLUS = 44,
	FUSE_RENAME2 = 45,
	FUSE_LSEEK = 46,
	FUSE_COPY_FILE_RANGE = 47,
	FUSE_SETUPMAPPING = 48,
	FUSE_REMOVEMAPPING = 49,
	FUSE_CANONICAL_PATH = 2016,
	CUSE_INIT = 4096,
	CUSE_INIT_BSWAP_RESERVED = 1048576,
	FUSE_INIT_BSWAP_RESERVED = 436207616,
};

enum fuse_notify_code {
	FUSE_NOTIFY_POLL = 1,
	FUSE_NOTIFY_INVAL_INODE = 2,
	FUSE_NOTIFY_INVAL_ENTRY = 3,
	FUSE_NOTIFY_STORE = 4,
	FUSE_NOTIFY_RETRIEVE = 5,
	FUSE_NOTIFY_DELETE = 6,
	FUSE_NOTIFY_CODE_MAX = 7,
};

struct fuse_forget_in {
	uint64_t nlookup;
};

struct fuse_forget_one {
	uint64_t nodeid;
	uint64_t nlookup;
};

struct fuse_batch_forget_in {
	uint32_t count;
	uint32_t dummy;
};

struct fuse_interrupt_in {
	uint64_t unique;
};

struct fuse_notify_poll_wakeup_out {
	uint64_t kh;
};

struct fuse_in_header {
	uint32_t len;
	uint32_t opcode;
	uint64_t unique;
	uint64_t nodeid;
	uint32_t uid;
	uint32_t gid;
	uint32_t pid;
	uint32_t padding;
};

struct fuse_out_header {
	uint32_t len;
	int32_t error;
	uint64_t unique;
};

struct fuse_notify_inval_inode_out {
	uint64_t ino;
	int64_t off;
	int64_t len;
};

struct fuse_notify_inval_entry_out {
	uint64_t parent;
	uint32_t namelen;
	uint32_t padding;
};

struct fuse_notify_delete_out {
	uint64_t parent;
	uint64_t child;
	uint32_t namelen;
	uint32_t padding;
};

struct fuse_notify_store_out {
	uint64_t nodeid;
	uint64_t offset;
	uint32_t size;
	uint32_t padding;
};

struct fuse_notify_retrieve_out {
	uint64_t notify_unique;
	uint64_t nodeid;
	uint64_t offset;
	uint32_t size;
	uint32_t padding;
};

struct fuse_notify_retrieve_in {
	uint64_t dummy1;
	uint64_t offset;
	uint32_t size;
	uint32_t dummy2;
	uint64_t dummy3;
	uint64_t dummy4;
};

struct fuse_forget_link {
	struct fuse_forget_one forget_one;
	struct fuse_forget_link *next;
};

struct fuse_passthrough {
	struct file *filp;
	struct cred *cred;
};

struct fuse_mount;

struct fuse_release_args;

struct fuse_file {
	struct fuse_mount *fm;
	struct fuse_release_args *release_args;
	u64 kh;
	u64 fh;
	u64 nodeid;
	refcount_t count;
	u32 open_flags;
	struct list_head write_entry;
	struct {
		struct mutex lock;
		loff_t pos;
		loff_t cache_off;
		u64 version;
	} readdir;
	struct fuse_passthrough passthrough;
	struct rb_node polled_node;
	wait_queue_head_t poll_wait;
	bool flock: 1;
};

struct fuse_conn;

struct fuse_mount {
	struct fuse_conn *fc;
	refcount_t count;
	struct super_block *sb;
	struct list_head fc_entry;
};

struct fuse_in_arg {
	unsigned int size;
	const void *value;
};

struct fuse_arg {
	unsigned int size;
	void *value;
};

struct fuse_page_desc {
	unsigned int length;
	unsigned int offset;
};

struct fuse_args {
	uint64_t nodeid;
	uint32_t opcode;
	short unsigned int in_numargs;
	short unsigned int out_numargs;
	bool force: 1;
	bool noreply: 1;
	bool nocreds: 1;
	bool in_pages: 1;
	bool out_pages: 1;
	bool user_pages: 1;
	bool out_argvar: 1;
	bool page_zeroing: 1;
	bool page_replace: 1;
	bool may_block: 1;
	struct fuse_in_arg in_args[3];
	struct fuse_arg out_args[2];
	void (*end)(struct fuse_mount *, struct fuse_args *, int);
	struct path *canonical_path;
};

struct fuse_args_pages {
	struct fuse_args args;
	struct page **pages;
	struct fuse_page_desc *descs;
	unsigned int num_pages;
};

enum fuse_req_flag {
	FR_ISREPLY = 0,
	FR_FORCE = 1,
	FR_BACKGROUND = 2,
	FR_WAITING = 3,
	FR_ABORTED = 4,
	FR_INTERRUPTED = 5,
	FR_LOCKED = 6,
	FR_PENDING = 7,
	FR_SENT = 8,
	FR_FINISHED = 9,
	FR_PRIVATE = 10,
	FR_ASYNC = 11,
};

struct fuse_req {
	struct list_head list;
	struct list_head intr_entry;
	struct fuse_args *args;
	refcount_t count;
	long unsigned int flags;
	struct {
		struct fuse_in_header h;
	} in;
	struct {
		struct fuse_out_header h;
	} out;
	wait_queue_head_t waitq;
	void *argbuf;
	struct fuse_mount *fm;
};

struct fuse_iqueue;

struct fuse_iqueue_ops {
	void (*wake_forget_and_unlock)(struct fuse_iqueue *);
	void (*wake_interrupt_and_unlock)(struct fuse_iqueue *);
	void (*wake_pending_and_unlock)(struct fuse_iqueue *);
	void (*release)(struct fuse_iqueue *);
};

struct fuse_iqueue {
	unsigned int connected;
	spinlock_t lock;
	wait_queue_head_t waitq;
	u64 reqctr;
	struct list_head pending;
	struct list_head interrupts;
	struct fuse_forget_link forget_list_head;
	struct fuse_forget_link *forget_list_tail;
	int forget_batch;
	struct fasync_struct *fasync;
	const struct fuse_iqueue_ops *ops;
	void *priv;
};

struct fuse_pqueue {
	unsigned int connected;
	spinlock_t lock;
	struct list_head *processing;
	struct list_head io;
};

struct fuse_dev {
	struct fuse_conn *fc;
	struct fuse_pqueue pq;
	struct list_head entry;
};

struct fuse_conn {
	spinlock_t lock;
	refcount_t count;
	atomic_t dev_count;
	struct callback_head rcu;
	kuid_t user_id;
	kgid_t group_id;
	struct pid_namespace *pid_ns;
	struct user_namespace *user_ns;
	unsigned int max_read;
	unsigned int max_write;
	unsigned int max_pages;
	struct fuse_iqueue iq;
	atomic64_t khctr;
	struct rb_root polled_files;
	unsigned int max_background;
	unsigned int congestion_threshold;
	unsigned int num_background;
	unsigned int active_background;
	struct list_head bg_queue;
	spinlock_t bg_lock;
	int initialized;
	int blocked;
	wait_queue_head_t blocked_waitq;
	unsigned int connected;
	bool aborted;
	unsigned int conn_error: 1;
	unsigned int conn_init: 1;
	unsigned int async_read: 1;
	unsigned int abort_err: 1;
	unsigned int atomic_o_trunc: 1;
	unsigned int export_support: 1;
	unsigned int writeback_cache: 1;
	unsigned int parallel_dirops: 1;
	unsigned int handle_killpriv: 1;
	unsigned int cache_symlinks: 1;
	unsigned int legacy_opts_show: 1;
	unsigned int no_open: 1;
	unsigned int no_opendir: 1;
	unsigned int no_fsync: 1;
	unsigned int no_fsyncdir: 1;
	unsigned int no_flush: 1;
	unsigned int no_setxattr: 1;
	unsigned int no_getxattr: 1;
	unsigned int no_listxattr: 1;
	unsigned int no_removexattr: 1;
	unsigned int no_lock: 1;
	unsigned int no_access: 1;
	unsigned int no_create: 1;
	unsigned int no_interrupt: 1;
	unsigned int no_bmap: 1;
	unsigned int no_poll: 1;
	unsigned int big_writes: 1;
	unsigned int dont_mask: 1;
	unsigned int no_flock: 1;
	unsigned int no_fallocate: 1;
	unsigned int no_rename2: 1;
	unsigned int auto_inval_data: 1;
	unsigned int explicit_inval_data: 1;
	unsigned int do_readdirplus: 1;
	unsigned int readdirplus_auto: 1;
	unsigned int async_dio: 1;
	unsigned int no_lseek: 1;
	unsigned int posix_acl: 1;
	unsigned int default_permissions: 1;
	unsigned int allow_other: 1;
	unsigned int no_copy_file_range: 1;
	unsigned int destroy: 1;
	unsigned int delete_stale: 1;
	unsigned int no_control: 1;
	unsigned int no_force_umount: 1;
	unsigned int auto_submounts: 1;
	unsigned int passthrough: 1;
	atomic_t num_waiting;
	unsigned int minor;
	struct list_head entry;
	dev_t dev;
	struct dentry *ctl_dentry[5];
	int ctl_ndents;
	u32 scramble_key[4];
	atomic64_t attr_version;
	void (*release)(struct fuse_conn *);
	struct rw_semaphore killsb;
	struct list_head devices;
	struct list_head mounts;
	struct idr passthrough_req;
	spinlock_t passthrough_req_lock;
};

struct fuse_copy_state {
	int write;
	struct fuse_req *req;
	struct iov_iter *iter;
	struct pipe_buffer *pipebufs;
	struct pipe_buffer *currbuf;
	struct pipe_inode_info *pipe;
	long unsigned int nr_segs;
	struct page *pg;
	unsigned int len;
	unsigned int offset;
	unsigned int move_pages: 1;
};

struct fuse_retrieve_args {
	struct fuse_args_pages ap;
	struct fuse_notify_retrieve_in inarg;
};

struct fuse_attr {
	uint64_t ino;
	uint64_t size;
	uint64_t blocks;
	uint64_t atime;
	uint64_t mtime;
	uint64_t ctime;
	uint32_t atimensec;
	uint32_t mtimensec;
	uint32_t ctimensec;
	uint32_t mode;
	uint32_t nlink;
	uint32_t uid;
	uint32_t gid;
	uint32_t rdev;
	uint32_t blksize;
	uint32_t flags;
};

struct fuse_entry_out {
	uint64_t nodeid;
	uint64_t generation;
	uint64_t entry_valid;
	uint64_t attr_valid;
	uint32_t entry_valid_nsec;
	uint32_t attr_valid_nsec;
	struct fuse_attr attr;
};

struct fuse_getattr_in {
	uint32_t getattr_flags;
	uint32_t dummy;
	uint64_t fh;
};

struct fuse_attr_out {
	uint64_t attr_valid;
	uint32_t attr_valid_nsec;
	uint32_t dummy;
	struct fuse_attr attr;
};

struct fuse_mknod_in {
	uint32_t mode;
	uint32_t rdev;
	uint32_t umask;
	uint32_t padding;
};

struct fuse_mkdir_in {
	uint32_t mode;
	uint32_t umask;
};

struct fuse_rename2_in {
	uint64_t newdir;
	uint32_t flags;
	uint32_t padding;
};

struct fuse_link_in {
	uint64_t oldnodeid;
};

struct fuse_setattr_in {
	uint32_t valid;
	uint32_t padding;
	uint64_t fh;
	uint64_t size;
	uint64_t lock_owner;
	uint64_t atime;
	uint64_t mtime;
	uint64_t ctime;
	uint32_t atimensec;
	uint32_t mtimensec;
	uint32_t ctimensec;
	uint32_t mode;
	uint32_t unused4;
	uint32_t uid;
	uint32_t gid;
	uint32_t unused5;
};

struct fuse_create_in {
	uint32_t flags;
	uint32_t mode;
	uint32_t umask;
	uint32_t padding;
};

struct fuse_open_out {
	uint64_t fh;
	uint32_t open_flags;
	uint32_t passthrough_fh;
};

struct fuse_access_in {
	uint32_t mask;
	uint32_t padding;
};

struct fuse_inode {
	struct inode inode;
	u64 nodeid;
	u64 nlookup;
	struct fuse_forget_link *forget;
	u64 i_time;
	u32 inval_mask;
	umode_t orig_i_mode;
	u64 orig_ino;
	u64 attr_version;
	union {
		struct {
			struct list_head write_files;
			struct list_head queued_writes;
			int writectr;
			wait_queue_head_t page_waitq;
			struct rb_root writepages;
		};
		struct {
			bool cached;
			loff_t size;
			loff_t pos;
			u64 version;
			struct timespec64 mtime;
			u64 iversion;
			spinlock_t lock;
		} rdc;
	};
	long unsigned int state;
	struct mutex mutex;
	spinlock_t lock;
	struct rw_semaphore i_mmap_sem;
};

enum {
	FUSE_I_ADVISE_RDPLUS = 0,
	FUSE_I_INIT_RDPLUS = 1,
	FUSE_I_SIZE_UNSTABLE = 2,
	FUSE_I_BAD = 3,
};

struct fuse_file_lock {
	uint64_t start;
	uint64_t end;
	uint32_t type;
	uint32_t pid;
};

struct fuse_open_in {
	uint32_t flags;
	uint32_t unused;
};

struct fuse_release_in {
	uint64_t fh;
	uint32_t flags;
	uint32_t release_flags;
	uint64_t lock_owner;
};

struct fuse_flush_in {
	uint64_t fh;
	uint32_t unused;
	uint32_t padding;
	uint64_t lock_owner;
};

struct fuse_read_in {
	uint64_t fh;
	uint64_t offset;
	uint32_t size;
	uint32_t read_flags;
	uint64_t lock_owner;
	uint32_t flags;
	uint32_t padding;
};

struct fuse_write_in {
	uint64_t fh;
	uint64_t offset;
	uint32_t size;
	uint32_t write_flags;
	uint64_t lock_owner;
	uint32_t flags;
	uint32_t padding;
};

struct fuse_write_out {
	uint32_t size;
	uint32_t padding;
};

struct fuse_fsync_in {
	uint64_t fh;
	uint32_t fsync_flags;
	uint32_t padding;
};

struct fuse_lk_in {
	uint64_t fh;
	uint64_t owner;
	struct fuse_file_lock lk;
	uint32_t lk_flags;
	uint32_t padding;
};

struct fuse_lk_out {
	struct fuse_file_lock lk;
};

struct fuse_bmap_in {
	uint64_t block;
	uint32_t blocksize;
	uint32_t padding;
};

struct fuse_bmap_out {
	uint64_t block;
};

struct fuse_ioctl_in {
	uint64_t fh;
	uint32_t flags;
	uint32_t cmd;
	uint64_t arg;
	uint32_t in_size;
	uint32_t out_size;
};

struct fuse_ioctl_iovec {
	uint64_t base;
	uint64_t len;
};

struct fuse_ioctl_out {
	int32_t result;
	uint32_t flags;
	uint32_t in_iovs;
	uint32_t out_iovs;
};

struct fuse_poll_in {
	uint64_t fh;
	uint64_t kh;
	uint32_t flags;
	uint32_t events;
};

struct fuse_poll_out {
	uint32_t revents;
	uint32_t padding;
};

struct fuse_fallocate_in {
	uint64_t fh;
	uint64_t offset;
	uint64_t length;
	uint32_t mode;
	uint32_t padding;
};

struct fuse_lseek_in {
	uint64_t fh;
	uint64_t offset;
	uint32_t whence;
	uint32_t padding;
};

struct fuse_lseek_out {
	uint64_t offset;
};

struct fuse_copy_file_range_in {
	uint64_t fh_in;
	uint64_t off_in;
	uint64_t nodeid_out;
	uint64_t fh_out;
	uint64_t off_out;
	uint64_t len;
	uint64_t flags;
};

struct fuse_release_args {
	struct fuse_args args;
	struct fuse_release_in inarg;
	struct inode *inode;
};

struct fuse_io_priv {
	struct kref refcnt;
	int async;
	spinlock_t lock;
	unsigned int reqs;
	ssize_t bytes;
	size_t size;
	__u64 offset;
	bool write;
	bool should_dirty;
	int err;
	struct kiocb *iocb;
	struct completion *done;
	bool blocking;
};

struct fuse_io_args {
	union {
		struct {
			struct fuse_read_in in;
			u64 attr_ver;
		} read;
		struct {
			struct fuse_write_in in;
			struct fuse_write_out out;
			bool page_locked;
		} write;
	};
	struct fuse_args_pages ap;
	struct fuse_io_priv *io;
	struct fuse_file *ff;
};

struct fuse_writepage_args {
	struct fuse_io_args ia;
	struct rb_node writepages_entry;
	struct list_head queue_entry;
	struct fuse_writepage_args *next;
	struct inode *inode;
};

struct fuse_fill_wb_data {
	struct fuse_writepage_args *wpa;
	struct fuse_file *ff;
	struct inode *inode;
	struct page **orig_pages;
	unsigned int max_pages;
};

struct fuse_kstatfs {
	uint64_t blocks;
	uint64_t bfree;
	uint64_t bavail;
	uint64_t files;
	uint64_t ffree;
	uint32_t bsize;
	uint32_t namelen;
	uint32_t frsize;
	uint32_t padding;
	uint32_t spare[6];
};

struct fuse_statfs_out {
	struct fuse_kstatfs st;
};

struct fuse_init_in {
	uint32_t major;
	uint32_t minor;
	uint32_t max_readahead;
	uint32_t flags;
};

struct fuse_init_out {
	uint32_t major;
	uint32_t minor;
	uint32_t max_readahead;
	uint32_t flags;
	uint16_t max_background;
	uint16_t congestion_threshold;
	uint32_t max_write;
	uint32_t time_gran;
	uint16_t max_pages;
	uint16_t map_alignment;
	uint32_t unused[8];
};

struct fuse_fs_context {
	int fd;
	unsigned int rootmode;
	kuid_t user_id;
	kgid_t group_id;
	bool is_bdev: 1;
	bool fd_present: 1;
	bool rootmode_present: 1;
	bool user_id_present: 1;
	bool group_id_present: 1;
	bool default_permissions: 1;
	bool allow_other: 1;
	bool destroy: 1;
	bool no_control: 1;
	bool no_force_umount: 1;
	bool legacy_opts_show: 1;
	bool dax: 1;
	unsigned int max_read;
	unsigned int blksize;
	const char *subtype;
	struct dax_device *dax_dev;
	void **fudptr;
};

enum {
	OPT_SOURCE = 0,
	OPT_SUBTYPE = 1,
	OPT_FD = 2,
	OPT_ROOTMODE = 3,
	OPT_USER_ID = 4,
	OPT_GROUP_ID = 5,
	OPT_DEFAULT_PERMISSIONS = 6,
	OPT_ALLOW_OTHER = 7,
	OPT_MAX_READ = 8,
	OPT_BLKSIZE = 9,
	OPT_ERR = 10,
};

struct fuse_inode_handle {
	u64 nodeid;
	u32 generation;
};

struct fuse_init_args {
	struct fuse_args args;
	struct fuse_init_in in;
	struct fuse_init_out out;
};

struct fuse_setxattr_in {
	uint32_t size;
	uint32_t flags;
};

struct fuse_getxattr_in {
	uint32_t size;
	uint32_t padding;
};

struct fuse_getxattr_out {
	uint32_t size;
	uint32_t padding;
};

struct fuse_dirent {
	uint64_t ino;
	uint64_t off;
	uint32_t namelen;
	uint32_t type;
	char name[0];
};

struct fuse_direntplus {
	struct fuse_entry_out entry_out;
	struct fuse_dirent dirent;
};

enum fuse_parse_result {
	FOUND_ERR = 4294967295,
	FOUND_NONE = 0,
	FOUND_SOME = 1,
	FOUND_ALL = 2,
};

struct fuse_aio_req {
	struct kiocb iocb;
	struct kiocb *iocb_fuse;
};

struct ovl_config {
	char *lowerdir;
	char *upperdir;
	char *workdir;
	bool default_permissions;
	bool redirect_dir;
	bool redirect_follow;
	const char *redirect_mode;
	bool index;
	bool nfs_export;
	int xino;
	bool metacopy;
	bool ovl_volatile;
	bool override_creds;
};

struct ovl_sb {
	struct super_block *sb;
	dev_t pseudo_dev;
	bool bad_uuid;
	bool is_lower;
};

struct ovl_layer {
	struct vfsmount *mnt;
	struct inode *trap;
	struct ovl_sb *fs;
	int idx;
	int fsid;
};

struct ovl_path {
	const struct ovl_layer *layer;
	struct dentry *dentry;
};

struct ovl_fs {
	unsigned int numlayer;
	unsigned int numfs;
	const struct ovl_layer *layers;
	struct ovl_sb *fs;
	struct dentry *workbasedir;
	struct dentry *workdir;
	struct dentry *indexdir;
	long int namelen;
	struct ovl_config config;
	const struct cred *creator_cred;
	bool tmpfile;
	bool noxattr;
	bool upperdir_locked;
	bool workdir_locked;
	bool share_whiteout;
	struct inode *workbasedir_trap;
	struct inode *workdir_trap;
	struct inode *indexdir_trap;
	int xino_mode;
	atomic_long_t last_ino;
	struct dentry *whiteout;
	errseq_t errseq;
};

struct ovl_entry {
	union {
		struct {
			long unsigned int flags;
		};
		struct callback_head rcu;
	};
	unsigned int numlower;
	struct ovl_path lowerstack[0];
};

struct ovl_dir_cache;

struct ovl_inode {
	union {
		struct ovl_dir_cache *cache;
		struct inode *lowerdata;
	};
	const char *redirect;
	u64 version;
	long unsigned int flags;
	struct inode vfs_inode;
	struct dentry *__upperdentry;
	struct inode *lower;
	struct mutex lock;
};

enum ovl_xattr {
	OVL_XATTR_OPAQUE = 0,
	OVL_XATTR_REDIRECT = 1,
	OVL_XATTR_ORIGIN = 2,
	OVL_XATTR_IMPURE = 3,
	OVL_XATTR_NLINK = 4,
	OVL_XATTR_UPPER = 5,
	OVL_XATTR_METACOPY = 6,
};

enum ovl_inode_flag {
	OVL_IMPURE = 0,
	OVL_WHITEOUTS = 1,
	OVL_INDEX = 2,
	OVL_UPPERDATA = 3,
	OVL_CONST_INO = 4,
};

enum ovl_entry_flag {
	OVL_E_UPPER_ALIAS = 0,
	OVL_E_OPAQUE = 1,
	OVL_E_CONNECTED = 2,
};

enum {
	OVL_XINO_OFF = 0,
	OVL_XINO_AUTO = 1,
	OVL_XINO_ON = 2,
};

struct ovl_inode_params {
	struct inode *newinode;
	struct dentry *upperdentry;
	struct ovl_path *lowerpath;
	bool index;
	unsigned int numlower;
	char *redirect;
	struct dentry *lowerdata;
};

struct ovl_cattr {
	dev_t rdev;
	umode_t mode;
	const char *link;
	struct dentry *hardlink;
};

enum {
	OPT_LOWERDIR = 0,
	OPT_UPPERDIR = 1,
	OPT_WORKDIR = 2,
	OPT_DEFAULT_PERMISSIONS___2 = 3,
	OPT_REDIRECT_DIR = 4,
	OPT_INDEX_ON = 5,
	OPT_INDEX_OFF = 6,
	OPT_NFS_EXPORT_ON = 7,
	OPT_NFS_EXPORT_OFF = 8,
	OPT_XINO_ON = 9,
	OPT_XINO_OFF = 10,
	OPT_XINO_AUTO = 11,
	OPT_METACOPY_ON = 12,
	OPT_METACOPY_OFF = 13,
	OPT_VOLATILE = 14,
	OPT_OVERRIDE_CREDS_ON = 15,
	OPT_OVERRIDE_CREDS_OFF = 16,
	OPT_ERR___2 = 17,
};

struct ovl_fb {
	u8 version;
	u8 magic;
	u8 len;
	u8 flags;
	u8 type;
	uuid_t uuid;
	u32 fid[0];
} __attribute__((packed));

struct ovl_fh {
	u8 padding[3];
	union {
		struct ovl_fb fb;
		u8 buf[0];
	};
} __attribute__((packed));

struct ovl_lookup_data {
	struct super_block *sb;
	struct qstr name;
	bool is_dir;
	bool opaque;
	bool stop;
	bool last;
	char *redirect;
	bool metacopy;
};

enum ovl_path_type {
	__OVL_PATH_UPPER = 1,
	__OVL_PATH_MERGE = 2,
	__OVL_PATH_ORIGIN = 4,
};

struct ovl_aio_req {
	struct kiocb iocb;
	refcount_t ref;
	struct kiocb *orig_iocb;
	struct fd fd;
};

enum ovl_copyop {
	OVL_COPY = 0,
	OVL_CLONE = 1,
	OVL_DEDUPE = 2,
};

struct ovl_dir_cache {
	long int refcount;
	u64 version;
	struct list_head entries;
	struct rb_root root;
};

struct ovl_cache_entry {
	unsigned int len;
	unsigned int type;
	u64 real_ino;
	u64 ino;
	struct list_head l_node;
	struct rb_node node;
	struct ovl_cache_entry *next_maybe_whiteout;
	bool is_upper;
	bool is_whiteout;
	char name[0];
};

struct ovl_readdir_data {
	struct dir_context ctx;
	struct dentry *dentry;
	bool is_lowest;
	struct rb_root *root;
	struct list_head *list;
	struct list_head middle;
	struct ovl_cache_entry *first_maybe_whiteout;
	int count;
	int err;
	bool is_upper;
	bool d_type_supported;
};

struct ovl_dir_file {
	bool is_real;
	bool is_upper;
	struct ovl_dir_cache *cache;
	struct list_head *cursor;
	struct file *realfile;
	struct file *upperfile;
};

struct ovl_readdir_translate {
	struct dir_context *orig_ctx;
	struct ovl_dir_cache *cache;
	struct dir_context ctx;
	u64 parent_ino;
	int fsid;
	int xinobits;
	bool xinowarn;
};

struct ovl_copy_up_ctx {
	struct dentry *parent;
	struct dentry *dentry;
	struct path lowerpath;
	struct kstat stat;
	struct kstat pstat;
	const char *link;
	struct dentry *destdir;
	struct qstr destname;
	struct dentry *workdir;
	bool origin;
	bool indexed;
	bool metacopy;
};

struct ovl_cu_creds {
	const struct cred *old;
	struct cred *new;
};

struct p9_qid {
	u8 type;
	u32 version;
	u64 path;
};

struct p9_wstat {
	u16 size;
	u16 type;
	u32 dev;
	struct p9_qid qid;
	u32 mode;
	u32 atime;
	u32 mtime;
	u64 length;
	const char *name;
	const char *uid;
	const char *gid;
	const char *muid;
	char *extension;
	kuid_t n_uid;
	kgid_t n_gid;
	kuid_t n_muid;
};

struct p9_stat_dotl {
	u64 st_result_mask;
	struct p9_qid qid;
	u32 st_mode;
	kuid_t st_uid;
	kgid_t st_gid;
	u64 st_nlink;
	u64 st_rdev;
	u64 st_size;
	u64 st_blksize;
	u64 st_blocks;
	u64 st_atime_sec;
	u64 st_atime_nsec;
	u64 st_mtime_sec;
	u64 st_mtime_nsec;
	u64 st_ctime_sec;
	u64 st_ctime_nsec;
	u64 st_btime_sec;
	u64 st_btime_nsec;
	u64 st_gen;
	u64 st_data_version;
};

struct p9_rstatfs {
	u32 type;
	u32 bsize;
	u64 blocks;
	u64 bfree;
	u64 bavail;
	u64 files;
	u64 ffree;
	u64 fsid;
	u32 namelen;
};

enum p9_trans_status {
	Connected = 0,
	BeginDisconnect = 1,
	Disconnected = 2,
	Hung = 3,
};

struct p9_trans_module;

struct p9_client {
	spinlock_t lock;
	unsigned int msize;
	unsigned char proto_version;
	struct p9_trans_module *trans_mod;
	enum p9_trans_status status;
	void *trans;
	struct kmem_cache *fcall_cache;
	union {
		struct {
			int rfd;
			int wfd;
		} fd;
		struct {
			u16 port;
			bool privport;
		} tcp;
	} trans_opts;
	struct idr fids;
	struct idr reqs;
	char name[65];
};

struct p9_fid {
	struct p9_client *clnt;
	u32 fid;
	int mode;
	struct p9_qid qid;
	u32 iounit;
	kuid_t uid;
	void *rdir;
	struct hlist_node dlist;
};

enum p9_session_flags {
	V9FS_PROTO_2000U = 1,
	V9FS_PROTO_2000L = 2,
	V9FS_ACCESS_SINGLE = 4,
	V9FS_ACCESS_USER = 8,
	V9FS_ACCESS_CLIENT = 16,
	V9FS_POSIX_ACL = 32,
};

enum p9_cache_modes {
	CACHE_NONE = 0,
	CACHE_MMAP = 1,
	CACHE_LOOSE = 2,
	CACHE_FSCACHE = 3,
	nr__p9_cache_modes = 4,
};

struct v9fs_session_info {
	unsigned char flags;
	unsigned char nodev;
	short unsigned int debug;
	unsigned int afid;
	unsigned int cache;
	char *uname;
	char *aname;
	unsigned int maxdata;
	kuid_t dfltuid;
	kgid_t dfltgid;
	kuid_t uid;
	struct p9_client *clnt;
	struct list_head slist;
	struct rw_semaphore rename_sem;
	long int session_lock_timeout;
};

struct v9fs_inode {
	struct p9_qid qid;
	unsigned int cache_validity;
	struct p9_fid *writeback_fid;
	struct mutex v_mutex;
	struct inode vfs_inode;
};

enum p9_open_mode_t {
	P9_OREAD = 0,
	P9_OWRITE = 1,
	P9_ORDWR = 2,
	P9_OEXEC = 3,
	P9_OTRUNC = 16,
	P9_OREXEC = 32,
	P9_ORCLOSE = 64,
	P9_OAPPEND = 128,
	P9_OEXCL = 4096,
};

enum p9_perm_t {
	P9_DMDIR = 2147483648,
	P9_DMAPPEND = 1073741824,
	P9_DMEXCL = 536870912,
	P9_DMMOUNT = 268435456,
	P9_DMAUTH = 134217728,
	P9_DMTMP = 67108864,
	P9_DMSYMLINK = 33554432,
	P9_DMLINK = 16777216,
	P9_DMDEVICE = 8388608,
	P9_DMNAMEDPIPE = 2097152,
	P9_DMSOCKET = 1048576,
	P9_DMSETUID = 524288,
	P9_DMSETGID = 262144,
	P9_DMSETVTX = 65536,
};

struct p9_iattr_dotl {
	u32 valid;
	u32 mode;
	kuid_t uid;
	kgid_t gid;
	u64 size;
	u64 atime_sec;
	u64 atime_nsec;
	u64 mtime_sec;
	u64 mtime_nsec;
};

struct dotl_openflag_map {
	int open_flag;
	int dotl_flag;
};

struct dotl_iattr_map {
	int iattr_valid;
	int p9_iattr_valid;
};

struct p9_flock {
	u8 type;
	u32 flags;
	u64 start;
	u64 length;
	u32 proc_id;
	char *client_id;
};

struct p9_getlock {
	u8 type;
	u64 start;
	u64 length;
	u32 proc_id;
	char *client_id;
};

struct p9_dirent {
	struct p9_qid qid;
	u64 d_off;
	unsigned char d_type;
	char d_name[256];
};

struct p9_rdir {
	int head;
	int tail;
	uint8_t buf[0];
};

struct p9_fcall {
	u32 size;
	u8 id;
	u16 tag;
	size_t offset;
	size_t capacity;
	struct kmem_cache *cache;
	u8 *sdata;
};

struct p9_req_t {
	int status;
	int t_err;
	struct kref refcount;
	wait_queue_head_t wq;
	struct p9_fcall tc;
	struct p9_fcall rc;
	struct list_head req_list;
};

struct p9_trans_module {
	struct list_head list;
	char *name;
	int maxsize;
	int def;
	struct module *owner;
	int (*create)(struct p9_client *, const char *, char *);
	void (*close)(struct p9_client *);
	int (*request)(struct p9_client *, struct p9_req_t *);
	int (*cancel)(struct p9_client *, struct p9_req_t *);
	int (*cancelled)(struct p9_client *, struct p9_req_t *);
	int (*zc_request)(struct p9_client *, struct p9_req_t *, struct iov_iter *, struct iov_iter *, int, int, int);
	int (*show_options)(struct seq_file *, struct p9_client *);
};

enum {
	Opt_debug___3 = 0,
	Opt_dfltuid = 1,
	Opt_dfltgid = 2,
	Opt_afid = 3,
	Opt_uname = 4,
	Opt_remotename = 5,
	Opt_cache = 6,
	Opt_cachetag = 7,
	Opt_nodevmap = 8,
	Opt_cache_loose = 9,
	Opt_fscache___2 = 10,
	Opt_mmap = 11,
	Opt_access = 12,
	Opt_posixacl = 13,
	Opt_locktimeout = 14,
	Opt_err___6 = 15,
};

typedef struct vfsmount * (*debugfs_automount_t)(struct dentry *, void *);

struct debugfs_fsdata {
	const struct file_operations *real_fops;
	refcount_t active_users;
	struct completion active_users_drained;
};

struct debugfs_mount_opts {
	kuid_t uid;
	kgid_t gid;
	umode_t mode;
};

enum {
	Opt_uid___6 = 0,
	Opt_gid___7 = 1,
	Opt_mode___5 = 2,
	Opt_err___7 = 3,
};

struct debugfs_fs_info {
	struct debugfs_mount_opts mount_opts;
};

struct debugfs_blob_wrapper {
	void *data;
	long unsigned int size;
};

struct debugfs_reg32 {
	char *name;
	long unsigned int offset;
};

struct debugfs_regset32 {
	const struct debugfs_reg32 *regs;
	int nregs;
	void *base;
	struct device *dev;
};

struct debugfs_devm_entry {
	int (*read)(struct seq_file *, void *);
	struct device *dev;
};

struct tracefs_dir_ops {
	int (*mkdir)(const char *);
	int (*rmdir)(const char *);
};

struct tracefs_mount_opts {
	kuid_t uid;
	kgid_t gid;
	umode_t mode;
};

struct tracefs_fs_info {
	struct tracefs_mount_opts mount_opts;
};

typedef int __kernel_key_t;

typedef __kernel_key_t key_t;

struct ipc_perm {
	__kernel_key_t key;
	__kernel_uid_t uid;
	__kernel_gid_t gid;
	__kernel_uid_t cuid;
	__kernel_gid_t cgid;
	__kernel_mode_t mode;
	short unsigned int seq;
};

struct ipc64_perm {
	__kernel_key_t key;
	__kernel_uid32_t uid;
	__kernel_gid32_t gid;
	__kernel_uid32_t cuid;
	__kernel_gid32_t cgid;
	__kernel_mode_t mode;
	unsigned char __pad1[0];
	short unsigned int seq;
	short unsigned int __pad2;
	__kernel_ulong_t __unused1;
	__kernel_ulong_t __unused2;
};

struct kern_ipc_perm {
	spinlock_t lock;
	bool deleted;
	int id;
	key_t key;
	kuid_t uid;
	kgid_t gid;
	kuid_t cuid;
	kgid_t cgid;
	umode_t mode;
	long unsigned int seq;
	void *security;
	struct rhash_head khtnode;
	struct callback_head rcu;
	refcount_t refcount;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct ipc_params {
	key_t key;
	int flg;
	union {
		size_t size;
		int nsems;
	} u;
};

struct ipc_ops {
	int (*getnew)(struct ipc_namespace *, struct ipc_params *);
	int (*associate)(struct kern_ipc_perm *, int);
	int (*more_checks)(struct kern_ipc_perm *, struct ipc_params *);
};

struct ipc_proc_iface {
	const char *path;
	const char *header;
	int ids;
	int (*show)(struct seq_file *, void *);
};

struct ipc_proc_iter {
	struct ipc_namespace *ns;
	struct pid_namespace *pid_ns;
	struct ipc_proc_iface *iface;
};

struct msg_msgseg;

struct msg_msg {
	struct list_head m_list;
	long int m_type;
	size_t m_ts;
	struct msg_msgseg *next;
	void *security;
};

struct msg_msgseg {
	struct msg_msgseg *next;
};

typedef int __kernel_ipc_pid_t;

typedef __kernel_long_t __kernel_old_time_t;

struct msgbuf {
	__kernel_long_t mtype;
	char mtext[1];
};

struct msg;

struct msqid_ds {
	struct ipc_perm msg_perm;
	struct msg *msg_first;
	struct msg *msg_last;
	__kernel_old_time_t msg_stime;
	__kernel_old_time_t msg_rtime;
	__kernel_old_time_t msg_ctime;
	long unsigned int msg_lcbytes;
	long unsigned int msg_lqbytes;
	short unsigned int msg_cbytes;
	short unsigned int msg_qnum;
	short unsigned int msg_qbytes;
	__kernel_ipc_pid_t msg_lspid;
	__kernel_ipc_pid_t msg_lrpid;
};

struct msqid64_ds {
	struct ipc64_perm msg_perm;
	long int msg_stime;
	long int msg_rtime;
	long int msg_ctime;
	long unsigned int msg_cbytes;
	long unsigned int msg_qnum;
	long unsigned int msg_qbytes;
	__kernel_pid_t msg_lspid;
	__kernel_pid_t msg_lrpid;
	long unsigned int __unused4;
	long unsigned int __unused5;
};

struct msginfo {
	int msgpool;
	int msgmap;
	int msgmax;
	int msgmnb;
	int msgmni;
	int msgssz;
	int msgtql;
	short unsigned int msgseg;
};

struct msg_queue {
	struct kern_ipc_perm q_perm;
	time64_t q_stime;
	time64_t q_rtime;
	time64_t q_ctime;
	long unsigned int q_cbytes;
	long unsigned int q_qnum;
	long unsigned int q_qbytes;
	struct pid *q_lspid;
	struct pid *q_lrpid;
	struct list_head q_messages;
	struct list_head q_receivers;
	struct list_head q_senders;
	long: 64;
	long: 64;
};

struct msg_receiver {
	struct list_head r_list;
	struct task_struct *r_tsk;
	int r_mode;
	long int r_msgtype;
	long int r_maxsize;
	struct msg_msg *r_msg;
};

struct msg_sender {
	struct list_head list;
	struct task_struct *tsk;
	size_t msgsz;
};

struct sem;

struct sem_queue;

struct sem_undo;

struct semid_ds {
	struct ipc_perm sem_perm;
	__kernel_old_time_t sem_otime;
	__kernel_old_time_t sem_ctime;
	struct sem *sem_base;
	struct sem_queue *sem_pending;
	struct sem_queue **sem_pending_last;
	struct sem_undo *undo;
	short unsigned int sem_nsems;
};

struct sem {
	int semval;
	struct pid *sempid;
	spinlock_t lock;
	struct list_head pending_alter;
	struct list_head pending_const;
	time64_t sem_otime;
};

struct sembuf;

struct sem_queue {
	struct list_head list;
	struct task_struct *sleeper;
	struct sem_undo *undo;
	struct pid *pid;
	int status;
	struct sembuf *sops;
	struct sembuf *blocking;
	int nsops;
	bool alter;
	bool dupsop;
};

struct sem_undo {
	struct list_head list_proc;
	struct callback_head rcu;
	struct sem_undo_list *ulp;
	struct list_head list_id;
	int semid;
	short int *semadj;
};

struct semid64_ds {
	struct ipc64_perm sem_perm;
	long int sem_otime;
	long int sem_ctime;
	long unsigned int sem_nsems;
	long unsigned int __unused3;
	long unsigned int __unused4;
};

struct sembuf {
	short unsigned int sem_num;
	short int sem_op;
	short int sem_flg;
};

struct seminfo {
	int semmap;
	int semmni;
	int semmns;
	int semmnu;
	int semmsl;
	int semopm;
	int semume;
	int semusz;
	int semvmx;
	int semaem;
};

struct sem_undo_list {
	refcount_t refcnt;
	spinlock_t lock;
	struct list_head list_proc;
};

struct sem_array {
	struct kern_ipc_perm sem_perm;
	time64_t sem_ctime;
	struct list_head pending_alter;
	struct list_head pending_const;
	struct list_head list_id;
	int sem_nsems;
	int complex_count;
	unsigned int use_global_lock;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct sem sems[0];
};

struct shmid_ds {
	struct ipc_perm shm_perm;
	int shm_segsz;
	__kernel_old_time_t shm_atime;
	__kernel_old_time_t shm_dtime;
	__kernel_old_time_t shm_ctime;
	__kernel_ipc_pid_t shm_cpid;
	__kernel_ipc_pid_t shm_lpid;
	short unsigned int shm_nattch;
	short unsigned int shm_unused;
	void *shm_unused2;
	void *shm_unused3;
};

struct shmid64_ds {
	struct ipc64_perm shm_perm;
	size_t shm_segsz;
	long int shm_atime;
	long int shm_dtime;
	long int shm_ctime;
	__kernel_pid_t shm_cpid;
	__kernel_pid_t shm_lpid;
	long unsigned int shm_nattch;
	long unsigned int __unused4;
	long unsigned int __unused5;
};

struct shminfo64 {
	long unsigned int shmmax;
	long unsigned int shmmin;
	long unsigned int shmmni;
	long unsigned int shmseg;
	long unsigned int shmall;
	long unsigned int __unused1;
	long unsigned int __unused2;
	long unsigned int __unused3;
	long unsigned int __unused4;
};

struct shminfo {
	int shmmax;
	int shmmin;
	int shmmni;
	int shmseg;
	int shmall;
};

struct shm_info {
	int used_ids;
	__kernel_ulong_t shm_tot;
	__kernel_ulong_t shm_rss;
	__kernel_ulong_t shm_swp;
	__kernel_ulong_t swap_attempts;
	__kernel_ulong_t swap_successes;
};

struct shmid_kernel {
	struct kern_ipc_perm shm_perm;
	struct file *shm_file;
	long unsigned int shm_nattch;
	long unsigned int shm_segsz;
	time64_t shm_atim;
	time64_t shm_dtim;
	time64_t shm_ctim;
	struct pid *shm_cprid;
	struct pid *shm_lprid;
	struct user_struct *mlock_user;
	struct task_struct *shm_creator;
	struct list_head shm_clist;
	struct ipc_namespace *ns;
	long: 64;
	long: 64;
	long: 64;
};

struct shm_file_data {
	int id;
	struct ipc_namespace *ns;
	struct file *file;
	const struct vm_operations_struct *vm_ops;
};

typedef int __kernel_mqd_t;

typedef __kernel_mqd_t mqd_t;

struct mq_attr {
	__kernel_long_t mq_flags;
	__kernel_long_t mq_maxmsg;
	__kernel_long_t mq_msgsize;
	__kernel_long_t mq_curmsgs;
	__kernel_long_t __reserved[4];
};

struct mqueue_fs_context {
	struct ipc_namespace *ipc_ns;
};

struct posix_msg_tree_node {
	struct rb_node rb_node;
	struct list_head msg_list;
	int priority;
};

struct ext_wait_queue {
	struct task_struct *task;
	struct list_head list;
	struct msg_msg *msg;
	int state;
};

struct mqueue_inode_info {
	spinlock_t lock;
	struct inode vfs_inode;
	wait_queue_head_t wait_q;
	struct rb_root msg_tree;
	struct rb_node *msg_tree_rightmost;
	struct posix_msg_tree_node *node_cache;
	struct mq_attr attr;
	struct sigevent notify;
	struct pid *notify_owner;
	u32 notify_self_exec_id;
	struct user_namespace *notify_user_ns;
	struct user_struct *user;
	struct sock *notify_sock;
	struct sk_buff *notify_cookie;
	struct ext_wait_queue e_wait_q[2];
	long unsigned int qsize;
};

enum key_state {
	KEY_IS_UNINSTANTIATED = 0,
	KEY_IS_POSITIVE = 1,
};

struct key_user {
	struct rb_node node;
	struct mutex cons_lock;
	spinlock_t lock;
	refcount_t usage;
	atomic_t nkeys;
	atomic_t nikeys;
	kuid_t uid;
	int qnkeys;
	int qnbytes;
};

enum key_need_perm {
	KEY_NEED_UNSPECIFIED = 0,
	KEY_NEED_VIEW = 1,
	KEY_NEED_READ = 2,
	KEY_NEED_WRITE = 3,
	KEY_NEED_SEARCH = 4,
	KEY_NEED_LINK = 5,
	KEY_NEED_SETATTR = 6,
	KEY_NEED_UNLINK = 7,
	KEY_SYSADMIN_OVERRIDE = 8,
	KEY_AUTHTOKEN_OVERRIDE = 9,
	KEY_DEFER_PERM_CHECK = 10,
};

enum key_notification_subtype {
	NOTIFY_KEY_INSTANTIATED = 0,
	NOTIFY_KEY_UPDATED = 1,
	NOTIFY_KEY_LINKED = 2,
	NOTIFY_KEY_UNLINKED = 3,
	NOTIFY_KEY_CLEARED = 4,
	NOTIFY_KEY_REVOKED = 5,
	NOTIFY_KEY_INVALIDATED = 6,
	NOTIFY_KEY_SETATTR = 7,
};

struct assoc_array_edit;

struct assoc_array_ops {
	long unsigned int (*get_key_chunk)(const void *, int);
	long unsigned int (*get_object_key_chunk)(const void *, int);
	bool (*compare_object)(const void *, const void *);
	int (*diff_objects)(const void *, const void *);
	void (*free_object)(void *);
};

struct assoc_array_node {
	struct assoc_array_ptr *back_pointer;
	u8 parent_slot;
	struct assoc_array_ptr *slots[16];
	long unsigned int nr_leaves_on_branch;
};

struct assoc_array_shortcut {
	struct assoc_array_ptr *back_pointer;
	int parent_slot;
	int skip_to_level;
	struct assoc_array_ptr *next_node;
	long unsigned int index_key[0];
};

struct assoc_array_edit {
	struct callback_head rcu;
	struct assoc_array *array;
	const struct assoc_array_ops *ops;
	const struct assoc_array_ops *ops_for_excised_subtree;
	struct assoc_array_ptr *leaf;
	struct assoc_array_ptr **leaf_p;
	struct assoc_array_ptr *dead_leaf;
	struct assoc_array_ptr *new_meta[3];
	struct assoc_array_ptr *excised_meta[1];
	struct assoc_array_ptr *excised_subtree;
	struct assoc_array_ptr **set_backpointers[16];
	struct assoc_array_ptr *set_backpointers_to;
	struct assoc_array_node *adjust_count_on;
	long int adjust_count_by;
	struct {
		struct assoc_array_ptr **ptr;
		struct assoc_array_ptr *to;
	} set[2];
	struct {
		u8 *p;
		u8 to;
	} set_parent_slot[1];
	u8 segment_cache[17];
};

struct keyring_search_context {
	struct keyring_index_key index_key;
	const struct cred *cred;
	struct key_match_data match_data;
	unsigned int flags;
	int (*iterator)(const void *, void *);
	int skipped_ret;
	bool possessed;
	key_ref_t result;
	time64_t now;
};

struct keyring_read_iterator_context {
	size_t buflen;
	size_t count;
	key_serial_t *buffer;
};

struct keyctl_dh_params {
	union {
		__s32 private;
		__s32 priv;
	};
	__s32 prime;
	__s32 base;
};

struct keyctl_kdf_params {
	char *hashname;
	char *otherinfo;
	__u32 otherinfolen;
	__u32 __spare[8];
};

struct keyctl_pkey_query {
	__u32 supported_ops;
	__u32 key_size;
	__u16 max_data_size;
	__u16 max_sig_size;
	__u16 max_enc_size;
	__u16 max_dec_size;
	__u32 __spare[10];
};

struct keyctl_pkey_params {
	__s32 key_id;
	__u32 in_len;
	union {
		__u32 out_len;
		__u32 in2_len;
	};
	__u32 __spare[7];
};

enum {
	Opt_err___8 = 0,
	Opt_enc = 1,
	Opt_hash = 2,
};

struct vfs_cap_data {
	__le32 magic_etc;
	struct {
		__le32 permitted;
		__le32 inheritable;
	} data[2];
};

struct vfs_ns_cap_data {
	__le32 magic_etc;
	struct {
		__le32 permitted;
		__le32 inheritable;
	} data[2];
	__le32 rootid;
};

struct cpu_vfs_cap_data {
	__u32 magic_etc;
	kernel_cap_t permitted;
	kernel_cap_t inheritable;
	kuid_t rootid;
};

struct crypto_async_request;

typedef void (*crypto_completion_t)(struct crypto_async_request *, int);

struct crypto_async_request {
	struct list_head list;
	crypto_completion_t complete;
	void *data;
	struct crypto_tfm *tfm;
	u32 flags;
};

struct crypto_wait {
	struct completion completion;
	int err;
};

enum {
	CRYPTO_MSG_ALG_REQUEST = 0,
	CRYPTO_MSG_ALG_REGISTER = 1,
	CRYPTO_MSG_ALG_LOADED = 2,
};

struct crypto_larval {
	struct crypto_alg alg;
	struct crypto_alg *adult;
	struct completion completion;
	u32 mask;
	long: 32;
	long: 64;
	long: 64;
};

struct crypto_cipher {
	struct crypto_tfm base;
};

struct crypto_queue {
	struct list_head list;
	struct list_head *backlog;
	unsigned int qlen;
	unsigned int max_qlen;
};

struct aead_request {
	struct crypto_async_request base;
	unsigned int assoclen;
	unsigned int cryptlen;
	u8 *iv;
	struct scatterlist *src;
	struct scatterlist *dst;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	void *__ctx[0];
};

struct akcipher_request {
	struct crypto_async_request base;
	struct scatterlist *src;
	struct scatterlist *dst;
	unsigned int src_len;
	unsigned int dst_len;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	void *__ctx[0];
};

struct ahash_request {
	struct crypto_async_request base;
	unsigned int nbytes;
	struct scatterlist *src;
	u8 *result;
	void *priv;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	void *__ctx[0];
};

struct skcipher_request {
	unsigned int cryptlen;
	u8 *iv;
	struct scatterlist *src;
	struct scatterlist *dst;
	struct crypto_async_request base;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	void *__ctx[0];
};

struct crypto_engine {
	char name[30];
	bool idling;
	bool busy;
	bool running;
	bool retry_support;
	struct list_head list;
	spinlock_t queue_lock;
	struct crypto_queue queue;
	struct device *dev;
	bool rt;
	int (*prepare_crypt_hardware)(struct crypto_engine *);
	int (*unprepare_crypt_hardware)(struct crypto_engine *);
	int (*do_batch_requests)(struct crypto_engine *);
	struct kthread_worker *kworker;
	struct kthread_work pump_requests;
	void *priv_data;
	struct crypto_async_request *cur_req;
};

struct crypto_engine_op {
	int (*prepare_request)(struct crypto_engine *, void *);
	int (*unprepare_request)(struct crypto_engine *, void *);
	int (*do_one_request)(struct crypto_engine *, void *);
};

struct crypto_engine_ctx {
	struct crypto_engine_op op;
};

enum {
	CRYPTOA_UNSPEC = 0,
	CRYPTOA_ALG = 1,
	CRYPTOA_TYPE = 2,
	CRYPTOA_U32 = 3,
	__CRYPTOA_MAX = 4,
};

struct crypto_attr_alg {
	char name[128];
};

struct crypto_attr_type {
	u32 type;
	u32 mask;
};

struct crypto_attr_u32 {
	u32 num;
};

struct rtattr {
	short unsigned int rta_len;
	short unsigned int rta_type;
};

enum {
	NAPI_STATE_SCHED = 0,
	NAPI_STATE_MISSED = 1,
	NAPI_STATE_DISABLE = 2,
	NAPI_STATE_NPSVC = 3,
	NAPI_STATE_LISTED = 4,
	NAPI_STATE_NO_BUSY_POLL = 5,
	NAPI_STATE_IN_BUSY_POLL = 6,
};

enum bpf_xdp_mode {
	XDP_MODE_SKB = 0,
	XDP_MODE_DRV = 1,
	XDP_MODE_HW = 2,
	__MAX_XDP_MODE = 3,
};

enum {
	NETIF_MSG_DRV_BIT = 0,
	NETIF_MSG_PROBE_BIT = 1,
	NETIF_MSG_LINK_BIT = 2,
	NETIF_MSG_TIMER_BIT = 3,
	NETIF_MSG_IFDOWN_BIT = 4,
	NETIF_MSG_IFUP_BIT = 5,
	NETIF_MSG_RX_ERR_BIT = 6,
	NETIF_MSG_TX_ERR_BIT = 7,
	NETIF_MSG_TX_QUEUED_BIT = 8,
	NETIF_MSG_INTR_BIT = 9,
	NETIF_MSG_TX_DONE_BIT = 10,
	NETIF_MSG_RX_STATUS_BIT = 11,
	NETIF_MSG_PKTDATA_BIT = 12,
	NETIF_MSG_HW_BIT = 13,
	NETIF_MSG_WOL_BIT = 14,
	NETIF_MSG_CLASS_COUNT = 15,
};

struct scatter_walk {
	struct scatterlist *sg;
	unsigned int offset;
};

struct crypto_aead;

struct aead_alg {
	int (*setkey)(struct crypto_aead *, const u8 *, unsigned int);
	int (*setauthsize)(struct crypto_aead *, unsigned int);
	int (*encrypt)(struct aead_request *);
	int (*decrypt)(struct aead_request *);
	int (*init)(struct crypto_aead *);
	void (*exit)(struct crypto_aead *);
	unsigned int ivsize;
	unsigned int maxauthsize;
	unsigned int chunksize;
	struct crypto_alg base;
};

struct crypto_aead {
	unsigned int authsize;
	unsigned int reqsize;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct crypto_tfm base;
};

struct aead_instance {
	void (*free)(struct aead_instance *);
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	union {
		struct {
			char head[64];
			struct crypto_instance base;
		} s;
		struct aead_alg alg;
	};
};

struct crypto_aead_spawn {
	struct crypto_spawn base;
};

enum crypto_attr_type_t {
	CRYPTOCFGA_UNSPEC = 0,
	CRYPTOCFGA_PRIORITY_VAL = 1,
	CRYPTOCFGA_REPORT_LARVAL = 2,
	CRYPTOCFGA_REPORT_HASH = 3,
	CRYPTOCFGA_REPORT_BLKCIPHER = 4,
	CRYPTOCFGA_REPORT_AEAD = 5,
	CRYPTOCFGA_REPORT_COMPRESS = 6,
	CRYPTOCFGA_REPORT_RNG = 7,
	CRYPTOCFGA_REPORT_CIPHER = 8,
	CRYPTOCFGA_REPORT_AKCIPHER = 9,
	CRYPTOCFGA_REPORT_KPP = 10,
	CRYPTOCFGA_REPORT_ACOMP = 11,
	CRYPTOCFGA_STAT_LARVAL = 12,
	CRYPTOCFGA_STAT_HASH = 13,
	CRYPTOCFGA_STAT_BLKCIPHER = 14,
	CRYPTOCFGA_STAT_AEAD = 15,
	CRYPTOCFGA_STAT_COMPRESS = 16,
	CRYPTOCFGA_STAT_RNG = 17,
	CRYPTOCFGA_STAT_CIPHER = 18,
	CRYPTOCFGA_STAT_AKCIPHER = 19,
	CRYPTOCFGA_STAT_KPP = 20,
	CRYPTOCFGA_STAT_ACOMP = 21,
	__CRYPTOCFGA_MAX = 22,
};

struct crypto_report_aead {
	char type[64];
	char geniv[64];
	unsigned int blocksize;
	unsigned int maxauthsize;
	unsigned int ivsize;
};

struct crypto_sync_skcipher;

struct aead_geniv_ctx {
	spinlock_t lock;
	struct crypto_aead *child;
	struct crypto_sync_skcipher *sknull;
	u8 salt[0];
};

struct crypto_rng;

struct rng_alg {
	int (*generate)(struct crypto_rng *, const u8 *, unsigned int, u8 *, unsigned int);
	int (*seed)(struct crypto_rng *, const u8 *, unsigned int);
	void (*set_ent)(struct crypto_rng *, const u8 *, unsigned int);
	unsigned int seedsize;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct crypto_alg base;
};

struct crypto_rng {
	struct crypto_tfm base;
};

struct crypto_cipher_spawn {
	struct crypto_spawn base;
};

struct crypto_skcipher {
	unsigned int reqsize;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct crypto_tfm base;
};

struct crypto_sync_skcipher {
	struct crypto_skcipher base;
};

struct skcipher_alg {
	int (*setkey)(struct crypto_skcipher *, const u8 *, unsigned int);
	int (*encrypt)(struct skcipher_request *);
	int (*decrypt)(struct skcipher_request *);
	int (*init)(struct crypto_skcipher *);
	void (*exit)(struct crypto_skcipher *);
	unsigned int min_keysize;
	unsigned int max_keysize;
	unsigned int ivsize;
	unsigned int chunksize;
	unsigned int walksize;
	struct crypto_alg base;
};

struct skcipher_instance {
	void (*free)(struct skcipher_instance *);
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	union {
		struct {
			char head[64];
			struct crypto_instance base;
		} s;
		struct skcipher_alg alg;
	};
};

struct crypto_skcipher_spawn {
	struct crypto_spawn base;
};

struct skcipher_walk {
	union {
		struct {
			struct page *page;
			long unsigned int offset;
		} phys;
		struct {
			u8 *page;
			void *addr;
		} virt;
	} src;
	union {
		struct {
			struct page *page;
			long unsigned int offset;
		} phys;
		struct {
			u8 *page;
			void *addr;
		} virt;
	} dst;
	struct scatter_walk in;
	unsigned int nbytes;
	struct scatter_walk out;
	unsigned int total;
	struct list_head buffers;
	u8 *page;
	u8 *buffer;
	u8 *oiv;
	void *iv;
	unsigned int ivsize;
	int flags;
	unsigned int blocksize;
	unsigned int stride;
	unsigned int alignmask;
};

struct skcipher_ctx_simple {
	struct crypto_cipher *cipher;
};

struct crypto_report_blkcipher {
	char type[64];
	char geniv[64];
	unsigned int blocksize;
	unsigned int min_keysize;
	unsigned int max_keysize;
	unsigned int ivsize;
};

enum {
	SKCIPHER_WALK_PHYS = 1,
	SKCIPHER_WALK_SLOW = 2,
	SKCIPHER_WALK_COPY = 4,
	SKCIPHER_WALK_DIFF = 8,
	SKCIPHER_WALK_SLEEP = 16,
};

struct skcipher_walk_buffer {
	struct list_head entry;
	struct scatter_walk dst;
	unsigned int len;
	u8 *data;
	u8 buffer[0];
};

struct hash_alg_common {
	unsigned int digestsize;
	unsigned int statesize;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct crypto_alg base;
};

struct crypto_ahash;

struct ahash_alg {
	int (*init)(struct ahash_request *);
	int (*update)(struct ahash_request *);
	int (*final)(struct ahash_request *);
	int (*finup)(struct ahash_request *);
	int (*digest)(struct ahash_request *);
	int (*export)(struct ahash_request *, void *);
	int (*import)(struct ahash_request *, const void *);
	int (*setkey)(struct crypto_ahash *, const u8 *, unsigned int);
	int (*init_tfm)(struct crypto_ahash *);
	void (*exit_tfm)(struct crypto_ahash *);
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct hash_alg_common halg;
};

struct crypto_ahash {
	int (*init)(struct ahash_request *);
	int (*update)(struct ahash_request *);
	int (*final)(struct ahash_request *);
	int (*finup)(struct ahash_request *);
	int (*digest)(struct ahash_request *);
	int (*export)(struct ahash_request *, void *);
	int (*import)(struct ahash_request *, const void *);
	int (*setkey)(struct crypto_ahash *, const u8 *, unsigned int);
	unsigned int reqsize;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct crypto_tfm base;
};

struct crypto_hash_walk {
	char *data;
	unsigned int offset;
	unsigned int alignmask;
	struct page *pg;
	unsigned int entrylen;
	unsigned int total;
	struct scatterlist *sg;
	unsigned int flags;
};

struct ahash_instance {
	void (*free)(struct ahash_instance *);
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	union {
		struct {
			char head[192];
			struct crypto_instance base;
		} s;
		struct ahash_alg alg;
	};
};

struct crypto_ahash_spawn {
	struct crypto_spawn base;
};

struct crypto_report_hash {
	char type[64];
	unsigned int blocksize;
	unsigned int digestsize;
};

struct ahash_request_priv {
	crypto_completion_t complete;
	void *data;
	u8 *result;
	u32 flags;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	void *ubuf[0];
};

struct shash_instance {
	void (*free)(struct shash_instance *);
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	union {
		struct {
			char head[192];
			struct crypto_instance base;
		} s;
		struct shash_alg alg;
	};
};

struct crypto_shash_spawn {
	struct crypto_spawn base;
};

struct crypto_report_akcipher {
	char type[64];
};

struct crypto_akcipher {
	struct crypto_tfm base;
};

struct akcipher_alg {
	int (*sign)(struct akcipher_request *);
	int (*verify)(struct akcipher_request *);
	int (*encrypt)(struct akcipher_request *);
	int (*decrypt)(struct akcipher_request *);
	int (*set_pub_key)(struct crypto_akcipher *, const void *, unsigned int);
	int (*set_priv_key)(struct crypto_akcipher *, const void *, unsigned int);
	unsigned int (*max_size)(struct crypto_akcipher *);
	int (*init)(struct crypto_akcipher *);
	void (*exit)(struct crypto_akcipher *);
	unsigned int reqsize;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct crypto_alg base;
};

struct akcipher_instance {
	void (*free)(struct akcipher_instance *);
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	union {
		struct {
			char head[128];
			struct crypto_instance base;
		} s;
		struct akcipher_alg alg;
	};
};

struct crypto_akcipher_spawn {
	struct crypto_spawn base;
};

struct crypto_report_kpp {
	char type[64];
};

struct kpp_request {
	struct crypto_async_request base;
	struct scatterlist *src;
	struct scatterlist *dst;
	unsigned int src_len;
	unsigned int dst_len;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	void *__ctx[0];
};

struct crypto_kpp {
	struct crypto_tfm base;
};

struct kpp_alg {
	int (*set_secret)(struct crypto_kpp *, const void *, unsigned int);
	int (*generate_public_key)(struct kpp_request *);
	int (*compute_shared_secret)(struct kpp_request *);
	unsigned int (*max_size)(struct crypto_kpp *);
	int (*init)(struct crypto_kpp *);
	void (*exit)(struct crypto_kpp *);
	unsigned int reqsize;
	long: 32;
	long: 64;
	struct crypto_alg base;
};

struct dh {
	void *key;
	void *p;
	void *q;
	void *g;
	unsigned int key_size;
	unsigned int p_size;
	unsigned int q_size;
	unsigned int g_size;
};

typedef long unsigned int mpi_limb_t;

struct gcry_mpi {
	int alloced;
	int nlimbs;
	int nbits;
	int sign;
	unsigned int flags;
	mpi_limb_t *d;
};

typedef struct gcry_mpi *MPI;

struct dh_ctx {
	MPI p;
	MPI q;
	MPI g;
	MPI xa;
};

enum {
	CRYPTO_KPP_SECRET_TYPE_UNKNOWN = 0,
	CRYPTO_KPP_SECRET_TYPE_DH = 1,
	CRYPTO_KPP_SECRET_TYPE_ECDH = 2,
};

struct kpp_secret {
	short unsigned int type;
	short unsigned int len;
};

enum asn1_class {
	ASN1_UNIV = 0,
	ASN1_APPL = 1,
	ASN1_CONT = 2,
	ASN1_PRIV = 3,
};

enum asn1_method {
	ASN1_PRIM = 0,
	ASN1_CONS = 1,
};

enum asn1_tag {
	ASN1_EOC = 0,
	ASN1_BOOL = 1,
	ASN1_INT = 2,
	ASN1_BTS = 3,
	ASN1_OTS = 4,
	ASN1_NULL = 5,
	ASN1_OID = 6,
	ASN1_ODE = 7,
	ASN1_EXT = 8,
	ASN1_REAL = 9,
	ASN1_ENUM = 10,
	ASN1_EPDV = 11,
	ASN1_UTF8STR = 12,
	ASN1_RELOID = 13,
	ASN1_SEQ = 16,
	ASN1_SET = 17,
	ASN1_NUMSTR = 18,
	ASN1_PRNSTR = 19,
	ASN1_TEXSTR = 20,
	ASN1_VIDSTR = 21,
	ASN1_IA5STR = 22,
	ASN1_UNITIM = 23,
	ASN1_GENTIM = 24,
	ASN1_GRASTR = 25,
	ASN1_VISSTR = 26,
	ASN1_GENSTR = 27,
	ASN1_UNISTR = 28,
	ASN1_CHRSTR = 29,
	ASN1_BMPSTR = 30,
	ASN1_LONG_TAG = 31,
};

typedef int (*asn1_action_t)(void *, size_t, unsigned char, const void *, size_t);

struct asn1_decoder {
	const unsigned char *machine;
	size_t machlen;
	const asn1_action_t *actions;
};

enum asn1_opcode {
	ASN1_OP_MATCH = 0,
	ASN1_OP_MATCH_OR_SKIP = 1,
	ASN1_OP_MATCH_ACT = 2,
	ASN1_OP_MATCH_ACT_OR_SKIP = 3,
	ASN1_OP_MATCH_JUMP = 4,
	ASN1_OP_MATCH_JUMP_OR_SKIP = 5,
	ASN1_OP_MATCH_ANY = 8,
	ASN1_OP_MATCH_ANY_OR_SKIP = 9,
	ASN1_OP_MATCH_ANY_ACT = 10,
	ASN1_OP_MATCH_ANY_ACT_OR_SKIP = 11,
	ASN1_OP_COND_MATCH_OR_SKIP = 17,
	ASN1_OP_COND_MATCH_ACT_OR_SKIP = 19,
	ASN1_OP_COND_MATCH_JUMP_OR_SKIP = 21,
	ASN1_OP_COND_MATCH_ANY = 24,
	ASN1_OP_COND_MATCH_ANY_OR_SKIP = 25,
	ASN1_OP_COND_MATCH_ANY_ACT = 26,
	ASN1_OP_COND_MATCH_ANY_ACT_OR_SKIP = 27,
	ASN1_OP_COND_FAIL = 28,
	ASN1_OP_COMPLETE = 29,
	ASN1_OP_ACT = 30,
	ASN1_OP_MAYBE_ACT = 31,
	ASN1_OP_END_SEQ = 32,
	ASN1_OP_END_SET = 33,
	ASN1_OP_END_SEQ_OF = 34,
	ASN1_OP_END_SET_OF = 35,
	ASN1_OP_END_SEQ_ACT = 36,
	ASN1_OP_END_SET_ACT = 37,
	ASN1_OP_END_SEQ_OF_ACT = 38,
	ASN1_OP_END_SET_OF_ACT = 39,
	ASN1_OP_RETURN = 40,
	ASN1_OP__NR = 41,
};

enum rsapubkey_actions {
	ACT_rsa_get_e = 0,
	ACT_rsa_get_n = 1,
	NR__rsapubkey_actions = 2,
};

enum rsaprivkey_actions {
	ACT_rsa_get_d = 0,
	ACT_rsa_get_dp = 1,
	ACT_rsa_get_dq = 2,
	ACT_rsa_get_e___2 = 3,
	ACT_rsa_get_n___2 = 4,
	ACT_rsa_get_p = 5,
	ACT_rsa_get_q = 6,
	ACT_rsa_get_qinv = 7,
	NR__rsaprivkey_actions = 8,
};

struct rsa_key {
	const u8 *n;
	const u8 *e;
	const u8 *d;
	const u8 *p;
	const u8 *q;
	const u8 *dp;
	const u8 *dq;
	const u8 *qinv;
	size_t n_sz;
	size_t e_sz;
	size_t d_sz;
	size_t p_sz;
	size_t q_sz;
	size_t dp_sz;
	size_t dq_sz;
	size_t qinv_sz;
};

struct rsa_mpi_key {
	MPI n;
	MPI e;
	MPI d;
};

struct asn1_decoder;

struct rsa_asn1_template {
	const char *name;
	const u8 *data;
	size_t size;
};

struct pkcs1pad_ctx {
	struct crypto_akcipher *child;
	unsigned int key_size;
};

struct pkcs1pad_inst_ctx {
	struct crypto_akcipher_spawn spawn;
	const struct rsa_asn1_template *digest_info;
};

struct pkcs1pad_request {
	struct scatterlist in_sg[2];
	struct scatterlist out_sg[1];
	uint8_t *in_buf;
	uint8_t *out_buf;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct akcipher_request child_req;
};

struct crypto_report_acomp {
	char type[64];
};

struct acomp_req {
	struct crypto_async_request base;
	struct scatterlist *src;
	struct scatterlist *dst;
	unsigned int slen;
	unsigned int dlen;
	u32 flags;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	void *__ctx[0];
};

struct crypto_acomp {
	int (*compress)(struct acomp_req *);
	int (*decompress)(struct acomp_req *);
	void (*dst_free)(struct scatterlist *);
	unsigned int reqsize;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct crypto_tfm base;
};

struct acomp_alg {
	int (*compress)(struct acomp_req *);
	int (*decompress)(struct acomp_req *);
	void (*dst_free)(struct scatterlist *);
	int (*init)(struct crypto_acomp *);
	void (*exit)(struct crypto_acomp *);
	unsigned int reqsize;
	long: 32;
	long: 64;
	long: 64;
	struct crypto_alg base;
};

struct crypto_report_comp {
	char type[64];
};

struct crypto_scomp {
	struct crypto_tfm base;
};

struct scomp_alg {
	void * (*alloc_ctx)(struct crypto_scomp *);
	void (*free_ctx)(struct crypto_scomp *, void *);
	int (*compress)(struct crypto_scomp *, const u8 *, unsigned int, u8 *, unsigned int *, void *);
	int (*decompress)(struct crypto_scomp *, const u8 *, unsigned int, u8 *, unsigned int *, void *);
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct crypto_alg base;
};

struct scomp_scratch {
	spinlock_t lock;
	void *src;
	void *dst;
};

struct cryptomgr_param {
	struct rtattr *tb[34];
	struct {
		struct rtattr attr;
		struct crypto_attr_type data;
	} type;
	union {
		struct rtattr attr;
		struct {
			struct rtattr attr;
			struct crypto_attr_alg data;
		} alg;
		struct {
			struct rtattr attr;
			struct crypto_attr_u32 data;
		} nu32;
	} attrs[32];
	char template[128];
	struct crypto_larval *larval;
	u32 otype;
	u32 omask;
};

struct crypto_test_param {
	char driver[128];
	char alg[128];
	u32 type;
};

struct cmac_tfm_ctx {
	struct crypto_cipher *child;
	u8 ctx[0];
};

struct cmac_desc_ctx {
	unsigned int len;
	u8 ctx[0];
};

struct hmac_ctx {
	struct crypto_shash *hash;
};

struct md5_state {
	u32 hash[4];
	u32 block[16];
	u64 byte_count;
};

struct sha1_state {
	u32 state[5];
	u64 count;
	u8 buffer[64];
};

typedef void sha1_block_fn(struct sha1_state *, const u8 *, int);

struct sha256_state {
	u32 state[8];
	u64 count;
	u8 buf[64];
};

struct sha512_state {
	u64 state[8];
	u64 count[2];
	u8 buf[128];
};

typedef void sha512_block_fn(struct sha512_state *, const u8 *, int);

struct sha3_state {
	u64 st[25];
	unsigned int rsiz;
	unsigned int rsizw;
	unsigned int partial;
	u8 buf[144];
};

struct sm3_state {
	u32 state[8];
	u64 count;
	u8 buffer[64];
};

typedef void sm3_block_fn(struct sm3_state *, const u8 *, int);

struct chachapoly_instance_ctx {
	struct crypto_skcipher_spawn chacha;
	struct crypto_ahash_spawn poly;
	unsigned int saltlen;
};

struct chachapoly_ctx {
	struct crypto_skcipher *chacha;
	struct crypto_ahash *poly;
	unsigned int saltlen;
	u8 salt[0];
};

struct poly_req {
	u8 pad[16];
	struct {
		__le64 assoclen;
		__le64 cryptlen;
	} tail;
	struct scatterlist src[1];
	long: 64;
	struct ahash_request req;
};

struct chacha_req {
	u8 iv[16];
	struct scatterlist src[1];
	long: 64;
	long: 64;
	long: 64;
	struct skcipher_request req;
};

struct chachapoly_req_ctx {
	struct scatterlist src[2];
	struct scatterlist dst[2];
	u8 key[32];
	u8 tag[16];
	unsigned int cryptlen;
	unsigned int assoclen;
	u32 flags;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	union {
		struct poly_req poly;
		struct chacha_req chacha;
	} u;
};

struct des_ctx {
	u32 expkey[32];
};

struct des3_ede_ctx {
	u32 expkey[96];
};

struct crypto_aes_ctx {
	u32 key_enc[60];
	u32 key_dec[60];
	u32 key_length;
};

struct chacha_ctx {
	u32 key[8];
	int nrounds;
};

struct poly1305_key {
	union {
		u32 r[5];
		u64 r64[3];
	};
};

struct poly1305_core_key {
	struct poly1305_key key;
	struct poly1305_key precomputed_s;
};

struct poly1305_state {
	union {
		u32 h[5];
		u64 h64[3];
	};
};

struct poly1305_desc_ctx {
	u8 buf[16];
	unsigned int buflen;
	short unsigned int rset;
	bool sset;
	u32 s[4];
	struct poly1305_state h;
	union {
		struct poly1305_key opaque_r[1];
		struct poly1305_core_key core_r;
	};
};

struct deflate_ctx {
	struct z_stream_s comp_stream;
	struct z_stream_s decomp_stream;
};

struct chksum_ctx {
	u32 key;
};

struct chksum_desc_ctx {
	u32 crc;
};

enum {
	CRYPTO_AUTHENC_KEYA_UNSPEC = 0,
	CRYPTO_AUTHENC_KEYA_PARAM = 1,
};

struct crypto_authenc_key_param {
	__be32 enckeylen;
};

struct crypto_authenc_keys {
	const u8 *authkey;
	const u8 *enckey;
	unsigned int authkeylen;
	unsigned int enckeylen;
};

struct authenc_instance_ctx {
	struct crypto_ahash_spawn auth;
	struct crypto_skcipher_spawn enc;
	unsigned int reqoff;
};

struct crypto_authenc_ctx {
	struct crypto_ahash *auth;
	struct crypto_skcipher *enc;
	struct crypto_sync_skcipher *null;
};

struct authenc_request_ctx {
	struct scatterlist src[2];
	struct scatterlist dst[2];
	char tail[0];
};

struct authenc_esn_instance_ctx {
	struct crypto_ahash_spawn auth;
	struct crypto_skcipher_spawn enc;
};

struct crypto_authenc_esn_ctx {
	unsigned int reqoff;
	struct crypto_ahash *auth;
	struct crypto_skcipher *enc;
	struct crypto_sync_skcipher *null;
};

struct authenc_esn_request_ctx {
	struct scatterlist src[2];
	struct scatterlist dst[2];
	char tail[0];
};

struct lzo_ctx {
	void *lzo_comp_mem;
};

struct lzorle_ctx {
	void *lzorle_comp_mem;
};

struct crypto_report_rng {
	char type[64];
	unsigned int seedsize;
};

struct random_ready_callback {
	struct list_head list;
	void (*func)(struct random_ready_callback *);
	struct module *owner;
};

struct drbg_string {
	const unsigned char *buf;
	size_t len;
	struct list_head list;
};

typedef uint32_t drbg_flag_t;

struct drbg_core {
	drbg_flag_t flags;
	__u8 statelen;
	__u8 blocklen_bytes;
	char cra_name[128];
	char backend_cra_name[128];
};

struct drbg_state;

struct drbg_state_ops {
	int (*update)(struct drbg_state *, struct list_head *, int);
	int (*generate)(struct drbg_state *, unsigned char *, unsigned int, struct list_head *);
	int (*crypto_init)(struct drbg_state *);
	int (*crypto_fini)(struct drbg_state *);
};

struct drbg_state {
	struct mutex drbg_mutex;
	unsigned char *V;
	unsigned char *Vbuf;
	unsigned char *C;
	unsigned char *Cbuf;
	size_t reseed_ctr;
	size_t reseed_threshold;
	unsigned char *scratchpad;
	unsigned char *scratchpadbuf;
	void *priv_data;
	struct crypto_skcipher *ctr_handle;
	struct skcipher_request *ctr_req;
	__u8 *outscratchpadbuf;
	__u8 *outscratchpad;
	struct crypto_wait ctr_wait;
	struct scatterlist sg_in;
	struct scatterlist sg_out;
	bool seeded;
	bool pr;
	bool fips_primed;
	unsigned char *prev;
	struct work_struct seed_work;
	struct crypto_rng *jent;
	const struct drbg_state_ops *d_ops;
	const struct drbg_core *core;
	struct drbg_string test_data;
	struct random_ready_callback random_ready;
};

enum drbg_prefixes {
	DRBG_PREFIX0 = 0,
	DRBG_PREFIX1 = 1,
	DRBG_PREFIX2 = 2,
	DRBG_PREFIX3 = 3,
};

struct sdesc {
	struct shash_desc shash;
	char ctx[0];
};

struct rand_data {
	__u64 data;
	__u64 old_data;
	__u64 prev_time;
	__u64 last_delta;
	__s64 last_delta2;
	unsigned int osr;
	unsigned char *mem;
	unsigned int memlocation;
	unsigned int memblocks;
	unsigned int memblocksize;
	unsigned int memaccessloops;
	int rct_count;
	unsigned int apt_observations;
	unsigned int apt_count;
	unsigned int apt_base;
	unsigned int apt_base_set: 1;
	unsigned int health_failure: 1;
};

struct rand_data;

struct jitterentropy {
	spinlock_t jent_lock;
	struct rand_data *entropy_collector;
	unsigned int reset_cnt;
};

struct sockaddr_alg_new {
	__u16 salg_family;
	__u8 salg_type[14];
	__u32 salg_feat;
	__u32 salg_mask;
	__u8 salg_name[0];
};

struct af_alg_iv {
	__u32 ivlen;
	__u8 iv[0];
};

struct cmsghdr {
	__kernel_size_t cmsg_len;
	int cmsg_level;
	int cmsg_type;
};

struct net_proto_family {
	int family;
	int (*create)(struct net *, struct socket *, int, int);
	struct module *owner;
};

enum {
	SOCK_WAKE_IO = 0,
	SOCK_WAKE_WAITD = 1,
	SOCK_WAKE_SPACE = 2,
	SOCK_WAKE_URG = 3,
};

struct af_alg_type;

struct alg_sock {
	struct sock sk;
	struct sock *parent;
	atomic_t refcnt;
	atomic_t nokey_refcnt;
	const struct af_alg_type *type;
	void *private;
};

struct af_alg_type {
	void * (*bind)(const char *, u32, u32);
	void (*release)(void *);
	int (*setkey)(void *, const u8 *, unsigned int);
	int (*setentropy)(void *, sockptr_t, unsigned int);
	int (*accept)(void *, struct sock *);
	int (*accept_nokey)(void *, struct sock *);
	int (*setauthsize)(void *, unsigned int);
	struct proto_ops *ops;
	struct proto_ops *ops_nokey;
	struct module *owner;
	char name[14];
};

struct af_alg_control {
	struct af_alg_iv *iv;
	int op;
	unsigned int aead_assoclen;
};

struct af_alg_sgl {
	struct scatterlist sg[17];
	struct page *pages[16];
	unsigned int npages;
};

struct af_alg_tsgl {
	struct list_head list;
	unsigned int cur;
	struct scatterlist sg[0];
};

struct af_alg_rsgl {
	struct af_alg_sgl sgl;
	struct list_head list;
	size_t sg_num_bytes;
};

struct af_alg_async_req {
	struct kiocb *iocb;
	struct sock *sk;
	struct af_alg_rsgl first_rsgl;
	struct af_alg_rsgl *last_rsgl;
	struct list_head rsgl_list;
	struct scatterlist *tsgl;
	unsigned int tsgl_entries;
	unsigned int outlen;
	unsigned int areqlen;
	long: 32;
	long: 64;
	union {
		struct aead_request aead_req;
		struct skcipher_request skcipher_req;
	} cra_u;
};

struct af_alg_ctx {
	struct list_head tsgl_list;
	void *iv;
	size_t aead_assoclen;
	struct crypto_wait wait;
	size_t used;
	atomic_t rcvused;
	bool more;
	bool merge;
	bool enc;
	bool init;
	unsigned int len;
};

struct alg_type_list {
	const struct af_alg_type *type;
	struct list_head list;
};

struct hash_ctx {
	struct af_alg_sgl sgl;
	u8 *result;
	struct crypto_wait wait;
	unsigned int len;
	bool more;
	long: 24;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct ahash_request req;
};

typedef enum {
	ZSTD_fast = 0,
	ZSTD_dfast = 1,
	ZSTD_greedy = 2,
	ZSTD_lazy = 3,
	ZSTD_lazy2 = 4,
	ZSTD_btlazy2 = 5,
	ZSTD_btopt = 6,
	ZSTD_btopt2 = 7,
} ZSTD_strategy;

typedef struct {
	unsigned int windowLog;
	unsigned int chainLog;
	unsigned int hashLog;
	unsigned int searchLog;
	unsigned int searchLength;
	unsigned int targetLength;
	ZSTD_strategy strategy;
} ZSTD_compressionParameters;

typedef struct {
	unsigned int contentSizeFlag;
	unsigned int checksumFlag;
	unsigned int noDictIDFlag;
} ZSTD_frameParameters;

typedef struct {
	ZSTD_compressionParameters cParams;
	ZSTD_frameParameters fParams;
} ZSTD_parameters;

struct ZSTD_CCtx_s;

typedef struct ZSTD_CCtx_s ZSTD_CCtx;

struct ZSTD_DCtx_s;

typedef struct ZSTD_DCtx_s ZSTD_DCtx;

struct zstd_ctx {
	ZSTD_CCtx *cctx;
	ZSTD_DCtx *dctx;
	void *cwksp;
	void *dwksp;
};

struct ecc_point {
	u64 *x;
	u64 *y;
	u8 ndigits;
};

struct ecc_curve {
	char *name;
	struct ecc_point g;
	u64 *p;
	u64 *n;
	u64 *a;
	u64 *b;
};

typedef struct {
	u64 m_low;
	u64 m_high;
} uint128_t;

enum curve25519_lengths {
	CURVE25519_KEY_SIZE = 32,
};

struct ecdh {
	short unsigned int curve_id;
	char *key;
	short unsigned int key_size;
};

struct ecdh_ctx {
	unsigned int curve_id;
	unsigned int ndigits;
	u64 private_key[8];
};

enum asymmetric_payload_bits {
	asym_crypto = 0,
	asym_subtype = 1,
	asym_key_ids = 2,
	asym_auth = 3,
};

struct asymmetric_key_id {
	short unsigned int len;
	unsigned char data[0];
};

struct asymmetric_key_ids {
	void *id[2];
};

struct public_key_signature;

struct asymmetric_key_subtype {
	struct module *owner;
	const char *name;
	short unsigned int name_len;
	void (*describe)(const struct key *, struct seq_file *);
	void (*destroy)(void *, void *);
	int (*query)(const struct kernel_pkey_params *, struct kernel_pkey_query *);
	int (*eds_op)(struct kernel_pkey_params *, const void *, void *);
	int (*verify_signature)(const struct key *, const struct public_key_signature *);
};

struct public_key_signature {
	struct asymmetric_key_id *auth_ids[2];
	u8 *s;
	u32 s_size;
	u8 *digest;
	u8 digest_size;
	const char *pkey_algo;
	const char *hash_algo;
	const char *encoding;
	const void *data;
	unsigned int data_size;
};

struct asymmetric_key_parser {
	struct list_head link;
	struct module *owner;
	const char *name;
	int (*parse)(struct key_preparsed_payload *);
};

enum OID {
	OID_id_dsa_with_sha1 = 0,
	OID_id_dsa = 1,
	OID_id_ecdsa_with_sha1 = 2,
	OID_id_ecPublicKey = 3,
	OID_rsaEncryption = 4,
	OID_md2WithRSAEncryption = 5,
	OID_md3WithRSAEncryption = 6,
	OID_md4WithRSAEncryption = 7,
	OID_sha1WithRSAEncryption = 8,
	OID_sha256WithRSAEncryption = 9,
	OID_sha384WithRSAEncryption = 10,
	OID_sha512WithRSAEncryption = 11,
	OID_sha224WithRSAEncryption = 12,
	OID_data = 13,
	OID_signed_data = 14,
	OID_email_address = 15,
	OID_contentType = 16,
	OID_messageDigest = 17,
	OID_signingTime = 18,
	OID_smimeCapabilites = 19,
	OID_smimeAuthenticatedAttrs = 20,
	OID_md2 = 21,
	OID_md4 = 22,
	OID_md5 = 23,
	OID_msIndirectData = 24,
	OID_msStatementType = 25,
	OID_msSpOpusInfo = 26,
	OID_msPeImageDataObjId = 27,
	OID_msIndividualSPKeyPurpose = 28,
	OID_msOutlookExpress = 29,
	OID_certAuthInfoAccess = 30,
	OID_sha1 = 31,
	OID_sha256 = 32,
	OID_sha384 = 33,
	OID_sha512 = 34,
	OID_sha224 = 35,
	OID_commonName = 36,
	OID_surname = 37,
	OID_countryName = 38,
	OID_locality = 39,
	OID_stateOrProvinceName = 40,
	OID_organizationName = 41,
	OID_organizationUnitName = 42,
	OID_title = 43,
	OID_description = 44,
	OID_name = 45,
	OID_givenName = 46,
	OID_initials = 47,
	OID_generationalQualifier = 48,
	OID_subjectKeyIdentifier = 49,
	OID_keyUsage = 50,
	OID_subjectAltName = 51,
	OID_issuerAltName = 52,
	OID_basicConstraints = 53,
	OID_crlDistributionPoints = 54,
	OID_certPolicies = 55,
	OID_authorityKeyIdentifier = 56,
	OID_extKeyUsage = 57,
	OID_gostCPSignA = 58,
	OID_gostCPSignB = 59,
	OID_gostCPSignC = 60,
	OID_gost2012PKey256 = 61,
	OID_gost2012PKey512 = 62,
	OID_gost2012Digest256 = 63,
	OID_gost2012Digest512 = 64,
	OID_gost2012Signature256 = 65,
	OID_gost2012Signature512 = 66,
	OID_gostTC26Sign256A = 67,
	OID_gostTC26Sign256B = 68,
	OID_gostTC26Sign256C = 69,
	OID_gostTC26Sign256D = 70,
	OID_gostTC26Sign512A = 71,
	OID_gostTC26Sign512B = 72,
	OID_gostTC26Sign512C = 73,
	OID_sm2 = 74,
	OID_sm3 = 75,
	OID_SM2_with_SM3 = 76,
	OID_sm3WithRSAEncryption = 77,
	OID__NR = 78,
};

struct public_key {
	void *key;
	u32 keylen;
	enum OID algo;
	void *params;
	u32 paramlen;
	bool key_is_private;
	const char *id_type;
	const char *pkey_algo;
};

enum x509_actions {
	ACT_x509_extract_key_data = 0,
	ACT_x509_extract_name_segment = 1,
	ACT_x509_note_OID = 2,
	ACT_x509_note_issuer = 3,
	ACT_x509_note_not_after = 4,
	ACT_x509_note_not_before = 5,
	ACT_x509_note_params = 6,
	ACT_x509_note_pkey_algo = 7,
	ACT_x509_note_serial = 8,
	ACT_x509_note_signature = 9,
	ACT_x509_note_subject = 10,
	ACT_x509_note_tbs_certificate = 11,
	ACT_x509_process_extension = 12,
	NR__x509_actions = 13,
};

enum x509_akid_actions {
	ACT_x509_akid_note_kid = 0,
	ACT_x509_akid_note_name = 1,
	ACT_x509_akid_note_serial = 2,
	ACT_x509_extract_name_segment___2 = 3,
	ACT_x509_note_OID___2 = 4,
	NR__x509_akid_actions = 5,
};

struct x509_certificate {
	struct x509_certificate *next;
	struct x509_certificate *signer;
	struct public_key *pub;
	struct public_key_signature *sig;
	char *issuer;
	char *subject;
	struct asymmetric_key_id *id;
	struct asymmetric_key_id *skid;
	time64_t valid_from;
	time64_t valid_to;
	const void *tbs;
	unsigned int tbs_size;
	unsigned int raw_sig_size;
	const void *raw_sig;
	const void *raw_serial;
	unsigned int raw_serial_size;
	unsigned int raw_issuer_size;
	const void *raw_issuer;
	const void *raw_subject;
	unsigned int raw_subject_size;
	unsigned int raw_skid_size;
	const void *raw_skid;
	unsigned int index;
	bool seen;
	bool verified;
	bool self_signed;
	bool unsupported_key;
	bool unsupported_sig;
	bool blacklisted;
};

struct x509_parse_context {
	struct x509_certificate *cert;
	long unsigned int data;
	const void *cert_start;
	const void *key;
	size_t key_size;
	const void *params;
	size_t params_size;
	enum OID key_algo;
	enum OID last_oid;
	enum OID algo_oid;
	unsigned char nr_mpi;
	u8 o_size;
	u8 cn_size;
	u8 email_size;
	u16 o_offset;
	u16 cn_offset;
	u16 email_offset;
	unsigned int raw_akid_size;
	const void *raw_akid;
	const void *akid_raw_issuer;
	unsigned int akid_raw_issuer_size;
};

enum pkcs7_actions {
	ACT_pkcs7_check_content_type = 0,
	ACT_pkcs7_extract_cert = 1,
	ACT_pkcs7_note_OID = 2,
	ACT_pkcs7_note_certificate_list = 3,
	ACT_pkcs7_note_content = 4,
	ACT_pkcs7_note_data = 5,
	ACT_pkcs7_note_signed_info = 6,
	ACT_pkcs7_note_signeddata_version = 7,
	ACT_pkcs7_note_signerinfo_version = 8,
	ACT_pkcs7_sig_note_authenticated_attr = 9,
	ACT_pkcs7_sig_note_digest_algo = 10,
	ACT_pkcs7_sig_note_issuer = 11,
	ACT_pkcs7_sig_note_pkey_algo = 12,
	ACT_pkcs7_sig_note_serial = 13,
	ACT_pkcs7_sig_note_set_of_authattrs = 14,
	ACT_pkcs7_sig_note_signature = 15,
	ACT_pkcs7_sig_note_skid = 16,
	NR__pkcs7_actions = 17,
};

struct pkcs7_signed_info {
	struct pkcs7_signed_info *next;
	struct x509_certificate *signer;
	unsigned int index;
	bool unsupported_crypto;
	bool blacklisted;
	const void *msgdigest;
	unsigned int msgdigest_len;
	unsigned int authattrs_len;
	const void *authattrs;
	long unsigned int aa_set;
	time64_t signing_time;
	struct public_key_signature *sig;
};

struct pkcs7_message {
	struct x509_certificate *certs;
	struct x509_certificate *crl;
	struct pkcs7_signed_info *signed_infos;
	u8 version;
	bool have_authattrs;
	enum OID data_type;
	size_t data_len;
	size_t data_hdrlen;
	const void *data;
};

struct pkcs7_parse_context {
	struct pkcs7_message *msg;
	struct pkcs7_signed_info *sinfo;
	struct pkcs7_signed_info **ppsinfo;
	struct x509_certificate *certs;
	struct x509_certificate **ppcerts;
	long unsigned int data;
	enum OID last_oid;
	unsigned int x509_index;
	unsigned int sinfo_index;
	const void *raw_serial;
	unsigned int raw_serial_size;
	unsigned int raw_issuer_size;
	const void *raw_issuer;
	const void *raw_skid;
	unsigned int raw_skid_size;
	bool expect_skid;
};

struct biovec_slab {
	int nr_vecs;
	char *name;
	struct kmem_cache *slab;
};

enum rq_qos_id {
	RQ_QOS_WBT = 0,
	RQ_QOS_LATENCY = 1,
	RQ_QOS_COST = 2,
	RQ_QOS_IOPRIO = 3,
};

struct rq_qos_ops;

struct rq_qos {
	struct rq_qos_ops *ops;
	struct request_queue *q;
	enum rq_qos_id id;
	struct rq_qos *next;
	struct dentry *debugfs_dir;
};

enum xen_domain_type {
	XEN_NATIVE = 0,
	XEN_PV_DOMAIN = 1,
	XEN_HVM_DOMAIN = 2,
};

struct rq_qos_ops {
	void (*throttle)(struct rq_qos *, struct bio *);
	void (*track)(struct rq_qos *, struct request *, struct bio *);
	void (*merge)(struct rq_qos *, struct request *, struct bio *);
	void (*issue)(struct rq_qos *, struct request *);
	void (*requeue)(struct rq_qos *, struct request *);
	void (*done)(struct rq_qos *, struct request *);
	void (*done_bio)(struct rq_qos *, struct bio *);
	void (*cleanup)(struct rq_qos *, struct bio *);
	void (*queue_depth_changed)(struct rq_qos *);
	void (*exit)(struct rq_qos *);
	const struct blk_mq_debugfs_attr *debugfs_attrs;
};

struct bio_slab {
	struct kmem_cache *slab;
	unsigned int slab_ref;
	unsigned int slab_size;
	char name[8];
};

enum {
	BLK_MQ_F_SHOULD_MERGE = 1,
	BLK_MQ_F_TAG_QUEUE_SHARED = 2,
	BLK_MQ_F_STACKING = 4,
	BLK_MQ_F_TAG_HCTX_SHARED = 8,
	BLK_MQ_F_BLOCKING = 32,
	BLK_MQ_F_NO_SCHED = 64,
	BLK_MQ_F_NO_SCHED_BY_DEFAULT = 128,
	BLK_MQ_F_ALLOC_POLICY_START_BIT = 8,
	BLK_MQ_F_ALLOC_POLICY_BITS = 1,
	BLK_MQ_S_STOPPED = 0,
	BLK_MQ_S_TAG_ACTIVE = 1,
	BLK_MQ_S_SCHED_RESTART = 2,
	BLK_MQ_S_INACTIVE = 3,
	BLK_MQ_MAX_DEPTH = 10240,
	BLK_MQ_CPU_WORK_BATCH = 8,
};

enum {
	WBT_RWQ_BG = 0,
	WBT_RWQ_KSWAPD = 1,
	WBT_RWQ_DISCARD = 2,
	WBT_NUM_RWQ = 3,
};

struct req_iterator {
	struct bvec_iter iter;
	struct bio *bio;
};

struct blk_plug_cb;

typedef void (*blk_plug_cb_fn)(struct blk_plug_cb *, bool);

struct blk_plug_cb {
	struct list_head list;
	blk_plug_cb_fn callback;
	void *data;
};

enum {
	BLK_MQ_REQ_NOWAIT = 1,
	BLK_MQ_REQ_RESERVED = 2,
	BLK_MQ_REQ_PM = 4,
};

struct trace_event_raw_block_buffer {
	struct trace_entry ent;
	dev_t dev;
	sector_t sector;
	size_t size;
	char __data[0];
};

struct trace_event_raw_block_rq_requeue {
	struct trace_entry ent;
	dev_t dev;
	sector_t sector;
	unsigned int nr_sector;
	char rwbs[8];
	u32 __data_loc_cmd;
	char __data[0];
};

struct trace_event_raw_block_rq_complete {
	struct trace_entry ent;
	dev_t dev;
	sector_t sector;
	unsigned int nr_sector;
	int error;
	char rwbs[8];
	u32 __data_loc_cmd;
	char __data[0];
};

struct trace_event_raw_block_rq {
	struct trace_entry ent;
	dev_t dev;
	sector_t sector;
	unsigned int nr_sector;
	unsigned int bytes;
	char rwbs[8];
	char comm[16];
	u32 __data_loc_cmd;
	char __data[0];
};

struct trace_event_raw_block_bio_bounce {
	struct trace_entry ent;
	dev_t dev;
	sector_t sector;
	unsigned int nr_sector;
	char rwbs[8];
	char comm[16];
	char __data[0];
};

struct trace_event_raw_block_bio_complete {
	struct trace_entry ent;
	dev_t dev;
	sector_t sector;
	unsigned int nr_sector;
	int error;
	char rwbs[8];
	char __data[0];
};

struct trace_event_raw_block_bio_merge {
	struct trace_entry ent;
	dev_t dev;
	sector_t sector;
	unsigned int nr_sector;
	char rwbs[8];
	char comm[16];
	char __data[0];
};

struct trace_event_raw_block_bio_queue {
	struct trace_entry ent;
	dev_t dev;
	sector_t sector;
	unsigned int nr_sector;
	char rwbs[8];
	char comm[16];
	char __data[0];
};

struct trace_event_raw_block_get_rq {
	struct trace_entry ent;
	dev_t dev;
	sector_t sector;
	unsigned int nr_sector;
	char rwbs[8];
	char comm[16];
	char __data[0];
};

struct trace_event_raw_block_plug {
	struct trace_entry ent;
	char comm[16];
	char __data[0];
};

struct trace_event_raw_block_unplug {
	struct trace_entry ent;
	int nr_rq;
	char comm[16];
	char __data[0];
};

struct trace_event_raw_block_split {
	struct trace_entry ent;
	dev_t dev;
	sector_t sector;
	sector_t new_sector;
	char rwbs[8];
	char comm[16];
	char __data[0];
};

struct trace_event_raw_block_bio_remap {
	struct trace_entry ent;
	dev_t dev;
	sector_t sector;
	unsigned int nr_sector;
	dev_t old_dev;
	sector_t old_sector;
	char rwbs[8];
	char __data[0];
};

struct trace_event_raw_block_rq_remap {
	struct trace_entry ent;
	dev_t dev;
	sector_t sector;
	unsigned int nr_sector;
	dev_t old_dev;
	sector_t old_sector;
	unsigned int nr_bios;
	char rwbs[8];
	char __data[0];
};

struct trace_event_data_offsets_block_buffer {};

struct trace_event_data_offsets_block_rq_requeue {
	u32 cmd;
};

struct trace_event_data_offsets_block_rq_complete {
	u32 cmd;
};

struct trace_event_data_offsets_block_rq {
	u32 cmd;
};

struct trace_event_data_offsets_block_bio_bounce {};

struct trace_event_data_offsets_block_bio_complete {};

struct trace_event_data_offsets_block_bio_merge {};

struct trace_event_data_offsets_block_bio_queue {};

struct trace_event_data_offsets_block_get_rq {};

struct trace_event_data_offsets_block_plug {};

struct trace_event_data_offsets_block_unplug {};

struct trace_event_data_offsets_block_split {};

struct trace_event_data_offsets_block_bio_remap {};

struct trace_event_data_offsets_block_rq_remap {};

typedef void (*btf_trace_block_touch_buffer)(void *, struct buffer_head *);

typedef void (*btf_trace_block_dirty_buffer)(void *, struct buffer_head *);

typedef void (*btf_trace_block_rq_requeue)(void *, struct request_queue *, struct request *);

typedef void (*btf_trace_block_rq_complete)(void *, struct request *, int, unsigned int);

typedef void (*btf_trace_block_rq_insert)(void *, struct request_queue *, struct request *);

typedef void (*btf_trace_block_rq_issue)(void *, struct request_queue *, struct request *);

typedef void (*btf_trace_block_rq_merge)(void *, struct request_queue *, struct request *);

typedef void (*btf_trace_block_bio_bounce)(void *, struct request_queue *, struct bio *);

typedef void (*btf_trace_block_bio_complete)(void *, struct request_queue *, struct bio *);

typedef void (*btf_trace_block_bio_backmerge)(void *, struct request_queue *, struct request *, struct bio *);

typedef void (*btf_trace_block_bio_frontmerge)(void *, struct request_queue *, struct request *, struct bio *);

typedef void (*btf_trace_block_bio_queue)(void *, struct request_queue *, struct bio *);

typedef void (*btf_trace_block_getrq)(void *, struct request_queue *, struct bio *, int);

typedef void (*btf_trace_block_sleeprq)(void *, struct request_queue *, struct bio *, int);

typedef void (*btf_trace_block_plug)(void *, struct request_queue *);

typedef void (*btf_trace_block_unplug)(void *, struct request_queue *, unsigned int, bool);

typedef void (*btf_trace_block_split)(void *, struct request_queue *, struct bio *, unsigned int);

typedef void (*btf_trace_block_bio_remap)(void *, struct request_queue *, struct bio *, dev_t, sector_t);

typedef void (*btf_trace_block_rq_remap)(void *, struct request_queue *, struct request *, dev_t, sector_t);

enum {
	BLK_MQ_NO_TAG = 4294967295,
	BLK_MQ_TAG_MIN = 1,
	BLK_MQ_TAG_MAX = 4294967294,
};

struct queue_sysfs_entry {
	struct attribute attr;
	ssize_t (*show)(struct request_queue *, char *);
	ssize_t (*store)(struct request_queue *, const char *, size_t);
};

enum {
	REQ_FSEQ_PREFLUSH = 1,
	REQ_FSEQ_DATA = 2,
	REQ_FSEQ_POSTFLUSH = 4,
	REQ_FSEQ_DONE = 8,
	REQ_FSEQ_ACTIONS = 7,
	FLUSH_PENDING_TIMEOUT = 1250,
};

enum {
	ICQ_EXITED = 4,
	ICQ_DESTROYED = 8,
};

struct rq_map_data {
	struct page **pages;
	int page_order;
	int nr_entries;
	long unsigned int offset;
	int null_mapped;
	int from_user;
};

struct bio_map_data {
	bool is_our_pages: 1;
	bool is_null_mapped: 1;
	struct iov_iter iter;
	struct iovec iov[0];
};

enum bio_merge_status {
	BIO_MERGE_OK = 0,
	BIO_MERGE_NONE = 1,
	BIO_MERGE_FAILED = 2,
};

typedef bool (*sb_for_each_fn)(struct sbitmap *, unsigned int, void *);

enum {
	BLK_MQ_UNIQUE_TAG_BITS = 16,
	BLK_MQ_UNIQUE_TAG_MASK = 65535,
};

struct mq_inflight {
	struct hd_struct *part;
	unsigned int inflight[2];
};

struct flush_busy_ctx_data {
	struct blk_mq_hw_ctx *hctx;
	struct list_head *list;
};

struct dispatch_rq_data {
	struct blk_mq_hw_ctx *hctx;
	struct request *rq;
};

enum prep_dispatch {
	PREP_DISPATCH_OK = 0,
	PREP_DISPATCH_NO_TAG = 1,
	PREP_DISPATCH_NO_BUDGET = 2,
};

struct rq_iter_data {
	struct blk_mq_hw_ctx *hctx;
	bool has_rq;
};

struct blk_mq_qe_pair {
	struct list_head node;
	struct request_queue *q;
	struct elevator_type *type;
};

struct sbq_wait {
	struct sbitmap_queue *sbq;
	struct wait_queue_entry wait;
};

typedef bool busy_iter_fn(struct blk_mq_hw_ctx *, struct request *, void *, bool);

typedef bool busy_tag_iter_fn(struct request *, void *, bool);

struct bt_iter_data {
	struct blk_mq_hw_ctx *hctx;
	busy_iter_fn *fn;
	void *data;
	bool reserved;
};

struct bt_tags_iter_data {
	struct blk_mq_tags *tags;
	busy_tag_iter_fn *fn;
	void *data;
	unsigned int flags;
};

struct blk_queue_stats {
	struct list_head callbacks;
	spinlock_t lock;
	bool enable_accounting;
};

struct blk_mq_ctx_sysfs_entry {
	struct attribute attr;
	ssize_t (*show)(struct blk_mq_ctx *, char *);
	ssize_t (*store)(struct blk_mq_ctx *, const char *, size_t);
};

struct blk_mq_hw_ctx_sysfs_entry {
	struct attribute attr;
	ssize_t (*show)(struct blk_mq_hw_ctx *, char *);
	ssize_t (*store)(struct blk_mq_hw_ctx *, const char *, size_t);
};

struct hd_geometry {
	unsigned char heads;
	unsigned char sectors;
	short unsigned int cylinders;
	long unsigned int start;
};

struct blkpg_ioctl_arg {
	int op;
	int flags;
	int datalen;
	void *data;
};

struct blkpg_partition {
	long long int start;
	long long int length;
	int pno;
	char devname[64];
	char volname[64];
};

struct pr_reservation {
	__u64 key;
	__u32 type;
	__u32 flags;
};

struct pr_registration {
	__u64 old_key;
	__u64 new_key;
	__u32 flags;
	__u32 __pad;
};

struct pr_preempt {
	__u64 old_key;
	__u64 new_key;
	__u32 type;
	__u32 flags;
};

struct pr_clear {
	__u64 key;
	__u32 flags;
	__u32 __pad;
};

struct klist_node;

struct klist {
	spinlock_t k_lock;
	struct list_head k_list;
	void (*get)(struct klist_node *);
	void (*put)(struct klist_node *);
};

struct klist_node {
	void *n_klist;
	struct list_head n_node;
	struct kref n_ref;
};

struct klist_iter {
	struct klist *i_klist;
	struct klist_node *i_cur;
};

struct class_dev_iter {
	struct klist_iter ki;
	const struct device_type *type;
};

enum {
	DISK_EVENT_FLAG_POLL = 1,
	DISK_EVENT_FLAG_UEVENT = 2,
};

struct disk_events {
	struct list_head node;
	struct gendisk *disk;
	spinlock_t lock;
	struct mutex block_mutex;
	int block;
	unsigned int pending;
	unsigned int clearing;
	long int poll_msecs;
	struct delayed_work dwork;
};

struct badblocks {
	struct device *dev;
	int count;
	int unacked_exist;
	int shift;
	u64 *page;
	int changed;
	seqlock_t lock;
	sector_t sector;
	sector_t size;
};

struct disk_part_iter {
	struct gendisk *disk;
	struct hd_struct *part;
	int idx;
	unsigned int flags;
};

struct blk_major_name {
	struct blk_major_name *next;
	int major;
	char name[16];
};

enum {
	IOPRIO_WHO_PROCESS = 1,
	IOPRIO_WHO_PGRP = 2,
	IOPRIO_WHO_USER = 3,
};

struct parsed_partitions {
	struct block_device *bdev;
	char name[32];
	struct {
		sector_t from;
		sector_t size;
		int flags;
		bool has_info;
		struct partition_meta_info info;
	} *parts;
	int next;
	int limit;
	bool access_beyond_eod;
	char *pp_buf;
};

typedef struct {
	struct page *v;
} Sector;

struct msdos_partition {
	u8 boot_ind;
	u8 head;
	u8 sector;
	u8 cyl;
	u8 sys_ind;
	u8 end_head;
	u8 end_sector;
	u8 end_cyl;
	__le32 start_sect;
	__le32 nr_sects;
};

enum msdos_sys_ind {
	DOS_EXTENDED_PARTITION = 5,
	LINUX_EXTENDED_PARTITION = 133,
	WIN98_EXTENDED_PARTITION = 15,
	LINUX_DATA_PARTITION = 131,
	LINUX_LVM_PARTITION = 142,
	LINUX_RAID_PARTITION = 253,
	SOLARIS_X86_PARTITION = 130,
	NEW_SOLARIS_X86_PARTITION = 191,
	DM6_AUX1PARTITION = 81,
	DM6_AUX3PARTITION = 83,
	DM6_PARTITION = 84,
	EZD_PARTITION = 85,
	FREEBSD_PARTITION = 165,
	OPENBSD_PARTITION = 166,
	NETBSD_PARTITION = 169,
	BSDI_PARTITION = 183,
	MINIX_PARTITION = 129,
	UNIXWARE_PARTITION = 99,
};

typedef struct {
	__u8 b[16];
} guid_t;

typedef guid_t efi_guid_t;

struct _gpt_header {
	__le64 signature;
	__le32 revision;
	__le32 header_size;
	__le32 header_crc32;
	__le32 reserved1;
	__le64 my_lba;
	__le64 alternate_lba;
	__le64 first_usable_lba;
	__le64 last_usable_lba;
	efi_guid_t disk_guid;
	__le64 partition_entry_lba;
	__le32 num_partition_entries;
	__le32 sizeof_partition_entry;
	__le32 partition_entry_array_crc32;
} __attribute__((packed));

typedef struct _gpt_header gpt_header;

struct _gpt_entry_attributes {
	u64 required_to_function: 1;
	u64 reserved: 47;
	u64 type_guid_specific: 16;
};

typedef struct _gpt_entry_attributes gpt_entry_attributes;

struct _gpt_entry {
	efi_guid_t partition_type_guid;
	efi_guid_t unique_partition_guid;
	__le64 starting_lba;
	__le64 ending_lba;
	gpt_entry_attributes attributes;
	__le16 partition_name[36];
};

typedef struct _gpt_entry gpt_entry;

struct _gpt_mbr_record {
	u8 boot_indicator;
	u8 start_head;
	u8 start_sector;
	u8 start_track;
	u8 os_type;
	u8 end_head;
	u8 end_sector;
	u8 end_track;
	__le32 starting_lba;
	__le32 size_in_lba;
};

typedef struct _gpt_mbr_record gpt_mbr_record;

struct _legacy_mbr {
	u8 boot_code[440];
	__le32 unique_mbr_signature;
	__le16 unknown;
	gpt_mbr_record partition_record[4];
	__le16 signature;
} __attribute__((packed));

typedef struct _legacy_mbr legacy_mbr;

struct rq_wait {
	wait_queue_head_t wait;
	atomic_t inflight;
};

struct rq_depth {
	unsigned int max_depth;
	int scale_step;
	bool scaled_max;
	unsigned int queue_depth;
	unsigned int default_depth;
};

typedef bool acquire_inflight_cb_t(struct rq_wait *, void *);

typedef void cleanup_cb_t(struct rq_wait *, void *);

struct rq_qos_wait_data {
	struct wait_queue_entry wq;
	struct task_struct *task;
	struct rq_wait *rqw;
	acquire_inflight_cb_t *cb;
	void *private_data;
	bool got_token;
};

struct request_sense;

struct cdrom_generic_command {
	unsigned char cmd[12];
	unsigned char *buffer;
	unsigned int buflen;
	int stat;
	struct request_sense *sense;
	unsigned char data_direction;
	int quiet;
	int timeout;
	union {
		void *reserved[1];
		void *unused;
	};
};

struct request_sense {
	__u8 error_code: 7;
	__u8 valid: 1;
	__u8 segment_number;
	__u8 sense_key: 4;
	__u8 reserved2: 1;
	__u8 ili: 1;
	__u8 reserved1: 2;
	__u8 information[4];
	__u8 add_sense_len;
	__u8 command_info[4];
	__u8 asc;
	__u8 ascq;
	__u8 fruc;
	__u8 sks[3];
	__u8 asb[46];
};

struct scsi_ioctl_command {
	unsigned int inlen;
	unsigned int outlen;
	unsigned char data[0];
};

enum scsi_device_event {
	SDEV_EVT_MEDIA_CHANGE = 1,
	SDEV_EVT_INQUIRY_CHANGE_REPORTED = 2,
	SDEV_EVT_CAPACITY_CHANGE_REPORTED = 3,
	SDEV_EVT_SOFT_THRESHOLD_REACHED_REPORTED = 4,
	SDEV_EVT_MODE_PARAMETER_CHANGE_REPORTED = 5,
	SDEV_EVT_LUN_CHANGE_REPORTED = 6,
	SDEV_EVT_ALUA_STATE_CHANGE_REPORTED = 7,
	SDEV_EVT_POWER_ON_RESET_OCCURRED = 8,
	SDEV_EVT_FIRST = 1,
	SDEV_EVT_LAST = 8,
	SDEV_EVT_MAXBITS = 9,
};

struct scsi_request {
	unsigned char __cmd[16];
	unsigned char *cmd;
	short unsigned int cmd_len;
	int result;
	unsigned int sense_len;
	unsigned int resid_len;
	int retries;
	void *sense;
};

struct sg_io_hdr {
	int interface_id;
	int dxfer_direction;
	unsigned char cmd_len;
	unsigned char mx_sb_len;
	short unsigned int iovec_count;
	unsigned int dxfer_len;
	void *dxferp;
	unsigned char *cmdp;
	void *sbp;
	unsigned int timeout;
	unsigned int flags;
	int pack_id;
	void *usr_ptr;
	unsigned char status;
	unsigned char masked_status;
	unsigned char msg_status;
	unsigned char sb_len_wr;
	short unsigned int host_status;
	short unsigned int driver_status;
	int resid;
	unsigned int duration;
	unsigned int info;
};

struct blk_cmd_filter {
	long unsigned int read_ok[4];
	long unsigned int write_ok[4];
};

enum {
	OMAX_SB_LEN = 16,
};

struct bsg_device {
	struct request_queue *queue;
	spinlock_t lock;
	struct hlist_node dev_list;
	refcount_t ref_count;
	char name[20];
	int max_queue;
};

struct blkcg_policy_data {};

struct io_stats_per_prio {
	local_t inserted;
	local_t merged;
	local_t dispatched;
	local_t completed;
};

struct blkcg_io_stats {
	struct io_stats_per_prio stats[4];
};

struct dd_blkcg {
	struct blkcg_policy_data cpd;
	struct blkcg_io_stats *stats;
};

enum dd_data_dir {
	DD_READ = 0,
	DD_WRITE = 1,
};

enum {
	DD_DIR_COUNT = 2,
};

enum dd_prio {
	DD_RT_PRIO = 0,
	DD_BE_PRIO = 1,
	DD_IDLE_PRIO = 2,
	DD_PRIO_MAX = 2,
};

enum {
	DD_PRIO_COUNT = 3,
};

struct io_stats {
	struct io_stats_per_prio stats[3];
};

struct dd_per_prio {
	struct list_head dispatch;
	struct rb_root sort_list[2];
	struct list_head fifo_list[2];
	struct request *next_rq[2];
};

struct deadline_data {
	struct request_queue *queue;
	struct dd_per_prio per_prio[3];
	enum dd_data_dir last_dir;
	unsigned int batching;
	unsigned int starved;
	struct io_stats *stats;
	int fifo_expire[2];
	int fifo_batch;
	int writes_starved;
	int front_merges;
	u32 async_depth;
	int aging_expire;
	spinlock_t lock;
	spinlock_t zone_lock;
};

struct trace_event_raw_kyber_latency {
	struct trace_entry ent;
	dev_t dev;
	char domain[16];
	char type[8];
	u8 percentile;
	u8 numerator;
	u8 denominator;
	unsigned int samples;
	char __data[0];
};

struct trace_event_raw_kyber_adjust {
	struct trace_entry ent;
	dev_t dev;
	char domain[16];
	unsigned int depth;
	char __data[0];
};

struct trace_event_raw_kyber_throttled {
	struct trace_entry ent;
	dev_t dev;
	char domain[16];
	char __data[0];
};

struct trace_event_data_offsets_kyber_latency {};

struct trace_event_data_offsets_kyber_adjust {};

struct trace_event_data_offsets_kyber_throttled {};

typedef void (*btf_trace_kyber_latency)(void *, struct request_queue *, const char *, const char *, unsigned int, unsigned int, unsigned int, unsigned int);

typedef void (*btf_trace_kyber_adjust)(void *, struct request_queue *, const char *, unsigned int);

typedef void (*btf_trace_kyber_throttled)(void *, struct request_queue *, const char *);

enum {
	KYBER_READ = 0,
	KYBER_WRITE = 1,
	KYBER_DISCARD = 2,
	KYBER_OTHER = 3,
	KYBER_NUM_DOMAINS = 4,
};

enum {
	KYBER_ASYNC_PERCENT = 75,
};

enum {
	KYBER_LATENCY_SHIFT = 2,
	KYBER_GOOD_BUCKETS = 4,
	KYBER_LATENCY_BUCKETS = 8,
};

enum {
	KYBER_TOTAL_LATENCY = 0,
	KYBER_IO_LATENCY = 1,
};

struct kyber_cpu_latency {
	atomic_t buckets[48];
};

struct kyber_ctx_queue {
	spinlock_t lock;
	struct list_head rq_list[4];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct kyber_queue_data {
	struct request_queue *q;
	struct sbitmap_queue domain_tokens[4];
	unsigned int async_depth;
	struct kyber_cpu_latency *cpu_latency;
	struct timer_list timer;
	unsigned int latency_buckets[48];
	long unsigned int latency_timeout[3];
	int domain_p99[3];
	u64 latency_targets[3];
};

struct kyber_hctx_data {
	spinlock_t lock;
	struct list_head rqs[4];
	unsigned int cur_domain;
	unsigned int batching;
	struct kyber_ctx_queue *kcqs;
	struct sbitmap kcq_map[4];
	struct sbq_wait domain_wait[4];
	struct sbq_wait_state *domain_ws[4];
	atomic_t wait_index[4];
};

struct flush_kcq_data {
	struct kyber_hctx_data *khd;
	unsigned int sched_domain;
	struct list_head *list;
};

struct virtio_device_id {
	__u32 device;
	__u32 vendor;
};

struct virtio_device;

struct virtqueue {
	struct list_head list;
	void (*callback)(struct virtqueue *);
	const char *name;
	struct virtio_device *vdev;
	unsigned int index;
	unsigned int num_free;
	void *priv;
};

struct vringh_config_ops;

struct virtio_config_ops;

struct virtio_device {
	int index;
	bool failed;
	bool config_enabled;
	bool config_change_pending;
	spinlock_t config_lock;
	struct device dev;
	struct virtio_device_id id;
	const struct virtio_config_ops *config;
	const struct vringh_config_ops *vringh_config;
	struct list_head vqs;
	u64 features;
	void *priv;
};

typedef void vq_callback_t(struct virtqueue *);

struct virtio_shm_region;

struct virtio_config_ops {
	void (*get)(struct virtio_device *, unsigned int, void *, unsigned int);
	void (*set)(struct virtio_device *, unsigned int, const void *, unsigned int);
	u32 (*generation)(struct virtio_device *);
	u8 (*get_status)(struct virtio_device *);
	void (*set_status)(struct virtio_device *, u8);
	void (*reset)(struct virtio_device *);
	int (*find_vqs)(struct virtio_device *, unsigned int, struct virtqueue **, vq_callback_t **, const char * const *, const bool *, struct irq_affinity *);
	void (*del_vqs)(struct virtio_device *);
	u64 (*get_features)(struct virtio_device *);
	int (*finalize_features)(struct virtio_device *);
	const char * (*bus_name)(struct virtio_device *);
	int (*set_vq_affinity)(struct virtqueue *, const struct cpumask *);
	const struct cpumask * (*get_vq_affinity)(struct virtio_device *, int);
	bool (*get_shm_region)(struct virtio_device *, struct virtio_shm_region *, u8);
};

struct virtio_shm_region {
	u64 addr;
	u64 len;
};

struct show_busy_params {
	struct seq_file *m;
	struct blk_mq_hw_ctx *hctx;
};

typedef void (*swap_func_t)(void *, void *, int);

typedef int (*cmp_r_func_t)(const void *, const void *, const void *);

struct siprand_state {
	long unsigned int v0;
	long unsigned int v1;
	long unsigned int v2;
	long unsigned int v3;
};

struct region {
	unsigned int start;
	unsigned int off;
	unsigned int group_len;
	unsigned int end;
};

enum {
	REG_OP_ISFREE = 0,
	REG_OP_ALLOC = 1,
	REG_OP_RELEASE = 2,
};

typedef struct scatterlist *sg_alloc_fn(unsigned int, gfp_t);

typedef void sg_free_fn(struct scatterlist *, unsigned int);

struct sg_page_iter {
	struct scatterlist *sg;
	unsigned int sg_pgoffset;
	unsigned int __nents;
	int __pg_advance;
};

struct sg_dma_page_iter {
	struct sg_page_iter base;
};

struct sg_mapping_iter {
	struct page *page;
	void *addr;
	size_t length;
	size_t consumed;
	struct sg_page_iter piter;
	unsigned int __offset;
	unsigned int __remaining;
	unsigned int __flags;
};

typedef int (*cmp_func)(void *, struct list_head *, struct list_head *);

struct csum_state {
	__wsum csum;
	size_t off;
};

typedef u32 compat_size_t;

typedef s32 compat_ssize_t;

struct compat_iovec {
	compat_uptr_t iov_base;
	compat_size_t iov_len;
};

struct __kfifo {
	unsigned int in;
	unsigned int out;
	unsigned int mask;
	unsigned int esize;
	void *data;
};

struct rhltable {
	struct rhashtable ht;
};

struct rhashtable_walker {
	struct list_head list;
	struct bucket_table *tbl;
};

struct rhashtable_iter {
	struct rhashtable *ht;
	struct rhash_head *p;
	struct rhlist_head *list;
	struct rhashtable_walker walker;
	unsigned int slot;
	unsigned int skip;
	bool end_of_table;
};

union nested_table {
	union nested_table *table;
	struct rhash_lock_head *bucket;
};

struct once_work {
	struct work_struct work;
	struct static_key_true *key;
};

struct genradix_iter {
	size_t offset;
	size_t pos;
};

struct genradix_node {
	union {
		struct genradix_node *children[512];
		u8 data[4096];
	};
};

struct reciprocal_value_adv {
	u32 m;
	u8 sh;
	u8 exp;
	bool is_wide_m;
};

typedef __int128 unsigned u128;

enum {
	PCI_STD_RESOURCES = 0,
	PCI_STD_RESOURCE_END = 5,
	PCI_ROM_RESOURCE = 6,
	PCI_BRIDGE_RESOURCES = 7,
	PCI_BRIDGE_RESOURCE_END = 10,
	PCI_NUM_RESOURCES = 11,
	DEVICE_COUNT_RESOURCE = 11,
};

typedef unsigned int pci_channel_state_t;

typedef unsigned int pcie_reset_state_t;

typedef short unsigned int pci_dev_flags_t;

typedef short unsigned int pci_bus_flags_t;

typedef unsigned int pci_ers_result_t;

enum devm_ioremap_type {
	DEVM_IOREMAP = 0,
	DEVM_IOREMAP_UC = 1,
	DEVM_IOREMAP_WC = 2,
};

enum assoc_array_walk_status {
	assoc_array_walk_tree_empty = 0,
	assoc_array_walk_found_terminal_node = 1,
	assoc_array_walk_found_wrong_shortcut = 2,
};

struct assoc_array_walk_result {
	struct {
		struct assoc_array_node *node;
		int level;
		int slot;
	} terminal_node;
	struct {
		struct assoc_array_shortcut *shortcut;
		int level;
		int sc_level;
		long unsigned int sc_segments;
		long unsigned int dissimilarity;
	} wrong_shortcut;
};

struct assoc_array_delete_collapse_context {
	struct assoc_array_node *node;
	const void *skip_leaf;
	int slot;
};

struct linear_range {
	unsigned int min;
	unsigned int min_sel;
	unsigned int max_sel;
	unsigned int step;
};

struct xxh32_state {
	uint32_t total_len_32;
	uint32_t large_len;
	uint32_t v1;
	uint32_t v2;
	uint32_t v3;
	uint32_t v4;
	uint32_t mem32[4];
	uint32_t memsize;
};

struct xxh64_state {
	uint64_t total_len;
	uint64_t v1;
	uint64_t v2;
	uint64_t v3;
	uint64_t v4;
	uint64_t mem64[4];
	uint32_t memsize;
};

struct gen_pool_chunk {
	struct list_head next_chunk;
	atomic_long_t avail;
	phys_addr_t phys_addr;
	void *owner;
	long unsigned int start_addr;
	long unsigned int end_addr;
	long unsigned int bits[0];
};

struct genpool_data_align {
	int align;
};

struct genpool_data_fixed {
	long unsigned int offset;
};

typedef z_stream *z_streamp;

typedef struct {
	unsigned char op;
	unsigned char bits;
	short unsigned int val;
} code;

typedef enum {
	HEAD = 0,
	FLAGS = 1,
	TIME = 2,
	OS = 3,
	EXLEN = 4,
	EXTRA = 5,
	NAME = 6,
	COMMENT = 7,
	HCRC = 8,
	DICTID = 9,
	DICT = 10,
	TYPE = 11,
	TYPEDO = 12,
	STORED = 13,
	COPY = 14,
	TABLE = 15,
	LENLENS = 16,
	CODELENS = 17,
	LEN = 18,
	LENEXT = 19,
	DIST = 20,
	DISTEXT = 21,
	MATCH = 22,
	LIT = 23,
	CHECK = 24,
	LENGTH = 25,
	DONE = 26,
	BAD = 27,
	MEM = 28,
	SYNC = 29,
} inflate_mode;

struct inflate_state {
	inflate_mode mode;
	int last;
	int wrap;
	int havedict;
	int flags;
	unsigned int dmax;
	long unsigned int check;
	long unsigned int total;
	unsigned int wbits;
	unsigned int wsize;
	unsigned int whave;
	unsigned int write;
	unsigned char *window;
	long unsigned int hold;
	unsigned int bits;
	unsigned int length;
	unsigned int offset;
	unsigned int extra;
	const code *lencode;
	const code *distcode;
	unsigned int lenbits;
	unsigned int distbits;
	unsigned int ncode;
	unsigned int nlen;
	unsigned int ndist;
	unsigned int have;
	code *next;
	short unsigned int lens[320];
	short unsigned int work[288];
	code codes[2048];
};

union uu {
	short unsigned int us;
	unsigned char b[2];
};

typedef unsigned int uInt;

struct inflate_workspace {
	struct inflate_state inflate_state;
	unsigned char working_window[32768];
};

typedef enum {
	CODES = 0,
	LENS = 1,
	DISTS = 2,
} codetype;

typedef unsigned char uch;

typedef short unsigned int ush;

typedef long unsigned int ulg;

struct ct_data_s {
	union {
		ush freq;
		ush code;
	} fc;
	union {
		ush dad;
		ush len;
	} dl;
};

typedef struct ct_data_s ct_data;

struct static_tree_desc_s {
	const ct_data *static_tree;
	const int *extra_bits;
	int extra_base;
	int elems;
	int max_length;
};

typedef struct static_tree_desc_s static_tree_desc;

struct tree_desc_s {
	ct_data *dyn_tree;
	int max_code;
	static_tree_desc *stat_desc;
};

typedef ush Pos;

typedef unsigned int IPos;

struct deflate_state {
	z_streamp strm;
	int status;
	Byte *pending_buf;
	ulg pending_buf_size;
	Byte *pending_out;
	int pending;
	int noheader;
	Byte data_type;
	Byte method;
	int last_flush;
	uInt w_size;
	uInt w_bits;
	uInt w_mask;
	Byte *window;
	ulg window_size;
	Pos *prev;
	Pos *head;
	uInt ins_h;
	uInt hash_size;
	uInt hash_bits;
	uInt hash_mask;
	uInt hash_shift;
	long int block_start;
	uInt match_length;
	IPos prev_match;
	int match_available;
	uInt strstart;
	uInt match_start;
	uInt lookahead;
	uInt prev_length;
	uInt max_chain_length;
	uInt max_lazy_match;
	int level;
	int strategy;
	uInt good_match;
	int nice_match;
	struct ct_data_s dyn_ltree[573];
	struct ct_data_s dyn_dtree[61];
	struct ct_data_s bl_tree[39];
	struct tree_desc_s l_desc;
	struct tree_desc_s d_desc;
	struct tree_desc_s bl_desc;
	ush bl_count[16];
	int heap[573];
	int heap_len;
	int heap_max;
	uch depth[573];
	uch *l_buf;
	uInt lit_bufsize;
	uInt last_lit;
	ush *d_buf;
	ulg opt_len;
	ulg static_len;
	ulg compressed_len;
	uInt matches;
	int last_eob_len;
	ush bi_buf;
	int bi_valid;
};

typedef struct deflate_state deflate_state;

typedef enum {
	need_more = 0,
	block_done = 1,
	finish_started = 2,
	finish_done = 3,
} block_state;

typedef block_state (*compress_func)(deflate_state *, int);

struct deflate_workspace {
	deflate_state deflate_memory;
	Byte *window_memory;
	Pos *prev_memory;
	Pos *head_memory;
	char *overlay_memory;
};

typedef struct deflate_workspace deflate_workspace;

struct config_s {
	ush good_length;
	ush max_lazy;
	ush nice_length;
	ush max_chain;
	compress_func func;
};

typedef struct config_s config;

typedef struct tree_desc_s tree_desc;

typedef struct {
	const uint8_t *externalDict;
	size_t extDictSize;
	const uint8_t *prefixEnd;
	size_t prefixSize;
} LZ4_streamDecode_t_internal;

typedef union {
	long long unsigned int table[4];
	LZ4_streamDecode_t_internal internal_donotuse;
} LZ4_streamDecode_t;

typedef uint8_t BYTE;

typedef uint16_t U16;

typedef uint32_t U32;

typedef uint64_t U64;

typedef uintptr_t uptrval;

typedef enum {
	noDict = 0,
	withPrefix64k = 1,
	usingExtDict = 2,
} dict_directive;

typedef enum {
	endOnOutputSize = 0,
	endOnInputSize = 1,
} endCondition_directive;

typedef enum {
	decode_full_block = 0,
	partial_decode = 1,
} earlyEnd_directive;

typedef struct {
	size_t bitContainer;
	int bitPos;
	char *startPtr;
	char *ptr;
	char *endPtr;
} BIT_CStream_t;

typedef unsigned int FSE_CTable;

typedef struct {
	ptrdiff_t value;
	const void *stateTable;
	const void *symbolTT;
	unsigned int stateLog;
} FSE_CState_t;

typedef struct {
	int deltaFindState;
	U32 deltaNbBits;
} FSE_symbolCompressionTransform;

typedef s16 int16_t;

typedef int16_t S16;

struct HUF_CElt_s {
	U16 val;
	BYTE nbBits;
};

typedef struct HUF_CElt_s HUF_CElt;

typedef enum {
	HUF_repeat_none = 0,
	HUF_repeat_check = 1,
	HUF_repeat_valid = 2,
} HUF_repeat;

struct nodeElt_s {
	U32 count;
	U16 parent;
	BYTE byte;
	BYTE nbBits;
};

typedef struct nodeElt_s nodeElt;

typedef struct {
	U32 base;
	U32 curr;
} rankPos;

typedef enum {
	ZSTDcs_created = 0,
	ZSTDcs_init = 1,
	ZSTDcs_ongoing = 2,
	ZSTDcs_ending = 3,
} ZSTD_compressionStage_e;

typedef void * (*ZSTD_allocFunction)(void *, size_t);

typedef void (*ZSTD_freeFunction)(void *, void *);

typedef struct {
	ZSTD_allocFunction customAlloc;
	ZSTD_freeFunction customFree;
	void *opaque;
} ZSTD_customMem;

typedef struct {
	U32 price;
	U32 off;
	U32 mlen;
	U32 litlen;
	U32 rep[3];
} ZSTD_optimal_t;

typedef struct {
	U32 off;
	U32 len;
} ZSTD_match_t;

struct seqDef_s;

typedef struct seqDef_s seqDef;

typedef struct {
	seqDef *sequencesStart;
	seqDef *sequences;
	BYTE *litStart;
	BYTE *lit;
	BYTE *llCode;
	BYTE *mlCode;
	BYTE *ofCode;
	U32 longLengthID;
	U32 longLengthPos;
	ZSTD_optimal_t *priceTable;
	ZSTD_match_t *matchTable;
	U32 *matchLengthFreq;
	U32 *litLengthFreq;
	U32 *litFreq;
	U32 *offCodeFreq;
	U32 matchLengthSum;
	U32 matchSum;
	U32 litLengthSum;
	U32 litSum;
	U32 offCodeSum;
	U32 log2matchLengthSum;
	U32 log2matchSum;
	U32 log2litLengthSum;
	U32 log2litSum;
	U32 log2offCodeSum;
	U32 factor;
	U32 staticPrices;
	U32 cachedPrice;
	U32 cachedLitLength;
	const BYTE *cachedLiterals;
} seqStore_t;

struct HUF_CElt_s;

typedef struct HUF_CElt_s HUF_CElt___2;

struct ZSTD_CCtx_s {
	const BYTE *nextSrc;
	const BYTE *base;
	const BYTE *dictBase;
	U32 dictLimit;
	U32 lowLimit;
	U32 nextToUpdate;
	U32 nextToUpdate3;
	U32 hashLog3;
	U32 loadedDictEnd;
	U32 forceWindow;
	U32 forceRawDict;
	ZSTD_compressionStage_e stage;
	U32 rep[3];
	U32 repToConfirm[3];
	U32 dictID;
	ZSTD_parameters params;
	void *workSpace;
	size_t workSpaceSize;
	size_t blockSize;
	U64 frameContentSize;
	struct xxh64_state xxhState;
	ZSTD_customMem customMem;
	seqStore_t seqStore;
	U32 *hashTable;
	U32 *hashTable3;
	U32 *chainTable;
	HUF_CElt___2 *hufTable;
	U32 flagStaticTables;
	HUF_repeat flagStaticHufTable;
	FSE_CTable offcodeCTable[187];
	FSE_CTable matchlengthCTable[363];
	FSE_CTable litlengthCTable[329];
	unsigned int tmpCounters[1536];
};

typedef struct ZSTD_CCtx_s ZSTD_CCtx___2;

struct ZSTD_CDict_s {
	void *dictBuffer;
	const void *dictContent;
	size_t dictContentSize;
	ZSTD_CCtx___2 *refContext;
};

typedef struct ZSTD_CDict_s ZSTD_CDict;

struct ZSTD_inBuffer_s {
	const void *src;
	size_t size;
	size_t pos;
};

typedef struct ZSTD_inBuffer_s ZSTD_inBuffer;

struct ZSTD_outBuffer_s {
	void *dst;
	size_t size;
	size_t pos;
};

typedef struct ZSTD_outBuffer_s ZSTD_outBuffer;

typedef enum {
	zcss_init = 0,
	zcss_load = 1,
	zcss_flush = 2,
	zcss_final = 3,
} ZSTD_cStreamStage;

struct ZSTD_CStream_s {
	ZSTD_CCtx___2 *cctx;
	ZSTD_CDict *cdictLocal;
	const ZSTD_CDict *cdict;
	char *inBuff;
	size_t inBuffSize;
	size_t inToCompress;
	size_t inBuffPos;
	size_t inBuffTarget;
	size_t blockSize;
	char *outBuff;
	size_t outBuffSize;
	size_t outBuffContentSize;
	size_t outBuffFlushedSize;
	ZSTD_cStreamStage stage;
	U32 checksum;
	U32 frameEnded;
	U64 pledgedSrcSize;
	U64 inputProcessed;
	ZSTD_parameters params;
	ZSTD_customMem customMem;
};

typedef struct ZSTD_CStream_s ZSTD_CStream;

typedef int32_t S32;

typedef enum {
	set_basic = 0,
	set_rle = 1,
	set_compressed = 2,
	set_repeat = 3,
} symbolEncodingType_e;

struct seqDef_s {
	U32 offset;
	U16 litLength;
	U16 matchLength;
};

typedef enum {
	ZSTDcrp_continue = 0,
	ZSTDcrp_noMemset = 1,
	ZSTDcrp_fullReset = 2,
} ZSTD_compResetPolicy_e;

typedef void (*ZSTD_blockCompressor)(ZSTD_CCtx___2 *, const void *, size_t);

typedef enum {
	zsf_gather = 0,
	zsf_flush = 1,
	zsf_end = 2,
} ZSTD_flush_e;

typedef size_t (*searchMax_f)(ZSTD_CCtx___2 *, const BYTE *, const BYTE *, size_t *, U32, U32);

typedef struct {
	size_t bitContainer;
	unsigned int bitsConsumed;
	const char *ptr;
	const char *start;
} BIT_DStream_t;

typedef enum {
	BIT_DStream_unfinished = 0,
	BIT_DStream_endOfBuffer = 1,
	BIT_DStream_completed = 2,
	BIT_DStream_overflow = 3,
} BIT_DStream_status;

typedef unsigned int FSE_DTable;

typedef struct {
	size_t state;
	const void *table;
} FSE_DState_t;

typedef struct {
	U16 tableLog;
	U16 fastMode;
} FSE_DTableHeader;

typedef struct {
	short unsigned int newState;
	unsigned char symbol;
	unsigned char nbBits;
} FSE_decode_t;

typedef struct {
	void *ptr;
	const void *end;
} ZSTD_stack;

typedef U32 HUF_DTable;

typedef struct {
	BYTE maxTableLog;
	BYTE tableType;
	BYTE tableLog;
	BYTE reserved;
} DTableDesc;

typedef struct {
	BYTE byte;
	BYTE nbBits;
} HUF_DEltX2;

typedef struct {
	U16 sequence;
	BYTE nbBits;
	BYTE length;
} HUF_DEltX4;

typedef struct {
	BYTE symbol;
	BYTE weight;
} sortedSymbol_t;

typedef U32 rankValCol_t[13];

typedef struct {
	U32 tableTime;
	U32 decode256Time;
} algo_time_t;

typedef struct {
	FSE_DTable LLTable[513];
	FSE_DTable OFTable[257];
	FSE_DTable MLTable[513];
	HUF_DTable hufTable[4097];
	U64 workspace[384];
	U32 rep[3];
} ZSTD_entropyTables_t;

typedef struct {
	long long unsigned int frameContentSize;
	unsigned int windowSize;
	unsigned int dictID;
	unsigned int checksumFlag;
} ZSTD_frameParams;

typedef enum {
	bt_raw = 0,
	bt_rle = 1,
	bt_compressed = 2,
	bt_reserved = 3,
} blockType_e;

typedef enum {
	ZSTDds_getFrameHeaderSize = 0,
	ZSTDds_decodeFrameHeader = 1,
	ZSTDds_decodeBlockHeader = 2,
	ZSTDds_decompressBlock = 3,
	ZSTDds_decompressLastBlock = 4,
	ZSTDds_checkChecksum = 5,
	ZSTDds_decodeSkippableHeader = 6,
	ZSTDds_skipFrame = 7,
} ZSTD_dStage;

struct ZSTD_DCtx_s {
	const FSE_DTable *LLTptr;
	const FSE_DTable *MLTptr;
	const FSE_DTable *OFTptr;
	const HUF_DTable *HUFptr;
	ZSTD_entropyTables_t entropy;
	const void *previousDstEnd;
	const void *base;
	const void *vBase;
	const void *dictEnd;
	size_t expected;
	ZSTD_frameParams fParams;
	blockType_e bType;
	ZSTD_dStage stage;
	U32 litEntropy;
	U32 fseEntropy;
	struct xxh64_state xxhState;
	size_t headerSize;
	U32 dictID;
	const BYTE *litPtr;
	ZSTD_customMem customMem;
	size_t litSize;
	size_t rleSize;
	BYTE litBuffer[131080];
	BYTE headerBuffer[18];
};

typedef struct ZSTD_DCtx_s ZSTD_DCtx___2;

struct ZSTD_DDict_s {
	void *dictBuffer;
	const void *dictContent;
	size_t dictSize;
	ZSTD_entropyTables_t entropy;
	U32 dictID;
	U32 entropyPresent;
	ZSTD_customMem cMem;
};

typedef struct ZSTD_DDict_s ZSTD_DDict;

typedef enum {
	zdss_init = 0,
	zdss_loadHeader = 1,
	zdss_read = 2,
	zdss_load = 3,
	zdss_flush = 4,
} ZSTD_dStreamStage;

struct ZSTD_DStream_s {
	ZSTD_DCtx___2 *dctx;
	ZSTD_DDict *ddictLocal;
	const ZSTD_DDict *ddict;
	ZSTD_frameParams fParams;
	ZSTD_dStreamStage stage;
	char *inBuff;
	size_t inBuffSize;
	size_t inPos;
	size_t maxWindowSize;
	char *outBuff;
	size_t outBuffSize;
	size_t outStart;
	size_t outEnd;
	size_t blockSize;
	BYTE headerBuffer[18];
	size_t lhSize;
	ZSTD_customMem customMem;
	void *legacyContext;
	U32 previousLegacyVersion;
	U32 legacyVersion;
	U32 hostageByte;
};

typedef struct ZSTD_DStream_s ZSTD_DStream;

typedef enum {
	ZSTDnit_frameHeader = 0,
	ZSTDnit_blockHeader = 1,
	ZSTDnit_block = 2,
	ZSTDnit_lastBlock = 3,
	ZSTDnit_checksum = 4,
	ZSTDnit_skippableFrame = 5,
} ZSTD_nextInputType_e;

typedef uintptr_t uPtrDiff;

typedef struct {
	blockType_e blockType;
	U32 lastBlock;
	U32 origSize;
} blockProperties_t;

typedef union {
	FSE_decode_t realData;
	U32 alignedBy4;
} FSE_decode_t4;

typedef struct {
	size_t litLength;
	size_t matchLength;
	size_t offset;
	const BYTE *match;
} seq_t;

typedef struct {
	BIT_DStream_t DStream;
	FSE_DState_t stateLL;
	FSE_DState_t stateOffb;
	FSE_DState_t stateML;
	size_t prevOffset[3];
	const BYTE *base;
	size_t pos;
	uPtrDiff gotoDict;
} seqState_t;

enum xz_mode {
	XZ_SINGLE = 0,
	XZ_PREALLOC = 1,
	XZ_DYNALLOC = 2,
};

enum xz_ret {
	XZ_OK = 0,
	XZ_STREAM_END = 1,
	XZ_UNSUPPORTED_CHECK = 2,
	XZ_MEM_ERROR = 3,
	XZ_MEMLIMIT_ERROR = 4,
	XZ_FORMAT_ERROR = 5,
	XZ_OPTIONS_ERROR = 6,
	XZ_DATA_ERROR = 7,
	XZ_BUF_ERROR = 8,
};

struct xz_buf {
	const uint8_t *in;
	size_t in_pos;
	size_t in_size;
	uint8_t *out;
	size_t out_pos;
	size_t out_size;
};

typedef uint64_t vli_type;

enum xz_check {
	XZ_CHECK_NONE = 0,
	XZ_CHECK_CRC32 = 1,
	XZ_CHECK_CRC64 = 4,
	XZ_CHECK_SHA256 = 10,
};

struct xz_dec_hash {
	vli_type unpadded;
	vli_type uncompressed;
	uint32_t crc32;
};

struct xz_dec_lzma2;

struct xz_dec_bcj;

struct xz_dec {
	enum {
		SEQ_STREAM_HEADER = 0,
		SEQ_BLOCK_START = 1,
		SEQ_BLOCK_HEADER = 2,
		SEQ_BLOCK_UNCOMPRESS = 3,
		SEQ_BLOCK_PADDING = 4,
		SEQ_BLOCK_CHECK = 5,
		SEQ_INDEX = 6,
		SEQ_INDEX_PADDING = 7,
		SEQ_INDEX_CRC32 = 8,
		SEQ_STREAM_FOOTER = 9,
	} sequence;
	uint32_t pos;
	vli_type vli;
	size_t in_start;
	size_t out_start;
	uint32_t crc32;
	enum xz_check check_type;
	enum xz_mode mode;
	bool allow_buf_error;
	struct {
		vli_type compressed;
		vli_type uncompressed;
		uint32_t size;
	} block_header;
	struct {
		vli_type compressed;
		vli_type uncompressed;
		vli_type count;
		struct xz_dec_hash hash;
	} block;
	struct {
		enum {
			SEQ_INDEX_COUNT = 0,
			SEQ_INDEX_UNPADDED = 1,
			SEQ_INDEX_UNCOMPRESSED = 2,
		} sequence;
		vli_type size;
		vli_type count;
		struct xz_dec_hash hash;
	} index;
	struct {
		size_t pos;
		size_t size;
		uint8_t buf[1024];
	} temp;
	struct xz_dec_lzma2 *lzma2;
	struct xz_dec_bcj *bcj;
	bool bcj_active;
};

enum lzma_state {
	STATE_LIT_LIT = 0,
	STATE_MATCH_LIT_LIT = 1,
	STATE_REP_LIT_LIT = 2,
	STATE_SHORTREP_LIT_LIT = 3,
	STATE_MATCH_LIT = 4,
	STATE_REP_LIT = 5,
	STATE_SHORTREP_LIT = 6,
	STATE_LIT_MATCH = 7,
	STATE_LIT_LONGREP = 8,
	STATE_LIT_SHORTREP = 9,
	STATE_NONLIT_MATCH = 10,
	STATE_NONLIT_REP = 11,
};

struct dictionary {
	uint8_t *buf;
	size_t start;
	size_t pos;
	size_t full;
	size_t limit;
	size_t end;
	uint32_t size;
	uint32_t size_max;
	uint32_t allocated;
	enum xz_mode mode;
};

struct rc_dec {
	uint32_t range;
	uint32_t code;
	uint32_t init_bytes_left;
	const uint8_t *in;
	size_t in_pos;
	size_t in_limit;
};

struct lzma_len_dec {
	uint16_t choice;
	uint16_t choice2;
	uint16_t low[128];
	uint16_t mid[128];
	uint16_t high[256];
};

struct lzma_dec {
	uint32_t rep0;
	uint32_t rep1;
	uint32_t rep2;
	uint32_t rep3;
	enum lzma_state state;
	uint32_t len;
	uint32_t lc;
	uint32_t literal_pos_mask;
	uint32_t pos_mask;
	uint16_t is_match[192];
	uint16_t is_rep[12];
	uint16_t is_rep0[12];
	uint16_t is_rep1[12];
	uint16_t is_rep2[12];
	uint16_t is_rep0_long[192];
	uint16_t dist_slot[256];
	uint16_t dist_special[114];
	uint16_t dist_align[16];
	struct lzma_len_dec match_len_dec;
	struct lzma_len_dec rep_len_dec;
	uint16_t literal[12288];
};

enum lzma2_seq {
	SEQ_CONTROL = 0,
	SEQ_UNCOMPRESSED_1 = 1,
	SEQ_UNCOMPRESSED_2 = 2,
	SEQ_COMPRESSED_0 = 3,
	SEQ_COMPRESSED_1 = 4,
	SEQ_PROPERTIES = 5,
	SEQ_LZMA_PREPARE = 6,
	SEQ_LZMA_RUN = 7,
	SEQ_COPY = 8,
};

struct lzma2_dec {
	enum lzma2_seq sequence;
	enum lzma2_seq next_sequence;
	uint32_t uncompressed;
	uint32_t compressed;
	bool need_dict_reset;
	bool need_props;
};

struct xz_dec_lzma2 {
	struct rc_dec rc;
	struct dictionary dict;
	struct lzma2_dec lzma2;
	struct lzma_dec lzma;
	struct {
		uint32_t size;
		uint8_t buf[63];
	} temp;
};

struct xz_dec_bcj {
	enum {
		BCJ_X86 = 4,
		BCJ_POWERPC = 5,
		BCJ_IA64 = 6,
		BCJ_ARM = 7,
		BCJ_ARMTHUMB = 8,
		BCJ_SPARC = 9,
	} type;
	enum xz_ret ret;
	bool single_call;
	uint32_t pos;
	uint32_t x86_prev_mask;
	uint8_t *out;
	size_t out_pos;
	size_t out_size;
	struct {
		size_t filtered;
		size_t size;
		uint8_t buf[16];
	} temp;
};

struct ei_entry {
	struct list_head list;
	long unsigned int start_addr;
	long unsigned int end_addr;
	int etype;
	void *priv;
};

enum ib_uverbs_write_cmds {
	IB_USER_VERBS_CMD_GET_CONTEXT = 0,
	IB_USER_VERBS_CMD_QUERY_DEVICE = 1,
	IB_USER_VERBS_CMD_QUERY_PORT = 2,
	IB_USER_VERBS_CMD_ALLOC_PD = 3,
	IB_USER_VERBS_CMD_DEALLOC_PD = 4,
	IB_USER_VERBS_CMD_CREATE_AH = 5,
	IB_USER_VERBS_CMD_MODIFY_AH = 6,
	IB_USER_VERBS_CMD_QUERY_AH = 7,
	IB_USER_VERBS_CMD_DESTROY_AH = 8,
	IB_USER_VERBS_CMD_REG_MR = 9,
	IB_USER_VERBS_CMD_REG_SMR = 10,
	IB_USER_VERBS_CMD_REREG_MR = 11,
	IB_USER_VERBS_CMD_QUERY_MR = 12,
	IB_USER_VERBS_CMD_DEREG_MR = 13,
	IB_USER_VERBS_CMD_ALLOC_MW = 14,
	IB_USER_VERBS_CMD_BIND_MW = 15,
	IB_USER_VERBS_CMD_DEALLOC_MW = 16,
	IB_USER_VERBS_CMD_CREATE_COMP_CHANNEL = 17,
	IB_USER_VERBS_CMD_CREATE_CQ = 18,
	IB_USER_VERBS_CMD_RESIZE_CQ = 19,
	IB_USER_VERBS_CMD_DESTROY_CQ = 20,
	IB_USER_VERBS_CMD_POLL_CQ = 21,
	IB_USER_VERBS_CMD_PEEK_CQ = 22,
	IB_USER_VERBS_CMD_REQ_NOTIFY_CQ = 23,
	IB_USER_VERBS_CMD_CREATE_QP = 24,
	IB_USER_VERBS_CMD_QUERY_QP = 25,
	IB_USER_VERBS_CMD_MODIFY_QP = 26,
	IB_USER_VERBS_CMD_DESTROY_QP = 27,
	IB_USER_VERBS_CMD_POST_SEND = 28,
	IB_USER_VERBS_CMD_POST_RECV = 29,
	IB_USER_VERBS_CMD_ATTACH_MCAST = 30,
	IB_USER_VERBS_CMD_DETACH_MCAST = 31,
	IB_USER_VERBS_CMD_CREATE_SRQ = 32,
	IB_USER_VERBS_CMD_MODIFY_SRQ = 33,
	IB_USER_VERBS_CMD_QUERY_SRQ = 34,
	IB_USER_VERBS_CMD_DESTROY_SRQ = 35,
	IB_USER_VERBS_CMD_POST_SRQ_RECV = 36,
	IB_USER_VERBS_CMD_OPEN_XRCD = 37,
	IB_USER_VERBS_CMD_CLOSE_XRCD = 38,
	IB_USER_VERBS_CMD_CREATE_XSRQ = 39,
	IB_USER_VERBS_CMD_OPEN_QP = 40,
};

enum ib_uverbs_wc_opcode {
	IB_UVERBS_WC_SEND = 0,
	IB_UVERBS_WC_RDMA_WRITE = 1,
	IB_UVERBS_WC_RDMA_READ = 2,
	IB_UVERBS_WC_COMP_SWAP = 3,
	IB_UVERBS_WC_FETCH_ADD = 4,
	IB_UVERBS_WC_BIND_MW = 5,
	IB_UVERBS_WC_LOCAL_INV = 6,
	IB_UVERBS_WC_TSO = 7,
};

enum ib_uverbs_create_qp_mask {
	IB_UVERBS_CREATE_QP_MASK_IND_TABLE = 1,
};

enum ib_uverbs_wr_opcode {
	IB_UVERBS_WR_RDMA_WRITE = 0,
	IB_UVERBS_WR_RDMA_WRITE_WITH_IMM = 1,
	IB_UVERBS_WR_SEND = 2,
	IB_UVERBS_WR_SEND_WITH_IMM = 3,
	IB_UVERBS_WR_RDMA_READ = 4,
	IB_UVERBS_WR_ATOMIC_CMP_AND_SWP = 5,
	IB_UVERBS_WR_ATOMIC_FETCH_AND_ADD = 6,
	IB_UVERBS_WR_LOCAL_INV = 7,
	IB_UVERBS_WR_BIND_MW = 8,
	IB_UVERBS_WR_SEND_WITH_INV = 9,
	IB_UVERBS_WR_TSO = 10,
	IB_UVERBS_WR_RDMA_READ_WITH_INV = 11,
	IB_UVERBS_WR_MASKED_ATOMIC_CMP_AND_SWP = 12,
	IB_UVERBS_WR_MASKED_ATOMIC_FETCH_AND_ADD = 13,
};

enum ib_uverbs_access_flags {
	IB_UVERBS_ACCESS_LOCAL_WRITE = 1,
	IB_UVERBS_ACCESS_REMOTE_WRITE = 2,
	IB_UVERBS_ACCESS_REMOTE_READ = 4,
	IB_UVERBS_ACCESS_REMOTE_ATOMIC = 8,
	IB_UVERBS_ACCESS_MW_BIND = 16,
	IB_UVERBS_ACCESS_ZERO_BASED = 32,
	IB_UVERBS_ACCESS_ON_DEMAND = 64,
	IB_UVERBS_ACCESS_HUGETLB = 128,
	IB_UVERBS_ACCESS_RELAXED_ORDERING = 1048576,
	IB_UVERBS_ACCESS_OPTIONAL_RANGE = 1072693248,
};

enum ib_uverbs_srq_type {
	IB_UVERBS_SRQT_BASIC = 0,
	IB_UVERBS_SRQT_XRC = 1,
	IB_UVERBS_SRQT_TM = 2,
};

enum ib_uverbs_wq_type {
	IB_UVERBS_WQT_RQ = 0,
};

enum ib_uverbs_wq_flags {
	IB_UVERBS_WQ_FLAGS_CVLAN_STRIPPING = 1,
	IB_UVERBS_WQ_FLAGS_SCATTER_FCS = 2,
	IB_UVERBS_WQ_FLAGS_DELAY_DROP = 4,
	IB_UVERBS_WQ_FLAGS_PCI_WRITE_END_PADDING = 8,
};

enum ib_uverbs_qp_type {
	IB_UVERBS_QPT_RC = 2,
	IB_UVERBS_QPT_UC = 3,
	IB_UVERBS_QPT_UD = 4,
	IB_UVERBS_QPT_RAW_PACKET = 8,
	IB_UVERBS_QPT_XRC_INI = 9,
	IB_UVERBS_QPT_XRC_TGT = 10,
	IB_UVERBS_QPT_DRIVER = 255,
};

enum ib_uverbs_qp_create_flags {
	IB_UVERBS_QP_CREATE_BLOCK_MULTICAST_LOOPBACK = 2,
	IB_UVERBS_QP_CREATE_SCATTER_FCS = 256,
	IB_UVERBS_QP_CREATE_CVLAN_STRIPPING = 512,
	IB_UVERBS_QP_CREATE_PCI_WRITE_END_PADDING = 2048,
	IB_UVERBS_QP_CREATE_SQ_SIG_ALL = 4096,
};

enum ib_uverbs_gid_type {
	IB_UVERBS_GID_TYPE_IB = 0,
	IB_UVERBS_GID_TYPE_ROCE_V1 = 1,
	IB_UVERBS_GID_TYPE_ROCE_V2 = 2,
};

enum ib_poll_context {
	IB_POLL_SOFTIRQ = 0,
	IB_POLL_WORKQUEUE = 1,
	IB_POLL_UNBOUND_WORKQUEUE = 2,
	IB_POLL_LAST_POOL_TYPE = 2,
	IB_POLL_DIRECT = 3,
};

struct ddebug_table {
	struct list_head link;
	const char *mod_name;
	unsigned int num_ddebugs;
	struct _ddebug *ddebugs;
};

struct ddebug_query {
	const char *filename;
	const char *module;
	const char *function;
	const char *format;
	unsigned int first_lineno;
	unsigned int last_lineno;
};

struct ddebug_iter {
	struct ddebug_table *table;
	unsigned int idx;
};

struct flag_settings {
	unsigned int flags;
	unsigned int mask;
};

struct flagsbuf {
	char buf[7];
};

struct nla_bitfield32 {
	__u32 value;
	__u32 selector;
};

enum {
	NLA_UNSPEC = 0,
	NLA_U8 = 1,
	NLA_U16 = 2,
	NLA_U32 = 3,
	NLA_U64 = 4,
	NLA_STRING = 5,
	NLA_FLAG = 6,
	NLA_MSECS = 7,
	NLA_NESTED = 8,
	NLA_NESTED_ARRAY = 9,
	NLA_NUL_STRING = 10,
	NLA_BINARY = 11,
	NLA_S8 = 12,
	NLA_S16 = 13,
	NLA_S32 = 14,
	NLA_S64 = 15,
	NLA_BITFIELD32 = 16,
	NLA_REJECT = 17,
	__NLA_TYPE_MAX = 18,
};

enum nla_policy_validation {
	NLA_VALIDATE_NONE = 0,
	NLA_VALIDATE_RANGE = 1,
	NLA_VALIDATE_RANGE_WARN_TOO_LONG = 2,
	NLA_VALIDATE_MIN = 3,
	NLA_VALIDATE_MAX = 4,
	NLA_VALIDATE_MASK = 5,
	NLA_VALIDATE_RANGE_PTR = 6,
	NLA_VALIDATE_FUNCTION = 7,
};

enum netlink_validation {
	NL_VALIDATE_LIBERAL = 0,
	NL_VALIDATE_TRAILING = 1,
	NL_VALIDATE_MAXTYPE = 2,
	NL_VALIDATE_UNSPEC = 4,
	NL_VALIDATE_STRICT_ATTRS = 8,
	NL_VALIDATE_NESTED = 16,
};

typedef __u16 __sum16;

struct cpu_rmap {
	struct kref refcount;
	u16 size;
	u16 used;
	void **obj;
	struct {
		u16 index;
		u16 dist;
	} near[0];
};

struct irq_glue {
	struct irq_affinity_notify notify;
	struct cpu_rmap *rmap;
	u16 index;
};

typedef mpi_limb_t *mpi_ptr_t;

typedef int mpi_size_t;

typedef mpi_limb_t UWtype;

typedef unsigned int UHWtype;

enum gcry_mpi_constants {
	MPI_C_ZERO = 0,
	MPI_C_ONE = 1,
	MPI_C_TWO = 2,
	MPI_C_THREE = 3,
	MPI_C_FOUR = 4,
	MPI_C_EIGHT = 5,
};

struct barrett_ctx_s;

typedef struct barrett_ctx_s *mpi_barrett_t;

struct gcry_mpi_point {
	MPI x;
	MPI y;
	MPI z;
};

typedef struct gcry_mpi_point *MPI_POINT;

enum gcry_mpi_ec_models {
	MPI_EC_WEIERSTRASS = 0,
	MPI_EC_MONTGOMERY = 1,
	MPI_EC_EDWARDS = 2,
};

enum ecc_dialects {
	ECC_DIALECT_STANDARD = 0,
	ECC_DIALECT_ED25519 = 1,
	ECC_DIALECT_SAFECURVE = 2,
};

struct mpi_ec_ctx {
	enum gcry_mpi_ec_models model;
	enum ecc_dialects dialect;
	int flags;
	unsigned int nbits;
	MPI p;
	MPI a;
	MPI b;
	MPI_POINT G;
	MPI n;
	unsigned int h;
	MPI_POINT Q;
	MPI d;
	const char *name;
	struct {
		struct {
			unsigned int a_is_pminus3: 1;
			unsigned int two_inv_p: 1;
		} valid;
		int a_is_pminus3;
		MPI two_inv_p;
		mpi_barrett_t p_barrett;
		MPI scratch[11];
	} t;
	void (*addm)(MPI, MPI, MPI, struct mpi_ec_ctx *);
	void (*subm)(MPI, MPI, MPI, struct mpi_ec_ctx *);
	void (*mulm)(MPI, MPI, MPI, struct mpi_ec_ctx *);
	void (*pow2)(MPI, const MPI, struct mpi_ec_ctx *);
	void (*mul2)(MPI, MPI, struct mpi_ec_ctx *);
};

struct field_table {
	const char *p;
	void (*addm)(MPI, MPI, MPI, struct mpi_ec_ctx *);
	void (*subm)(MPI, MPI, MPI, struct mpi_ec_ctx *);
	void (*mulm)(MPI, MPI, MPI, struct mpi_ec_ctx *);
	void (*mul2)(MPI, MPI, struct mpi_ec_ctx *);
	void (*pow2)(MPI, const MPI, struct mpi_ec_ctx *);
};

enum gcry_mpi_format {
	GCRYMPI_FMT_NONE = 0,
	GCRYMPI_FMT_STD = 1,
	GCRYMPI_FMT_PGP = 2,
	GCRYMPI_FMT_SSH = 3,
	GCRYMPI_FMT_HEX = 4,
	GCRYMPI_FMT_USG = 5,
	GCRYMPI_FMT_OPAQUE = 8,
};

struct barrett_ctx_s;

typedef struct barrett_ctx_s *mpi_barrett_t___2;

struct barrett_ctx_s {
	MPI m;
	int m_copied;
	int k;
	MPI y;
	MPI r1;
	MPI r2;
	MPI r3;
};

struct karatsuba_ctx {
	struct karatsuba_ctx *next;
	mpi_ptr_t tspace;
	mpi_size_t tspace_size;
	mpi_ptr_t tp;
	mpi_size_t tp_size;
};

typedef long int mpi_limb_signed_t;

struct word_at_a_time {
	const long unsigned int one_bits;
	const long unsigned int high_bits;
};

struct sg_pool {
	size_t size;
	char *name;
	struct kmem_cache *slab;
	mempool_t *pool;
};

struct font_desc {
	int idx;
	const char *name;
	int width;
	int height;
	const void *data;
	int pref;
};

struct font_data {
	unsigned int extra[4];
	const unsigned char data[0];
};

typedef u16 ucs2_char_t;

struct compress_format {
	unsigned char magic[2];
	const char *name;
	decompress_fn decompressor;
};

struct group_data {
	int limit[21];
	int base[20];
	int permute[258];
	int minLen;
	int maxLen;
};

struct bunzip_data {
	int writeCopies;
	int writePos;
	int writeRunCountdown;
	int writeCount;
	int writeCurrent;
	long int (*fill)(void *, long unsigned int);
	long int inbufCount;
	long int inbufPos;
	unsigned char *inbuf;
	unsigned int inbufBitCount;
	unsigned int inbufBits;
	unsigned int crc32Table[256];
	unsigned int headerCRC;
	unsigned int totalCRC;
	unsigned int writeCRC;
	unsigned int *dbuf;
	unsigned int dbufSize;
	unsigned char selectors[32768];
	struct group_data groups[6];
	int io_error;
	int byteCount[256];
	unsigned char symToByte[256];
	unsigned char mtfSymbol[256];
};

struct rc {
	long int (*fill)(void *, long unsigned int);
	uint8_t *ptr;
	uint8_t *buffer;
	uint8_t *buffer_end;
	long int buffer_size;
	uint32_t code;
	uint32_t range;
	uint32_t bound;
	void (*error)(char *);
};

struct lzma_header {
	uint8_t pos;
	uint32_t dict_size;
	uint64_t dst_size;
} __attribute__((packed));

struct writer {
	uint8_t *buffer;
	uint8_t previous_byte;
	size_t buffer_pos;
	int bufsize;
	size_t global_pos;
	long int (*flush)(void *, long unsigned int);
	struct lzma_header *header;
};

struct cstate {
	int state;
	uint32_t rep0;
	uint32_t rep1;
	uint32_t rep2;
	uint32_t rep3;
};

struct xz_dec;

typedef enum {
	ZSTD_error_no_error = 0,
	ZSTD_error_GENERIC = 1,
	ZSTD_error_prefix_unknown = 2,
	ZSTD_error_version_unsupported = 3,
	ZSTD_error_parameter_unknown = 4,
	ZSTD_error_frameParameter_unsupported = 5,
	ZSTD_error_frameParameter_unsupportedBy32bits = 6,
	ZSTD_error_frameParameter_windowTooLarge = 7,
	ZSTD_error_compressionParameter_unsupported = 8,
	ZSTD_error_init_missing = 9,
	ZSTD_error_memory_allocation = 10,
	ZSTD_error_stage_wrong = 11,
	ZSTD_error_dstSize_tooSmall = 12,
	ZSTD_error_srcSize_wrong = 13,
	ZSTD_error_corruption_detected = 14,
	ZSTD_error_checksum_wrong = 15,
	ZSTD_error_tableLog_tooLarge = 16,
	ZSTD_error_maxSymbolValue_tooLarge = 17,
	ZSTD_error_maxSymbolValue_tooSmall = 18,
	ZSTD_error_dictionary_corrupted = 19,
	ZSTD_error_dictionary_wrong = 20,
	ZSTD_error_dictionaryCreation_failed = 21,
	ZSTD_error_maxCode = 22,
} ZSTD_ErrorCode;

struct ZSTD_DStream_s;

typedef struct ZSTD_DStream_s ZSTD_DStream___2;

struct cpio_data {
	void *data;
	size_t size;
	char name[18];
};

enum cpio_fields {
	C_MAGIC = 0,
	C_INO = 1,
	C_MODE = 2,
	C_UID = 3,
	C_GID = 4,
	C_NLINK = 5,
	C_MTIME = 6,
	C_FILESIZE = 7,
	C_MAJ = 8,
	C_MIN = 9,
	C_RMAJ = 10,
	C_RMIN = 11,
	C_NAMESIZE = 12,
	C_CHKSUM = 13,
	C_NFIELDS = 14,
};

enum {
	ASSUME_PERFECT = 255,
	ASSUME_VALID_DTB = 1,
	ASSUME_VALID_INPUT = 2,
	ASSUME_LATEST = 4,
	ASSUME_NO_ROLLBACK = 8,
	ASSUME_LIBFDT_ORDER = 16,
	ASSUME_LIBFDT_FLAWLESS = 32,
};

typedef __be64 fdt64_t;

struct fdt_reserve_entry {
	fdt64_t address;
	fdt64_t size;
};

struct fdt_node_header {
	fdt32_t tag;
	char name[0];
};

struct fdt_property {
	fdt32_t tag;
	fdt32_t len;
	fdt32_t nameoff;
	char data[0];
};

struct fdt_errtabent {
	const char *str;
};

struct fprop_local_single {
	long unsigned int events;
	unsigned int period;
	raw_spinlock_t lock;
};

struct radix_tree_iter {
	long unsigned int index;
	long unsigned int next_index;
	long unsigned int tags;
	struct xa_node *node;
};

enum {
	RADIX_TREE_ITER_TAG_MASK = 15,
	RADIX_TREE_ITER_TAGGED = 16,
	RADIX_TREE_ITER_CONTIG = 32,
};

struct ida_bitmap {
	long unsigned int bitmap[16];
};

struct klist_waiter {
	struct list_head list;
	struct klist_node *node;
	struct task_struct *process;
	int woken;
};

struct scm_creds {
	u32 pid;
	kuid_t uid;
	kgid_t gid;
};

struct netlink_skb_parms {
	struct scm_creds creds;
	__u32 portid;
	__u32 dst_group;
	__u32 flags;
	struct sock *sk;
	bool nsid_is_set;
	int nsid;
};

struct netlink_kernel_cfg {
	unsigned int groups;
	unsigned int flags;
	void (*input)(struct sk_buff *);
	struct mutex *cb_mutex;
	int (*bind)(struct net *, int);
	void (*unbind)(struct net *, int);
	bool (*compare)(struct net *, struct sock *);
};

struct uevent_sock {
	struct list_head list;
	struct sock *sk;
};

enum {
	LOGIC_PIO_INDIRECT = 0,
	LOGIC_PIO_CPU_MMIO = 1,
};

struct logic_pio_host_ops;

struct logic_pio_hwaddr {
	struct list_head list;
	struct fwnode_handle *fwnode;
	resource_size_t hw_start;
	resource_size_t io_start;
	resource_size_t size;
	long unsigned int flags;
	void *hostdata;
	const struct logic_pio_host_ops *ops;
};

struct logic_pio_host_ops {
	u32 (*in)(void *, long unsigned int, size_t);
	void (*out)(void *, long unsigned int, u32, size_t);
	u32 (*ins)(void *, long unsigned int, void *, size_t, unsigned int);
	void (*outs)(void *, long unsigned int, const void *, size_t, unsigned int);
};

typedef struct {
	long unsigned int key[2];
} hsiphash_key_t;

enum format_type {
	FORMAT_TYPE_NONE = 0,
	FORMAT_TYPE_WIDTH = 1,
	FORMAT_TYPE_PRECISION = 2,
	FORMAT_TYPE_CHAR = 3,
	FORMAT_TYPE_STR = 4,
	FORMAT_TYPE_PTR = 5,
	FORMAT_TYPE_PERCENT_CHAR = 6,
	FORMAT_TYPE_INVALID = 7,
	FORMAT_TYPE_LONG_LONG = 8,
	FORMAT_TYPE_ULONG = 9,
	FORMAT_TYPE_LONG = 10,
	FORMAT_TYPE_UBYTE = 11,
	FORMAT_TYPE_BYTE = 12,
	FORMAT_TYPE_USHORT = 13,
	FORMAT_TYPE_SHORT = 14,
	FORMAT_TYPE_UINT = 15,
	FORMAT_TYPE_INT = 16,
	FORMAT_TYPE_SIZE_T = 17,
	FORMAT_TYPE_PTRDIFF = 18,
};

struct printf_spec {
	unsigned int type: 8;
	int field_width: 24;
	unsigned int flags: 8;
	unsigned int base: 8;
	int precision: 16;
};

struct minmax_sample {
	u32 t;
	u32 v;
};

struct minmax {
	struct minmax_sample s[3];
};

typedef int (*of_irq_init_cb_t)(struct device_node *, struct device_node *);

typedef int (*of_init_fn_2)(struct device_node *, struct device_node *);

struct plic_priv {
	struct cpumask lmask;
	struct irq_domain *irqdomain;
	void *regs;
	unsigned int nr_irqs;
};

struct plic_handler {
	bool present;
	void *hart_base;
	raw_spinlock_t enable_lock;
	void *enable_base;
	struct plic_priv *priv;
};

enum device_link_state {
	DL_STATE_NONE = 4294967295,
	DL_STATE_DORMANT = 0,
	DL_STATE_AVAILABLE = 1,
	DL_STATE_CONSUMER_PROBE = 2,
	DL_STATE_ACTIVE = 3,
	DL_STATE_SUPPLIER_UNBIND = 4,
};

struct device_link {
	struct device *supplier;
	struct list_head s_node;
	struct device *consumer;
	struct list_head c_node;
	struct device link_dev;
	enum device_link_state status;
	u32 flags;
	refcount_t rpm_active;
	struct kref kref;
	struct callback_head callback_head;
	struct work_struct rm_work;
	bool supplier_preactivated;
};

struct phy_configure_opts_dp {
	unsigned int link_rate;
	unsigned int lanes;
	unsigned int voltage[4];
	unsigned int pre[4];
	u8 ssc: 1;
	u8 set_rate: 1;
	u8 set_lanes: 1;
	u8 set_voltages: 1;
};

struct phy_configure_opts_mipi_dphy {
	unsigned int clk_miss;
	unsigned int clk_post;
	unsigned int clk_pre;
	unsigned int clk_prepare;
	unsigned int clk_settle;
	unsigned int clk_term_en;
	unsigned int clk_trail;
	unsigned int clk_zero;
	unsigned int d_term_en;
	unsigned int eot;
	unsigned int hs_exit;
	unsigned int hs_prepare;
	unsigned int hs_settle;
	unsigned int hs_skip;
	unsigned int hs_trail;
	unsigned int hs_zero;
	unsigned int init;
	unsigned int lpx;
	unsigned int ta_get;
	unsigned int ta_go;
	unsigned int ta_sure;
	unsigned int wakeup;
	long unsigned int hs_clk_rate;
	long unsigned int lp_clk_rate;
	unsigned char lanes;
};

enum phy_mode {
	PHY_MODE_INVALID = 0,
	PHY_MODE_USB_HOST = 1,
	PHY_MODE_USB_HOST_LS = 2,
	PHY_MODE_USB_HOST_FS = 3,
	PHY_MODE_USB_HOST_HS = 4,
	PHY_MODE_USB_HOST_SS = 5,
	PHY_MODE_USB_DEVICE = 6,
	PHY_MODE_USB_DEVICE_LS = 7,
	PHY_MODE_USB_DEVICE_FS = 8,
	PHY_MODE_USB_DEVICE_HS = 9,
	PHY_MODE_USB_DEVICE_SS = 10,
	PHY_MODE_USB_OTG = 11,
	PHY_MODE_UFS_HS_A = 12,
	PHY_MODE_UFS_HS_B = 13,
	PHY_MODE_PCIE = 14,
	PHY_MODE_ETHERNET = 15,
	PHY_MODE_MIPI_DPHY = 16,
	PHY_MODE_SATA = 17,
	PHY_MODE_LVDS = 18,
	PHY_MODE_DP = 19,
};

union phy_configure_opts {
	struct phy_configure_opts_mipi_dphy mipi_dphy;
	struct phy_configure_opts_dp dp;
};

struct phy;

struct phy_ops {
	int (*init)(struct phy *);
	int (*exit)(struct phy *);
	int (*power_on)(struct phy *);
	int (*power_off)(struct phy *);
	int (*set_mode)(struct phy *, enum phy_mode, int);
	int (*configure)(struct phy *, union phy_configure_opts *);
	int (*validate)(struct phy *, enum phy_mode, int, union phy_configure_opts *);
	int (*reset)(struct phy *);
	int (*calibrate)(struct phy *);
	void (*release)(struct phy *);
	struct module *owner;
};

struct phy_attrs {
	u32 bus_width;
	u32 max_link_rate;
	enum phy_mode mode;
};

struct regulator;

struct phy {
	struct device dev;
	int id;
	const struct phy_ops *ops;
	struct mutex mutex;
	int init_count;
	int power_count;
	struct phy_attrs attrs;
	struct regulator *pwr;
};

struct phy_provider {
	struct device *dev;
	struct device_node *children;
	struct module *owner;
	struct list_head list;
	struct phy * (*of_xlate)(struct device *, struct of_phandle_args *);
};

struct phy_lookup {
	struct list_head node;
	const char *dev_id;
	const char *con_id;
	struct phy *phy;
};

enum regcache_type {
	REGCACHE_NONE = 0,
	REGCACHE_RBTREE = 1,
	REGCACHE_COMPRESSED = 2,
	REGCACHE_FLAT = 3,
};

struct reg_default {
	unsigned int reg;
	unsigned int def;
};

enum regmap_endian {
	REGMAP_ENDIAN_DEFAULT = 0,
	REGMAP_ENDIAN_BIG = 1,
	REGMAP_ENDIAN_LITTLE = 2,
	REGMAP_ENDIAN_NATIVE = 3,
};

struct regmap_range {
	unsigned int range_min;
	unsigned int range_max;
};

struct regmap_access_table {
	const struct regmap_range *yes_ranges;
	unsigned int n_yes_ranges;
	const struct regmap_range *no_ranges;
	unsigned int n_no_ranges;
};

typedef void (*regmap_lock)(void *);

typedef void (*regmap_unlock)(void *);

struct regmap_range_cfg;

struct regmap_config {
	const char *name;
	int reg_bits;
	int reg_stride;
	int pad_bits;
	int val_bits;
	bool (*writeable_reg)(struct device *, unsigned int);
	bool (*readable_reg)(struct device *, unsigned int);
	bool (*volatile_reg)(struct device *, unsigned int);
	bool (*precious_reg)(struct device *, unsigned int);
	bool (*writeable_noinc_reg)(struct device *, unsigned int);
	bool (*readable_noinc_reg)(struct device *, unsigned int);
	bool disable_locking;
	regmap_lock lock;
	regmap_unlock unlock;
	void *lock_arg;
	int (*reg_read)(void *, unsigned int, unsigned int *);
	int (*reg_write)(void *, unsigned int, unsigned int);
	bool fast_io;
	unsigned int max_register;
	const struct regmap_access_table *wr_table;
	const struct regmap_access_table *rd_table;
	const struct regmap_access_table *volatile_table;
	const struct regmap_access_table *precious_table;
	const struct regmap_access_table *wr_noinc_table;
	const struct regmap_access_table *rd_noinc_table;
	const struct reg_default *reg_defaults;
	unsigned int num_reg_defaults;
	enum regcache_type cache_type;
	const void *reg_defaults_raw;
	unsigned int num_reg_defaults_raw;
	long unsigned int read_flag_mask;
	long unsigned int write_flag_mask;
	bool zero_flag_mask;
	bool use_single_read;
	bool use_single_write;
	bool can_multi_write;
	enum regmap_endian reg_format_endian;
	enum regmap_endian val_format_endian;
	const struct regmap_range_cfg *ranges;
	unsigned int num_ranges;
	bool use_hwlock;
	unsigned int hwlock_id;
	unsigned int hwlock_mode;
	bool can_sleep;
};

struct regmap_range_cfg {
	const char *name;
	unsigned int range_min;
	unsigned int range_max;
	unsigned int selector_reg;
	unsigned int selector_mask;
	int selector_shift;
	unsigned int window_start;
	unsigned int window_len;
};

struct dw_pll_range {
	u32 data_rate;
	u8 hsfreqrange;
	u8 vco_range;
	u16 clk_lp2hs;
	u16 clk_hs2lp;
	u16 data_lp2hs;
	u16 data_hs2lp;
};

struct dw_dphy_cfg {
	long unsigned int hs_clk_rate;
	u8 hsfreqrange;
	u8 cfgclkfreqrange;
	u8 vco_range;
	u8 n_div;
	u8 m_div;
	u16 clk_lp2hs;
	u16 clk_hs2lp;
	u16 data_lp2hs;
	u16 data_hs2lp;
};

struct regmap;

struct dw_dphy {
	struct phy *phy;
	struct device *dev;
	struct dw_dphy_cfg cfg;
	struct regmap *regmap;
	struct regmap *vosys_regmap;
	struct clk *refclk;
	struct clk *cfgclk;
	struct clk *pclk;
	struct clk *prefclk;
	struct clk *pcfgclk;
};

struct pinctrl;

struct pinctrl_state;

struct dev_pin_info {
	struct pinctrl *p;
	struct pinctrl_state *default_state;
	struct pinctrl_state *init_state;
	struct pinctrl_state *sleep_state;
	struct pinctrl_state *idle_state;
};

struct pinctrl {
	struct list_head node;
	struct device *dev;
	struct list_head states;
	struct pinctrl_state *state;
	struct list_head dt_maps;
	struct kref users;
};

struct pinctrl_state {
	struct list_head node;
	const char *name;
	struct list_head settings;
};

struct pinctrl_pin_desc {
	unsigned int number;
	const char *name;
	void *drv_data;
};

struct gpio_chip;

struct pinctrl_gpio_range {
	struct list_head node;
	const char *name;
	unsigned int id;
	unsigned int base;
	unsigned int pin_base;
	const unsigned int *pins;
	unsigned int npins;
	struct gpio_chip *gc;
};

struct gpio_irq_chip {
	struct irq_chip *chip;
	struct irq_domain *domain;
	const struct irq_domain_ops *domain_ops;
	struct fwnode_handle *fwnode;
	struct irq_domain *parent_domain;
	int (*child_to_parent_hwirq)(struct gpio_chip *, unsigned int, unsigned int, unsigned int *, unsigned int *);
	void * (*populate_parent_alloc_arg)(struct gpio_chip *, unsigned int, unsigned int);
	unsigned int (*child_offset_to_irq)(struct gpio_chip *, unsigned int);
	struct irq_domain_ops child_irq_domain_ops;
	irq_flow_handler_t handler;
	unsigned int default_type;
	struct lock_class_key *lock_key;
	struct lock_class_key *request_key;
	irq_flow_handler_t parent_handler;
	void *parent_handler_data;
	unsigned int num_parents;
	unsigned int *parents;
	unsigned int *map;
	bool threaded;
	int (*init_hw)(struct gpio_chip *);
	void (*init_valid_mask)(struct gpio_chip *, long unsigned int *, unsigned int);
	long unsigned int *valid_mask;
	unsigned int first;
	void (*irq_enable)(struct irq_data *);
	void (*irq_disable)(struct irq_data *);
	void (*irq_unmask)(struct irq_data *);
	void (*irq_mask)(struct irq_data *);
	union {
		bool initialized;
		struct {
			u64 android_kabi_reserved1;
		};
		union {		};
	};
};

struct gpio_device;

struct gpio_chip {
	const char *label;
	struct gpio_device *gpiodev;
	struct device *parent;
	struct module *owner;
	int (*request)(struct gpio_chip *, unsigned int);
	void (*free)(struct gpio_chip *, unsigned int);
	int (*get_direction)(struct gpio_chip *, unsigned int);
	int (*direction_input)(struct gpio_chip *, unsigned int);
	int (*direction_output)(struct gpio_chip *, unsigned int, int);
	int (*get)(struct gpio_chip *, unsigned int);
	int (*get_multiple)(struct gpio_chip *, long unsigned int *, long unsigned int *);
	void (*set)(struct gpio_chip *, unsigned int, int);
	void (*set_multiple)(struct gpio_chip *, long unsigned int *, long unsigned int *);
	int (*set_config)(struct gpio_chip *, unsigned int, long unsigned int);
	int (*to_irq)(struct gpio_chip *, unsigned int);
	void (*dbg_show)(struct seq_file *, struct gpio_chip *);
	int (*init_valid_mask)(struct gpio_chip *, long unsigned int *, unsigned int);
	int (*add_pin_ranges)(struct gpio_chip *);
	int base;
	u16 ngpio;
	const char * const *names;
	bool can_sleep;
	long unsigned int (*read_reg)(void *);
	void (*write_reg)(void *, long unsigned int);
	bool be_bits;
	void *reg_dat;
	void *reg_set;
	void *reg_clr;
	void *reg_dir_out;
	void *reg_dir_in;
	bool bgpio_dir_unreadable;
	int bgpio_bits;
	spinlock_t bgpio_lock;
	long unsigned int bgpio_data;
	long unsigned int bgpio_dir;
	struct gpio_irq_chip irq;
	long unsigned int *valid_mask;
	struct device_node *of_node;
	unsigned int of_gpio_n_cells;
	int (*of_xlate)(struct gpio_chip *, const struct of_phandle_args *, u32 *);
};

struct pinctrl_dev;

struct pinctrl_map;

struct pinctrl_ops {
	int (*get_groups_count)(struct pinctrl_dev *);
	const char * (*get_group_name)(struct pinctrl_dev *, unsigned int);
	int (*get_group_pins)(struct pinctrl_dev *, unsigned int, const unsigned int **, unsigned int *);
	void (*pin_dbg_show)(struct pinctrl_dev *, struct seq_file *, unsigned int);
	int (*dt_node_to_map)(struct pinctrl_dev *, struct device_node *, struct pinctrl_map **, unsigned int *);
	void (*dt_free_map)(struct pinctrl_dev *, struct pinctrl_map *, unsigned int);
};

struct pinctrl_desc;

struct pinctrl_dev {
	struct list_head node;
	struct pinctrl_desc *desc;
	struct xarray pin_desc_tree;
	struct xarray pin_group_tree;
	unsigned int num_groups;
	struct xarray pin_function_tree;
	unsigned int num_functions;
	struct list_head gpio_ranges;
	struct device *dev;
	struct module *owner;
	void *driver_data;
	struct pinctrl *p;
	struct pinctrl_state *hog_default;
	struct pinctrl_state *hog_sleep;
	struct mutex mutex;
	struct dentry *device_root;
};

enum pinctrl_map_type {
	PIN_MAP_TYPE_INVALID = 0,
	PIN_MAP_TYPE_DUMMY_STATE = 1,
	PIN_MAP_TYPE_MUX_GROUP = 2,
	PIN_MAP_TYPE_CONFIGS_PIN = 3,
	PIN_MAP_TYPE_CONFIGS_GROUP = 4,
};

struct pinctrl_map_mux {
	const char *group;
	const char *function;
};

struct pinctrl_map_configs {
	const char *group_or_pin;
	long unsigned int *configs;
	unsigned int num_configs;
};

struct pinctrl_map {
	const char *dev_name;
	const char *name;
	enum pinctrl_map_type type;
	const char *ctrl_dev_name;
	union {
		struct pinctrl_map_mux mux;
		struct pinctrl_map_configs configs;
	} data;
};

struct pinmux_ops;

struct pinconf_ops;

struct pinconf_generic_params;

struct pin_config_item;

struct pinctrl_desc {
	const char *name;
	const struct pinctrl_pin_desc *pins;
	unsigned int npins;
	const struct pinctrl_ops *pctlops;
	const struct pinmux_ops *pmxops;
	const struct pinconf_ops *confops;
	struct module *owner;
	unsigned int num_custom_params;
	const struct pinconf_generic_params *custom_params;
	const struct pin_config_item *custom_conf_items;
	bool link_consumers;
};

struct pinmux_ops {
	int (*request)(struct pinctrl_dev *, unsigned int);
	int (*free)(struct pinctrl_dev *, unsigned int);
	int (*get_functions_count)(struct pinctrl_dev *);
	const char * (*get_function_name)(struct pinctrl_dev *, unsigned int);
	int (*get_function_groups)(struct pinctrl_dev *, unsigned int, const char * const **, unsigned int *);
	int (*set_mux)(struct pinctrl_dev *, unsigned int, unsigned int);
	int (*gpio_request_enable)(struct pinctrl_dev *, struct pinctrl_gpio_range *, unsigned int);
	void (*gpio_disable_free)(struct pinctrl_dev *, struct pinctrl_gpio_range *, unsigned int);
	int (*gpio_set_direction)(struct pinctrl_dev *, struct pinctrl_gpio_range *, unsigned int, bool);
	bool strict;
};

struct pinconf_ops {
	bool is_generic;
	int (*pin_config_get)(struct pinctrl_dev *, unsigned int, long unsigned int *);
	int (*pin_config_set)(struct pinctrl_dev *, unsigned int, long unsigned int *, unsigned int);
	int (*pin_config_group_get)(struct pinctrl_dev *, unsigned int, long unsigned int *);
	int (*pin_config_group_set)(struct pinctrl_dev *, unsigned int, long unsigned int *, unsigned int);
	void (*pin_config_dbg_show)(struct pinctrl_dev *, struct seq_file *, unsigned int);
	void (*pin_config_group_dbg_show)(struct pinctrl_dev *, struct seq_file *, unsigned int);
	void (*pin_config_config_dbg_show)(struct pinctrl_dev *, struct seq_file *, long unsigned int);
};

enum pin_config_param {
	PIN_CONFIG_BIAS_BUS_HOLD = 0,
	PIN_CONFIG_BIAS_DISABLE = 1,
	PIN_CONFIG_BIAS_HIGH_IMPEDANCE = 2,
	PIN_CONFIG_BIAS_PULL_DOWN = 3,
	PIN_CONFIG_BIAS_PULL_PIN_DEFAULT = 4,
	PIN_CONFIG_BIAS_PULL_UP = 5,
	PIN_CONFIG_DRIVE_OPEN_DRAIN = 6,
	PIN_CONFIG_DRIVE_OPEN_SOURCE = 7,
	PIN_CONFIG_DRIVE_PUSH_PULL = 8,
	PIN_CONFIG_DRIVE_STRENGTH = 9,
	PIN_CONFIG_DRIVE_STRENGTH_UA = 10,
	PIN_CONFIG_INPUT_DEBOUNCE = 11,
	PIN_CONFIG_INPUT_ENABLE = 12,
	PIN_CONFIG_INPUT_SCHMITT = 13,
	PIN_CONFIG_INPUT_SCHMITT_ENABLE = 14,
	PIN_CONFIG_LOW_POWER_MODE = 15,
	PIN_CONFIG_OUTPUT_ENABLE = 16,
	PIN_CONFIG_OUTPUT = 17,
	PIN_CONFIG_POWER_SOURCE = 18,
	PIN_CONFIG_SLEEP_HARDWARE_STATE = 19,
	PIN_CONFIG_SLEW_RATE = 20,
	PIN_CONFIG_SKEW_DELAY = 21,
	PIN_CONFIG_PERSIST_STATE = 22,
	PIN_CONFIG_END = 127,
	PIN_CONFIG_MAX = 255,
};

struct pinconf_generic_params {
	const char * const property;
	enum pin_config_param param;
	u32 default_value;
};

struct pin_config_item {
	const enum pin_config_param param;
	const char * const display;
	const char * const format;
	bool has_arg;
};

struct gpio_desc;

struct gpio_device {
	int id;
	struct device dev;
	struct cdev chrdev;
	struct device *mockdev;
	struct module *owner;
	struct gpio_chip *chip;
	struct gpio_desc *descs;
	int base;
	u16 ngpio;
	const char *label;
	void *data;
	struct list_head list;
	struct blocking_notifier_head notifier;
	struct list_head pin_ranges;
};

struct gpio_desc {
	struct gpio_device *gdev;
	long unsigned int flags;
	const char *label;
	const char *name;
	unsigned int debounce_period_us;
};

struct pinctrl_setting_mux {
	unsigned int group;
	unsigned int func;
};

struct pinctrl_setting_configs {
	unsigned int group_or_pin;
	long unsigned int *configs;
	unsigned int num_configs;
};

struct pinctrl_setting {
	struct list_head node;
	enum pinctrl_map_type type;
	struct pinctrl_dev *pctldev;
	const char *dev_name;
	union {
		struct pinctrl_setting_mux mux;
		struct pinctrl_setting_configs configs;
	} data;
};

struct pin_desc {
	struct pinctrl_dev *pctldev;
	const char *name;
	bool dynamic_name;
	void *drv_data;
	unsigned int mux_usecount;
	const char *mux_owner;
	const struct pinctrl_setting_mux *mux_setting;
	const char *gpio_owner;
};

struct pinctrl_maps {
	struct list_head node;
	const struct pinctrl_map *maps;
	unsigned int num_maps;
};

struct group_desc {
	const char *name;
	int *pins;
	int num_pins;
	void *data;
};

struct pctldev;

struct function_desc {
	const char *name;
	const char **group_names;
	int num_group_names;
	void *data;
};

struct pinctrl_dt_map {
	struct list_head node;
	struct pinctrl_dev *pctldev;
	struct pinctrl_map *map;
	unsigned int num_maps;
};

struct light_pin {
	unsigned int pin_id;
	unsigned int mux_mode;
	long unsigned int config;
};

struct light_pin_group {
	const char *name;
	unsigned int npins;
	unsigned int *pin_ids;
	struct light_pin *pins;
};

struct light_pmx_func {
	const char *name;
	const char **groups;
	unsigned int num_groups;
};

struct light_pinctrl_soc_info {
	struct device *dev;
	struct pinctrl_desc *desc;
	const struct pinctrl_pin_desc *pins;
	unsigned int npins;
	struct light_pin_group *groups;
	unsigned int ngroups;
	unsigned int grp_index;
	struct light_pmx_func *functions;
	unsigned int nfunctions;
	unsigned int cfg_off;
	unsigned int mux_off;
	int (*covert_pin_off)(const unsigned int);
};

struct light_pinctrl {
	struct device *dev;
	struct pinctrl_dev *pctl;
	void *base;
	const struct light_pinctrl_soc_info *info;
};

struct pinctrl_dev;

struct gpio_pin_range {
	struct list_head node;
	struct pinctrl_dev *pctldev;
	struct pinctrl_gpio_range range;
};

struct gpio_array;

struct gpio_descs {
	struct gpio_array *info;
	unsigned int ndescs;
	struct gpio_desc *desc[0];
};

struct gpio_array {
	struct gpio_desc **desc;
	unsigned int size;
	struct gpio_chip *chip;
	long unsigned int *get_mask;
	long unsigned int *set_mask;
	long unsigned int invert_mask[0];
};

enum gpiod_flags {
	GPIOD_ASIS = 0,
	GPIOD_IN = 1,
	GPIOD_OUT_LOW = 3,
	GPIOD_OUT_HIGH = 7,
	GPIOD_OUT_LOW_OPEN_DRAIN = 11,
	GPIOD_OUT_HIGH_OPEN_DRAIN = 15,
};

enum gpio_lookup_flags {
	GPIO_ACTIVE_HIGH = 0,
	GPIO_ACTIVE_LOW = 1,
	GPIO_OPEN_DRAIN = 2,
	GPIO_OPEN_SOURCE = 4,
	GPIO_PERSISTENT = 0,
	GPIO_TRANSITORY = 8,
	GPIO_PULL_UP = 16,
	GPIO_PULL_DOWN = 32,
	GPIO_LOOKUP_FLAGS_DEFAULT = 0,
};

struct gpiod_lookup {
	const char *key;
	u16 chip_hwnum;
	const char *con_id;
	unsigned int idx;
	long unsigned int flags;
};

struct gpiod_lookup_table {
	struct list_head list;
	const char *dev_id;
	struct gpiod_lookup table[0];
};

struct gpiod_hog {
	struct list_head list;
	const char *chip_label;
	u16 chip_hwnum;
	const char *line_name;
	long unsigned int lflags;
	int dflags;
};

enum {
	GPIOLINE_CHANGED_REQUESTED = 1,
	GPIOLINE_CHANGED_RELEASED = 2,
	GPIOLINE_CHANGED_CONFIG = 3,
};

struct acpi_device;

struct acpi_gpio_info {
	struct acpi_device *adev;
	enum gpiod_flags flags;
	bool gpioint;
	int pin_config;
	int polarity;
	int triggering;
	unsigned int quirks;
};

struct trace_event_raw_gpio_direction {
	struct trace_entry ent;
	unsigned int gpio;
	int in;
	int err;
	char __data[0];
};

struct trace_event_raw_gpio_value {
	struct trace_entry ent;
	unsigned int gpio;
	int get;
	int value;
	char __data[0];
};

struct trace_event_data_offsets_gpio_direction {};

struct trace_event_data_offsets_gpio_value {};

typedef void (*btf_trace_gpio_direction)(void *, unsigned int, int, int);

typedef void (*btf_trace_gpio_value)(void *, unsigned int, int, int);

struct devres;

struct gpio {
	unsigned int gpio;
	long unsigned int flags;
	const char *label;
};

enum of_gpio_flags {
	OF_GPIO_ACTIVE_LOW = 1,
	OF_GPIO_SINGLE_ENDED = 2,
	OF_GPIO_OPEN_DRAIN = 4,
	OF_GPIO_TRANSITORY = 8,
	OF_GPIO_PULL_UP = 16,
	OF_GPIO_PULL_DOWN = 32,
};

struct of_mm_gpio_chip {
	struct gpio_chip gc;
	void (*save_regs)(struct of_mm_gpio_chip *);
	void *regs;
};

struct gpiochip_info {
	char name[32];
	char label[32];
	__u32 lines;
};

enum gpio_v2_line_flag {
	GPIO_V2_LINE_FLAG_USED = 1,
	GPIO_V2_LINE_FLAG_ACTIVE_LOW = 2,
	GPIO_V2_LINE_FLAG_INPUT = 4,
	GPIO_V2_LINE_FLAG_OUTPUT = 8,
	GPIO_V2_LINE_FLAG_EDGE_RISING = 16,
	GPIO_V2_LINE_FLAG_EDGE_FALLING = 32,
	GPIO_V2_LINE_FLAG_OPEN_DRAIN = 64,
	GPIO_V2_LINE_FLAG_OPEN_SOURCE = 128,
	GPIO_V2_LINE_FLAG_BIAS_PULL_UP = 256,
	GPIO_V2_LINE_FLAG_BIAS_PULL_DOWN = 512,
	GPIO_V2_LINE_FLAG_BIAS_DISABLED = 1024,
};

struct gpio_v2_line_values {
	__u64 bits;
	__u64 mask;
};

enum gpio_v2_line_attr_id {
	GPIO_V2_LINE_ATTR_ID_FLAGS = 1,
	GPIO_V2_LINE_ATTR_ID_OUTPUT_VALUES = 2,
	GPIO_V2_LINE_ATTR_ID_DEBOUNCE = 3,
};

struct gpio_v2_line_attribute {
	__u32 id;
	__u32 padding;
	union {
		__u64 flags;
		__u64 values;
		__u32 debounce_period_us;
	};
};

struct gpio_v2_line_config_attribute {
	struct gpio_v2_line_attribute attr;
	__u64 mask;
};

struct gpio_v2_line_config {
	__u64 flags;
	__u32 num_attrs;
	__u32 padding[5];
	struct gpio_v2_line_config_attribute attrs[10];
};

struct gpio_v2_line_request {
	__u32 offsets[64];
	char consumer[32];
	struct gpio_v2_line_config config;
	__u32 num_lines;
	__u32 event_buffer_size;
	__u32 padding[5];
	__s32 fd;
};

struct gpio_v2_line_info {
	char name[32];
	char consumer[32];
	__u32 offset;
	__u32 num_attrs;
	__u64 flags;
	struct gpio_v2_line_attribute attrs[10];
	__u32 padding[4];
};

enum gpio_v2_line_changed_type {
	GPIO_V2_LINE_CHANGED_REQUESTED = 1,
	GPIO_V2_LINE_CHANGED_RELEASED = 2,
	GPIO_V2_LINE_CHANGED_CONFIG = 3,
};

struct gpio_v2_line_info_changed {
	struct gpio_v2_line_info info;
	__u64 timestamp_ns;
	__u32 event_type;
	__u32 padding[5];
};

enum gpio_v2_line_event_id {
	GPIO_V2_LINE_EVENT_RISING_EDGE = 1,
	GPIO_V2_LINE_EVENT_FALLING_EDGE = 2,
};

struct gpio_v2_line_event {
	__u64 timestamp_ns;
	__u32 id;
	__u32 offset;
	__u32 seqno;
	__u32 line_seqno;
	__u32 padding[6];
};

struct gpioline_info {
	__u32 line_offset;
	__u32 flags;
	char name[32];
	char consumer[32];
};

struct gpioline_info_changed {
	struct gpioline_info info;
	__u64 timestamp;
	__u32 event_type;
	__u32 padding[5];
};

struct gpiohandle_request {
	__u32 lineoffsets[64];
	__u32 flags;
	__u8 default_values[64];
	char consumer_label[32];
	__u32 lines;
	int fd;
};

struct gpiohandle_config {
	__u32 flags;
	__u8 default_values[64];
	__u32 padding[4];
};

struct gpiohandle_data {
	__u8 values[64];
};

struct gpioevent_request {
	__u32 lineoffset;
	__u32 handleflags;
	__u32 eventflags;
	char consumer_label[32];
	int fd;
};

struct gpioevent_data {
	__u64 timestamp;
	__u32 id;
};

struct linehandle_state {
	struct gpio_device *gdev;
	const char *label;
	struct gpio_desc *descs[64];
	u32 num_descs;
};

struct linereq;

struct line {
	struct gpio_desc *desc;
	struct linereq *req;
	unsigned int irq;
	u64 eflags;
	u64 timestamp_ns;
	u32 req_seqno;
	u32 line_seqno;
	struct delayed_work work;
	unsigned int sw_debounced;
	unsigned int level;
};

struct linereq {
	struct gpio_device *gdev;
	const char *label;
	u32 num_lines;
	wait_queue_head_t wait;
	u32 event_buffer_size;
	struct {
		union {
			struct __kfifo kfifo;
			struct gpio_v2_line_event *type;
			const struct gpio_v2_line_event *const_type;
			char (*rectype)[0];
			struct gpio_v2_line_event *ptr;
			const struct gpio_v2_line_event *ptr_const;
		};
		struct gpio_v2_line_event buf[0];
	} events;
	atomic_t seqno;
	struct mutex config_mutex;
	struct line lines[0];
};

struct lineevent_state {
	struct gpio_device *gdev;
	const char *label;
	struct gpio_desc *desc;
	u32 eflags;
	int irq;
	wait_queue_head_t wait;
	struct {
		union {
			struct __kfifo kfifo;
			struct gpioevent_data *type;
			const struct gpioevent_data *const_type;
			char (*rectype)[0];
			struct gpioevent_data *ptr;
			const struct gpioevent_data *ptr_const;
		};
		struct gpioevent_data buf[16];
	} events;
	u64 timestamp;
};

struct gpio_chardev_data {
	struct gpio_device *gdev;
	wait_queue_head_t wait;
	struct {
		union {
			struct __kfifo kfifo;
			struct gpio_v2_line_info_changed *type;
			const struct gpio_v2_line_info_changed *const_type;
			char (*rectype)[0];
			struct gpio_v2_line_info_changed *ptr;
			const struct gpio_v2_line_info_changed *ptr_const;
		};
		struct gpio_v2_line_info_changed buf[32];
	} events;
	struct notifier_block lineinfo_changed_nb;
	long unsigned int *watched_lines;
	atomic_t watch_abi_version;
};

struct class_attribute {
	struct attribute attr;
	ssize_t (*show)(struct class *, struct class_attribute *, char *);
	ssize_t (*store)(struct class *, struct class_attribute *, const char *, size_t);
};

struct gpiod_data {
	struct gpio_desc *desc;
	struct mutex mutex;
	struct kernfs_node *value_kn;
	int irq;
	unsigned char irq_flags;
	bool direction_can_change;
};

struct clk_bulk_data {
	const char *id;
	struct clk *clk;
};

struct dwapb_port_property {
	struct fwnode_handle *fwnode;
	unsigned int idx;
	unsigned int ngpio;
	unsigned int gpio_base;
	int irq[32];
	bool irq_shared;
};

struct dwapb_platform_data {
	struct dwapb_port_property *properties;
	unsigned int nports;
};

struct dwapb_gpio_port_irqchip {
	struct irq_chip irqchip;
	unsigned int nr_irqs;
	unsigned int irq[32];
};

struct dwapb_gpio;

struct dwapb_gpio_port {
	struct gpio_chip gc;
	struct dwapb_gpio_port_irqchip *pirq;
	struct dwapb_gpio *gpio;
	unsigned int idx;
};

struct reset_control;

struct dwapb_gpio {
	struct device *dev;
	void *regs;
	struct dwapb_gpio_port *ports;
	unsigned int nr_ports;
	unsigned int flags;
	struct reset_control *rst;
	struct clk_bulk_data clks[2];
};

struct i2c_device_id {
	char name[20];
	kernel_ulong_t driver_data;
};

enum dmi_field {
	DMI_NONE = 0,
	DMI_BIOS_VENDOR = 1,
	DMI_BIOS_VERSION = 2,
	DMI_BIOS_DATE = 3,
	DMI_BIOS_RELEASE = 4,
	DMI_EC_FIRMWARE_RELEASE = 5,
	DMI_SYS_VENDOR = 6,
	DMI_PRODUCT_NAME = 7,
	DMI_PRODUCT_VERSION = 8,
	DMI_PRODUCT_SERIAL = 9,
	DMI_PRODUCT_UUID = 10,
	DMI_PRODUCT_SKU = 11,
	DMI_PRODUCT_FAMILY = 12,
	DMI_BOARD_VENDOR = 13,
	DMI_BOARD_NAME = 14,
	DMI_BOARD_VERSION = 15,
	DMI_BOARD_SERIAL = 16,
	DMI_BOARD_ASSET_TAG = 17,
	DMI_CHASSIS_VENDOR = 18,
	DMI_CHASSIS_TYPE = 19,
	DMI_CHASSIS_VERSION = 20,
	DMI_CHASSIS_SERIAL = 21,
	DMI_CHASSIS_ASSET_TAG = 22,
	DMI_STRING_MAX = 23,
	DMI_OEM_STRING = 24,
};

struct dmi_strmatch {
	unsigned char slot: 7;
	unsigned char exact_match: 1;
	char substr[79];
};

struct dmi_system_id {
	int (*callback)(const struct dmi_system_id *);
	const char *ident;
	struct dmi_strmatch matches[4];
	void *driver_data;
};

struct acpi_gpio_params {
	unsigned int crs_entry_index;
	unsigned int line_index;
	bool active_low;
};

struct acpi_gpio_mapping {
	const char *name;
	const struct acpi_gpio_params *data;
	unsigned int size;
	unsigned int quirks;
};

struct i2c_msg {
	__u16 addr;
	__u16 flags;
	__u16 len;
	__u8 *buf;
};

union i2c_smbus_data {
	__u8 byte;
	__u16 word;
	__u8 block[34];
};

struct i2c_adapter;

struct i2c_client {
	short unsigned int flags;
	short unsigned int addr;
	char name[20];
	struct i2c_adapter *adapter;
	struct device dev;
	int init_irq;
	int irq;
	struct list_head detected;
};

enum i2c_alert_protocol {
	I2C_PROTOCOL_SMBUS_ALERT = 0,
	I2C_PROTOCOL_SMBUS_HOST_NOTIFY = 1,
};

struct i2c_board_info;

struct i2c_driver {
	unsigned int class;
	int (*probe)(struct i2c_client *, const struct i2c_device_id *);
	int (*remove)(struct i2c_client *);
	int (*probe_new)(struct i2c_client *);
	void (*shutdown)(struct i2c_client *);
	void (*alert)(struct i2c_client *, enum i2c_alert_protocol, unsigned int);
	int (*command)(struct i2c_client *, unsigned int, void *);
	struct device_driver driver;
	const struct i2c_device_id *id_table;
	int (*detect)(struct i2c_client *, struct i2c_board_info *);
	const short unsigned int *address_list;
	struct list_head clients;
};

struct i2c_board_info {
	char type[20];
	short unsigned int flags;
	short unsigned int addr;
	const char *dev_name;
	void *platform_data;
	struct device_node *of_node;
	struct fwnode_handle *fwnode;
	const struct property_entry *properties;
	const struct resource *resources;
	unsigned int num_resources;
	int irq;
};

struct i2c_algorithm;

struct i2c_lock_operations;

struct i2c_bus_recovery_info;

struct i2c_adapter_quirks;

struct i2c_adapter {
	struct module *owner;
	unsigned int class;
	const struct i2c_algorithm *algo;
	void *algo_data;
	const struct i2c_lock_operations *lock_ops;
	struct rt_mutex bus_lock;
	struct rt_mutex mux_lock;
	int timeout;
	int retries;
	struct device dev;
	long unsigned int locked_flags;
	int nr;
	char name[48];
	struct completion dev_released;
	struct mutex userspace_clients_lock;
	struct list_head userspace_clients;
	struct i2c_bus_recovery_info *bus_recovery_info;
	const struct i2c_adapter_quirks *quirks;
	struct irq_domain *host_notify_domain;
};

struct i2c_algorithm {
	int (*master_xfer)(struct i2c_adapter *, struct i2c_msg *, int);
	int (*master_xfer_atomic)(struct i2c_adapter *, struct i2c_msg *, int);
	int (*smbus_xfer)(struct i2c_adapter *, u16, short unsigned int, char, u8, int, union i2c_smbus_data *);
	int (*smbus_xfer_atomic)(struct i2c_adapter *, u16, short unsigned int, char, u8, int, union i2c_smbus_data *);
	u32 (*functionality)(struct i2c_adapter *);
};

struct i2c_lock_operations {
	void (*lock_bus)(struct i2c_adapter *, unsigned int);
	int (*trylock_bus)(struct i2c_adapter *, unsigned int);
	void (*unlock_bus)(struct i2c_adapter *, unsigned int);
};

struct i2c_bus_recovery_info {
	int (*recover_bus)(struct i2c_adapter *);
	int (*get_scl)(struct i2c_adapter *);
	void (*set_scl)(struct i2c_adapter *, int);
	int (*get_sda)(struct i2c_adapter *);
	void (*set_sda)(struct i2c_adapter *, int);
	int (*get_bus_free)(struct i2c_adapter *);
	void (*prepare_recovery)(struct i2c_adapter *);
	void (*unprepare_recovery)(struct i2c_adapter *);
	struct gpio_desc *scl_gpiod;
	struct gpio_desc *sda_gpiod;
	struct pinctrl *pinctrl;
	struct pinctrl_state *pins_default;
	struct pinctrl_state *pins_gpio;
};

struct i2c_adapter_quirks {
	u64 flags;
	int max_num_msgs;
	u16 max_write_len;
	u16 max_read_len;
	u16 max_comb_1st_msg_len;
	u16 max_comb_2nd_msg_len;
};

struct pca953x_platform_data {
	unsigned int gpio_base;
	u32 invert;
	int irq_base;
	void *context;
	int (*setup)(struct i2c_client *, unsigned int, unsigned int, void *);
	int (*teardown)(struct i2c_client *, unsigned int, unsigned int, void *);
	const char * const *names;
};

struct pca953x_reg_config {
	int direction;
	int output;
	int input;
	int invert;
};

struct pca953x_chip {
	unsigned int gpio_start;
	struct mutex i2c_lock;
	struct regmap *regmap;
	struct mutex irq_lock;
	long unsigned int irq_mask[1];
	long unsigned int irq_stat[1];
	long unsigned int irq_trig_raise[1];
	long unsigned int irq_trig_fall[1];
	struct irq_chip irq_chip;
	atomic_t wakeup_path;
	struct i2c_client *client;
	struct gpio_chip gpio_chip;
	const char * const *names;
	long unsigned int driver_data;
	struct regulator *regulator;
	const struct pca953x_reg_config *regs;
};

enum pwm_polarity {
	PWM_POLARITY_NORMAL = 0,
	PWM_POLARITY_INVERSED = 1,
};

struct pwm_args {
	u64 period;
	enum pwm_polarity polarity;
};

enum {
	PWMF_REQUESTED = 1,
	PWMF_EXPORTED = 2,
};

enum pwm_output_type {
	PWM_OUTPUT_FIXED = 1,
	PWM_OUTPUT_MODULATED = 2,
};

struct pwm_state {
	u64 period;
	u64 duty_cycle;
	enum pwm_polarity polarity;
	enum pwm_output_type output_type;
	bool enabled;
};

struct pwm_chip;

struct pwm_device {
	const char *label;
	long unsigned int flags;
	unsigned int hwpwm;
	unsigned int pwm;
	struct pwm_chip *chip;
	void *chip_data;
	struct pwm_args args;
	struct pwm_state state;
	struct pwm_state last;
};

struct pwm_ops;

struct pwm_chip {
	struct device *dev;
	const struct pwm_ops *ops;
	int base;
	unsigned int npwm;
	struct pwm_device * (*of_xlate)(struct pwm_chip *, const struct of_phandle_args *);
	unsigned int of_pwm_n_cells;
	struct list_head list;
	struct pwm_device *pwms;
};

struct pwm_capture;

struct pwm_ops {
	int (*request)(struct pwm_chip *, struct pwm_device *);
	void (*free)(struct pwm_chip *, struct pwm_device *);
	int (*capture)(struct pwm_chip *, struct pwm_device *, struct pwm_capture *, long unsigned int);
	int (*apply)(struct pwm_chip *, struct pwm_device *, const struct pwm_state *);
	void (*get_state)(struct pwm_chip *, struct pwm_device *, struct pwm_state *);
	int (*get_output_type_supported)(struct pwm_chip *, struct pwm_device *);
	struct module *owner;
	int (*config)(struct pwm_chip *, struct pwm_device *, int, int);
	int (*set_polarity)(struct pwm_chip *, struct pwm_device *, enum pwm_polarity);
	int (*enable)(struct pwm_chip *, struct pwm_device *);
	void (*disable)(struct pwm_chip *, struct pwm_device *);
};

struct pwm_capture {
	unsigned int period;
	unsigned int duty_cycle;
};

struct pwm_lookup {
	struct list_head list;
	const char *provider;
	unsigned int index;
	const char *dev_id;
	const char *con_id;
	unsigned int period;
	enum pwm_polarity polarity;
	const char *module;
};

struct trace_event_raw_pwm {
	struct trace_entry ent;
	struct pwm_device *pwm;
	u64 period;
	u64 duty_cycle;
	enum pwm_polarity polarity;
	bool enabled;
	char __data[0];
};

struct trace_event_data_offsets_pwm {};

typedef void (*btf_trace_pwm_apply)(void *, struct pwm_device *, const struct pwm_state *);

typedef void (*btf_trace_pwm_get)(void *, struct pwm_device *, const struct pwm_state *);

struct pwm_export {
	struct device child;
	struct pwm_device *pwm;
	struct mutex lock;
	struct pwm_state suspend;
};

struct pwm_light_chip {
	struct clk *pwm_pclk;
	struct clk *pwm_cclk;
	void *mmio_base;
	struct pwm_chip chip;
};

enum hdmi_infoframe_type {
	HDMI_INFOFRAME_TYPE_VENDOR = 129,
	HDMI_INFOFRAME_TYPE_AVI = 130,
	HDMI_INFOFRAME_TYPE_SPD = 131,
	HDMI_INFOFRAME_TYPE_AUDIO = 132,
	HDMI_INFOFRAME_TYPE_DRM = 135,
};

struct hdmi_any_infoframe {
	enum hdmi_infoframe_type type;
	unsigned char version;
	unsigned char length;
};

enum hdmi_colorspace {
	HDMI_COLORSPACE_RGB = 0,
	HDMI_COLORSPACE_YUV422 = 1,
	HDMI_COLORSPACE_YUV444 = 2,
	HDMI_COLORSPACE_YUV420 = 3,
	HDMI_COLORSPACE_RESERVED4 = 4,
	HDMI_COLORSPACE_RESERVED5 = 5,
	HDMI_COLORSPACE_RESERVED6 = 6,
	HDMI_COLORSPACE_IDO_DEFINED = 7,
};

enum hdmi_scan_mode {
	HDMI_SCAN_MODE_NONE = 0,
	HDMI_SCAN_MODE_OVERSCAN = 1,
	HDMI_SCAN_MODE_UNDERSCAN = 2,
	HDMI_SCAN_MODE_RESERVED = 3,
};

enum hdmi_colorimetry {
	HDMI_COLORIMETRY_NONE = 0,
	HDMI_COLORIMETRY_ITU_601 = 1,
	HDMI_COLORIMETRY_ITU_709 = 2,
	HDMI_COLORIMETRY_EXTENDED = 3,
};

enum hdmi_picture_aspect {
	HDMI_PICTURE_ASPECT_NONE = 0,
	HDMI_PICTURE_ASPECT_4_3 = 1,
	HDMI_PICTURE_ASPECT_16_9 = 2,
	HDMI_PICTURE_ASPECT_64_27 = 3,
	HDMI_PICTURE_ASPECT_256_135 = 4,
	HDMI_PICTURE_ASPECT_RESERVED = 5,
};

enum hdmi_active_aspect {
	HDMI_ACTIVE_ASPECT_16_9_TOP = 2,
	HDMI_ACTIVE_ASPECT_14_9_TOP = 3,
	HDMI_ACTIVE_ASPECT_16_9_CENTER = 4,
	HDMI_ACTIVE_ASPECT_PICTURE = 8,
	HDMI_ACTIVE_ASPECT_4_3 = 9,
	HDMI_ACTIVE_ASPECT_16_9 = 10,
	HDMI_ACTIVE_ASPECT_14_9 = 11,
	HDMI_ACTIVE_ASPECT_4_3_SP_14_9 = 13,
	HDMI_ACTIVE_ASPECT_16_9_SP_14_9 = 14,
	HDMI_ACTIVE_ASPECT_16_9_SP_4_3 = 15,
};

enum hdmi_extended_colorimetry {
	HDMI_EXTENDED_COLORIMETRY_XV_YCC_601 = 0,
	HDMI_EXTENDED_COLORIMETRY_XV_YCC_709 = 1,
	HDMI_EXTENDED_COLORIMETRY_S_YCC_601 = 2,
	HDMI_EXTENDED_COLORIMETRY_OPYCC_601 = 3,
	HDMI_EXTENDED_COLORIMETRY_OPRGB = 4,
	HDMI_EXTENDED_COLORIMETRY_BT2020_CONST_LUM = 5,
	HDMI_EXTENDED_COLORIMETRY_BT2020 = 6,
	HDMI_EXTENDED_COLORIMETRY_RESERVED = 7,
};

enum hdmi_quantization_range {
	HDMI_QUANTIZATION_RANGE_DEFAULT = 0,
	HDMI_QUANTIZATION_RANGE_LIMITED = 1,
	HDMI_QUANTIZATION_RANGE_FULL = 2,
	HDMI_QUANTIZATION_RANGE_RESERVED = 3,
};

enum hdmi_nups {
	HDMI_NUPS_UNKNOWN = 0,
	HDMI_NUPS_HORIZONTAL = 1,
	HDMI_NUPS_VERTICAL = 2,
	HDMI_NUPS_BOTH = 3,
};

enum hdmi_ycc_quantization_range {
	HDMI_YCC_QUANTIZATION_RANGE_LIMITED = 0,
	HDMI_YCC_QUANTIZATION_RANGE_FULL = 1,
};

enum hdmi_content_type {
	HDMI_CONTENT_TYPE_GRAPHICS = 0,
	HDMI_CONTENT_TYPE_PHOTO = 1,
	HDMI_CONTENT_TYPE_CINEMA = 2,
	HDMI_CONTENT_TYPE_GAME = 3,
};

enum hdmi_metadata_type {
	HDMI_STATIC_METADATA_TYPE1 = 1,
};

enum hdmi_eotf {
	HDMI_EOTF_TRADITIONAL_GAMMA_SDR = 0,
	HDMI_EOTF_TRADITIONAL_GAMMA_HDR = 1,
	HDMI_EOTF_SMPTE_ST2084 = 2,
	HDMI_EOTF_BT_2100_HLG = 3,
};

struct hdmi_avi_infoframe {
	enum hdmi_infoframe_type type;
	unsigned char version;
	unsigned char length;
	enum hdmi_colorspace colorspace;
	enum hdmi_scan_mode scan_mode;
	enum hdmi_colorimetry colorimetry;
	enum hdmi_picture_aspect picture_aspect;
	enum hdmi_active_aspect active_aspect;
	bool itc;
	enum hdmi_extended_colorimetry extended_colorimetry;
	enum hdmi_quantization_range quantization_range;
	enum hdmi_nups nups;
	unsigned char video_code;
	enum hdmi_ycc_quantization_range ycc_quantization_range;
	enum hdmi_content_type content_type;
	unsigned char pixel_repeat;
	short unsigned int top_bar;
	short unsigned int bottom_bar;
	short unsigned int left_bar;
	short unsigned int right_bar;
};

struct hdmi_drm_infoframe {
	enum hdmi_infoframe_type type;
	unsigned char version;
	unsigned char length;
	enum hdmi_eotf eotf;
	enum hdmi_metadata_type metadata_type;
	struct {
		u16 x;
		u16 y;
	} display_primaries[3];
	struct {
		u16 x;
		u16 y;
	} white_point;
	u16 max_display_mastering_luminance;
	u16 min_display_mastering_luminance;
	u16 max_cll;
	u16 max_fall;
};

enum hdmi_spd_sdi {
	HDMI_SPD_SDI_UNKNOWN = 0,
	HDMI_SPD_SDI_DSTB = 1,
	HDMI_SPD_SDI_DVDP = 2,
	HDMI_SPD_SDI_DVHS = 3,
	HDMI_SPD_SDI_HDDVR = 4,
	HDMI_SPD_SDI_DVC = 5,
	HDMI_SPD_SDI_DSC = 6,
	HDMI_SPD_SDI_VCD = 7,
	HDMI_SPD_SDI_GAME = 8,
	HDMI_SPD_SDI_PC = 9,
	HDMI_SPD_SDI_BD = 10,
	HDMI_SPD_SDI_SACD = 11,
	HDMI_SPD_SDI_HDDVD = 12,
	HDMI_SPD_SDI_PMP = 13,
};

struct hdmi_spd_infoframe {
	enum hdmi_infoframe_type type;
	unsigned char version;
	unsigned char length;
	char vendor[8];
	char product[16];
	enum hdmi_spd_sdi sdi;
};

enum hdmi_audio_coding_type {
	HDMI_AUDIO_CODING_TYPE_STREAM = 0,
	HDMI_AUDIO_CODING_TYPE_PCM = 1,
	HDMI_AUDIO_CODING_TYPE_AC3 = 2,
	HDMI_AUDIO_CODING_TYPE_MPEG1 = 3,
	HDMI_AUDIO_CODING_TYPE_MP3 = 4,
	HDMI_AUDIO_CODING_TYPE_MPEG2 = 5,
	HDMI_AUDIO_CODING_TYPE_AAC_LC = 6,
	HDMI_AUDIO_CODING_TYPE_DTS = 7,
	HDMI_AUDIO_CODING_TYPE_ATRAC = 8,
	HDMI_AUDIO_CODING_TYPE_DSD = 9,
	HDMI_AUDIO_CODING_TYPE_EAC3 = 10,
	HDMI_AUDIO_CODING_TYPE_DTS_HD = 11,
	HDMI_AUDIO_CODING_TYPE_MLP = 12,
	HDMI_AUDIO_CODING_TYPE_DST = 13,
	HDMI_AUDIO_CODING_TYPE_WMA_PRO = 14,
	HDMI_AUDIO_CODING_TYPE_CXT = 15,
};

enum hdmi_audio_sample_size {
	HDMI_AUDIO_SAMPLE_SIZE_STREAM = 0,
	HDMI_AUDIO_SAMPLE_SIZE_16 = 1,
	HDMI_AUDIO_SAMPLE_SIZE_20 = 2,
	HDMI_AUDIO_SAMPLE_SIZE_24 = 3,
};

enum hdmi_audio_sample_frequency {
	HDMI_AUDIO_SAMPLE_FREQUENCY_STREAM = 0,
	HDMI_AUDIO_SAMPLE_FREQUENCY_32000 = 1,
	HDMI_AUDIO_SAMPLE_FREQUENCY_44100 = 2,
	HDMI_AUDIO_SAMPLE_FREQUENCY_48000 = 3,
	HDMI_AUDIO_SAMPLE_FREQUENCY_88200 = 4,
	HDMI_AUDIO_SAMPLE_FREQUENCY_96000 = 5,
	HDMI_AUDIO_SAMPLE_FREQUENCY_176400 = 6,
	HDMI_AUDIO_SAMPLE_FREQUENCY_192000 = 7,
};

enum hdmi_audio_coding_type_ext {
	HDMI_AUDIO_CODING_TYPE_EXT_CT = 0,
	HDMI_AUDIO_CODING_TYPE_EXT_HE_AAC = 1,
	HDMI_AUDIO_CODING_TYPE_EXT_HE_AAC_V2 = 2,
	HDMI_AUDIO_CODING_TYPE_EXT_MPEG_SURROUND = 3,
	HDMI_AUDIO_CODING_TYPE_EXT_MPEG4_HE_AAC = 4,
	HDMI_AUDIO_CODING_TYPE_EXT_MPEG4_HE_AAC_V2 = 5,
	HDMI_AUDIO_CODING_TYPE_EXT_MPEG4_AAC_LC = 6,
	HDMI_AUDIO_CODING_TYPE_EXT_DRA = 7,
	HDMI_AUDIO_CODING_TYPE_EXT_MPEG4_HE_AAC_SURROUND = 8,
	HDMI_AUDIO_CODING_TYPE_EXT_MPEG4_AAC_LC_SURROUND = 10,
};

struct hdmi_audio_infoframe {
	enum hdmi_infoframe_type type;
	unsigned char version;
	unsigned char length;
	unsigned char channels;
	enum hdmi_audio_coding_type coding_type;
	enum hdmi_audio_sample_size sample_size;
	enum hdmi_audio_sample_frequency sample_frequency;
	enum hdmi_audio_coding_type_ext coding_type_ext;
	unsigned char channel_allocation;
	unsigned char level_shift_value;
	bool downmix_inhibit;
};

enum hdmi_3d_structure {
	HDMI_3D_STRUCTURE_INVALID = 4294967295,
	HDMI_3D_STRUCTURE_FRAME_PACKING = 0,
	HDMI_3D_STRUCTURE_FIELD_ALTERNATIVE = 1,
	HDMI_3D_STRUCTURE_LINE_ALTERNATIVE = 2,
	HDMI_3D_STRUCTURE_SIDE_BY_SIDE_FULL = 3,
	HDMI_3D_STRUCTURE_L_DEPTH = 4,
	HDMI_3D_STRUCTURE_L_DEPTH_GFX_GFX_DEPTH = 5,
	HDMI_3D_STRUCTURE_TOP_AND_BOTTOM = 6,
	HDMI_3D_STRUCTURE_SIDE_BY_SIDE_HALF = 8,
};

struct hdmi_vendor_infoframe {
	enum hdmi_infoframe_type type;
	unsigned char version;
	unsigned char length;
	unsigned int oui;
	u8 vic;
	enum hdmi_3d_structure s3d_struct;
	unsigned int s3d_ext_data;
};

union hdmi_vendor_any_infoframe {
	struct {
		enum hdmi_infoframe_type type;
		unsigned char version;
		unsigned char length;
		unsigned int oui;
	} any;
	struct hdmi_vendor_infoframe hdmi;
};

union hdmi_infoframe {
	struct hdmi_any_infoframe any;
	struct hdmi_avi_infoframe avi;
	struct hdmi_spd_infoframe spd;
	union hdmi_vendor_any_infoframe vendor;
	struct hdmi_audio_infoframe audio;
	struct hdmi_drm_infoframe drm;
};

enum con_scroll {
	SM_UP = 0,
	SM_DOWN = 1,
};

enum vc_intensity {
	VCI_HALF_BRIGHT = 0,
	VCI_NORMAL = 1,
	VCI_BOLD = 2,
	VCI_MASK = 3,
};

struct vc_data;

struct console_font;

struct consw {
	struct module *owner;
	const char * (*con_startup)();
	void (*con_init)(struct vc_data *, int);
	void (*con_deinit)(struct vc_data *);
	void (*con_clear)(struct vc_data *, int, int, int, int);
	void (*con_putc)(struct vc_data *, int, int, int);
	void (*con_putcs)(struct vc_data *, const short unsigned int *, int, int, int);
	void (*con_cursor)(struct vc_data *, int);
	bool (*con_scroll)(struct vc_data *, unsigned int, unsigned int, enum con_scroll, unsigned int);
	int (*con_switch)(struct vc_data *);
	int (*con_blank)(struct vc_data *, int, int);
	int (*con_font_set)(struct vc_data *, struct console_font *, unsigned int);
	int (*con_font_get)(struct vc_data *, struct console_font *);
	int (*con_font_default)(struct vc_data *, struct console_font *, char *);
	int (*con_font_copy)(struct vc_data *, int);
	int (*con_resize)(struct vc_data *, unsigned int, unsigned int, unsigned int);
	void (*con_set_palette)(struct vc_data *, const unsigned char *);
	void (*con_scrolldelta)(struct vc_data *, int);
	int (*con_set_origin)(struct vc_data *);
	void (*con_save_screen)(struct vc_data *);
	u8 (*con_build_attr)(struct vc_data *, u8, enum vc_intensity, bool, bool, bool, bool);
	void (*con_invert_region)(struct vc_data *, u16 *, int);
	u16 * (*con_screen_pos)(const struct vc_data *, int);
	long unsigned int (*con_getxy)(struct vc_data *, long unsigned int, int *, int *);
	void (*con_flush_scrollback)(struct vc_data *);
	int (*con_debug_enter)(struct vc_data *);
	int (*con_debug_leave)(struct vc_data *);
};

struct vc_state {
	unsigned int x;
	unsigned int y;
	unsigned char color;
	unsigned char Gx_charset[2];
	unsigned int charset: 1;
	enum vc_intensity intensity;
	bool italic;
	bool underline;
	bool blink;
	bool reverse;
};

struct console_font {
	unsigned int width;
	unsigned int height;
	unsigned int charcount;
	unsigned char *data;
};

struct vt_mode {
	char mode;
	char waitv;
	short int relsig;
	short int acqsig;
	short int frsig;
};

struct uni_pagedir;

struct uni_screen;

struct vc_data {
	struct tty_port port;
	struct vc_state state;
	struct vc_state saved_state;
	short unsigned int vc_num;
	unsigned int vc_cols;
	unsigned int vc_rows;
	unsigned int vc_size_row;
	unsigned int vc_scan_lines;
	unsigned int vc_cell_height;
	long unsigned int vc_origin;
	long unsigned int vc_scr_end;
	long unsigned int vc_visible_origin;
	unsigned int vc_top;
	unsigned int vc_bottom;
	const struct consw *vc_sw;
	short unsigned int *vc_screenbuf;
	unsigned int vc_screenbuf_size;
	unsigned char vc_mode;
	unsigned char vc_attr;
	unsigned char vc_def_color;
	unsigned char vc_ulcolor;
	unsigned char vc_itcolor;
	unsigned char vc_halfcolor;
	unsigned int vc_cursor_type;
	short unsigned int vc_complement_mask;
	short unsigned int vc_s_complement_mask;
	long unsigned int vc_pos;
	short unsigned int vc_hi_font_mask;
	struct console_font vc_font;
	short unsigned int vc_video_erase_char;
	unsigned int vc_state;
	unsigned int vc_npar;
	unsigned int vc_par[16];
	struct vt_mode vt_mode;
	struct pid *vt_pid;
	int vt_newvt;
	wait_queue_head_t paste_wait;
	unsigned int vc_disp_ctrl: 1;
	unsigned int vc_toggle_meta: 1;
	unsigned int vc_decscnm: 1;
	unsigned int vc_decom: 1;
	unsigned int vc_decawm: 1;
	unsigned int vc_deccm: 1;
	unsigned int vc_decim: 1;
	unsigned int vc_priv: 3;
	unsigned int vc_need_wrap: 1;
	unsigned int vc_can_do_color: 1;
	unsigned int vc_report_mouse: 2;
	unsigned char vc_utf: 1;
	unsigned char vc_utf_count;
	int vc_utf_char;
	long unsigned int vc_tab_stop[4];
	unsigned char vc_palette[48];
	short unsigned int *vc_translate;
	unsigned int vc_resize_user;
	unsigned int vc_bell_pitch;
	unsigned int vc_bell_duration;
	short unsigned int vc_cur_blink_ms;
	struct vc_data **vc_display_fg;
	struct uni_pagedir *vc_uni_pagedir;
	struct uni_pagedir **vc_uni_pagedir_loc;
	struct uni_screen *vc_uni_screen;
};

struct vc {
	struct vc_data *d;
	struct work_struct SAK_work;
};

struct vgastate {
	void *vgabase;
	long unsigned int membase;
	__u32 memsize;
	__u32 flags;
	__u32 depth;
	__u32 num_attr;
	__u32 num_crtc;
	__u32 num_gfx;
	__u32 num_seq;
	void *vidstate;
};

struct linux_logo {
	int type;
	unsigned int width;
	unsigned int height;
	unsigned int clutsize;
	const unsigned char *clut;
	const unsigned char *data;
};

struct fb_fix_screeninfo {
	char id[16];
	long unsigned int smem_start;
	__u32 smem_len;
	__u32 type;
	__u32 type_aux;
	__u32 visual;
	__u16 xpanstep;
	__u16 ypanstep;
	__u16 ywrapstep;
	__u32 line_length;
	long unsigned int mmio_start;
	__u32 mmio_len;
	__u32 accel;
	__u16 capabilities;
	__u16 reserved[2];
};

struct fb_bitfield {
	__u32 offset;
	__u32 length;
	__u32 msb_right;
};

struct fb_var_screeninfo {
	__u32 xres;
	__u32 yres;
	__u32 xres_virtual;
	__u32 yres_virtual;
	__u32 xoffset;
	__u32 yoffset;
	__u32 bits_per_pixel;
	__u32 grayscale;
	struct fb_bitfield red;
	struct fb_bitfield green;
	struct fb_bitfield blue;
	struct fb_bitfield transp;
	__u32 nonstd;
	__u32 activate;
	__u32 height;
	__u32 width;
	__u32 accel_flags;
	__u32 pixclock;
	__u32 left_margin;
	__u32 right_margin;
	__u32 upper_margin;
	__u32 lower_margin;
	__u32 hsync_len;
	__u32 vsync_len;
	__u32 sync;
	__u32 vmode;
	__u32 rotate;
	__u32 colorspace;
	__u32 reserved[4];
};

struct fb_cmap {
	__u32 start;
	__u32 len;
	__u16 *red;
	__u16 *green;
	__u16 *blue;
	__u16 *transp;
};

enum {
	FB_BLANK_UNBLANK = 0,
	FB_BLANK_NORMAL = 1,
	FB_BLANK_VSYNC_SUSPEND = 2,
	FB_BLANK_HSYNC_SUSPEND = 3,
	FB_BLANK_POWERDOWN = 4,
};

struct fb_copyarea {
	__u32 dx;
	__u32 dy;
	__u32 width;
	__u32 height;
	__u32 sx;
	__u32 sy;
};

struct fb_fillrect {
	__u32 dx;
	__u32 dy;
	__u32 width;
	__u32 height;
	__u32 color;
	__u32 rop;
};

struct fb_image {
	__u32 dx;
	__u32 dy;
	__u32 width;
	__u32 height;
	__u32 fg_color;
	__u32 bg_color;
	__u8 depth;
	const char *data;
	struct fb_cmap cmap;
};

struct fbcurpos {
	__u16 x;
	__u16 y;
};

struct fb_cursor {
	__u16 set;
	__u16 enable;
	__u16 rop;
	const char *mask;
	struct fbcurpos hot;
	struct fb_image image;
};

struct fb_chroma {
	__u32 redx;
	__u32 greenx;
	__u32 bluex;
	__u32 whitex;
	__u32 redy;
	__u32 greeny;
	__u32 bluey;
	__u32 whitey;
};

struct fb_videomode;

struct fb_monspecs {
	struct fb_chroma chroma;
	struct fb_videomode *modedb;
	__u8 manufacturer[4];
	__u8 monitor[14];
	__u8 serial_no[14];
	__u8 ascii[14];
	__u32 modedb_len;
	__u32 model;
	__u32 serial;
	__u32 year;
	__u32 week;
	__u32 hfmin;
	__u32 hfmax;
	__u32 dclkmin;
	__u32 dclkmax;
	__u16 input;
	__u16 dpms;
	__u16 signal;
	__u16 vfmin;
	__u16 vfmax;
	__u16 gamma;
	__u16 gtf: 1;
	__u16 misc;
	__u8 version;
	__u8 revision;
	__u8 max_x;
	__u8 max_y;
};

struct fb_videomode {
	const char *name;
	u32 refresh;
	u32 xres;
	u32 yres;
	u32 pixclock;
	u32 left_margin;
	u32 right_margin;
	u32 upper_margin;
	u32 lower_margin;
	u32 hsync_len;
	u32 vsync_len;
	u32 sync;
	u32 vmode;
	u32 flag;
};

struct fb_info;

struct fb_event {
	struct fb_info *info;
	void *data;
};

struct fb_pixmap {
	u8 *addr;
	u32 size;
	u32 offset;
	u32 buf_align;
	u32 scan_align;
	u32 access_align;
	u32 flags;
	u32 blit_x;
	u32 blit_y;
	void (*writeio)(struct fb_info *, void *, void *, unsigned int);
	void (*readio)(struct fb_info *, void *, void *, unsigned int);
};

struct fb_deferred_io;

struct fb_ops;

struct apertures_struct;

struct fb_info {
	atomic_t count;
	int node;
	int flags;
	int fbcon_rotate_hint;
	struct mutex lock;
	struct mutex mm_lock;
	struct fb_var_screeninfo var;
	struct fb_fix_screeninfo fix;
	struct fb_monspecs monspecs;
	struct work_struct queue;
	struct fb_pixmap pixmap;
	struct fb_pixmap sprite;
	struct fb_cmap cmap;
	struct list_head modelist;
	struct fb_videomode *mode;
	struct delayed_work deferred_work;
	struct fb_deferred_io *fbdefio;
	const struct fb_ops *fbops;
	struct device *device;
	struct device *dev;
	int class_flag;
	union {
		char *screen_base;
		char *screen_buffer;
	};
	long unsigned int screen_size;
	void *pseudo_palette;
	u32 state;
	void *fbcon_par;
	void *par;
	struct apertures_struct *apertures;
	bool skip_vt_switch;
};

struct fb_blit_caps {
	u32 x;
	u32 y;
	u32 len;
	u32 flags;
};

struct fb_deferred_io {
	long unsigned int delay;
	struct mutex lock;
	struct list_head pagelist;
	void (*first_io)(struct fb_info *);
	void (*deferred_io)(struct fb_info *, struct list_head *);
};

struct fb_ops {
	struct module *owner;
	int (*fb_open)(struct fb_info *, int);
	int (*fb_release)(struct fb_info *, int);
	ssize_t (*fb_read)(struct fb_info *, char *, size_t, loff_t *);
	ssize_t (*fb_write)(struct fb_info *, const char *, size_t, loff_t *);
	int (*fb_check_var)(struct fb_var_screeninfo *, struct fb_info *);
	int (*fb_set_par)(struct fb_info *);
	int (*fb_setcolreg)(unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, struct fb_info *);
	int (*fb_setcmap)(struct fb_cmap *, struct fb_info *);
	int (*fb_blank)(int, struct fb_info *);
	int (*fb_pan_display)(struct fb_var_screeninfo *, struct fb_info *);
	void (*fb_fillrect)(struct fb_info *, const struct fb_fillrect *);
	void (*fb_copyarea)(struct fb_info *, const struct fb_copyarea *);
	void (*fb_imageblit)(struct fb_info *, const struct fb_image *);
	int (*fb_cursor)(struct fb_info *, struct fb_cursor *);
	int (*fb_sync)(struct fb_info *);
	int (*fb_ioctl)(struct fb_info *, unsigned int, long unsigned int);
	int (*fb_compat_ioctl)(struct fb_info *, unsigned int, long unsigned int);
	int (*fb_mmap)(struct fb_info *, struct vm_area_struct *);
	void (*fb_get_caps)(struct fb_info *, struct fb_blit_caps *, struct fb_var_screeninfo *);
	void (*fb_destroy)(struct fb_info *);
	int (*fb_debug_enter)(struct fb_info *);
	int (*fb_debug_leave)(struct fb_info *);
};

struct aperture {
	resource_size_t base;
	resource_size_t size;
};

struct apertures_struct {
	unsigned int count;
	struct aperture ranges[0];
};

enum backlight_update_reason {
	BACKLIGHT_UPDATE_HOTKEY = 0,
	BACKLIGHT_UPDATE_SYSFS = 1,
};

enum backlight_type {
	BACKLIGHT_RAW = 1,
	BACKLIGHT_PLATFORM = 2,
	BACKLIGHT_FIRMWARE = 3,
	BACKLIGHT_TYPE_MAX = 4,
};

enum backlight_notification {
	BACKLIGHT_REGISTERED = 0,
	BACKLIGHT_UNREGISTERED = 1,
};

enum backlight_scale {
	BACKLIGHT_SCALE_UNKNOWN = 0,
	BACKLIGHT_SCALE_LINEAR = 1,
	BACKLIGHT_SCALE_NON_LINEAR = 2,
};

struct backlight_device;

struct backlight_ops {
	unsigned int options;
	int (*update_status)(struct backlight_device *);
	int (*get_brightness)(struct backlight_device *);
	int (*check_fb)(struct backlight_device *, struct fb_info *);
};

struct backlight_properties {
	int brightness;
	int max_brightness;
	int power;
	int fb_blank;
	enum backlight_type type;
	unsigned int state;
	enum backlight_scale scale;
};

struct backlight_device {
	struct backlight_properties props;
	struct mutex update_lock;
	struct mutex ops_lock;
	const struct backlight_ops *ops;
	struct notifier_block fb_notif;
	struct list_head entry;
	struct device dev;
	bool fb_bl_on[32];
	int use_count;
};

struct platform_pwm_backlight_data {
	int pwm_id;
	unsigned int max_brightness;
	unsigned int dft_brightness;
	unsigned int lth_brightness;
	unsigned int pwm_period_ns;
	unsigned int *levels;
	unsigned int post_pwm_on_delay;
	unsigned int pwm_off_delay;
	int (*init)(struct device *);
	int (*notify)(struct device *, int);
	void (*notify_after)(struct device *, int);
	void (*exit)(struct device *);
	int (*check_fb)(struct device *, struct fb_info *);
};

struct pwm_bl_data {
	struct pwm_device *pwm;
	struct device *dev;
	unsigned int lth_brightness;
	unsigned int *levels;
	bool enabled;
	struct regulator *power_supply;
	struct gpio_desc *enable_gpio;
	unsigned int scale;
	bool legacy;
	unsigned int post_pwm_on_delay;
	unsigned int pwm_off_delay;
	int (*notify)(struct device *, int);
	void (*notify_after)(struct device *, int);
	int (*check_fb)(struct device *, struct fb_info *);
	void (*exit)(struct device *);
};

struct pci_device_id {
	__u32 vendor;
	__u32 device;
	__u32 subvendor;
	__u32 subdevice;
	__u32 class;
	__u32 class_mask;
	kernel_ulong_t driver_data;
};

struct fb_cmap_user {
	__u32 start;
	__u32 len;
	__u16 *red;
	__u16 *green;
	__u16 *blue;
	__u16 *transp;
};

struct fb_modelist {
	struct list_head list;
	struct fb_videomode mode;
};

struct hotplug_slot;

struct pci_bus;

struct pci_slot {
	struct pci_bus *bus;
	struct list_head list;
	struct hotplug_slot *hotplug;
	unsigned char number;
	struct kobject kobj;
};

struct msi_controller;

struct pci_dev;

struct pci_ops;

struct pci_bus {
	struct list_head node;
	struct pci_bus *parent;
	struct list_head children;
	struct list_head devices;
	struct pci_dev *self;
	struct list_head slots;
	struct resource *resource[4];
	struct list_head resources;
	struct resource busn_res;
	struct pci_ops *ops;
	struct msi_controller *msi;
	void *sysdata;
	struct proc_dir_entry *procdir;
	unsigned char number;
	unsigned char primary;
	unsigned char max_bus_speed;
	unsigned char cur_bus_speed;
	char name[48];
	short unsigned int bridge_ctl;
	pci_bus_flags_t bus_flags;
	struct device *bridge;
	struct device dev;
	struct bin_attribute *legacy_io;
	struct bin_attribute *legacy_mem;
	unsigned int is_added: 1;
};

typedef int pci_power_t;

struct pci_vpd;

struct pci_driver;

struct pci_dev {
	struct list_head bus_list;
	struct pci_bus *bus;
	struct pci_bus *subordinate;
	void *sysdata;
	struct proc_dir_entry *procent;
	struct pci_slot *slot;
	unsigned int devfn;
	short unsigned int vendor;
	short unsigned int device;
	short unsigned int subsystem_vendor;
	short unsigned int subsystem_device;
	unsigned int class;
	u8 revision;
	u8 hdr_type;
	u8 pcie_cap;
	u8 msi_cap;
	u8 msix_cap;
	u8 pcie_mpss: 3;
	u8 rom_base_reg;
	u8 pin;
	u16 pcie_flags_reg;
	long unsigned int *dma_alias_mask;
	struct pci_driver *driver;
	u64 dma_mask;
	struct device_dma_parameters dma_parms;
	pci_power_t current_state;
	unsigned int imm_ready: 1;
	u8 pm_cap;
	unsigned int pme_support: 5;
	unsigned int pme_poll: 1;
	unsigned int d1_support: 1;
	unsigned int d2_support: 1;
	unsigned int no_d1d2: 1;
	unsigned int no_d3cold: 1;
	unsigned int bridge_d3: 1;
	unsigned int d3cold_allowed: 1;
	unsigned int mmio_always_on: 1;
	unsigned int wakeup_prepared: 1;
	unsigned int runtime_d3cold: 1;
	unsigned int skip_bus_pm: 1;
	unsigned int ignore_hotplug: 1;
	unsigned int hotplug_user_indicators: 1;
	unsigned int clear_retrain_link: 1;
	unsigned int d3hot_delay;
	unsigned int d3cold_delay;
	unsigned int eetlp_prefix_path: 1;
	pci_channel_state_t error_state;
	struct device dev;
	int cfg_size;
	unsigned int irq;
	struct resource resource[11];
	bool match_driver;
	unsigned int transparent: 1;
	unsigned int io_window: 1;
	unsigned int pref_window: 1;
	unsigned int pref_64_window: 1;
	unsigned int multifunction: 1;
	unsigned int is_busmaster: 1;
	unsigned int no_msi: 1;
	unsigned int no_64bit_msi: 1;
	unsigned int block_cfg_access: 1;
	unsigned int broken_parity_status: 1;
	unsigned int irq_reroute_variant: 2;
	unsigned int msi_enabled: 1;
	unsigned int msix_enabled: 1;
	unsigned int ari_enabled: 1;
	unsigned int ats_enabled: 1;
	unsigned int pasid_enabled: 1;
	unsigned int pri_enabled: 1;
	unsigned int is_managed: 1;
	unsigned int needs_freset: 1;
	unsigned int state_saved: 1;
	unsigned int is_physfn: 1;
	unsigned int is_virtfn: 1;
	unsigned int reset_fn: 1;
	unsigned int is_hotplug_bridge: 1;
	unsigned int shpc_managed: 1;
	unsigned int is_thunderbolt: 1;
	unsigned int untrusted: 1;
	unsigned int external_facing: 1;
	unsigned int broken_intx_masking: 1;
	unsigned int io_window_1k: 1;
	unsigned int irq_managed: 1;
	unsigned int non_compliant_bars: 1;
	unsigned int is_probed: 1;
	unsigned int link_active_reporting: 1;
	unsigned int no_vf_scan: 1;
	unsigned int no_command_memory: 1;
	pci_dev_flags_t dev_flags;
	atomic_t enable_cnt;
	u32 saved_config_space[16];
	struct hlist_head saved_cap_space;
	struct bin_attribute *rom_attr;
	int rom_attr_enabled;
	struct bin_attribute *res_attr[11];
	struct bin_attribute *res_attr_wc[11];
	struct pci_vpd *vpd;
	u16 acs_cap;
	phys_addr_t rom;
	size_t romlen;
	char *driver_override;
	long unsigned int priv_flags;
};

struct pci_dynids {
	spinlock_t lock;
	struct list_head list;
};

struct pci_error_handlers;

struct pci_driver {
	struct list_head node;
	const char *name;
	const struct pci_device_id *id_table;
	int (*probe)(struct pci_dev *, const struct pci_device_id *);
	void (*remove)(struct pci_dev *);
	int (*suspend)(struct pci_dev *, pm_message_t);
	int (*resume)(struct pci_dev *);
	void (*shutdown)(struct pci_dev *);
	int (*sriov_configure)(struct pci_dev *, int);
	const struct pci_error_handlers *err_handler;
	const struct attribute_group **groups;
	struct device_driver driver;
	struct pci_dynids dynids;
};

struct pci_ops {
	int (*add_bus)(struct pci_bus *);
	void (*remove_bus)(struct pci_bus *);
	void * (*map_bus)(struct pci_bus *, unsigned int, int);
	int (*read)(struct pci_bus *, unsigned int, int, int, u32 *);
	int (*write)(struct pci_bus *, unsigned int, int, int, u32);
};

struct pci_error_handlers {
	pci_ers_result_t (*error_detected)(struct pci_dev *, pci_channel_state_t);
	pci_ers_result_t (*mmio_enabled)(struct pci_dev *);
	pci_ers_result_t (*slot_reset)(struct pci_dev *);
	void (*reset_prepare)(struct pci_dev *);
	void (*reset_done)(struct pci_dev *);
	void (*resume)(struct pci_dev *);
};

struct logo_data {
	int depth;
	int needs_directpalette;
	int needs_truepalette;
	int needs_cmapreset;
	const struct linux_logo *logo;
};

typedef unsigned int u_int;

struct fb_cvt_data {
	u32 xres;
	u32 yres;
	u32 refresh;
	u32 f_refresh;
	u32 pixclock;
	u32 hperiod;
	u32 hblank;
	u32 hfreq;
	u32 htotal;
	u32 vtotal;
	u32 vsync;
	u32 hsync;
	u32 h_front_porch;
	u32 h_back_porch;
	u32 v_front_porch;
	u32 v_back_porch;
	u32 h_margin;
	u32 v_margin;
	u32 interlace;
	u32 aspect_ratio;
	u32 active_pixels;
	u32 flags;
	u32 status;
};

typedef short unsigned int u_short;

struct fb_con2fbmap {
	__u32 console;
	__u32 framebuffer;
};

struct fbcon_display {
	const u_char *fontdata;
	int userfont;
	u_short inverse;
	short int yscroll;
	int vrows;
	int cursor_shape;
	int con_rotate;
	u32 xres_virtual;
	u32 yres_virtual;
	u32 height;
	u32 width;
	u32 bits_per_pixel;
	u32 grayscale;
	u32 nonstd;
	u32 accel_flags;
	u32 rotate;
	struct fb_bitfield red;
	struct fb_bitfield green;
	struct fb_bitfield blue;
	struct fb_bitfield transp;
	const struct fb_videomode *mode;
};

struct fbcon_ops {
	void (*bmove)(struct vc_data *, struct fb_info *, int, int, int, int, int, int);
	void (*clear)(struct vc_data *, struct fb_info *, int, int, int, int);
	void (*putcs)(struct vc_data *, struct fb_info *, const short unsigned int *, int, int, int, int, int);
	void (*clear_margins)(struct vc_data *, struct fb_info *, int, int);
	void (*cursor)(struct vc_data *, struct fb_info *, int, int, int);
	int (*update_start)(struct fb_info *);
	int (*rotate_font)(struct fb_info *, struct vc_data *);
	struct fb_var_screeninfo var;
	struct timer_list cursor_timer;
	struct fb_cursor cursor_state;
	struct fbcon_display *p;
	struct fb_info *info;
	int currcon;
	int cur_blink_jiffies;
	int cursor_flash;
	int cursor_reset;
	int blank_state;
	int graphics;
	int save_graphics;
	int flags;
	int rotate;
	int cur_rotate;
	char *cursor_data;
	u8 *fontbuffer;
	u8 *fontdata;
	u8 *cursor_src;
	u32 cursor_size;
	u32 fd_size;
};

enum {
	FBCON_LOGO_CANSHOW = 4294967295,
	FBCON_LOGO_DRAW = 4294967294,
	FBCON_LOGO_DONTSHOW = 4294967293,
};

enum display_flags {
	DISPLAY_FLAGS_HSYNC_LOW = 1,
	DISPLAY_FLAGS_HSYNC_HIGH = 2,
	DISPLAY_FLAGS_VSYNC_LOW = 4,
	DISPLAY_FLAGS_VSYNC_HIGH = 8,
	DISPLAY_FLAGS_DE_LOW = 16,
	DISPLAY_FLAGS_DE_HIGH = 32,
	DISPLAY_FLAGS_PIXDATA_POSEDGE = 64,
	DISPLAY_FLAGS_PIXDATA_NEGEDGE = 128,
	DISPLAY_FLAGS_INTERLACED = 256,
	DISPLAY_FLAGS_DOUBLESCAN = 512,
	DISPLAY_FLAGS_DOUBLECLK = 1024,
	DISPLAY_FLAGS_SYNC_POSEDGE = 2048,
	DISPLAY_FLAGS_SYNC_NEGEDGE = 4096,
};

struct timing_entry {
	u32 min;
	u32 typ;
	u32 max;
};

struct display_timing {
	struct timing_entry pixelclock;
	struct timing_entry hactive;
	struct timing_entry hfront_porch;
	struct timing_entry hback_porch;
	struct timing_entry hsync_len;
	struct timing_entry vactive;
	struct timing_entry vfront_porch;
	struct timing_entry vback_porch;
	struct timing_entry vsync_len;
	enum display_flags flags;
};

struct display_timings {
	unsigned int num_timings;
	unsigned int native_mode;
	struct display_timing **timings;
};

struct videomode {
	long unsigned int pixelclock;
	u32 hactive;
	u32 hfront_porch;
	u32 hback_porch;
	u32 hsync_len;
	u32 vactive;
	u32 vfront_porch;
	u32 vback_porch;
	u32 vsync_len;
	enum display_flags flags;
};

struct clk_bulk_devres {
	struct clk_bulk_data *clks;
	int num_clks;
};

struct clk_hw;

struct clk_lookup {
	struct list_head node;
	const char *dev_id;
	const char *con_id;
	struct clk *clk;
	struct clk_hw *clk_hw;
};

struct clk_core;

struct clk_init_data;

struct clk_hw {
	struct clk_core *core;
	struct clk *clk;
	const struct clk_init_data *init;
};

struct clk_rate_request {
	long unsigned int rate;
	long unsigned int min_rate;
	long unsigned int max_rate;
	long unsigned int best_parent_rate;
	struct clk_hw *best_parent_hw;
};

struct clk_duty {
	unsigned int num;
	unsigned int den;
};

struct clk_ops {
	int (*prepare)(struct clk_hw *);
	void (*unprepare)(struct clk_hw *);
	int (*is_prepared)(struct clk_hw *);
	void (*unprepare_unused)(struct clk_hw *);
	int (*enable)(struct clk_hw *);
	void (*disable)(struct clk_hw *);
	int (*is_enabled)(struct clk_hw *);
	void (*disable_unused)(struct clk_hw *);
	int (*save_context)(struct clk_hw *);
	void (*restore_context)(struct clk_hw *);
	long unsigned int (*recalc_rate)(struct clk_hw *, long unsigned int);
	long int (*round_rate)(struct clk_hw *, long unsigned int, long unsigned int *);
	int (*determine_rate)(struct clk_hw *, struct clk_rate_request *);
	int (*set_parent)(struct clk_hw *, u8);
	u8 (*get_parent)(struct clk_hw *);
	int (*set_rate)(struct clk_hw *, long unsigned int, long unsigned int);
	int (*set_rate_and_parent)(struct clk_hw *, long unsigned int, long unsigned int, u8);
	long unsigned int (*recalc_accuracy)(struct clk_hw *, long unsigned int);
	int (*get_phase)(struct clk_hw *);
	int (*set_phase)(struct clk_hw *, int);
	int (*get_duty_cycle)(struct clk_hw *, struct clk_duty *);
	int (*set_duty_cycle)(struct clk_hw *, struct clk_duty *);
	int (*init)(struct clk_hw *);
	void (*terminate)(struct clk_hw *);
	void (*debug_init)(struct clk_hw *, struct dentry *);
	int (*pre_rate_change)(struct clk_hw *, long unsigned int, long unsigned int);
	int (*post_rate_change)(struct clk_hw *, long unsigned int, long unsigned int);
};

struct clk_parent_data {
	const struct clk_hw *hw;
	const char *fw_name;
	const char *name;
	int index;
};

struct clk_init_data {
	const char *name;
	const struct clk_ops *ops;
	const char * const *parent_names;
	const struct clk_parent_data *parent_data;
	const struct clk_hw **parent_hws;
	u8 num_parents;
	long unsigned int flags;
};

struct clk_lookup_alloc {
	struct clk_lookup cl;
	char dev_id[20];
	char con_id[16];
};

struct clk_notifier {
	struct clk *clk;
	struct srcu_notifier_head notifier_head;
	struct list_head node;
};

struct clk {
	struct clk_core *core;
	struct device *dev;
	const char *dev_id;
	const char *con_id;
	long unsigned int min_rate;
	long unsigned int max_rate;
	unsigned int exclusive_count;
	struct hlist_node clks_node;
};

struct clk_notifier_data {
	struct clk *clk;
	long unsigned int old_rate;
	long unsigned int new_rate;
};

struct clk_parent_map;

struct clk_core {
	const char *name;
	const struct clk_ops *ops;
	struct clk_hw *hw;
	struct module *owner;
	struct device *dev;
	struct device_node *of_node;
	struct clk_core *parent;
	struct clk_parent_map *parents;
	u8 num_parents;
	u8 new_parent_index;
	long unsigned int rate;
	long unsigned int req_rate;
	long unsigned int new_rate;
	struct clk_core *new_parent;
	struct clk_core *new_child;
	long unsigned int flags;
	bool orphan;
	bool rpm_enabled;
	bool need_sync;
	bool boot_enabled;
	unsigned int enable_count;
	unsigned int prepare_count;
	unsigned int protect_count;
	long unsigned int min_rate;
	long unsigned int max_rate;
	long unsigned int accuracy;
	int phase;
	struct clk_duty duty;
	struct hlist_head children;
	struct hlist_node child_node;
	struct hlist_head clks;
	unsigned int notifier_count;
	struct dentry *dentry;
	struct hlist_node debug_node;
	struct kref ref;
};

struct clk_onecell_data {
	struct clk **clks;
	unsigned int clk_num;
};

struct clk_hw_onecell_data {
	unsigned int num;
	struct clk_hw *hws[0];
};

struct clk_parent_map {
	const struct clk_hw *hw;
	struct clk_core *core;
	const char *fw_name;
	const char *name;
	int index;
};

struct trace_event_raw_clk {
	struct trace_entry ent;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_clk_rate {
	struct trace_entry ent;
	u32 __data_loc_name;
	long unsigned int rate;
	char __data[0];
};

struct trace_event_raw_clk_parent {
	struct trace_entry ent;
	u32 __data_loc_name;
	u32 __data_loc_pname;
	char __data[0];
};

struct trace_event_raw_clk_phase {
	struct trace_entry ent;
	u32 __data_loc_name;
	int phase;
	char __data[0];
};

struct trace_event_raw_clk_duty_cycle {
	struct trace_entry ent;
	u32 __data_loc_name;
	unsigned int num;
	unsigned int den;
	char __data[0];
};

struct trace_event_data_offsets_clk {
	u32 name;
};

struct trace_event_data_offsets_clk_rate {
	u32 name;
};

struct trace_event_data_offsets_clk_parent {
	u32 name;
	u32 pname;
};

struct trace_event_data_offsets_clk_phase {
	u32 name;
};

struct trace_event_data_offsets_clk_duty_cycle {
	u32 name;
};

typedef void (*btf_trace_clk_enable)(void *, struct clk_core *);

typedef void (*btf_trace_clk_enable_complete)(void *, struct clk_core *);

typedef void (*btf_trace_clk_disable)(void *, struct clk_core *);

typedef void (*btf_trace_clk_disable_complete)(void *, struct clk_core *);

typedef void (*btf_trace_clk_prepare)(void *, struct clk_core *);

typedef void (*btf_trace_clk_prepare_complete)(void *, struct clk_core *);

typedef void (*btf_trace_clk_unprepare)(void *, struct clk_core *);

typedef void (*btf_trace_clk_unprepare_complete)(void *, struct clk_core *);

typedef void (*btf_trace_clk_set_rate)(void *, struct clk_core *, long unsigned int);

typedef void (*btf_trace_clk_set_rate_complete)(void *, struct clk_core *, long unsigned int);

typedef void (*btf_trace_clk_set_parent)(void *, struct clk_core *, struct clk_core *);

typedef void (*btf_trace_clk_set_parent_complete)(void *, struct clk_core *, struct clk_core *);

typedef void (*btf_trace_clk_set_phase)(void *, struct clk_core *, int);

typedef void (*btf_trace_clk_set_phase_complete)(void *, struct clk_core *, int);

typedef void (*btf_trace_clk_set_duty_cycle)(void *, struct clk_core *, struct clk_duty *);

typedef void (*btf_trace_clk_set_duty_cycle_complete)(void *, struct clk_core *, struct clk_duty *);

struct clk_notifier_devres {
	struct clk *clk;
	struct notifier_block *nb;
};

struct of_clk_provider {
	struct list_head link;
	struct device_node *node;
	struct clk * (*get)(struct of_phandle_args *, void *);
	struct clk_hw * (*get_hw)(struct of_phandle_args *, void *);
	void *data;
};

struct clock_provider {
	void (*clk_init_cb)(struct device_node *);
	struct device_node *np;
	struct list_head node;
};

struct clk_div_table {
	unsigned int val;
	unsigned int div;
};

struct clk_divider {
	struct clk_hw hw;
	void *reg;
	u8 shift;
	u8 width;
	u8 flags;
	const struct clk_div_table *table;
	spinlock_t *lock;
};

typedef void (*of_init_fn_1)(struct device_node *);

struct clk_fixed_factor {
	struct clk_hw hw;
	unsigned int mult;
	unsigned int div;
};

struct clk_fixed_rate {
	struct clk_hw hw;
	long unsigned int fixed_rate;
	long unsigned int fixed_accuracy;
	long unsigned int flags;
};

struct clk_gate {
	struct clk_hw hw;
	void *reg;
	u8 bit_idx;
	u8 flags;
	spinlock_t *lock;
};

struct clk_multiplier {
	struct clk_hw hw;
	void *reg;
	u8 shift;
	u8 width;
	u8 flags;
	spinlock_t *lock;
};

struct clk_mux {
	struct clk_hw hw;
	void *reg;
	u32 *table;
	u32 mask;
	u8 shift;
	u8 flags;
	spinlock_t *lock;
};

struct clk_composite {
	struct clk_hw hw;
	struct clk_ops ops;
	struct clk_hw *mux_hw;
	struct clk_hw *rate_hw;
	struct clk_hw *gate_hw;
	const struct clk_ops *mux_ops;
	const struct clk_ops *rate_ops;
	const struct clk_ops *gate_ops;
};

struct clk_fractional_divider {
	struct clk_hw hw;
	void *reg;
	u8 mshift;
	u8 mwidth;
	u32 mmask;
	u8 nshift;
	u8 nwidth;
	u32 nmask;
	u8 flags;
	void (*approximation)(struct clk_hw *, long unsigned int, long unsigned int *, long unsigned int *, long unsigned int *);
	spinlock_t *lock;
};

struct clk_gpio {
	struct clk_hw hw;
	struct gpio_desc *gpiod;
};

struct wrpll_cfg {
	u8 divr;
	u8 divq;
	u8 range;
	u8 flags;
	u16 divf;
	u32 output_rate_cache[6];
	long unsigned int parent_rate;
	u8 max_r;
	u8 init_r;
};

struct __prci_data {
	void *va;
	struct clk_hw_onecell_data hw_clks;
};

struct __prci_wrpll_data {
	struct wrpll_cfg c;
	void (*enable_bypass)(struct __prci_data *);
	void (*disable_bypass)(struct __prci_data *);
	u8 cfg0_offs;
};

struct __prci_clock {
	const char *name;
	const char *parent_name;
	const struct clk_ops *ops;
	struct clk_hw hw;
	struct __prci_wrpll_data *pwd;
	struct __prci_data *pd;
};

enum light_pll_outtype {
	LIGHT_PLL_VCO = 0,
	LIGHT_PLL_DIV = 1,
};

enum light_div_type {
	MUX_TYPE_DIV = 0,
	MUX_TYPE_CDE = 1,
};

enum light_pll_clktype {
	LIGHT_AUDIO_PLL = 0,
	LIGHT_SYS_PLL = 1,
	LIGHT_CPU_PLL0 = 2,
	LIGHT_CPU_PLL1 = 3,
	LIGHT_GMAC_PLL = 4,
	LIGHT_VIDEO_PLL = 5,
	LIGHT_DDR_PLL = 6,
	LIGHT_DPU0_PLL = 7,
	LIGHT_DPU1_PLL = 8,
};

struct light_pll_rate_table {
	long unsigned int vco_rate;
	long unsigned int rate;
	unsigned int refdiv;
	unsigned int fbdiv;
	unsigned int frac;
	unsigned int postdiv1;
	unsigned int postdiv2;
};

struct light_pll_clk {
	enum light_pll_outtype out_type;
	enum light_pll_clktype clk_type;
	const struct light_pll_rate_table *rate_table;
	int rate_count;
	int flags;
};

enum light_pll_mode {
	PLL_MODE_FRAC = 0,
	PLL_MODE_INT = 1,
};

struct clk_lightpll {
	struct clk_hw hw;
	void *base;
	enum light_pll_clktype clk_type;
	enum light_pll_outtype out_type;
	enum light_pll_mode pll_mode;
	const struct light_pll_rate_table *rate_table;
	int rate_count;
	u32 cfg0_reg_off;
	u32 pll_sts_off;
	int pll_lock_bit;
	int pll_rst_bit;
	int pll_bypass_bit;
};

struct clk_lightdiv {
	struct clk_divider divider;
	enum light_div_type div_type;
	u16 min_div;
	u16 max_div;
	u8 sync_en;
	const struct clk_ops *ops;
};

struct clk_lightgate {
	struct clk_gate gate;
	unsigned int *share_count;
	const struct clk_ops *ops;
};

struct thead_clk_gate {
	struct clk_hw hw;
	struct regmap *regmap;
	u32 offset;
	u8 bit;
	bool shared;
	u32 *share_count;
};

enum clk_gate_type {
	GATE_NOT_SHARED = 0,
	GATE_SHARED = 1,
};

typedef s32 dma_cookie_t;

enum dma_status {
	DMA_COMPLETE = 0,
	DMA_IN_PROGRESS = 1,
	DMA_PAUSED = 2,
	DMA_ERROR = 3,
	DMA_OUT_OF_ORDER = 4,
};

enum dma_transaction_type {
	DMA_MEMCPY = 0,
	DMA_XOR = 1,
	DMA_PQ = 2,
	DMA_XOR_VAL = 3,
	DMA_PQ_VAL = 4,
	DMA_MEMSET = 5,
	DMA_MEMSET_SG = 6,
	DMA_INTERRUPT = 7,
	DMA_PRIVATE = 8,
	DMA_ASYNC_TX = 9,
	DMA_SLAVE = 10,
	DMA_CYCLIC = 11,
	DMA_INTERLEAVE = 12,
	DMA_COMPLETION_NO_ORDER = 13,
	DMA_REPEAT = 14,
	DMA_LOAD_EOT = 15,
	DMA_TX_TYPE_END = 16,
};

enum dma_transfer_direction {
	DMA_MEM_TO_MEM = 0,
	DMA_MEM_TO_DEV = 1,
	DMA_DEV_TO_MEM = 2,
	DMA_DEV_TO_DEV = 3,
	DMA_TRANS_NONE = 4,
};

struct data_chunk {
	size_t size;
	size_t icg;
	size_t dst_icg;
	size_t src_icg;
};

struct dma_interleaved_template {
	dma_addr_t src_start;
	dma_addr_t dst_start;
	enum dma_transfer_direction dir;
	bool src_inc;
	bool dst_inc;
	bool src_sgl;
	bool dst_sgl;
	size_t numf;
	size_t frame_size;
	struct data_chunk sgl[0];
};

enum dma_ctrl_flags {
	DMA_PREP_INTERRUPT = 1,
	DMA_CTRL_ACK = 2,
	DMA_PREP_PQ_DISABLE_P = 4,
	DMA_PREP_PQ_DISABLE_Q = 8,
	DMA_PREP_CONTINUE = 16,
	DMA_PREP_FENCE = 32,
	DMA_CTRL_REUSE = 64,
	DMA_PREP_CMD = 128,
	DMA_PREP_REPEAT = 256,
	DMA_PREP_LOAD_EOT = 512,
};

enum sum_check_bits {
	SUM_CHECK_P = 0,
	SUM_CHECK_Q = 1,
};

enum sum_check_flags {
	SUM_CHECK_P_RESULT = 1,
	SUM_CHECK_Q_RESULT = 2,
};

typedef struct {
	long unsigned int bits[1];
} dma_cap_mask_t;

enum dma_desc_metadata_mode {
	DESC_METADATA_NONE = 0,
	DESC_METADATA_CLIENT = 1,
	DESC_METADATA_ENGINE = 2,
};

struct dma_chan_percpu {
	long unsigned int memcpy_count;
	long unsigned int bytes_transferred;
};

struct dma_router {
	struct device *dev;
	void (*route_free)(struct device *, void *);
};

struct dma_device;

struct dma_chan_dev;

struct dma_chan {
	struct dma_device *device;
	struct device *slave;
	dma_cookie_t cookie;
	dma_cookie_t completed_cookie;
	int chan_id;
	struct dma_chan_dev *dev;
	const char *name;
	char *dbg_client_name;
	struct list_head device_node;
	struct dma_chan_percpu *local;
	int client_count;
	int table_count;
	struct dma_router *router;
	void *route_data;
	void *private;
};

typedef bool (*dma_filter_fn)(struct dma_chan *, void *);

struct dma_slave_map;

struct dma_filter {
	dma_filter_fn fn;
	int mapcnt;
	const struct dma_slave_map *map;
};

enum dmaengine_alignment {
	DMAENGINE_ALIGN_1_BYTE = 0,
	DMAENGINE_ALIGN_2_BYTES = 1,
	DMAENGINE_ALIGN_4_BYTES = 2,
	DMAENGINE_ALIGN_8_BYTES = 3,
	DMAENGINE_ALIGN_16_BYTES = 4,
	DMAENGINE_ALIGN_32_BYTES = 5,
	DMAENGINE_ALIGN_64_BYTES = 6,
};

enum dma_residue_granularity {
	DMA_RESIDUE_GRANULARITY_DESCRIPTOR = 0,
	DMA_RESIDUE_GRANULARITY_SEGMENT = 1,
	DMA_RESIDUE_GRANULARITY_BURST = 2,
};

struct dma_async_tx_descriptor;

struct dma_slave_caps;

struct dma_slave_config;

struct dma_tx_state;

struct dma_device {
	struct kref ref;
	unsigned int chancnt;
	unsigned int privatecnt;
	struct list_head channels;
	struct list_head global_node;
	struct dma_filter filter;
	dma_cap_mask_t cap_mask;
	enum dma_desc_metadata_mode desc_metadata_modes;
	short unsigned int max_xor;
	short unsigned int max_pq;
	enum dmaengine_alignment copy_align;
	enum dmaengine_alignment xor_align;
	enum dmaengine_alignment pq_align;
	enum dmaengine_alignment fill_align;
	int dev_id;
	struct device *dev;
	struct module *owner;
	struct ida chan_ida;
	struct mutex chan_mutex;
	u32 src_addr_widths;
	u32 dst_addr_widths;
	u32 directions;
	u32 min_burst;
	u32 max_burst;
	u32 max_sg_burst;
	bool descriptor_reuse;
	enum dma_residue_granularity residue_granularity;
	int (*device_alloc_chan_resources)(struct dma_chan *);
	void (*device_free_chan_resources)(struct dma_chan *);
	struct dma_async_tx_descriptor * (*device_prep_dma_memcpy)(struct dma_chan *, dma_addr_t, dma_addr_t, size_t, long unsigned int);
	struct dma_async_tx_descriptor * (*device_prep_dma_xor)(struct dma_chan *, dma_addr_t, dma_addr_t *, unsigned int, size_t, long unsigned int);
	struct dma_async_tx_descriptor * (*device_prep_dma_xor_val)(struct dma_chan *, dma_addr_t *, unsigned int, size_t, enum sum_check_flags *, long unsigned int);
	struct dma_async_tx_descriptor * (*device_prep_dma_pq)(struct dma_chan *, dma_addr_t *, dma_addr_t *, unsigned int, const unsigned char *, size_t, long unsigned int);
	struct dma_async_tx_descriptor * (*device_prep_dma_pq_val)(struct dma_chan *, dma_addr_t *, dma_addr_t *, unsigned int, const unsigned char *, size_t, enum sum_check_flags *, long unsigned int);
	struct dma_async_tx_descriptor * (*device_prep_dma_memset)(struct dma_chan *, dma_addr_t, int, size_t, long unsigned int);
	struct dma_async_tx_descriptor * (*device_prep_dma_memset_sg)(struct dma_chan *, struct scatterlist *, unsigned int, int, long unsigned int);
	struct dma_async_tx_descriptor * (*device_prep_dma_interrupt)(struct dma_chan *, long unsigned int);
	struct dma_async_tx_descriptor * (*device_prep_slave_sg)(struct dma_chan *, struct scatterlist *, unsigned int, enum dma_transfer_direction, long unsigned int, void *);
	struct dma_async_tx_descriptor * (*device_prep_dma_cyclic)(struct dma_chan *, dma_addr_t, size_t, size_t, enum dma_transfer_direction, long unsigned int);
	struct dma_async_tx_descriptor * (*device_prep_interleaved_dma)(struct dma_chan *, struct dma_interleaved_template *, long unsigned int);
	struct dma_async_tx_descriptor * (*device_prep_dma_imm_data)(struct dma_chan *, dma_addr_t, u64, long unsigned int);
	void (*device_caps)(struct dma_chan *, struct dma_slave_caps *);
	int (*device_config)(struct dma_chan *, struct dma_slave_config *);
	int (*device_pause)(struct dma_chan *);
	int (*device_resume)(struct dma_chan *);
	int (*device_terminate_all)(struct dma_chan *);
	void (*device_synchronize)(struct dma_chan *);
	enum dma_status (*device_tx_status)(struct dma_chan *, dma_cookie_t, struct dma_tx_state *);
	void (*device_issue_pending)(struct dma_chan *);
	void (*device_release)(struct dma_device *);
	void (*dbg_summary_show)(struct seq_file *, struct dma_device *);
	struct dentry *dbg_dev_root;
};

struct dma_chan_dev {
	struct dma_chan *chan;
	struct device device;
	int dev_id;
};

enum dma_slave_buswidth {
	DMA_SLAVE_BUSWIDTH_UNDEFINED = 0,
	DMA_SLAVE_BUSWIDTH_1_BYTE = 1,
	DMA_SLAVE_BUSWIDTH_2_BYTES = 2,
	DMA_SLAVE_BUSWIDTH_3_BYTES = 3,
	DMA_SLAVE_BUSWIDTH_4_BYTES = 4,
	DMA_SLAVE_BUSWIDTH_8_BYTES = 8,
	DMA_SLAVE_BUSWIDTH_16_BYTES = 16,
	DMA_SLAVE_BUSWIDTH_32_BYTES = 32,
	DMA_SLAVE_BUSWIDTH_64_BYTES = 64,
};

struct dma_slave_config {
	enum dma_transfer_direction direction;
	phys_addr_t src_addr;
	phys_addr_t dst_addr;
	enum dma_slave_buswidth src_addr_width;
	enum dma_slave_buswidth dst_addr_width;
	u32 src_maxburst;
	u32 dst_maxburst;
	u32 src_port_window_size;
	u32 dst_port_window_size;
	bool device_fc;
	unsigned int slave_id;
	void *peripheral_config;
	size_t peripheral_size;
};

struct dma_slave_caps {
	u32 src_addr_widths;
	u32 dst_addr_widths;
	u32 directions;
	u32 min_burst;
	u32 max_burst;
	u32 max_sg_burst;
	bool cmd_pause;
	bool cmd_resume;
	bool cmd_terminate;
	enum dma_residue_granularity residue_granularity;
	bool descriptor_reuse;
};

typedef void (*dma_async_tx_callback)(void *);

enum dmaengine_tx_result {
	DMA_TRANS_NOERROR = 0,
	DMA_TRANS_READ_FAILED = 1,
	DMA_TRANS_WRITE_FAILED = 2,
	DMA_TRANS_ABORTED = 3,
};

struct dmaengine_result {
	enum dmaengine_tx_result result;
	u32 residue;
};

typedef void (*dma_async_tx_callback_result)(void *, const struct dmaengine_result *);

struct dmaengine_unmap_data {
	u16 map_cnt;
	u8 to_cnt;
	u8 from_cnt;
	u8 bidi_cnt;
	struct device *dev;
	struct kref kref;
	size_t len;
	dma_addr_t addr[0];
};

struct dma_descriptor_metadata_ops {
	int (*attach)(struct dma_async_tx_descriptor *, void *, size_t);
	void * (*get_ptr)(struct dma_async_tx_descriptor *, size_t *, size_t *);
	int (*set_len)(struct dma_async_tx_descriptor *, size_t);
};

struct dma_async_tx_descriptor {
	dma_cookie_t cookie;
	enum dma_ctrl_flags flags;
	dma_addr_t phys;
	struct dma_chan *chan;
	dma_cookie_t (*tx_submit)(struct dma_async_tx_descriptor *);
	int (*desc_free)(struct dma_async_tx_descriptor *);
	dma_async_tx_callback callback;
	dma_async_tx_callback_result callback_result;
	void *callback_param;
	struct dmaengine_unmap_data *unmap;
	enum dma_desc_metadata_mode desc_metadata_mode;
	struct dma_descriptor_metadata_ops *metadata_ops;
};

struct dma_tx_state {
	dma_cookie_t last;
	dma_cookie_t used;
	u32 residue;
	u32 in_flight_bytes;
};

struct dma_slave_map {
	const char *devname;
	const char *slave;
	void *param;
};

struct dma_chan_tbl_ent {
	struct dma_chan *chan;
};

struct dmaengine_unmap_pool {
	struct kmem_cache *cache;
	const char *name;
	mempool_t *pool;
	size_t size;
};

struct dmaengine_desc_callback {
	dma_async_tx_callback callback;
	dma_async_tx_callback_result callback_result;
	void *callback_param;
};

struct virt_dma_desc {
	struct dma_async_tx_descriptor tx;
	struct dmaengine_result tx_result;
	struct list_head node;
};

struct virt_dma_chan {
	struct dma_chan chan;
	struct tasklet_struct task;
	void (*desc_free)(struct virt_dma_desc *);
	spinlock_t lock;
	struct list_head desc_allocated;
	struct list_head desc_submitted;
	struct list_head desc_issued;
	struct list_head desc_completed;
	struct list_head desc_terminated;
	struct virt_dma_desc *cyclic;
};

struct of_dma {
	struct list_head of_dma_controllers;
	struct device_node *of_node;
	struct dma_chan * (*of_dma_xlate)(struct of_phandle_args *, struct of_dma *);
	void * (*of_dma_route_allocate)(struct of_phandle_args *, struct of_dma *);
	struct dma_router *dma_router;
	void *of_dma_data;
};

struct of_dma_filter_info {
	dma_cap_mask_t dma_cap;
	dma_filter_fn filter_fn;
};

struct dmatest_params {
	unsigned int buf_size;
	char channel[20];
	char device[32];
	unsigned int threads_per_chan;
	unsigned int max_channels;
	unsigned int iterations;
	unsigned int xor_sources;
	unsigned int pq_sources;
	int timeout;
	bool noverify;
	bool norandom;
	int alignment;
	unsigned int transfer_size;
	bool polled;
};

struct dmatest_info {
	struct dmatest_params params;
	struct list_head channels;
	unsigned int nr_channels;
	int last_error;
	struct mutex lock;
	bool did_init;
};

struct dmatest_done {
	bool done;
	wait_queue_head_t *wait;
};

struct dmatest_data {
	u8 **raw;
	u8 **aligned;
	unsigned int cnt;
	unsigned int off;
};

struct dmatest_thread {
	struct list_head node;
	struct dmatest_info *info;
	struct task_struct *task;
	struct dma_chan *chan;
	struct dmatest_data src;
	struct dmatest_data dst;
	enum dma_transaction_type type;
	wait_queue_head_t done_wait;
	struct dmatest_done test_done;
	bool done;
	bool pending;
};

struct dmatest_chan {
	struct list_head node;
	struct dma_chan *chan;
	struct list_head threads;
};

struct dw_axi_dma_hcfg {
	u32 nr_channels;
	u32 nr_masters;
	u32 m_data_width;
	u32 block_size[16];
	u32 priority[16];
	u32 axi_rw_burst_len;
	bool reg_map_8_channels;
	bool restrict_axi_burst_len;
};

struct dma_pool;

struct axi_dma_chip;

struct axi_dma_desc;

struct axi_dma_chan {
	struct axi_dma_chip *chip;
	void *chan_regs;
	u8 id;
	u8 hw_handshake_num;
	atomic_t descs_allocated;
	struct dma_pool *desc_pool;
	struct virt_dma_chan vc;
	struct axi_dma_desc *desc;
	struct dma_slave_config config;
	enum dma_transfer_direction direction;
	bool cyclic;
	bool is_paused;
};

struct dw_axi_dma;

struct axi_dma_chip {
	struct device *dev;
	int irq;
	void *regs;
	void *apb_regs;
	struct clk *core_clk;
	struct clk *cfgr_clk;
	struct dw_axi_dma *dw;
	spinlock_t lock;
};

struct axi_dma_hw_desc;

struct axi_dma_desc {
	struct axi_dma_hw_desc *hw_desc;
	struct virt_dma_desc vd;
	struct axi_dma_chan *chan;
	u32 completed_blocks;
	u32 length;
	u32 period_len;
};

struct dw_axi_dma {
	struct dma_device dma;
	struct dw_axi_dma_hcfg *hdata;
	struct device_dma_parameters dma_parms;
	struct axi_dma_chan *chan;
};

struct axi_dma_lli {
	__le64 sar;
	__le64 dar;
	__le32 block_ts_lo;
	__le32 block_ts_hi;
	__le64 llp;
	__le32 ctl_lo;
	__le32 ctl_hi;
	__le32 sstat;
	__le32 dstat;
	__le32 status_lo;
	__le32 status_hi;
	__le32 reserved_lo;
	__le32 reserved_hi;
};

struct axi_dma_hw_desc {
	struct axi_dma_lli *lli;
	dma_addr_t llp;
	u32 len;
};

enum {
	DWAXIDMAC_ARWLEN_1 = 0,
	DWAXIDMAC_ARWLEN_2 = 1,
	DWAXIDMAC_ARWLEN_4 = 3,
	DWAXIDMAC_ARWLEN_8 = 7,
	DWAXIDMAC_ARWLEN_16 = 15,
	DWAXIDMAC_ARWLEN_32 = 31,
	DWAXIDMAC_ARWLEN_64 = 63,
	DWAXIDMAC_ARWLEN_128 = 127,
	DWAXIDMAC_ARWLEN_256 = 255,
	DWAXIDMAC_ARWLEN_MIN = 0,
	DWAXIDMAC_ARWLEN_MAX = 255,
};

enum {
	DWAXIDMAC_BURST_TRANS_LEN_1 = 0,
	DWAXIDMAC_BURST_TRANS_LEN_4 = 1,
	DWAXIDMAC_BURST_TRANS_LEN_8 = 2,
	DWAXIDMAC_BURST_TRANS_LEN_16 = 3,
	DWAXIDMAC_BURST_TRANS_LEN_32 = 4,
	DWAXIDMAC_BURST_TRANS_LEN_64 = 5,
	DWAXIDMAC_BURST_TRANS_LEN_128 = 6,
	DWAXIDMAC_BURST_TRANS_LEN_256 = 7,
	DWAXIDMAC_BURST_TRANS_LEN_512 = 8,
	DWAXIDMAC_BURST_TRANS_LEN_1024 = 9,
};

enum {
	DWAXIDMAC_CH_CTL_L_INC = 0,
	DWAXIDMAC_CH_CTL_L_NOINC = 1,
};

enum {
	DWAXIDMAC_HS_SEL_HW = 0,
	DWAXIDMAC_HS_SEL_SW = 1,
};

enum {
	DWAXIDMAC_TT_FC_MEM_TO_MEM_DMAC = 0,
	DWAXIDMAC_TT_FC_MEM_TO_PER_DMAC = 1,
	DWAXIDMAC_TT_FC_PER_TO_MEM_DMAC = 2,
	DWAXIDMAC_TT_FC_PER_TO_PER_DMAC = 3,
	DWAXIDMAC_TT_FC_PER_TO_MEM_SRC = 4,
	DWAXIDMAC_TT_FC_PER_TO_PER_SRC = 5,
	DWAXIDMAC_TT_FC_MEM_TO_PER_DST = 6,
	DWAXIDMAC_TT_FC_PER_TO_PER_DST = 7,
};

enum {
	DWAXIDMAC_MBLK_TYPE_CONTIGUOUS = 0,
	DWAXIDMAC_MBLK_TYPE_RELOAD = 1,
	DWAXIDMAC_MBLK_TYPE_SHADOW_REG = 2,
	DWAXIDMAC_MBLK_TYPE_LL = 3,
};

enum {
	DWAXIDMAC_IRQ_NONE = 0,
	DWAXIDMAC_IRQ_BLOCK_TRF = 1,
	DWAXIDMAC_IRQ_DMA_TRF = 2,
	DWAXIDMAC_IRQ_SRC_TRAN = 8,
	DWAXIDMAC_IRQ_DST_TRAN = 16,
	DWAXIDMAC_IRQ_SRC_DEC_ERR = 32,
	DWAXIDMAC_IRQ_DST_DEC_ERR = 64,
	DWAXIDMAC_IRQ_SRC_SLV_ERR = 128,
	DWAXIDMAC_IRQ_DST_SLV_ERR = 256,
	DWAXIDMAC_IRQ_LLI_RD_DEC_ERR = 512,
	DWAXIDMAC_IRQ_LLI_WR_DEC_ERR = 1024,
	DWAXIDMAC_IRQ_LLI_RD_SLV_ERR = 2048,
	DWAXIDMAC_IRQ_LLI_WR_SLV_ERR = 4096,
	DWAXIDMAC_IRQ_INVALID_ERR = 8192,
	DWAXIDMAC_IRQ_MULTIBLKTYPE_ERR = 16384,
	DWAXIDMAC_IRQ_DEC_ERR = 65536,
	DWAXIDMAC_IRQ_WR2RO_ERR = 131072,
	DWAXIDMAC_IRQ_RD2RWO_ERR = 262144,
	DWAXIDMAC_IRQ_WRONCHEN_ERR = 524288,
	DWAXIDMAC_IRQ_SHADOWREG_ERR = 1048576,
	DWAXIDMAC_IRQ_WRONHOLD_ERR = 2097152,
	DWAXIDMAC_IRQ_LOCK_CLEARED = 134217728,
	DWAXIDMAC_IRQ_SRC_SUSPENDED = 268435456,
	DWAXIDMAC_IRQ_SUSPENDED = 536870912,
	DWAXIDMAC_IRQ_DISABLED = 1073741824,
	DWAXIDMAC_IRQ_ABORTED = 2147483648,
	DWAXIDMAC_IRQ_ALL_ERR = 4161504,
	DWAXIDMAC_IRQ_ALL = 4294967295,
};

enum {
	DWAXIDMAC_TRANS_WIDTH_8 = 0,
	DWAXIDMAC_TRANS_WIDTH_16 = 1,
	DWAXIDMAC_TRANS_WIDTH_32 = 2,
	DWAXIDMAC_TRANS_WIDTH_64 = 3,
	DWAXIDMAC_TRANS_WIDTH_128 = 4,
	DWAXIDMAC_TRANS_WIDTH_256 = 5,
	DWAXIDMAC_TRANS_WIDTH_512 = 6,
	DWAXIDMAC_TRANS_WIDTH_MAX = 6,
};

struct light_iopmp_entry {
	u32 reg_start[16];
	u32 reg_end[16];
	u32 entry_valid_num;
};

struct light_iopmp_cur_sys_entry {
	int iopmp_type;
	u32 start_addr;
	u32 end_addr;
	u32 attr;
	int lock;
};

struct light_iopmp_list;

struct light_iopmp_info {
	struct device *dev;
	int entries;
	struct light_iopmp_list *iopmp_list;
	struct light_iopmp_cur_sys_entry cur_entry;
	struct light_iopmp_entry iopmp_entry[0];
};

struct light_iopmp_list {
	int iopmp_type;
	resource_size_t offset;
	void *base;
};

struct light_iopmp_driver_data {
	struct light_iopmp_list *iopmp_list;
};

enum light_aon_rpc_svc {
	LIGHT_AON_RPC_SVC_UNKNOWN = 0,
	LIGHT_AON_RPC_SVC_RETURN = 1,
	LIGHT_AON_RPC_SVC_PM = 2,
	LIGHT_AON_RPC_SVC_MISC = 3,
	LIGHT_AON_RPC_SVC_AVFS = 4,
};

enum light_aon_misc_func {
	LIGHT_AON_MISC_FUNC_UNKNOWN = 0,
	LIGHT_AON_MISC_FUNC_SET_CONTROL = 1,
	LIGHT_AON_MISC_FUNC_GET_CONTROL = 2,
	LIGHT_AON_MISC_FUNC_WDG_START = 3,
	LIGHT_AON_MISC_FUNC_WDG_STOP = 4,
	LIGHT_AON_MISC_FUNC_WDG_PING = 5,
	LIGHT_AON_MISC_FUNC_WDG_TIMEOUTSET = 6,
	LIGHT_AON_MISC_FUNC_WDG_RESTART = 7,
	LIGHT_AON_MISC_FUNC_WDG_GET_STATE = 8,
	LIGHT_AON_MISC_FUNC_WDG_POWER_OFF = 9,
	LIGHT_AON_MISC_FUNC_AON_WDT_ON = 10,
	LIGHT_AON_MISC_FUNC_AON_WDT_OFF = 11,
	LIGHT_AON_MISC_FUNC_AON_RESERVE_MEM = 12,
};

struct light_aon_rpc_msg_hdr {
	uint8_t ver;
	uint8_t size;
	uint8_t svc;
	uint8_t func;
};

struct light_aon_msg_event_ctrl {
	struct light_aon_rpc_msg_hdr hdr;
	u32 reserve_offset;
	u32 reserved[5];
};

struct light_aon_ipc;

struct light_event {
	struct device *dev;
	struct light_aon_ipc *ipc_handle;
	struct light_aon_msg_event_ctrl msg;
	struct regmap *aon_iram;
	bool init;
};

struct virtio_driver {
	struct device_driver driver;
	const struct virtio_device_id *id_table;
	const unsigned int *feature_table;
	unsigned int feature_table_size;
	const unsigned int *feature_table_legacy;
	unsigned int feature_table_size_legacy;
	int (*validate)(struct virtio_device *);
	int (*probe)(struct virtio_device *);
	void (*scan)(struct virtio_device *);
	void (*remove)(struct virtio_device *);
	void (*config_changed)(struct virtio_device *);
	int (*freeze)(struct virtio_device *);
	int (*restore)(struct virtio_device *);
};

typedef __u16 __virtio16;

typedef __u32 __virtio32;

typedef __u64 __virtio64;

struct vring_desc {
	__virtio64 addr;
	__virtio32 len;
	__virtio16 flags;
	__virtio16 next;
};

struct vring_avail {
	__virtio16 flags;
	__virtio16 idx;
	__virtio16 ring[0];
};

struct vring_used_elem {
	__virtio32 id;
	__virtio32 len;
};

typedef struct vring_used_elem vring_used_elem_t;

struct vring_used {
	__virtio16 flags;
	__virtio16 idx;
	vring_used_elem_t ring[0];
};

typedef struct vring_desc vring_desc_t;

typedef struct vring_avail vring_avail_t;

typedef struct vring_used vring_used_t;

struct vring {
	unsigned int num;
	vring_desc_t *desc;
	vring_avail_t *avail;
	vring_used_t *used;
};

struct vring_packed_desc_event {
	__le16 off_wrap;
	__le16 flags;
};

struct vring_packed_desc {
	__le64 addr;
	__le32 len;
	__le16 id;
	__le16 flags;
};

struct vring_desc_state_split {
	void *data;
	struct vring_desc *indir_desc;
};

struct vring_desc_state_packed {
	void *data;
	struct vring_packed_desc *indir_desc;
	u16 num;
	u16 next;
	u16 last;
};

struct vring_desc_extra_packed {
	dma_addr_t addr;
	u32 len;
	u16 flags;
};

struct vring_virtqueue {
	struct virtqueue vq;
	bool packed_ring;
	bool use_dma_api;
	bool weak_barriers;
	bool broken;
	bool indirect;
	bool event;
	unsigned int free_head;
	unsigned int num_added;
	u16 last_used_idx;
	union {
		struct {
			struct vring vring;
			u16 avail_flags_shadow;
			u16 avail_idx_shadow;
			struct vring_desc_state_split *desc_state;
			dma_addr_t queue_dma_addr;
			size_t queue_size_in_bytes;
		} split;
		struct {
			struct {
				unsigned int num;
				struct vring_packed_desc *desc;
				struct vring_packed_desc_event *driver;
				struct vring_packed_desc_event *device;
			} vring;
			bool avail_wrap_counter;
			bool used_wrap_counter;
			u16 avail_used_flags;
			u16 next_avail_idx;
			u16 event_flags_shadow;
			struct vring_desc_state_packed *desc_state;
			struct vring_desc_extra_packed *desc_extra;
			dma_addr_t ring_dma_addr;
			dma_addr_t driver_event_dma_addr;
			dma_addr_t device_event_dma_addr;
			size_t ring_size_in_bytes;
			size_t event_size_in_bytes;
		} packed;
	};
	bool (*notify)(struct virtqueue *);
	bool we_own_ring;
};

struct virtio_mmio_device {
	struct virtio_device vdev;
	struct platform_device *pdev;
	void *base;
	long unsigned int version;
	spinlock_t lock;
	struct list_head virtqueues;
};

struct virtio_mmio_vq_info {
	struct virtqueue *vq;
	struct list_head node;
};

struct virtio_khv_mmio_device {
	struct virtio_device vdev;
	struct platform_device *pdev;
	u64 base;
	long unsigned int version;
	spinlock_t lock;
	struct list_head virtqueues;
};

struct virtio_khv_mmio_vq_info {
	struct virtqueue *vq;
	struct list_head node;
};

struct mmio_khv_device {
	void *base;
	volatile unsigned char *notify_host_reg;
	u32 notify_host_reg_val;
	volatile unsigned char *notify_guest_reg;
	u32 notify_guest_reg_clr;
};

struct virtio_light_device {
	struct virtio_device vdev;
	struct platform_device *pdev;
	void *base;
	long unsigned int version;
	spinlock_t lock;
	struct list_head virtqueues;
	volatile unsigned char *backend_intr_reg;
	volatile unsigned char *frontend_intr_reg;
	u32 enable_intr;
	u32 clear_intr;
};

struct virtio_light_vq_info {
	struct virtqueue *vq;
	struct list_head node;
};

struct dma_fence_ops;

struct dma_fence {
	spinlock_t *lock;
	const struct dma_fence_ops *ops;
	union {
		struct list_head cb_list;
		ktime_t timestamp;
		struct callback_head rcu;
	};
	u64 context;
	u64 seqno;
	long unsigned int flags;
	struct kref refcount;
	int error;
};

struct dma_fence_ops {
	bool use_64bit_seqno;
	const char * (*get_driver_name)(struct dma_fence *);
	const char * (*get_timeline_name)(struct dma_fence *);
	bool (*enable_signaling)(struct dma_fence *);
	bool (*signaled)(struct dma_fence *);
	long int (*wait)(struct dma_fence *, bool, long int);
	void (*release)(struct dma_fence *);
	void (*fence_value_str)(struct dma_fence *, char *, int);
	void (*timeline_value_str)(struct dma_fence *, char *, int);
};

struct dma_fence_cb;

typedef void (*dma_fence_func_t)(struct dma_fence *, struct dma_fence_cb *);

struct dma_fence_cb {
	struct list_head node;
	dma_fence_func_t func;
};

struct dma_buf;

struct dma_buf_attachment;

struct dma_buf_ops {
	bool cache_sgt_mapping;
	int (*attach)(struct dma_buf *, struct dma_buf_attachment *);
	void (*detach)(struct dma_buf *, struct dma_buf_attachment *);
	int (*pin)(struct dma_buf_attachment *);
	void (*unpin)(struct dma_buf_attachment *);
	struct sg_table * (*map_dma_buf)(struct dma_buf_attachment *, enum dma_data_direction);
	void (*unmap_dma_buf)(struct dma_buf_attachment *, struct sg_table *, enum dma_data_direction);
	void (*release)(struct dma_buf *);
	int (*begin_cpu_access)(struct dma_buf *, enum dma_data_direction);
	int (*begin_cpu_access_partial)(struct dma_buf *, enum dma_data_direction, unsigned int, unsigned int);
	int (*end_cpu_access)(struct dma_buf *, enum dma_data_direction);
	int (*end_cpu_access_partial)(struct dma_buf *, enum dma_data_direction, unsigned int, unsigned int);
	int (*mmap)(struct dma_buf *, struct vm_area_struct *);
	void * (*vmap)(struct dma_buf *);
	void (*vunmap)(struct dma_buf *, void *);
	int (*get_uuid)(struct dma_buf *, uuid_t *);
	int (*get_flags)(struct dma_buf *, long unsigned int *);
};

struct dma_buf_poll_cb_t {
	struct dma_fence_cb cb;
	wait_queue_head_t *poll;
	__poll_t active;
};

struct dma_resv;

struct dma_buf {
	size_t size;
	struct file *file;
	struct list_head attachments;
	const struct dma_buf_ops *ops;
	struct mutex lock;
	unsigned int vmapping_counter;
	void *vmap_ptr;
	const char *exp_name;
	const char *name;
	spinlock_t name_lock;
	struct module *owner;
	struct list_head list_node;
	void *priv;
	struct dma_resv *resv;
	wait_queue_head_t poll;
	struct dma_buf_poll_cb_t cb_excl;
	struct dma_buf_poll_cb_t cb_shared;
};

struct dma_buf_attach_ops;

struct dma_buf_attachment {
	struct dma_buf *dmabuf;
	struct device *dev;
	struct list_head node;
	struct sg_table *sgt;
	enum dma_data_direction dir;
	bool peer2peer;
	const struct dma_buf_attach_ops *importer_ops;
	void *importer_priv;
	void *priv;
	long unsigned int dma_map_attrs;
};

struct dma_buf_attach_ops {
	bool allow_peer2peer;
	void (*move_notify)(struct dma_buf_attachment *);
};

struct dma_buf_export_info {
	const char *exp_name;
	struct module *owner;
	const struct dma_buf_ops *ops;
	size_t size;
	int flags;
	struct dma_resv *resv;
	void *priv;
};

struct virtio_vdmabuf_alloc {
	size_t size;
	int align;
	void *uaddr;
	int fd;
	unsigned int buf_id;
	int heap_type;
	int carveout_type;
	int flags;
};

struct virtio_vdmabuf_import {
	unsigned int buf_id;
	int fd;
	size_t size;
};

enum virtio_vdmabuf_heap_type {
	VIRTIO_VDMABUF_HEAP_TYPE_USER = 0,
	VIRTIO_VDMABUF_HEAP_TYPE_SYSTEM = 1,
	VIRTIO_VDMABUF_HEAP_TYPE_SYSTEM_CONTIG = 2,
	VIRTIO_VDMABUF_HEAP_TYPE_CARVEOUT = 3,
	VIRTIO_VDMABUF_HEAP_NUM_HEAPS = 4,
};

enum virtio_vdmabuf_carveout_id {
	VIRTIO_VDMABUF_CARVEOUT_TYPE_VI = 0,
	VIRTIO_VDMABUF_CARVEOUT_TYPE_VO = 1,
	VIRTIO_VDMABUF_CARVEOUT_TYPE_ENC = 2,
	VIRTIO_VDMABUF_CARVEOUT_TYPE_DEC = 3,
	VIRTIO_VDMABUF_CARVEOUT_TYPE_GPU = 4,
	VIRTIO_VDMABUF_CARVEOUT_TYPE_DPU = 5,
	VIRTIO_VDMABUF_CARVEOUTS_NUM = 6,
};

enum vhost_uaddr_type {
	VHOST_ADDR_DESC = 0,
	VHOST_ADDR_AVAIL = 1,
	VHOST_ADDR_USED = 2,
	VHOST_NUM_ADDRS = 3,
};

struct buf_pair {
	struct page *page;
	phys_addr_t addr;
	unsigned int size;
};

struct virtio_vdmabuf_buf {
	int vmid;
	size_t size;
	unsigned int buf_id;
	struct mutex lock;
	struct list_head attachments;
	struct dma_buf *dma_buf;
	bool valid;
	bool imported;
	size_t sz_priv;
	void *priv;
	void *host;
	struct hlist_node node;
	int heap_type;
	int carveout_type;
	int flags;
	int bp_num;
	struct buf_pair bp[0];
};

struct virtio_vdmabuf_attachment {
	struct device *dev;
	struct sg_table *sgt;
	struct list_head list;
};

struct carveout_buf {
	phys_addr_t addr;
	unsigned int size;
	bool ready;
};

struct virtio_vdmabuf_event {
	struct list_head list;
	unsigned int op[6];
	struct buf_pair bp[0];
};

struct virtio_vdmabuf_event_queue {
	wait_queue_head_t e_wait;
	struct list_head e_list;
	spinlock_t e_lock;
	struct mutex e_readlock;
};

struct virtio_vdmabuf_info {
	struct device *dev;
	struct list_head head_vdmabuf_list;
	struct list_head kvm_instances;
	spinlock_t local_lock;
	struct hlist_head buf_list_local[128];
	spinlock_t import_lock;
	struct hlist_head buf_list_import[128];
	void *priv;
	struct mutex g_mutex;
	bool host_ready;
};

struct virtio_vdmabuf;

typedef int (*virtio_vdmabuf_ioctl_t)(struct virtio_vdmabuf *, void *);

struct virtio_vdmabuf {
	struct virtio_device *vdev;
	struct virtqueue *vqs[2];
	unsigned int vmid;
	spinlock_t vq_lock;
	struct mutex recv_lock;
	struct mutex send_lock;
	spinlock_t msg_list_lock;
	struct list_head msg_list;
	struct workqueue_struct *wq;
	struct work_struct recv_work;
	struct work_struct send_work;
	struct work_struct send_msg_work;
	struct virtio_vdmabuf_event_queue *eq_import;
};

struct virtio_vdmabuf_ioctl_desc {
	unsigned int cmd;
	int flags;
	virtio_vdmabuf_ioctl_t func;
	const char *name;
};

struct virtio_vdmabuf_msg {
	struct list_head list;
	unsigned int cmd;
	unsigned int op[6];
	struct buf_pair bp[0];
};

enum {
	VDMABUF_VQ_RECV = 0,
	VDMABUF_VQ_SEND = 1,
	VDMABUF_VQ_MAX = 2,
};

enum virtio_vdmabuf_cmd {
	VIRTIO_VDMABUF_CMD_VMID_REQ = 0,
	VIRTIO_VDMABUF_CMD_VMID_REPLY = 1,
	VIRTIO_VDMABUF_CMD_IMPORT_REQ = 2,
	VIRTIO_VDMABUF_CMD_IMPORT_REPLY = 3,
	VIRTIO_VDMABUF_CMD_REL_NOTIFY = 4,
};

struct ww_class {
	atomic_long_t stamp;
	struct lock_class_key acquire_key;
	struct lock_class_key mutex_key;
	const char *acquire_name;
	const char *mutex_name;
	unsigned int is_wait_die;
};

struct regulator_state {
	int uV;
	int min_uV;
	int max_uV;
	unsigned int mode;
	int enabled;
	bool changeable;
};

struct regulation_constraints {
	const char *name;
	int min_uV;
	int max_uV;
	int uV_offset;
	int min_uA;
	int max_uA;
	int ilim_uA;
	int system_load;
	u32 *max_spread;
	int max_uV_step;
	unsigned int valid_modes_mask;
	unsigned int valid_ops_mask;
	int input_uV;
	struct regulator_state state_disk;
	struct regulator_state state_mem;
	struct regulator_state state_standby;
	suspend_state_t initial_state;
	unsigned int initial_mode;
	unsigned int ramp_delay;
	unsigned int settling_time;
	unsigned int settling_time_up;
	unsigned int settling_time_down;
	unsigned int enable_time;
	unsigned int active_discharge;
	unsigned int always_on: 1;
	unsigned int boot_on: 1;
	unsigned int apply_uV: 1;
	unsigned int ramp_disable: 1;
	unsigned int soft_start: 1;
	unsigned int pull_down: 1;
	unsigned int over_current_protection: 1;
};

struct regulator_consumer_supply;

struct regulator_init_data {
	const char *supply_regulator;
	struct regulation_constraints constraints;
	int num_consumer_supplies;
	struct regulator_consumer_supply *consumer_supplies;
	int (*regulator_init)(void *);
	void *driver_data;
};

enum regulator_type {
	REGULATOR_VOLTAGE = 0,
	REGULATOR_CURRENT = 1,
};

struct regulator_config;

struct regulator_ops;

struct regulator_desc {
	const char *name;
	const char *supply_name;
	const char *of_match;
	bool of_match_full_name;
	const char *regulators_node;
	int (*of_parse_cb)(struct device_node *, const struct regulator_desc *, struct regulator_config *);
	int id;
	unsigned int continuous_voltage_range: 1;
	unsigned int n_voltages;
	unsigned int n_current_limits;
	const struct regulator_ops *ops;
	int irq;
	enum regulator_type type;
	struct module *owner;
	unsigned int min_uV;
	unsigned int uV_step;
	unsigned int linear_min_sel;
	int fixed_uV;
	unsigned int ramp_delay;
	int min_dropout_uV;
	const struct linear_range *linear_ranges;
	const unsigned int *linear_range_selectors;
	int n_linear_ranges;
	const unsigned int *volt_table;
	const unsigned int *curr_table;
	unsigned int vsel_range_reg;
	unsigned int vsel_range_mask;
	unsigned int vsel_reg;
	unsigned int vsel_mask;
	unsigned int vsel_step;
	unsigned int csel_reg;
	unsigned int csel_mask;
	unsigned int apply_reg;
	unsigned int apply_bit;
	unsigned int enable_reg;
	unsigned int enable_mask;
	unsigned int enable_val;
	unsigned int disable_val;
	bool enable_is_inverted;
	unsigned int bypass_reg;
	unsigned int bypass_mask;
	unsigned int bypass_val_on;
	unsigned int bypass_val_off;
	unsigned int active_discharge_on;
	unsigned int active_discharge_off;
	unsigned int active_discharge_mask;
	unsigned int active_discharge_reg;
	unsigned int soft_start_reg;
	unsigned int soft_start_mask;
	unsigned int soft_start_val_on;
	unsigned int pull_down_reg;
	unsigned int pull_down_mask;
	unsigned int pull_down_val_on;
	unsigned int enable_time;
	unsigned int off_on_delay;
	unsigned int poll_enabled_time;
	unsigned int (*of_map_mode)(unsigned int);
};

struct pre_voltage_change_data {
	long unsigned int old_uV;
	long unsigned int min_uV;
	long unsigned int max_uV;
};

struct regulator_bulk_data {
	const char *supply;
	struct regulator *consumer;
	int ret;
};

struct regulator_voltage {
	int min_uV;
	int max_uV;
};

struct regulator_dev;

struct regulator {
	struct device *dev;
	struct list_head list;
	unsigned int always_on: 1;
	unsigned int bypass: 1;
	unsigned int device_link: 1;
	int uA_load;
	unsigned int enable_count;
	unsigned int deferred_disables;
	struct regulator_voltage voltage[5];
	const char *supply_name;
	struct device_attribute dev_attr;
	struct regulator_dev *rdev;
	struct dentry *debugfs;
};

struct regulator_coupler {
	struct list_head list;
	int (*attach_regulator)(struct regulator_coupler *, struct regulator_dev *);
	int (*detach_regulator)(struct regulator_coupler *, struct regulator_dev *);
	int (*balance_voltage)(struct regulator_coupler *, struct regulator_dev *, suspend_state_t);
};

struct coupling_desc {
	struct regulator_dev **coupled_rdevs;
	struct regulator_coupler *coupler;
	int n_resolved;
	int n_coupled;
};

struct regulator_enable_gpio;

struct regulator_dev {
	const struct regulator_desc *desc;
	int exclusive;
	u32 use_count;
	u32 open_count;
	u32 bypass_count;
	struct list_head list;
	struct list_head consumer_list;
	struct coupling_desc coupling_desc;
	struct blocking_notifier_head notifier;
	struct ww_mutex mutex;
	struct task_struct *mutex_owner;
	int ref_cnt;
	struct module *owner;
	struct device dev;
	struct regulation_constraints *constraints;
	struct regulator *supply;
	const char *supply_name;
	struct regmap *regmap;
	struct delayed_work disable_work;
	void *reg_data;
	struct dentry *debugfs;
	struct regulator_enable_gpio *ena_pin;
	unsigned int ena_gpio_state: 1;
	unsigned int is_switch: 1;
	long unsigned int last_off_jiffy;
};

enum regulator_status {
	REGULATOR_STATUS_OFF = 0,
	REGULATOR_STATUS_ON = 1,
	REGULATOR_STATUS_ERROR = 2,
	REGULATOR_STATUS_FAST = 3,
	REGULATOR_STATUS_NORMAL = 4,
	REGULATOR_STATUS_IDLE = 5,
	REGULATOR_STATUS_STANDBY = 6,
	REGULATOR_STATUS_BYPASS = 7,
	REGULATOR_STATUS_UNDEFINED = 8,
};

struct regulator_ops {
	int (*list_voltage)(struct regulator_dev *, unsigned int);
	int (*set_voltage)(struct regulator_dev *, int, int, unsigned int *);
	int (*map_voltage)(struct regulator_dev *, int, int);
	int (*set_voltage_sel)(struct regulator_dev *, unsigned int);
	int (*get_voltage)(struct regulator_dev *);
	int (*get_voltage_sel)(struct regulator_dev *);
	int (*set_current_limit)(struct regulator_dev *, int, int);
	int (*get_current_limit)(struct regulator_dev *);
	int (*set_input_current_limit)(struct regulator_dev *, int);
	int (*set_over_current_protection)(struct regulator_dev *);
	int (*set_active_discharge)(struct regulator_dev *, bool);
	int (*enable)(struct regulator_dev *);
	int (*disable)(struct regulator_dev *);
	int (*is_enabled)(struct regulator_dev *);
	int (*set_mode)(struct regulator_dev *, unsigned int);
	unsigned int (*get_mode)(struct regulator_dev *);
	int (*get_error_flags)(struct regulator_dev *, unsigned int *);
	int (*enable_time)(struct regulator_dev *);
	int (*set_ramp_delay)(struct regulator_dev *, int);
	int (*set_voltage_time)(struct regulator_dev *, int, int);
	int (*set_voltage_time_sel)(struct regulator_dev *, unsigned int, unsigned int);
	int (*set_soft_start)(struct regulator_dev *);
	int (*get_status)(struct regulator_dev *);
	unsigned int (*get_optimum_mode)(struct regulator_dev *, int, int, int);
	int (*set_load)(struct regulator_dev *, int);
	int (*set_bypass)(struct regulator_dev *, bool);
	int (*get_bypass)(struct regulator_dev *, bool *);
	int (*set_suspend_voltage)(struct regulator_dev *, int);
	int (*set_suspend_enable)(struct regulator_dev *);
	int (*set_suspend_disable)(struct regulator_dev *);
	int (*set_suspend_mode)(struct regulator_dev *, unsigned int);
	int (*resume)(struct regulator_dev *);
	int (*set_pull_down)(struct regulator_dev *);
};

struct regulator_config {
	struct device *dev;
	const struct regulator_init_data *init_data;
	void *driver_data;
	struct device_node *of_node;
	struct regmap *regmap;
	struct gpio_desc *ena_gpiod;
};

struct regulator_enable_gpio {
	struct list_head list;
	struct gpio_desc *gpiod;
	u32 enable_count;
	u32 request_count;
};

enum regulator_active_discharge {
	REGULATOR_ACTIVE_DISCHARGE_DEFAULT = 0,
	REGULATOR_ACTIVE_DISCHARGE_DISABLE = 1,
	REGULATOR_ACTIVE_DISCHARGE_ENABLE = 2,
};

struct regulator_consumer_supply {
	const char *dev_name;
	const char *supply;
};

struct trace_event_raw_regulator_basic {
	struct trace_entry ent;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_regulator_range {
	struct trace_entry ent;
	u32 __data_loc_name;
	int min;
	int max;
	char __data[0];
};

struct trace_event_raw_regulator_value {
	struct trace_entry ent;
	u32 __data_loc_name;
	unsigned int val;
	char __data[0];
};

struct trace_event_data_offsets_regulator_basic {
	u32 name;
};

struct trace_event_data_offsets_regulator_range {
	u32 name;
};

struct trace_event_data_offsets_regulator_value {
	u32 name;
};

typedef void (*btf_trace_regulator_enable)(void *, const char *);

typedef void (*btf_trace_regulator_enable_delay)(void *, const char *);

typedef void (*btf_trace_regulator_enable_complete)(void *, const char *);

typedef void (*btf_trace_regulator_disable)(void *, const char *);

typedef void (*btf_trace_regulator_disable_complete)(void *, const char *);

typedef void (*btf_trace_regulator_bypass_enable)(void *, const char *);

typedef void (*btf_trace_regulator_bypass_enable_complete)(void *, const char *);

typedef void (*btf_trace_regulator_bypass_disable)(void *, const char *);

typedef void (*btf_trace_regulator_bypass_disable_complete)(void *, const char *);

typedef void (*btf_trace_regulator_set_voltage)(void *, const char *, int, int);

typedef void (*btf_trace_regulator_set_voltage_complete)(void *, const char *, unsigned int);

enum regulator_get_type {
	NORMAL_GET = 0,
	EXCLUSIVE_GET = 1,
	OPTIONAL_GET = 2,
	MAX_GET_TYPE = 3,
};

struct regulator_map {
	struct list_head list;
	const char *dev_name;
	const char *supply;
	struct regulator_dev *regulator;
};

struct regulator_supply_alias {
	struct list_head list;
	struct device *src_dev;
	const char *src_supply;
	struct device *alias_dev;
	const char *alias_supply;
};

struct summary_data {
	struct seq_file *s;
	struct regulator_dev *parent;
	int level;
};

struct summary_lock_data {
	struct ww_acquire_ctx *ww_ctx;
	struct regulator_dev **new_contended_rdev;
	struct regulator_dev **old_contended_rdev;
};

struct fixed_voltage_config {
	const char *supply_name;
	const char *input_supply;
	int microvolts;
	unsigned int startup_delay;
	unsigned int off_on_delay;
	unsigned int enabled_at_boot: 1;
	struct regulator_init_data *init_data;
};

struct fixed_regulator_data {
	struct fixed_voltage_config cfg;
	struct regulator_init_data init_data;
	struct platform_device pdev;
};

struct regulator_bulk_devres {
	struct regulator_bulk_data *consumers;
	int num_consumers;
};

struct regulator_supply_alias_match {
	struct device *dev;
	const char *id;
};

struct regulator_notifier_match {
	struct regulator *regulator;
	struct notifier_block *nb;
};

struct of_regulator_match {
	const char *name;
	void *driver_data;
	struct regulator_init_data *init_data;
	struct device_node *of_node;
	const struct regulator_desc *desc;
};

struct devm_of_regulator_matches {
	struct of_regulator_match *matches;
	unsigned int num_matches;
};

struct fixed_voltage_data {
	struct regulator_desc desc;
	struct regulator_dev *dev;
	struct clk *enable_clock;
	unsigned int clk_enable_counter;
};

struct fixed_dev_type {
	bool has_enable_clock;
};

enum light_aon_pm_func {
	LIGHT_AON_PM_FUNC_UNKNOWN = 0,
	LIGHT_AON_PM_FUNC_SET_RESOURCE_REGULATOR = 1,
	LIGHT_AON_PM_FUNC_GET_RESOURCE_REGULATOR = 2,
	LIGHT_AON_PM_FUNC_SET_RESOURCE_POWER_MODE = 3,
	LIGHT_AON_PM_FUNC_PWR_SET = 4,
	LIGHT_AON_PM_FUNC_PWR_GET = 5,
};

struct rpc_msg_regu_vol_set {
	u16 regu_id;
	u16 is_dual_rail;
	u32 dc1;
	u32 dc2;
	u16 reserved[6];
};

struct rpc_msg_regu_vol_get {
	u16 regu_id;
	u16 is_dual_rail;
	u32 dc1;
	u32 dc2;
	u16 reserved[6];
};

struct rpc_msg_regu_pwr_set {
	u16 regu_id;
	u16 status;
	u32 reserved[5];
};

struct rpc_msg_regu_pwr_get {
	u16 regu_id;
	u16 status;
	u32 reserved[5];
};

union rpc_func_t {
	struct rpc_msg_regu_vol_set regu_vol_set;
	struct rpc_msg_regu_vol_get regu_vol_get;
	struct rpc_msg_regu_pwr_set regu_pwr_set;
	struct rpc_msg_regu_pwr_get regu_pwr_get;
};

struct light_aon_msg_regulator_ctrl {
	struct light_aon_rpc_msg_hdr hdr;
	union rpc_func_t rpc;
};

enum pm_resource {
	SOC_DVDD18_AON = 0,
	SOC_AVDD33_USB3 = 1,
	SOC_DVDD08_AON = 2,
	SOC_APCPU_DVDD_DVDDM = 3,
	SOC_DVDD08_DDR = 4,
	SOC_VDD_DDR_1V8 = 5,
	SOC_VDD_DDR_1V1 = 6,
	SOC_VDD_DDR_0V6 = 7,
	SOC_DVDD18_AP = 8,
	SOC_DVDD08_AP = 9,
	SOC_AVDD08_MIPI_HDMI = 10,
	SOC_AVDD18_MIPI_HDMI = 11,
	SOC_DVDD33_EMMC = 12,
	SOC_DVDD18_EMMC = 13,
	SOC_DOVDD18_SCAN = 14,
	SOC_VEXT_2V8 = 15,
	SOC_DVDD12_SCAN = 16,
	SOC_AVDD28_SCAN_EN = 17,
	SOC_AVDD28_RGB = 18,
	SOC_DOVDD18_RGB = 19,
	SOC_DVDD12_RGB = 20,
	SOC_AVDD25_IR = 21,
	SOC_DOVDD18_IR = 22,
	SOC_DVDD12_IR = 23,
	SOC_ADC_VREF = 24,
	SOC_LCD0_EN = 25,
	SOC_VEXT_1V8 = 26,
	SOC_REGU_MAX = 27,
};

struct apcpu_vol_set {
	u32 vdd;
	u32 vddm;
};

struct aon_regu_desc {
	struct regulator_desc *regu_desc;
	u32 regu_num;
};

struct aon_regu_info {
	struct device *dev;
	const struct apcpu_vol_set *cpu_vol;
	u32 vddm;
	struct aon_regu_desc *regu_desc;
	struct light_aon_ipc *ipc_handle;
};

struct reset_controller_dev;

struct reset_control_ops {
	int (*reset)(struct reset_controller_dev *, long unsigned int);
	int (*assert)(struct reset_controller_dev *, long unsigned int);
	int (*deassert)(struct reset_controller_dev *, long unsigned int);
	int (*status)(struct reset_controller_dev *, long unsigned int);
};

struct reset_controller_dev {
	const struct reset_control_ops *ops;
	struct module *owner;
	struct list_head list;
	struct list_head reset_control_head;
	struct device *dev;
	struct device_node *of_node;
	int of_reset_n_cells;
	int (*of_xlate)(struct reset_controller_dev *, const struct of_phandle_args *);
	unsigned int nr_resets;
};

struct reset_control_lookup {
	struct list_head list;
	const char *provider;
	unsigned int index;
	const char *dev_id;
	const char *con_id;
};

struct reset_control {
	struct reset_controller_dev *rcdev;
	struct list_head list;
	unsigned int id;
	struct kref refcnt;
	bool acquired;
	bool shared;
	bool array;
	atomic_t deassert_count;
	atomic_t triggered_count;
};

struct reset_control_array {
	struct reset_control base;
	unsigned int num_rstcs;
	struct reset_control *rstc[0];
};

struct light_src_signal {
	unsigned int offset;
	unsigned int bit;
};

struct light_src_variant {
	const struct light_src_signal *signals;
	unsigned int signals_num;
	struct reset_control_ops ops;
};

struct light_src {
	struct reset_controller_dev rcdev;
	struct regmap *regmap;
	const struct light_src_signal *signals;
};

enum light_src_registers {
	SRC_WDT0 = 52,
	SRC_WDT1 = 56,
};

struct serial_icounter_struct {
	int cts;
	int dsr;
	int rng;
	int dcd;
	int rx;
	int tx;
	int frame;
	int overrun;
	int parity;
	int brk;
	int buf_overrun;
	int reserved[9];
};

struct serial_struct {
	int type;
	int line;
	unsigned int port;
	int irq;
	int flags;
	int xmit_fifo_size;
	int custom_divisor;
	int baud_base;
	short unsigned int close_delay;
	char io_type;
	char reserved_char[1];
	int hub6;
	short unsigned int closing_wait;
	short unsigned int closing_wait2;
	unsigned char *iomem_base;
	short unsigned int iomem_reg_shift;
	unsigned int port_high;
	long unsigned int iomap_base;
};

struct tty_file_private {
	struct tty_struct *tty;
	struct file *file;
	struct list_head list;
};

struct n_tty_data {
	size_t read_head;
	size_t commit_head;
	size_t canon_head;
	size_t echo_head;
	size_t echo_commit;
	size_t echo_mark;
	long unsigned int char_map[4];
	long unsigned int overrun_time;
	int num_overrun;
	bool no_room;
	unsigned char lnext: 1;
	unsigned char erasing: 1;
	unsigned char raw: 1;
	unsigned char real_raw: 1;
	unsigned char icanon: 1;
	unsigned char push: 1;
	char read_buf[4096];
	long unsigned int read_flags[64];
	unsigned char echo_buf[4096];
	size_t read_tail;
	size_t line_start;
	unsigned int column;
	unsigned int canon_column;
	size_t echo_tail;
	struct mutex atomic_read_lock;
	struct mutex output_lock;
};

enum {
	ERASE = 0,
	WERASE = 1,
	KILL = 2,
};

struct termios {
	tcflag_t c_iflag;
	tcflag_t c_oflag;
	tcflag_t c_cflag;
	tcflag_t c_lflag;
	cc_t c_line;
	cc_t c_cc[19];
};

struct termios2 {
	tcflag_t c_iflag;
	tcflag_t c_oflag;
	tcflag_t c_cflag;
	tcflag_t c_lflag;
	cc_t c_line;
	cc_t c_cc[19];
	speed_t c_ispeed;
	speed_t c_ospeed;
};

struct termio {
	short unsigned int c_iflag;
	short unsigned int c_oflag;
	short unsigned int c_cflag;
	short unsigned int c_lflag;
	unsigned char c_line;
	unsigned char c_cc[8];
};

struct ldsem_waiter {
	struct list_head list;
	struct task_struct *task;
};

struct pts_fs_info;

struct input_id {
	__u16 bustype;
	__u16 vendor;
	__u16 product;
	__u16 version;
};

struct input_absinfo {
	__s32 value;
	__s32 minimum;
	__s32 maximum;
	__s32 fuzz;
	__s32 flat;
	__s32 resolution;
};

struct input_keymap_entry {
	__u8 flags;
	__u8 len;
	__u16 index;
	__u32 keycode;
	__u8 scancode[32];
};

struct ff_replay {
	__u16 length;
	__u16 delay;
};

struct ff_trigger {
	__u16 button;
	__u16 interval;
};

struct ff_envelope {
	__u16 attack_length;
	__u16 attack_level;
	__u16 fade_length;
	__u16 fade_level;
};

struct ff_constant_effect {
	__s16 level;
	struct ff_envelope envelope;
};

struct ff_ramp_effect {
	__s16 start_level;
	__s16 end_level;
	struct ff_envelope envelope;
};

struct ff_condition_effect {
	__u16 right_saturation;
	__u16 left_saturation;
	__s16 right_coeff;
	__s16 left_coeff;
	__u16 deadband;
	__s16 center;
};

struct ff_periodic_effect {
	__u16 waveform;
	__u16 period;
	__s16 magnitude;
	__s16 offset;
	__u16 phase;
	struct ff_envelope envelope;
	__u32 custom_len;
	__s16 *custom_data;
};

struct ff_rumble_effect {
	__u16 strong_magnitude;
	__u16 weak_magnitude;
};

struct ff_effect {
	__u16 type;
	__s16 id;
	__u16 direction;
	struct ff_trigger trigger;
	struct ff_replay replay;
	union {
		struct ff_constant_effect constant;
		struct ff_ramp_effect ramp;
		struct ff_periodic_effect periodic;
		struct ff_condition_effect condition[2];
		struct ff_rumble_effect rumble;
	} u;
};

struct input_device_id {
	kernel_ulong_t flags;
	__u16 bustype;
	__u16 vendor;
	__u16 product;
	__u16 version;
	kernel_ulong_t evbit[1];
	kernel_ulong_t keybit[12];
	kernel_ulong_t relbit[1];
	kernel_ulong_t absbit[1];
	kernel_ulong_t mscbit[1];
	kernel_ulong_t ledbit[1];
	kernel_ulong_t sndbit[1];
	kernel_ulong_t ffbit[2];
	kernel_ulong_t swbit[1];
	kernel_ulong_t propbit[1];
	kernel_ulong_t driver_info;
};

struct input_value {
	__u16 type;
	__u16 code;
	__s32 value;
};

enum input_clock_type {
	INPUT_CLK_REAL = 0,
	INPUT_CLK_MONO = 1,
	INPUT_CLK_BOOT = 2,
	INPUT_CLK_MAX = 3,
};

struct ff_device;

struct input_dev_poller;

struct input_mt;

struct input_handle;

struct input_dev {
	const char *name;
	const char *phys;
	const char *uniq;
	struct input_id id;
	long unsigned int propbit[1];
	long unsigned int evbit[1];
	long unsigned int keybit[12];
	long unsigned int relbit[1];
	long unsigned int absbit[1];
	long unsigned int mscbit[1];
	long unsigned int ledbit[1];
	long unsigned int sndbit[1];
	long unsigned int ffbit[2];
	long unsigned int swbit[1];
	unsigned int hint_events_per_packet;
	unsigned int keycodemax;
	unsigned int keycodesize;
	void *keycode;
	int (*setkeycode)(struct input_dev *, const struct input_keymap_entry *, unsigned int *);
	int (*getkeycode)(struct input_dev *, struct input_keymap_entry *);
	struct ff_device *ff;
	struct input_dev_poller *poller;
	unsigned int repeat_key;
	struct timer_list timer;
	int rep[2];
	struct input_mt *mt;
	struct input_absinfo *absinfo;
	long unsigned int key[12];
	long unsigned int led[1];
	long unsigned int snd[1];
	long unsigned int sw[1];
	int (*open)(struct input_dev *);
	void (*close)(struct input_dev *);
	int (*flush)(struct input_dev *, struct file *);
	int (*event)(struct input_dev *, unsigned int, unsigned int, int);
	struct input_handle *grab;
	spinlock_t event_lock;
	struct mutex mutex;
	unsigned int users;
	bool going_away;
	struct device dev;
	struct list_head h_list;
	struct list_head node;
	unsigned int num_vals;
	unsigned int max_vals;
	struct input_value *vals;
	bool devres_managed;
	ktime_t timestamp[3];
};

struct ff_device {
	int (*upload)(struct input_dev *, struct ff_effect *, struct ff_effect *);
	int (*erase)(struct input_dev *, int);
	int (*playback)(struct input_dev *, int, int);
	void (*set_gain)(struct input_dev *, u16);
	void (*set_autocenter)(struct input_dev *, u16);
	void (*destroy)(struct ff_device *);
	void *private;
	long unsigned int ffbit[2];
	struct mutex mutex;
	int max_effects;
	struct ff_effect *effects;
	struct file *effect_owners[0];
};

struct input_handler;

struct input_handle {
	void *private;
	int open;
	const char *name;
	struct input_dev *dev;
	struct input_handler *handler;
	struct list_head d_node;
	struct list_head h_node;
};

struct input_handler {
	void *private;
	void (*event)(struct input_handle *, unsigned int, unsigned int, int);
	void (*events)(struct input_handle *, const struct input_value *, unsigned int);
	bool (*filter)(struct input_handle *, unsigned int, unsigned int, int);
	bool (*match)(struct input_handler *, struct input_dev *);
	int (*connect)(struct input_handler *, struct input_dev *, const struct input_device_id *);
	void (*disconnect)(struct input_handle *);
	void (*start)(struct input_handle *);
	bool legacy_minors;
	int minor;
	const char *name;
	const struct input_device_id *id_table;
	struct list_head h_list;
	struct list_head node;
};

struct sysrq_state {
	struct input_handle handle;
	struct work_struct reinject_work;
	long unsigned int key_down[12];
	unsigned int alt;
	unsigned int alt_use;
	unsigned int shift;
	unsigned int shift_use;
	bool active;
	bool need_reinject;
	bool reinjecting;
	bool reset_canceled;
	bool reset_requested;
	long unsigned int reset_keybit[12];
	int reset_seq_len;
	int reset_seq_cnt;
	int reset_seq_version;
	struct timer_list keyreset_timer;
};

struct consolefontdesc {
	short unsigned int charcount;
	short unsigned int charheight;
	char *chardata;
};

struct unipair {
	short unsigned int unicode;
	short unsigned int fontpos;
};

struct unimapdesc {
	short unsigned int entry_ct;
	struct unipair *entries;
};

struct kbd_repeat {
	int delay;
	int period;
};

struct console_font_op {
	unsigned int op;
	unsigned int flags;
	unsigned int width;
	unsigned int height;
	unsigned int charcount;
	unsigned char *data;
};

struct vt_stat {
	short unsigned int v_active;
	short unsigned int v_signal;
	short unsigned int v_state;
};

struct vt_sizes {
	short unsigned int v_rows;
	short unsigned int v_cols;
	short unsigned int v_scrollsize;
};

struct vt_consize {
	short unsigned int v_rows;
	short unsigned int v_cols;
	short unsigned int v_vlin;
	short unsigned int v_clin;
	short unsigned int v_vcol;
	short unsigned int v_ccol;
};

struct vt_event {
	unsigned int event;
	unsigned int oldev;
	unsigned int newev;
	unsigned int pad[4];
};

struct vt_setactivate {
	unsigned int console;
	struct vt_mode mode;
};

struct vt_spawn_console {
	spinlock_t lock;
	struct pid *pid;
	int sig;
};

struct vt_event_wait {
	struct list_head list;
	struct vt_event event;
	int done;
};

struct vt_notifier_param {
	struct vc_data *vc;
	unsigned int c;
};

struct vcs_poll_data {
	struct notifier_block notifier;
	unsigned int cons_num;
	int event;
	wait_queue_head_t waitq;
	struct fasync_struct *fasync;
};

struct tiocl_selection {
	short unsigned int xs;
	short unsigned int ys;
	short unsigned int xe;
	short unsigned int ye;
	short unsigned int sel_mode;
};

struct vc_selection {
	struct mutex lock;
	struct vc_data *cons;
	char *buffer;
	unsigned int buf_len;
	volatile int start;
	int end;
};

struct keyboard_notifier_param {
	struct vc_data *vc;
	int down;
	int shift;
	int ledstate;
	unsigned int value;
};

struct kbd_struct {
	unsigned char lockstate;
	unsigned char slockstate;
	unsigned char ledmode: 1;
	unsigned char ledflagstate: 4;
	char: 3;
	unsigned char default_ledflagstate: 4;
	unsigned char kbdmode: 3;
	char: 1;
	unsigned char modeflags: 5;
};

struct kbentry {
	unsigned char kb_table;
	unsigned char kb_index;
	short unsigned int kb_value;
};

struct kbsentry {
	unsigned char kb_func;
	unsigned char kb_string[512];
};

struct kbdiacr {
	unsigned char diacr;
	unsigned char base;
	unsigned char result;
};

struct kbdiacrs {
	unsigned int kb_cnt;
	struct kbdiacr kbdiacr[256];
};

struct kbdiacruc {
	unsigned int diacr;
	unsigned int base;
	unsigned int result;
};

struct kbdiacrsuc {
	unsigned int kb_cnt;
	struct kbdiacruc kbdiacruc[256];
};

struct kbkeycode {
	unsigned int scancode;
	unsigned int keycode;
};

typedef void k_handler_fn(struct vc_data *, unsigned char, char);

typedef void fn_handler_fn(struct vc_data *);

struct getset_keycode_data {
	struct input_keymap_entry ke;
	int error;
};

struct uni_pagedir {
	u16 **uni_pgdir[32];
	long unsigned int refcount;
	long unsigned int sum;
	unsigned char *inverse_translations[4];
	u16 *inverse_trans_unicode;
};

typedef uint32_t char32_t;

struct uni_screen {
	char32_t *lines[0];
};

struct con_driver {
	const struct consw *con;
	const char *desc;
	struct device *dev;
	int node;
	int first;
	int last;
	int flag;
};

enum {
	blank_off = 0,
	blank_normal_wait = 1,
	blank_vesa_wait = 2,
};

enum {
	EPecma = 0,
	EPdec = 1,
	EPeq = 2,
	EPgt = 3,
	EPlt = 4,
};

struct rgb {
	u8 r;
	u8 g;
	u8 b;
};

enum {
	ESnormal = 0,
	ESesc = 1,
	ESsquare = 2,
	ESgetpars = 3,
	ESfunckey = 4,
	EShash = 5,
	ESsetG0 = 6,
	ESsetG1 = 7,
	ESpercent = 8,
	EScsiignore = 9,
	ESnonstd = 10,
	ESpalette = 11,
	ESosc = 12,
	ESapc = 13,
	ESpm = 14,
	ESdcs = 15,
};

struct interval {
	uint32_t first;
	uint32_t last;
};

struct vc_draw_region {
	long unsigned int from;
	long unsigned int to;
	int x;
};

struct hv_ops;

struct hvc_struct {
	struct tty_port port;
	spinlock_t lock;
	int index;
	int do_wakeup;
	char *outbuf;
	int outbuf_size;
	int n_outbuf;
	uint32_t vtermno;
	const struct hv_ops *ops;
	int irq_requested;
	int data;
	struct winsize ws;
	struct work_struct tty_resize;
	struct list_head next;
	long unsigned int flags;
};

struct hv_ops {
	int (*get_chars)(uint32_t, char *, int);
	int (*put_chars)(uint32_t, const char *, int);
	int (*flush)(uint32_t, bool);
	int (*notifier_add)(struct hvc_struct *, int);
	void (*notifier_del)(struct hvc_struct *, int);
	void (*notifier_hangup)(struct hvc_struct *, int);
	int (*tiocmget)(struct hvc_struct *);
	int (*tiocmset)(struct hvc_struct *, unsigned int, unsigned int);
	void (*dtr_rts)(struct hvc_struct *, int);
};

struct serial_rs485 {
	__u32 flags;
	__u32 delay_rts_before_send;
	__u32 delay_rts_after_send;
	__u32 padding[5];
};

struct serial_iso7816 {
	__u32 flags;
	__u32 tg;
	__u32 sc_fi;
	__u32 sc_di;
	__u32 clk;
	__u32 reserved[5];
};

struct circ_buf {
	char *buf;
	int head;
	int tail;
};

struct uart_port;

struct uart_ops {
	unsigned int (*tx_empty)(struct uart_port *);
	void (*set_mctrl)(struct uart_port *, unsigned int);
	unsigned int (*get_mctrl)(struct uart_port *);
	void (*stop_tx)(struct uart_port *);
	void (*start_tx)(struct uart_port *);
	void (*throttle)(struct uart_port *);
	void (*unthrottle)(struct uart_port *);
	void (*send_xchar)(struct uart_port *, char);
	void (*stop_rx)(struct uart_port *);
	void (*enable_ms)(struct uart_port *);
	void (*break_ctl)(struct uart_port *, int);
	int (*startup)(struct uart_port *);
	void (*shutdown)(struct uart_port *);
	void (*flush_buffer)(struct uart_port *);
	void (*set_termios)(struct uart_port *, struct ktermios *, struct ktermios *);
	void (*set_ldisc)(struct uart_port *, struct ktermios *);
	void (*pm)(struct uart_port *, unsigned int, unsigned int);
	const char * (*type)(struct uart_port *);
	void (*release_port)(struct uart_port *);
	int (*request_port)(struct uart_port *);
	void (*config_port)(struct uart_port *, int);
	int (*verify_port)(struct uart_port *, struct serial_struct *);
	int (*ioctl)(struct uart_port *, unsigned int, long unsigned int);
};

struct uart_icount {
	__u32 cts;
	__u32 dsr;
	__u32 rng;
	__u32 dcd;
	__u32 rx;
	__u32 tx;
	__u32 frame;
	__u32 overrun;
	__u32 parity;
	__u32 brk;
	__u32 buf_overrun;
};

typedef unsigned int upf_t;

typedef unsigned int upstat_t;

struct uart_state;

struct uart_port {
	spinlock_t lock;
	long unsigned int iobase;
	unsigned char *membase;
	unsigned int (*serial_in)(struct uart_port *, int);
	void (*serial_out)(struct uart_port *, int, int);
	void (*set_termios)(struct uart_port *, struct ktermios *, struct ktermios *);
	void (*set_ldisc)(struct uart_port *, struct ktermios *);
	unsigned int (*get_mctrl)(struct uart_port *);
	void (*set_mctrl)(struct uart_port *, unsigned int);
	unsigned int (*get_divisor)(struct uart_port *, unsigned int, unsigned int *);
	void (*set_divisor)(struct uart_port *, unsigned int, unsigned int, unsigned int);
	int (*startup)(struct uart_port *);
	void (*shutdown)(struct uart_port *);
	void (*throttle)(struct uart_port *);
	void (*unthrottle)(struct uart_port *);
	int (*handle_irq)(struct uart_port *);
	void (*pm)(struct uart_port *, unsigned int, unsigned int);
	void (*handle_break)(struct uart_port *);
	int (*rs485_config)(struct uart_port *, struct serial_rs485 *);
	int (*iso7816_config)(struct uart_port *, struct serial_iso7816 *);
	unsigned int irq;
	long unsigned int irqflags;
	unsigned int uartclk;
	unsigned int fifosize;
	unsigned char x_char;
	unsigned char regshift;
	unsigned char iotype;
	unsigned char quirks;
	unsigned int read_status_mask;
	unsigned int ignore_status_mask;
	struct uart_state *state;
	struct uart_icount icount;
	struct console *cons;
	upf_t flags;
	upstat_t status;
	int hw_stopped;
	unsigned int mctrl;
	unsigned int timeout;
	unsigned int type;
	const struct uart_ops *ops;
	unsigned int custom_divisor;
	unsigned int line;
	unsigned int minor;
	resource_size_t mapbase;
	resource_size_t mapsize;
	struct device *dev;
	long unsigned int sysrq;
	unsigned int sysrq_ch;
	unsigned char has_sysrq;
	unsigned char sysrq_seq;
	unsigned char hub6;
	unsigned char suspended;
	unsigned char console_reinit;
	const char *name;
	struct attribute_group *attr_group;
	const struct attribute_group **tty_groups;
	struct serial_rs485 rs485;
	struct gpio_desc *rs485_term_gpio;
	struct serial_iso7816 iso7816;
	void *private_data;
};

enum uart_pm_state {
	UART_PM_STATE_ON = 0,
	UART_PM_STATE_OFF = 3,
	UART_PM_STATE_UNDEFINED = 4,
};

struct uart_state {
	struct tty_port port;
	enum uart_pm_state pm_state;
	struct circ_buf xmit;
	atomic_t refcount;
	wait_queue_head_t remove_wait;
	struct uart_port *uart_port;
};

struct uart_driver {
	struct module *owner;
	const char *driver_name;
	const char *dev_name;
	int major;
	int minor;
	int nr;
	struct console *cons;
	struct uart_state *state;
	struct tty_driver *tty_driver;
};

struct uart_match {
	struct uart_port *port;
	struct uart_driver *driver;
};

struct earlycon_device {
	struct console *con;
	struct uart_port port;
	char options[16];
	unsigned int baud;
};

struct earlycon_id {
	char name[15];
	char name_term;
	char compatible[128];
	int (*setup)(struct earlycon_device *, const char *);
};

enum hwparam_type {
	hwparam_ioport = 0,
	hwparam_iomem = 1,
	hwparam_ioport_or_iomem = 2,
	hwparam_irq = 3,
	hwparam_dma = 4,
	hwparam_dma_addr = 5,
	hwparam_other = 6,
};

struct plat_serial8250_port {
	long unsigned int iobase;
	void *membase;
	resource_size_t mapbase;
	unsigned int irq;
	long unsigned int irqflags;
	unsigned int uartclk;
	void *private_data;
	unsigned char regshift;
	unsigned char iotype;
	unsigned char hub6;
	unsigned char has_sysrq;
	upf_t flags;
	unsigned int type;
	unsigned int (*serial_in)(struct uart_port *, int);
	void (*serial_out)(struct uart_port *, int, int);
	void (*set_termios)(struct uart_port *, struct ktermios *, struct ktermios *);
	void (*set_ldisc)(struct uart_port *, struct ktermios *);
	unsigned int (*get_mctrl)(struct uart_port *);
	int (*handle_irq)(struct uart_port *);
	void (*pm)(struct uart_port *, unsigned int, unsigned int);
	void (*handle_break)(struct uart_port *);
};

enum {
	PLAT8250_DEV_LEGACY = 4294967295,
	PLAT8250_DEV_PLATFORM = 0,
	PLAT8250_DEV_PLATFORM1 = 1,
	PLAT8250_DEV_PLATFORM2 = 2,
	PLAT8250_DEV_FOURPORT = 3,
	PLAT8250_DEV_ACCENT = 4,
	PLAT8250_DEV_BOCA = 5,
	PLAT8250_DEV_EXAR_ST16C554 = 6,
	PLAT8250_DEV_HUB6 = 7,
	PLAT8250_DEV_AU1X00 = 8,
	PLAT8250_DEV_SM501 = 9,
};

struct uart_8250_port;

struct uart_8250_ops {
	int (*setup_irq)(struct uart_8250_port *);
	void (*release_irq)(struct uart_8250_port *);
};

struct mctrl_gpios;

struct uart_8250_dma;

struct uart_8250_em485;

struct uart_8250_port {
	struct uart_port port;
	struct timer_list timer;
	struct list_head list;
	u32 capabilities;
	short unsigned int bugs;
	bool fifo_bug;
	unsigned int tx_loadsz;
	unsigned char acr;
	unsigned char fcr;
	unsigned char ier;
	unsigned char lcr;
	unsigned char mcr;
	unsigned char mcr_mask;
	unsigned char mcr_force;
	unsigned char cur_iotype;
	unsigned int rpm_tx_active;
	unsigned char canary;
	unsigned char probe;
	struct mctrl_gpios *gpios;
	unsigned char lsr_saved_flags;
	unsigned char msr_saved_flags;
	struct uart_8250_dma *dma;
	const struct uart_8250_ops *ops;
	int (*dl_read)(struct uart_8250_port *);
	void (*dl_write)(struct uart_8250_port *, int);
	struct uart_8250_em485 *em485;
	void (*rs485_start_tx)(struct uart_8250_port *);
	void (*rs485_stop_tx)(struct uart_8250_port *);
	struct delayed_work overrun_backoff;
	u32 overrun_backoff_time_ms;
};

struct uart_8250_em485 {
	struct hrtimer start_tx_timer;
	struct hrtimer stop_tx_timer;
	struct hrtimer *active_timer;
	struct uart_8250_port *port;
	unsigned int tx_stopped: 1;
};

struct uart_8250_dma {
	int (*tx_dma)(struct uart_8250_port *);
	int (*rx_dma)(struct uart_8250_port *);
	dma_filter_fn fn;
	void *rx_param;
	void *tx_param;
	struct dma_slave_config rxconf;
	struct dma_slave_config txconf;
	struct dma_chan *rxchan;
	struct dma_chan *txchan;
	phys_addr_t rx_dma_addr;
	phys_addr_t tx_dma_addr;
	dma_addr_t rx_addr;
	dma_addr_t tx_addr;
	dma_cookie_t rx_cookie;
	dma_cookie_t tx_cookie;
	void *rx_buf;
	size_t rx_size;
	size_t tx_size;
	unsigned char tx_running;
	unsigned char tx_err;
	unsigned char rx_running;
};

struct old_serial_port {
	unsigned int uart;
	unsigned int baud_base;
	unsigned int port;
	unsigned int irq;
	upf_t flags;
	unsigned char io_type;
	unsigned char *iomem_base;
	short unsigned int iomem_reg_shift;
};

struct irq_info {
	struct hlist_node node;
	int irq;
	spinlock_t lock;
	struct list_head *head;
};

struct serial8250_config {
	const char *name;
	short unsigned int fifo_size;
	short unsigned int tx_loadsz;
	unsigned char fcr;
	unsigned char rxtrig_bytes[4];
	unsigned int flags;
};

struct dw8250_port_data {
	int line;
	struct uart_8250_dma dma;
	u8 dlf_size;
};

struct dw8250_data {
	struct dw8250_port_data data;
	u8 usr_reg;
	int msr_mask_on;
	int msr_mask_off;
	struct clk *clk;
	struct clk *pclk;
	struct notifier_block clk_notifier;
	struct work_struct clk_work;
	struct reset_control *rst;
	unsigned int skip_autocfg: 1;
	unsigned int uart_16550_compatible: 1;
};

struct of_serial_info {
	struct clk *clk;
	struct reset_control *rst;
	int type;
	int line;
};

struct sifive_serial_port {
	struct uart_port port;
	struct device *dev;
	unsigned char ier;
	long unsigned int clkin_rate;
	long unsigned int baud_rate;
	struct clk *clk;
	struct notifier_block clk_notifier;
};

enum mctrl_gpio_idx {
	UART_GPIO_CTS = 0,
	UART_GPIO_DSR = 1,
	UART_GPIO_DCD = 2,
	UART_GPIO_RNG = 3,
	UART_GPIO_RI = 3,
	UART_GPIO_RTS = 4,
	UART_GPIO_DTR = 5,
	UART_GPIO_MAX = 6,
};

struct mctrl_gpios {
	struct uart_port *port;
	struct gpio_desc *gpio[6];
	int irq[6];
	unsigned int mctrl_prev;
	bool mctrl_on;
};

struct memdev {
	const char *name;
	umode_t mode;
	const struct file_operations *fops;
	fmode_t fmode;
};

struct timer_rand_state {
	cycles_t last_time;
	long int last_delta;
	long int last_delta2;
};

struct trace_event_raw_add_device_randomness {
	struct trace_entry ent;
	int bytes;
	long unsigned int IP;
	char __data[0];
};

struct trace_event_raw_random__mix_pool_bytes {
	struct trace_entry ent;
	const char *pool_name;
	int bytes;
	long unsigned int IP;
	char __data[0];
};

struct trace_event_raw_credit_entropy_bits {
	struct trace_entry ent;
	const char *pool_name;
	int bits;
	int entropy_count;
	long unsigned int IP;
	char __data[0];
};

struct trace_event_raw_push_to_pool {
	struct trace_entry ent;
	const char *pool_name;
	int pool_bits;
	int input_bits;
	char __data[0];
};

struct trace_event_raw_debit_entropy {
	struct trace_entry ent;
	const char *pool_name;
	int debit_bits;
	char __data[0];
};

struct trace_event_raw_add_input_randomness {
	struct trace_entry ent;
	int input_bits;
	char __data[0];
};

struct trace_event_raw_add_disk_randomness {
	struct trace_entry ent;
	dev_t dev;
	int input_bits;
	char __data[0];
};

struct trace_event_raw_xfer_secondary_pool {
	struct trace_entry ent;
	const char *pool_name;
	int xfer_bits;
	int request_bits;
	int pool_entropy;
	int input_entropy;
	char __data[0];
};

struct trace_event_raw_random__get_random_bytes {
	struct trace_entry ent;
	int nbytes;
	long unsigned int IP;
	char __data[0];
};

struct trace_event_raw_random__extract_entropy {
	struct trace_entry ent;
	const char *pool_name;
	int nbytes;
	int entropy_count;
	long unsigned int IP;
	char __data[0];
};

struct trace_event_raw_random_read {
	struct trace_entry ent;
	int got_bits;
	int need_bits;
	int pool_left;
	int input_left;
	char __data[0];
};

struct trace_event_raw_urandom_read {
	struct trace_entry ent;
	int got_bits;
	int pool_left;
	int input_left;
	char __data[0];
};

struct trace_event_raw_prandom_u32 {
	struct trace_entry ent;
	unsigned int ret;
	char __data[0];
};

struct trace_event_data_offsets_add_device_randomness {};

struct trace_event_data_offsets_random__mix_pool_bytes {};

struct trace_event_data_offsets_credit_entropy_bits {};

struct trace_event_data_offsets_push_to_pool {};

struct trace_event_data_offsets_debit_entropy {};

struct trace_event_data_offsets_add_input_randomness {};

struct trace_event_data_offsets_add_disk_randomness {};

struct trace_event_data_offsets_xfer_secondary_pool {};

struct trace_event_data_offsets_random__get_random_bytes {};

struct trace_event_data_offsets_random__extract_entropy {};

struct trace_event_data_offsets_random_read {};

struct trace_event_data_offsets_urandom_read {};

struct trace_event_data_offsets_prandom_u32 {};

typedef void (*btf_trace_add_device_randomness)(void *, int, long unsigned int);

typedef void (*btf_trace_mix_pool_bytes)(void *, const char *, int, long unsigned int);

typedef void (*btf_trace_mix_pool_bytes_nolock)(void *, const char *, int, long unsigned int);

typedef void (*btf_trace_credit_entropy_bits)(void *, const char *, int, int, long unsigned int);

typedef void (*btf_trace_push_to_pool)(void *, const char *, int, int);

typedef void (*btf_trace_debit_entropy)(void *, const char *, int);

typedef void (*btf_trace_add_input_randomness)(void *, int);

typedef void (*btf_trace_add_disk_randomness)(void *, dev_t, int);

typedef void (*btf_trace_xfer_secondary_pool)(void *, const char *, int, int, int, int);

typedef void (*btf_trace_get_random_bytes)(void *, int, long unsigned int);

typedef void (*btf_trace_get_random_bytes_arch)(void *, int, long unsigned int);

typedef void (*btf_trace_extract_entropy)(void *, const char *, int, int, long unsigned int);

typedef void (*btf_trace_extract_entropy_user)(void *, const char *, int, int, long unsigned int);

typedef void (*btf_trace_random_read)(void *, int, int, int, int);

typedef void (*btf_trace_urandom_read)(void *, int, int, int);

typedef void (*btf_trace_prandom_u32)(void *, unsigned int);

struct poolinfo {
	int poolbitshift;
	int poolwords;
	int poolbytes;
	int poolfracbits;
	int tap1;
	int tap2;
	int tap3;
	int tap4;
	int tap5;
};

struct crng_state {
	__u32 state[16];
	long unsigned int init_time;
	spinlock_t lock;
};

struct entropy_store {
	const struct poolinfo *poolinfo;
	__u32 *pool;
	const char *name;
	spinlock_t lock;
	short unsigned int add_ptr;
	short unsigned int input_rotate;
	int entropy_count;
	unsigned int initialized: 1;
	unsigned int last_data_init: 1;
	__u8 last_data[10];
};

struct fast_pool {
	__u32 pool[4];
	long unsigned int last;
	short unsigned int reg_idx;
	unsigned char count;
};

struct batched_entropy {
	union {
		u64 entropy_u64[8];
		u32 entropy_u32[16];
	};
	unsigned int position;
	spinlock_t batch_lock;
};

struct virtio_console_config {
	__virtio16 cols;
	__virtio16 rows;
	__virtio32 max_nr_ports;
	__virtio32 emerg_wr;
};

struct virtio_console_control {
	__virtio32 id;
	__virtio16 event;
	__virtio16 value;
};

struct ports_driver_data {
	struct class *class;
	struct dentry *debugfs_dir;
	struct list_head portdevs;
	unsigned int next_vtermno;
	struct list_head consoles;
};

struct console___2 {
	struct list_head list;
	struct hvc_struct *hvc;
	struct winsize ws;
	u32 vtermno;
};

struct port_buffer {
	char *buf;
	size_t size;
	size_t len;
	size_t offset;
	dma_addr_t dma;
	struct device *dev;
	struct list_head list;
	unsigned int sgpages;
	struct scatterlist sg[0];
};

struct ports_device {
	struct list_head list;
	struct work_struct control_work;
	struct work_struct config_work;
	struct list_head ports;
	spinlock_t ports_lock;
	spinlock_t c_ivq_lock;
	spinlock_t c_ovq_lock;
	u32 max_nr_ports;
	struct virtio_device *vdev;
	struct virtqueue *c_ivq;
	struct virtqueue *c_ovq;
	struct virtio_console_control cpkt;
	struct virtqueue **in_vqs;
	struct virtqueue **out_vqs;
	int chr_major;
};

struct port_stats {
	long unsigned int bytes_sent;
	long unsigned int bytes_received;
	long unsigned int bytes_discarded;
};

struct port {
	struct list_head list;
	struct ports_device *portdev;
	struct port_buffer *inbuf;
	spinlock_t inbuf_lock;
	spinlock_t outvq_lock;
	struct virtqueue *in_vq;
	struct virtqueue *out_vq;
	struct dentry *debugfs_file;
	struct port_stats stats;
	struct console___2 cons;
	struct cdev *cdev;
	struct device *dev;
	struct kref kref;
	wait_queue_head_t waitqueue;
	char *name;
	struct fasync_struct *async_queue;
	u32 id;
	bool outvq_full;
	bool host_connected;
	bool guest_connected;
};

struct sg_list {
	unsigned int n;
	unsigned int size;
	size_t len;
	struct scatterlist *sg;
};

struct hwrng {
	const char *name;
	int (*init)(struct hwrng *);
	void (*cleanup)(struct hwrng *);
	int (*data_present)(struct hwrng *, int);
	int (*data_read)(struct hwrng *, u32 *);
	int (*read)(struct hwrng *, void *, size_t, bool);
	long unsigned int priv;
	short unsigned int quality;
	struct list_head list;
	struct kref ref;
	struct completion cleanup_done;
};

enum {
	RNG_OUTPUT_0_REG = 0,
	RNG_OUTPUT_1_REG = 1,
	RNG_OUTPUT_2_REG = 2,
	RNG_OUTPUT_3_REG = 3,
	RNG_STATUS_REG = 4,
	RNG_INTMASK_REG = 5,
	RNG_INTACK_REG = 6,
	RNG_CONTROL_REG = 7,
	RNG_CONFIG_REG = 8,
	RNG_ALARMCNT_REG = 9,
	RNG_FROENABLE_REG = 10,
	RNG_FRODETUNE_REG = 11,
	RNG_ALARMMASK_REG = 12,
	RNG_ALARMSTOP_REG = 13,
	RNG_REV_REG = 14,
	RNG_SYSCONFIG_REG = 15,
};

struct omap_rng_dev;

struct omap_rng_pdata {
	u16 *regs;
	u32 data_size;
	u32 (*data_present)(struct omap_rng_dev *);
	int (*init)(struct omap_rng_dev *);
	void (*cleanup)(struct omap_rng_dev *);
};

struct omap_rng_dev {
	void *base;
	struct device *dev;
	const struct omap_rng_pdata *pdata;
	struct hwrng rng;
	struct clk *clk;
	struct clk *clk_reg;
};

struct virtrng_info {
	struct hwrng hwrng;
	struct virtqueue *vq;
	struct completion have_data;
	char name[25];
	unsigned int data_avail;
	int index;
	bool busy;
	bool hwrng_register_done;
	bool hwrng_removed;
};

struct tee_client_device_id {
	uuid_t uuid;
};

struct tee_ioctl_version_data {
	__u32 impl_id;
	__u32 impl_caps;
	__u32 gen_caps;
};

struct tee_ioctl_param {
	__u64 attr;
	__u64 a;
	__u64 b;
	__u64 c;
};

struct tee_ioctl_open_session_arg {
	__u8 uuid[16];
	__u8 clnt_uuid[16];
	__u32 clnt_login;
	__u32 cancel_id;
	__u32 session;
	__u32 ret;
	__u32 ret_origin;
	__u32 num_params;
	struct tee_ioctl_param params[0];
};

struct tee_ioctl_invoke_arg {
	__u32 func;
	__u32 session;
	__u32 cancel_id;
	__u32 ret;
	__u32 ret_origin;
	__u32 num_params;
	struct tee_ioctl_param params[0];
};

struct tee_device;

struct tee_context {
	struct tee_device *teedev;
	void *data;
	struct kref refcount;
	bool releasing;
	bool supp_nowait;
	bool cap_memref_null;
};

struct tee_shm;

struct tee_param_memref {
	size_t shm_offs;
	size_t size;
	struct tee_shm *shm;
};

struct tee_shm {
	struct tee_context *ctx;
	phys_addr_t paddr;
	void *kaddr;
	size_t size;
	unsigned int offset;
	struct page **pages;
	size_t num_pages;
	struct dma_buf *dmabuf;
	u32 flags;
	int id;
};

struct tee_param_value {
	u64 a;
	u64 b;
	u64 c;
};

struct tee_param {
	u64 attr;
	union {
		struct tee_param_memref memref;
		struct tee_param_value value;
	} u;
};

struct tee_client_device {
	struct tee_client_device_id id;
	struct device dev;
};

struct tee_client_driver {
	const struct tee_client_device_id *id_table;
	struct device_driver driver;
};

struct optee_rng_private {
	struct device *dev;
	struct tee_context *ctx;
	u32 session_id;
	u32 data_rate;
	struct tee_shm *entropy_shm_pool;
	struct hwrng optee_rng;
};

struct hdr_static_metadata {
	__u8 eotf;
	__u8 metadata_type;
	__u16 max_cll;
	__u16 max_fall;
	__u16 min_cll;
};

struct hdr_sink_metadata {
	__u32 metadata_type;
	union {
		struct hdr_static_metadata hdmi_type1;
	};
};

struct drm_clip_rect {
	short unsigned int x1;
	short unsigned int y1;
	short unsigned int x2;
	short unsigned int y2;
};

enum drm_mode_subconnector {
	DRM_MODE_SUBCONNECTOR_Automatic = 0,
	DRM_MODE_SUBCONNECTOR_Unknown = 0,
	DRM_MODE_SUBCONNECTOR_VGA = 1,
	DRM_MODE_SUBCONNECTOR_DVID = 3,
	DRM_MODE_SUBCONNECTOR_DVIA = 4,
	DRM_MODE_SUBCONNECTOR_Composite = 5,
	DRM_MODE_SUBCONNECTOR_SVIDEO = 6,
	DRM_MODE_SUBCONNECTOR_Component = 8,
	DRM_MODE_SUBCONNECTOR_SCART = 9,
	DRM_MODE_SUBCONNECTOR_DisplayPort = 10,
	DRM_MODE_SUBCONNECTOR_HDMIA = 11,
	DRM_MODE_SUBCONNECTOR_Native = 15,
	DRM_MODE_SUBCONNECTOR_Wireless = 18,
};

struct drm_mode_fb_cmd2 {
	__u32 fb_id;
	__u32 width;
	__u32 height;
	__u32 pixel_format;
	__u32 flags;
	__u32 handles[4];
	__u32 pitches[4];
	__u32 offsets[4];
	__u64 modifier[4];
};

struct drm_modeset_lock;

struct drm_modeset_acquire_ctx {
	struct ww_acquire_ctx ww_ctx;
	struct drm_modeset_lock *contended;
	struct list_head locked;
	bool trylock_only;
	bool interruptible;
};

struct drm_modeset_lock {
	struct ww_mutex mutex;
	struct list_head head;
};

struct drm_rect {
	int x1;
	int y1;
	int x2;
	int y2;
};

struct drm_object_properties;

struct drm_mode_object {
	uint32_t id;
	uint32_t type;
	struct drm_object_properties *properties;
	struct kref refcount;
	void (*free_cb)(struct kref *);
};

struct drm_property;

struct drm_object_properties {
	int count;
	struct drm_property *properties[64];
	uint64_t values[64];
};

struct drm_device;

struct drm_property {
	struct list_head head;
	struct drm_mode_object base;
	uint32_t flags;
	char name[32];
	uint32_t num_values;
	uint64_t *values;
	struct drm_device *dev;
	struct list_head enum_list;
};

struct drm_framebuffer;

struct drm_file;

struct drm_framebuffer_funcs {
	void (*destroy)(struct drm_framebuffer *);
	int (*create_handle)(struct drm_framebuffer *, struct drm_file *, unsigned int *);
	int (*dirty)(struct drm_framebuffer *, struct drm_file *, unsigned int, unsigned int, struct drm_clip_rect *, unsigned int);
};

struct drm_format_info;

struct drm_gem_object;

struct drm_framebuffer {
	struct drm_device *dev;
	struct list_head head;
	struct drm_mode_object base;
	char comm[16];
	const struct drm_format_info *format;
	const struct drm_framebuffer_funcs *funcs;
	unsigned int pitches[4];
	unsigned int offsets[4];
	uint64_t modifier;
	unsigned int width;
	unsigned int height;
	int flags;
	int hot_x;
	int hot_y;
	struct list_head filp_head;
	struct drm_gem_object *obj[4];
};

struct drm_mode_config_funcs;

struct drm_atomic_state;

struct drm_mode_config_helper_funcs;

struct drm_mode_config {
	struct mutex mutex;
	struct drm_modeset_lock connection_mutex;
	struct drm_modeset_acquire_ctx *acquire_ctx;
	struct mutex idr_mutex;
	struct idr object_idr;
	struct idr tile_idr;
	struct mutex fb_lock;
	int num_fb;
	struct list_head fb_list;
	spinlock_t connector_list_lock;
	int num_connector;
	struct ida connector_ida;
	struct list_head connector_list;
	struct llist_head connector_free_list;
	struct work_struct connector_free_work;
	int num_encoder;
	struct list_head encoder_list;
	int num_total_plane;
	struct list_head plane_list;
	int num_crtc;
	struct list_head crtc_list;
	struct list_head property_list;
	struct list_head privobj_list;
	int min_width;
	int min_height;
	int max_width;
	int max_height;
	const struct drm_mode_config_funcs *funcs;
	resource_size_t fb_base;
	bool poll_enabled;
	bool poll_running;
	bool delayed_event;
	struct delayed_work output_poll_work;
	struct mutex blob_lock;
	struct list_head property_blob_list;
	struct drm_property *edid_property;
	struct drm_property *dpms_property;
	struct drm_property *path_property;
	struct drm_property *tile_property;
	struct drm_property *link_status_property;
	struct drm_property *plane_type_property;
	struct drm_property *prop_src_x;
	struct drm_property *prop_src_y;
	struct drm_property *prop_src_w;
	struct drm_property *prop_src_h;
	struct drm_property *prop_crtc_x;
	struct drm_property *prop_crtc_y;
	struct drm_property *prop_crtc_w;
	struct drm_property *prop_crtc_h;
	struct drm_property *prop_fb_id;
	struct drm_property *prop_in_fence_fd;
	struct drm_property *prop_out_fence_ptr;
	struct drm_property *prop_crtc_id;
	struct drm_property *prop_fb_damage_clips;
	struct drm_property *prop_active;
	struct drm_property *prop_mode_id;
	struct drm_property *prop_vrr_enabled;
	struct drm_property *dvi_i_subconnector_property;
	struct drm_property *dvi_i_select_subconnector_property;
	struct drm_property *dp_subconnector_property;
	struct drm_property *tv_subconnector_property;
	struct drm_property *tv_select_subconnector_property;
	struct drm_property *tv_mode_property;
	struct drm_property *tv_left_margin_property;
	struct drm_property *tv_right_margin_property;
	struct drm_property *tv_top_margin_property;
	struct drm_property *tv_bottom_margin_property;
	struct drm_property *tv_brightness_property;
	struct drm_property *tv_contrast_property;
	struct drm_property *tv_flicker_reduction_property;
	struct drm_property *tv_overscan_property;
	struct drm_property *tv_saturation_property;
	struct drm_property *tv_hue_property;
	struct drm_property *scaling_mode_property;
	struct drm_property *aspect_ratio_property;
	struct drm_property *content_type_property;
	struct drm_property *degamma_lut_property;
	struct drm_property *degamma_lut_size_property;
	struct drm_property *ctm_property;
	struct drm_property *gamma_lut_property;
	struct drm_property *gamma_lut_size_property;
	struct drm_property *suggested_x_property;
	struct drm_property *suggested_y_property;
	struct drm_property *non_desktop_property;
	struct drm_property *panel_orientation_property;
	struct drm_property *writeback_fb_id_property;
	struct drm_property *writeback_pixel_formats_property;
	struct drm_property *writeback_out_fence_ptr_property;
	struct drm_property *hdr_output_metadata_property;
	struct drm_property *content_protection_property;
	struct drm_property *hdcp_content_type_property;
	uint32_t preferred_depth;
	uint32_t prefer_shadow;
	bool prefer_shadow_fbdev;
	bool fbdev_use_iomem;
	bool quirk_addfb_prefer_xbgr_30bpp;
	bool quirk_addfb_prefer_host_byte_order;
	bool async_page_flip;
	bool allow_fb_modifiers;
	bool normalize_zpos;
	struct drm_property *modifiers_property;
	uint32_t cursor_width;
	uint32_t cursor_height;
	struct drm_atomic_state *suspend_state;
	const struct drm_mode_config_helper_funcs *helper_private;
};

struct drm_vram_mm;

enum switch_power_state {
	DRM_SWITCH_POWER_ON = 0,
	DRM_SWITCH_POWER_OFF = 1,
	DRM_SWITCH_POWER_CHANGING = 2,
	DRM_SWITCH_POWER_DYNAMIC_OFF = 3,
};

struct drm_driver;

struct drm_minor;

struct drm_master;

struct drm_vblank_crtc;

struct drm_agp_head;

struct drm_vma_offset_manager;

struct drm_fb_helper;

struct drm_device {
	struct list_head legacy_dev_list;
	int if_version;
	struct kref ref;
	struct device *dev;
	struct {
		struct list_head resources;
		void *final_kfree;
		spinlock_t lock;
	} managed;
	struct drm_driver *driver;
	void *dev_private;
	struct drm_minor *primary;
	struct drm_minor *render;
	bool registered;
	struct drm_master *master;
	u32 driver_features;
	bool unplugged;
	struct inode *anon_inode;
	char *unique;
	struct mutex struct_mutex;
	struct mutex master_mutex;
	atomic_t open_count;
	struct mutex filelist_mutex;
	struct list_head filelist;
	struct list_head filelist_internal;
	struct mutex clientlist_mutex;
	struct list_head clientlist;
	bool irq_enabled;
	int irq;
	bool vblank_disable_immediate;
	struct drm_vblank_crtc *vblank;
	spinlock_t vblank_time_lock;
	spinlock_t vbl_lock;
	u32 max_vblank_count;
	struct list_head vblank_event_list;
	spinlock_t event_lock;
	struct drm_agp_head *agp;
	struct pci_dev *pdev;
	unsigned int num_crtcs;
	struct drm_mode_config mode_config;
	struct mutex object_name_lock;
	struct idr object_name_idr;
	struct drm_vma_offset_manager *vma_offset_manager;
	struct drm_vram_mm *vram_mm;
	enum switch_power_state switch_power_state;
	struct drm_fb_helper *fb_helper;
};

struct drm_format_info {
	u32 format;
	u8 depth;
	u8 num_planes;
	union {
		u8 cpp[4];
		u8 char_per_block[4];
	};
	u8 block_w[4];
	u8 block_h[4];
	u8 hsub;
	u8 vsub;
	bool has_alpha;
	bool is_yuv;
};

enum drm_connector_force {
	DRM_FORCE_UNSPECIFIED = 0,
	DRM_FORCE_OFF = 1,
	DRM_FORCE_ON = 2,
	DRM_FORCE_ON_DIGITAL = 3,
};

enum drm_connector_status {
	connector_status_connected = 1,
	connector_status_disconnected = 2,
	connector_status_unknown = 3,
};

enum drm_connector_registration_state {
	DRM_CONNECTOR_INITIALIZING = 0,
	DRM_CONNECTOR_REGISTERED = 1,
	DRM_CONNECTOR_UNREGISTERED = 2,
};

enum subpixel_order {
	SubPixelUnknown = 0,
	SubPixelHorizontalRGB = 1,
	SubPixelHorizontalBGR = 2,
	SubPixelVerticalRGB = 3,
	SubPixelVerticalBGR = 4,
	SubPixelNone = 5,
};

struct drm_scrambling {
	bool supported;
	bool low_rates;
};

struct drm_scdc {
	bool supported;
	bool read_request;
	struct drm_scrambling scrambling;
};

struct drm_hdmi_info {
	struct drm_scdc scdc;
	long unsigned int y420_vdb_modes[4];
	long unsigned int y420_cmdb_modes[4];
	u64 y420_cmdb_map;
	u8 y420_dc_modes;
};

enum drm_link_status {
	DRM_LINK_STATUS_GOOD = 0,
	DRM_LINK_STATUS_BAD = 1,
};

enum drm_panel_orientation {
	DRM_MODE_PANEL_ORIENTATION_UNKNOWN = 4294967295,
	DRM_MODE_PANEL_ORIENTATION_NORMAL = 0,
	DRM_MODE_PANEL_ORIENTATION_BOTTOM_UP = 1,
	DRM_MODE_PANEL_ORIENTATION_LEFT_UP = 2,
	DRM_MODE_PANEL_ORIENTATION_RIGHT_UP = 3,
};

struct drm_monitor_range_info {
	u8 min_vfreq;
	u8 max_vfreq;
};

struct drm_display_info {
	unsigned int width_mm;
	unsigned int height_mm;
	unsigned int bpc;
	enum subpixel_order subpixel_order;
	int panel_orientation;
	u32 color_formats;
	const u32 *bus_formats;
	unsigned int num_bus_formats;
	u32 bus_flags;
	int max_tmds_clock;
	bool dvi_dual;
	bool is_hdmi;
	bool has_hdmi_infoframe;
	bool rgb_quant_range_selectable;
	u8 edid_hdmi_dc_modes;
	u8 cea_rev;
	struct drm_hdmi_info hdmi;
	bool non_desktop;
	struct drm_monitor_range_info monitor_range;
};

struct drm_connector_tv_margins {
	unsigned int bottom;
	unsigned int left;
	unsigned int right;
	unsigned int top;
};

struct drm_tv_connector_state {
	enum drm_mode_subconnector subconnector;
	struct drm_connector_tv_margins margins;
	unsigned int mode;
	unsigned int brightness;
	unsigned int contrast;
	unsigned int flicker_reduction;
	unsigned int overscan;
	unsigned int saturation;
	unsigned int hue;
};

struct drm_connector;

struct drm_crtc;

struct drm_encoder;

struct drm_crtc_commit;

struct drm_writeback_job;

struct drm_property_blob;

struct drm_connector_state {
	struct drm_connector *connector;
	struct drm_crtc *crtc;
	struct drm_encoder *best_encoder;
	enum drm_link_status link_status;
	struct drm_atomic_state *state;
	struct drm_crtc_commit *commit;
	struct drm_tv_connector_state tv;
	bool self_refresh_aware;
	enum hdmi_picture_aspect picture_aspect_ratio;
	unsigned int content_type;
	unsigned int hdcp_content_type;
	unsigned int scaling_mode;
	unsigned int content_protection;
	u32 colorspace;
	struct drm_writeback_job *writeback_job;
	u8 max_requested_bpc;
	u8 max_bpc;
	struct drm_property_blob *hdr_output_metadata;
};

struct drm_cmdline_mode {
	char name[32];
	bool specified;
	bool refresh_specified;
	bool bpp_specified;
	int xres;
	int yres;
	int bpp;
	int refresh;
	bool rb;
	bool interlace;
	bool cvt;
	bool margins;
	enum drm_connector_force force;
	unsigned int rotation_reflection;
	enum drm_panel_orientation panel_orientation;
	struct drm_connector_tv_margins tv_margins;
};

struct drm_connector_funcs;

struct drm_connector_helper_funcs;

struct drm_tile_group;

struct drm_connector {
	struct drm_device *dev;
	struct device *kdev;
	struct device_attribute *attr;
	struct list_head head;
	struct drm_mode_object base;
	char *name;
	struct mutex mutex;
	unsigned int index;
	int connector_type;
	int connector_type_id;
	bool interlace_allowed;
	bool doublescan_allowed;
	bool stereo_allowed;
	bool ycbcr_420_allowed;
	enum drm_connector_registration_state registration_state;
	struct list_head modes;
	enum drm_connector_status status;
	struct list_head probed_modes;
	struct drm_display_info display_info;
	const struct drm_connector_funcs *funcs;
	struct drm_property_blob *edid_blob_ptr;
	struct drm_object_properties properties;
	struct drm_property *scaling_mode_property;
	struct drm_property *vrr_capable_property;
	struct drm_property *colorspace_property;
	struct drm_property_blob *path_blob_ptr;
	struct drm_property *max_bpc_property;
	uint8_t polled;
	int dpms;
	const struct drm_connector_helper_funcs *helper_private;
	struct drm_cmdline_mode cmdline_mode;
	enum drm_connector_force force;
	bool override_edid;
	u64 epoch_counter;
	u32 possible_encoders;
	struct drm_encoder *encoder;
	uint8_t eld[128];
	bool latency_present[2];
	int video_latency[2];
	int audio_latency[2];
	struct i2c_adapter *ddc;
	int null_edid_counter;
	unsigned int bad_edid_counter;
	bool edid_corrupt;
	u8 real_edid_checksum;
	struct dentry *debugfs_entry;
	struct drm_connector_state *state;
	struct drm_property_blob *tile_blob_ptr;
	bool has_tile;
	struct drm_tile_group *tile_group;
	bool tile_is_single_monitor;
	uint8_t num_h_tile;
	uint8_t num_v_tile;
	uint8_t tile_h_loc;
	uint8_t tile_v_loc;
	uint16_t tile_h_size;
	uint16_t tile_v_size;
	struct llist_node free_node;
	struct hdr_sink_metadata hdr_sink_metadata;
};

enum drm_mode_status {
	MODE_OK = 0,
	MODE_HSYNC = 1,
	MODE_VSYNC = 2,
	MODE_H_ILLEGAL = 3,
	MODE_V_ILLEGAL = 4,
	MODE_BAD_WIDTH = 5,
	MODE_NOMODE = 6,
	MODE_NO_INTERLACE = 7,
	MODE_NO_DBLESCAN = 8,
	MODE_NO_VSCAN = 9,
	MODE_MEM = 10,
	MODE_VIRTUAL_X = 11,
	MODE_VIRTUAL_Y = 12,
	MODE_MEM_VIRT = 13,
	MODE_NOCLOCK = 14,
	MODE_CLOCK_HIGH = 15,
	MODE_CLOCK_LOW = 16,
	MODE_CLOCK_RANGE = 17,
	MODE_BAD_HVALUE = 18,
	MODE_BAD_VVALUE = 19,
	MODE_BAD_VSCAN = 20,
	MODE_HSYNC_NARROW = 21,
	MODE_HSYNC_WIDE = 22,
	MODE_HBLANK_NARROW = 23,
	MODE_HBLANK_WIDE = 24,
	MODE_VSYNC_NARROW = 25,
	MODE_VSYNC_WIDE = 26,
	MODE_VBLANK_NARROW = 27,
	MODE_VBLANK_WIDE = 28,
	MODE_PANEL = 29,
	MODE_INTERLACE_WIDTH = 30,
	MODE_ONE_WIDTH = 31,
	MODE_ONE_HEIGHT = 32,
	MODE_ONE_SIZE = 33,
	MODE_NO_REDUCED = 34,
	MODE_NO_STEREO = 35,
	MODE_NO_420 = 36,
	MODE_STALE = 4294967293,
	MODE_BAD = 4294967294,
	MODE_ERROR = 4294967295,
};

struct drm_display_mode {
	int clock;
	u16 hdisplay;
	u16 hsync_start;
	u16 hsync_end;
	u16 htotal;
	u16 hskew;
	u16 vdisplay;
	u16 vsync_start;
	u16 vsync_end;
	u16 vtotal;
	u16 vscan;
	u32 flags;
	int crtc_clock;
	u16 crtc_hdisplay;
	u16 crtc_hblank_start;
	u16 crtc_hblank_end;
	u16 crtc_hsync_start;
	u16 crtc_hsync_end;
	u16 crtc_htotal;
	u16 crtc_hskew;
	u16 crtc_vdisplay;
	u16 crtc_vblank_start;
	u16 crtc_vblank_end;
	u16 crtc_vsync_start;
	u16 crtc_vsync_end;
	u16 crtc_vtotal;
	u16 width_mm;
	u16 height_mm;
	u8 type;
	bool expose_to_userspace;
	struct list_head head;
	char name[32];
	enum drm_mode_status status;
	enum hdmi_picture_aspect picture_aspect_ratio;
};

struct drm_crtc_crc_entry;

struct drm_crtc_crc {
	spinlock_t lock;
	const char *source;
	bool opened;
	bool overflow;
	struct drm_crtc_crc_entry *entries;
	int head;
	int tail;
	size_t values_cnt;
	wait_queue_head_t wq;
};

struct drm_plane;

struct drm_crtc_funcs;

struct drm_crtc_helper_funcs;

struct drm_crtc_state;

struct drm_self_refresh_data;

struct drm_crtc {
	struct drm_device *dev;
	struct device_node *port;
	struct list_head head;
	char *name;
	struct drm_modeset_lock mutex;
	struct drm_mode_object base;
	struct drm_plane *primary;
	struct drm_plane *cursor;
	unsigned int index;
	int cursor_x;
	int cursor_y;
	bool enabled;
	struct drm_display_mode mode;
	struct drm_display_mode hwmode;
	int x;
	int y;
	const struct drm_crtc_funcs *funcs;
	uint32_t gamma_size;
	uint16_t *gamma_store;
	const struct drm_crtc_helper_funcs *helper_private;
	struct drm_object_properties properties;
	struct drm_crtc_state *state;
	struct list_head commit_list;
	spinlock_t commit_lock;
	struct dentry *debugfs_entry;
	struct drm_crtc_crc crc;
	unsigned int fence_context;
	spinlock_t fence_lock;
	long unsigned int fence_seqno;
	char timeline_name[32];
	struct drm_self_refresh_data *self_refresh_data;
};

struct drm_encoder_funcs;

struct drm_encoder_helper_funcs;

struct drm_encoder {
	struct drm_device *dev;
	struct list_head head;
	struct drm_mode_object base;
	char *name;
	int encoder_type;
	unsigned int index;
	uint32_t possible_crtcs;
	uint32_t possible_clones;
	struct drm_crtc *crtc;
	struct list_head bridge_chain;
	const struct drm_encoder_funcs *funcs;
	const struct drm_encoder_helper_funcs *helper_private;
};

struct __drm_planes_state;

struct __drm_crtcs_state;

struct __drm_connnectors_state;

struct __drm_private_objs_state;

struct drm_atomic_state {
	struct kref ref;
	struct drm_device *dev;
	bool allow_modeset: 1;
	bool legacy_cursor_update: 1;
	bool async_update: 1;
	bool duplicated: 1;
	struct __drm_planes_state *planes;
	struct __drm_crtcs_state *crtcs;
	int num_connector;
	struct __drm_connnectors_state *connectors;
	int num_private_objs;
	struct __drm_private_objs_state *private_objs;
	struct drm_modeset_acquire_ctx *acquire_ctx;
	struct drm_crtc_commit *fake_commit;
	struct work_struct commit_work;
};

struct drm_pending_vblank_event;

struct drm_crtc_commit {
	struct drm_crtc *crtc;
	struct kref ref;
	struct completion flip_done;
	struct completion hw_done;
	struct completion cleanup_done;
	struct list_head commit_entry;
	struct drm_pending_vblank_event *event;
	bool abort_completion;
};

struct drm_property_blob {
	struct drm_mode_object base;
	struct drm_device *dev;
	struct list_head head_global;
	struct list_head head_file;
	size_t length;
	void *data;
};

struct drm_printer;

struct drm_connector_funcs {
	int (*dpms)(struct drm_connector *, int);
	void (*reset)(struct drm_connector *);
	enum drm_connector_status (*detect)(struct drm_connector *, bool);
	void (*force)(struct drm_connector *);
	int (*fill_modes)(struct drm_connector *, uint32_t, uint32_t);
	int (*set_property)(struct drm_connector *, struct drm_property *, uint64_t);
	int (*late_register)(struct drm_connector *);
	void (*early_unregister)(struct drm_connector *);
	void (*destroy)(struct drm_connector *);
	struct drm_connector_state * (*atomic_duplicate_state)(struct drm_connector *);
	void (*atomic_destroy_state)(struct drm_connector *, struct drm_connector_state *);
	int (*atomic_set_property)(struct drm_connector *, struct drm_connector_state *, struct drm_property *, uint64_t);
	int (*atomic_get_property)(struct drm_connector *, const struct drm_connector_state *, struct drm_property *, uint64_t *);
	void (*atomic_print_state)(struct drm_printer *, const struct drm_connector_state *);
};

struct drm_writeback_connector;

struct drm_connector_helper_funcs {
	int (*get_modes)(struct drm_connector *);
	int (*detect_ctx)(struct drm_connector *, struct drm_modeset_acquire_ctx *, bool);
	enum drm_mode_status (*mode_valid)(struct drm_connector *, struct drm_display_mode *);
	int (*mode_valid_ctx)(struct drm_connector *, struct drm_display_mode *, struct drm_modeset_acquire_ctx *, enum drm_mode_status *);
	struct drm_encoder * (*best_encoder)(struct drm_connector *);
	struct drm_encoder * (*atomic_best_encoder)(struct drm_connector *, struct drm_connector_state *);
	int (*atomic_check)(struct drm_connector *, struct drm_atomic_state *);
	void (*atomic_commit)(struct drm_connector *, struct drm_connector_state *);
	int (*prepare_writeback_job)(struct drm_writeback_connector *, struct drm_writeback_job *);
	void (*cleanup_writeback_job)(struct drm_writeback_connector *, struct drm_writeback_job *);
};

struct drm_tile_group {
	struct kref refcount;
	struct drm_device *dev;
	int id;
	u8 group_data[8];
};

struct drm_mode_config_funcs {
	struct drm_framebuffer * (*fb_create)(struct drm_device *, struct drm_file *, const struct drm_mode_fb_cmd2 *);
	const struct drm_format_info * (*get_format_info)(const struct drm_mode_fb_cmd2 *);
	void (*output_poll_changed)(struct drm_device *);
	enum drm_mode_status (*mode_valid)(struct drm_device *, const struct drm_display_mode *);
	int (*atomic_check)(struct drm_device *, struct drm_atomic_state *);
	int (*atomic_commit)(struct drm_device *, struct drm_atomic_state *, bool);
	struct drm_atomic_state * (*atomic_state_alloc)(struct drm_device *);
	void (*atomic_state_clear)(struct drm_atomic_state *);
	void (*atomic_state_free)(struct drm_atomic_state *);
};

struct drm_mode_config_helper_funcs {
	void (*atomic_commit_tail)(struct drm_atomic_state *);
};

struct est_timings {
	u8 t1;
	u8 t2;
	u8 mfg_rsvd;
};

struct std_timing {
	u8 hsize;
	u8 vfreq_aspect;
};

struct detailed_pixel_timing {
	u8 hactive_lo;
	u8 hblank_lo;
	u8 hactive_hblank_hi;
	u8 vactive_lo;
	u8 vblank_lo;
	u8 vactive_vblank_hi;
	u8 hsync_offset_lo;
	u8 hsync_pulse_width_lo;
	u8 vsync_offset_pulse_width_lo;
	u8 hsync_vsync_offset_pulse_width_hi;
	u8 width_mm_lo;
	u8 height_mm_lo;
	u8 width_height_mm_hi;
	u8 hborder;
	u8 vborder;
	u8 misc;
};

struct detailed_data_string {
	u8 str[13];
};

struct detailed_data_monitor_range {
	u8 min_vfreq;
	u8 max_vfreq;
	u8 min_hfreq_khz;
	u8 max_hfreq_khz;
	u8 pixel_clock_mhz;
	u8 flags;
	union {
		struct {
			u8 reserved;
			u8 hfreq_start_khz;
			u8 c;
			__le16 m;
			u8 k;
			u8 j;
		} __attribute__((packed)) gtf2;
		struct {
			u8 version;
			u8 data1;
			u8 data2;
			u8 supported_aspects;
			u8 flags;
			u8 supported_scalings;
			u8 preferred_refresh;
		} cvt;
	} formula;
} __attribute__((packed));

struct detailed_data_wpindex {
	u8 white_yx_lo;
	u8 white_x_hi;
	u8 white_y_hi;
	u8 gamma;
};

struct cvt_timing {
	u8 code[3];
};

struct detailed_non_pixel {
	u8 pad1;
	u8 type;
	u8 pad2;
	union {
		struct detailed_data_string str;
		struct detailed_data_monitor_range range;
		struct detailed_data_wpindex color;
		struct std_timing timings[6];
		struct cvt_timing cvt[4];
	} data;
} __attribute__((packed));

struct detailed_timing {
	__le16 pixel_clock;
	union {
		struct detailed_pixel_timing pixel_data;
		struct detailed_non_pixel other_data;
	} data;
};

struct edid {
	u8 header[8];
	u8 mfg_id[2];
	u8 prod_code[2];
	u32 serial;
	u8 mfg_week;
	u8 mfg_year;
	u8 version;
	u8 revision;
	u8 input;
	u8 width_cm;
	u8 height_cm;
	u8 gamma;
	u8 features;
	u8 red_green_lo;
	u8 black_white_lo;
	u8 red_x;
	u8 red_y;
	u8 green_x;
	u8 green_y;
	u8 blue_x;
	u8 blue_y;
	u8 white_x;
	u8 white_y;
	struct est_timings established_timings;
	struct std_timing standard_timings[8];
	struct detailed_timing detailed_timings[4];
	u8 extensions;
	u8 checksum;
};

enum drm_color_encoding {
	DRM_COLOR_YCBCR_BT601 = 0,
	DRM_COLOR_YCBCR_BT709 = 1,
	DRM_COLOR_YCBCR_BT2020 = 2,
	DRM_COLOR_ENCODING_MAX = 3,
};

enum drm_color_range {
	DRM_COLOR_YCBCR_LIMITED_RANGE = 0,
	DRM_COLOR_YCBCR_FULL_RANGE = 1,
	DRM_COLOR_RANGE_MAX = 2,
};

struct drm_plane_state {
	struct drm_plane *plane;
	struct drm_crtc *crtc;
	struct drm_framebuffer *fb;
	struct dma_fence *fence;
	int32_t crtc_x;
	int32_t crtc_y;
	uint32_t crtc_w;
	uint32_t crtc_h;
	uint32_t src_x;
	uint32_t src_y;
	uint32_t src_h;
	uint32_t src_w;
	u16 alpha;
	uint16_t pixel_blend_mode;
	unsigned int rotation;
	unsigned int zpos;
	unsigned int normalized_zpos;
	enum drm_color_encoding color_encoding;
	enum drm_color_range color_range;
	struct drm_property_blob *fb_damage_clips;
	struct drm_rect src;
	struct drm_rect dst;
	bool visible;
	struct drm_crtc_commit *commit;
	struct drm_atomic_state *state;
};

enum drm_plane_type {
	DRM_PLANE_TYPE_OVERLAY = 0,
	DRM_PLANE_TYPE_PRIMARY = 1,
	DRM_PLANE_TYPE_CURSOR = 2,
};

struct drm_plane_funcs;

struct drm_plane_helper_funcs;

struct drm_plane {
	struct drm_device *dev;
	struct list_head head;
	char *name;
	struct drm_modeset_lock mutex;
	struct drm_mode_object base;
	uint32_t possible_crtcs;
	uint32_t *format_types;
	unsigned int format_count;
	bool format_default;
	uint64_t *modifiers;
	unsigned int modifier_count;
	struct drm_crtc *crtc;
	struct drm_framebuffer *fb;
	struct drm_framebuffer *old_fb;
	const struct drm_plane_funcs *funcs;
	struct drm_object_properties properties;
	enum drm_plane_type type;
	unsigned int index;
	const struct drm_plane_helper_funcs *helper_private;
	struct drm_plane_state *state;
	struct drm_property *alpha_property;
	struct drm_property *zpos_property;
	struct drm_property *rotation_property;
	struct drm_property *blend_mode_property;
	struct drm_property *color_encoding_property;
	struct drm_property *color_range_property;
};

struct drm_plane_funcs {
	int (*update_plane)(struct drm_plane *, struct drm_crtc *, struct drm_framebuffer *, int, int, unsigned int, unsigned int, uint32_t, uint32_t, uint32_t, uint32_t, struct drm_modeset_acquire_ctx *);
	int (*disable_plane)(struct drm_plane *, struct drm_modeset_acquire_ctx *);
	void (*destroy)(struct drm_plane *);
	void (*reset)(struct drm_plane *);
	int (*set_property)(struct drm_plane *, struct drm_property *, uint64_t);
	struct drm_plane_state * (*atomic_duplicate_state)(struct drm_plane *);
	void (*atomic_destroy_state)(struct drm_plane *, struct drm_plane_state *);
	int (*atomic_set_property)(struct drm_plane *, struct drm_plane_state *, struct drm_property *, uint64_t);
	int (*atomic_get_property)(struct drm_plane *, const struct drm_plane_state *, struct drm_property *, uint64_t *);
	int (*late_register)(struct drm_plane *);
	void (*early_unregister)(struct drm_plane *);
	void (*atomic_print_state)(struct drm_printer *, const struct drm_plane_state *);
	bool (*format_mod_supported)(struct drm_plane *, uint32_t, uint64_t);
};

struct drm_plane_helper_funcs {
	int (*prepare_fb)(struct drm_plane *, struct drm_plane_state *);
	void (*cleanup_fb)(struct drm_plane *, struct drm_plane_state *);
	int (*atomic_check)(struct drm_plane *, struct drm_plane_state *);
	void (*atomic_update)(struct drm_plane *, struct drm_plane_state *);
	void (*atomic_disable)(struct drm_plane *, struct drm_plane_state *);
	int (*atomic_async_check)(struct drm_plane *, struct drm_plane_state *);
	void (*atomic_async_update)(struct drm_plane *, struct drm_plane_state *);
};

struct drm_crtc_crc_entry {
	bool has_frame_counter;
	uint32_t frame;
	uint32_t crcs[10];
};

struct drm_crtc_state {
	struct drm_crtc *crtc;
	bool enable;
	bool active;
	bool planes_changed: 1;
	bool mode_changed: 1;
	bool active_changed: 1;
	bool connectors_changed: 1;
	bool zpos_changed: 1;
	bool color_mgmt_changed: 1;
	bool no_vblank: 1;
	u32 plane_mask;
	u32 connector_mask;
	u32 encoder_mask;
	struct drm_display_mode adjusted_mode;
	struct drm_display_mode mode;
	struct drm_property_blob *mode_blob;
	struct drm_property_blob *degamma_lut;
	struct drm_property_blob *ctm;
	struct drm_property_blob *gamma_lut;
	u32 target_vblank;
	bool async_flip;
	bool vrr_enabled;
	bool self_refresh_active;
	struct drm_pending_vblank_event *event;
	struct drm_crtc_commit *commit;
	struct drm_atomic_state *state;
};

struct drm_mode_set;

struct drm_crtc_funcs {
	void (*reset)(struct drm_crtc *);
	int (*cursor_set)(struct drm_crtc *, struct drm_file *, uint32_t, uint32_t, uint32_t);
	int (*cursor_set2)(struct drm_crtc *, struct drm_file *, uint32_t, uint32_t, uint32_t, int32_t, int32_t);
	int (*cursor_move)(struct drm_crtc *, int, int);
	int (*gamma_set)(struct drm_crtc *, u16 *, u16 *, u16 *, uint32_t, struct drm_modeset_acquire_ctx *);
	void (*destroy)(struct drm_crtc *);
	int (*set_config)(struct drm_mode_set *, struct drm_modeset_acquire_ctx *);
	int (*page_flip)(struct drm_crtc *, struct drm_framebuffer *, struct drm_pending_vblank_event *, uint32_t, struct drm_modeset_acquire_ctx *);
	int (*page_flip_target)(struct drm_crtc *, struct drm_framebuffer *, struct drm_pending_vblank_event *, uint32_t, uint32_t, struct drm_modeset_acquire_ctx *);
	int (*set_property)(struct drm_crtc *, struct drm_property *, uint64_t);
	struct drm_crtc_state * (*atomic_duplicate_state)(struct drm_crtc *);
	void (*atomic_destroy_state)(struct drm_crtc *, struct drm_crtc_state *);
	int (*atomic_set_property)(struct drm_crtc *, struct drm_crtc_state *, struct drm_property *, uint64_t);
	int (*atomic_get_property)(struct drm_crtc *, const struct drm_crtc_state *, struct drm_property *, uint64_t *);
	int (*late_register)(struct drm_crtc *);
	void (*early_unregister)(struct drm_crtc *);
	int (*set_crc_source)(struct drm_crtc *, const char *);
	int (*verify_crc_source)(struct drm_crtc *, const char *, size_t *);
	const char * const * (*get_crc_sources)(struct drm_crtc *, size_t *);
	void (*atomic_print_state)(struct drm_printer *, const struct drm_crtc_state *);
	u32 (*get_vblank_counter)(struct drm_crtc *);
	int (*enable_vblank)(struct drm_crtc *);
	void (*disable_vblank)(struct drm_crtc *);
	bool (*get_vblank_timestamp)(struct drm_crtc *, int *, ktime_t *, bool);
};

struct drm_mode_set {
	struct drm_framebuffer *fb;
	struct drm_crtc *crtc;
	struct drm_display_mode *mode;
	uint32_t x;
	uint32_t y;
	struct drm_connector **connectors;
	size_t num_connectors;
};

enum mode_set_atomic {
	LEAVE_ATOMIC_MODE_SET = 0,
	ENTER_ATOMIC_MODE_SET = 1,
};

struct drm_crtc_helper_funcs {
	void (*dpms)(struct drm_crtc *, int);
	void (*prepare)(struct drm_crtc *);
	void (*commit)(struct drm_crtc *);
	enum drm_mode_status (*mode_valid)(struct drm_crtc *, const struct drm_display_mode *);
	bool (*mode_fixup)(struct drm_crtc *, const struct drm_display_mode *, struct drm_display_mode *);
	int (*mode_set)(struct drm_crtc *, struct drm_display_mode *, struct drm_display_mode *, int, int, struct drm_framebuffer *);
	void (*mode_set_nofb)(struct drm_crtc *);
	int (*mode_set_base)(struct drm_crtc *, int, int, struct drm_framebuffer *);
	int (*mode_set_base_atomic)(struct drm_crtc *, struct drm_framebuffer *, int, int, enum mode_set_atomic);
	void (*disable)(struct drm_crtc *);
	int (*atomic_check)(struct drm_crtc *, struct drm_crtc_state *);
	void (*atomic_begin)(struct drm_crtc *, struct drm_crtc_state *);
	void (*atomic_flush)(struct drm_crtc *, struct drm_crtc_state *);
	void (*atomic_enable)(struct drm_crtc *, struct drm_crtc_state *);
	void (*atomic_disable)(struct drm_crtc *, struct drm_crtc_state *);
	bool (*get_scanout_position)(struct drm_crtc *, bool, int *, int *, ktime_t *, ktime_t *, const struct drm_display_mode *);
};

struct __drm_planes_state {
	struct drm_plane *ptr;
	struct drm_plane_state *state;
	struct drm_plane_state *old_state;
	struct drm_plane_state *new_state;
};

struct __drm_crtcs_state {
	struct drm_crtc *ptr;
	struct drm_crtc_state *state;
	struct drm_crtc_state *old_state;
	struct drm_crtc_state *new_state;
	struct drm_crtc_commit *commit;
	s32 *out_fence_ptr;
	u64 last_vblank_count;
};

struct __drm_connnectors_state {
	struct drm_connector *ptr;
	struct drm_connector_state *state;
	struct drm_connector_state *old_state;
	struct drm_connector_state *new_state;
	s32 *out_fence_ptr;
};

struct drm_private_state;

struct drm_private_obj;

struct drm_private_state_funcs {
	struct drm_private_state * (*atomic_duplicate_state)(struct drm_private_obj *);
	void (*atomic_destroy_state)(struct drm_private_obj *, struct drm_private_state *);
};

struct drm_private_state {
	struct drm_atomic_state *state;
};

struct drm_private_obj {
	struct list_head head;
	struct drm_modeset_lock lock;
	struct drm_private_state *state;
	const struct drm_private_state_funcs *funcs;
};

struct __drm_private_objs_state {
	struct drm_private_obj *ptr;
	struct drm_private_state *state;
	struct drm_private_state *old_state;
	struct drm_private_state *new_state;
};

struct drm_bus_cfg {
	u32 format;
	u32 flags;
};

struct drm_bridge;

struct drm_bridge_state {
	struct drm_private_state base;
	struct drm_bridge *bridge;
	struct drm_bus_cfg input_bus_cfg;
	struct drm_bus_cfg output_bus_cfg;
};

enum drm_bridge_ops {
	DRM_BRIDGE_OP_DETECT = 1,
	DRM_BRIDGE_OP_EDID = 2,
	DRM_BRIDGE_OP_HPD = 4,
	DRM_BRIDGE_OP_MODES = 8,
};

struct drm_bridge_timings;

struct drm_bridge_funcs;

struct drm_bridge {
	struct drm_private_obj base;
	struct drm_device *dev;
	struct drm_encoder *encoder;
	struct list_head chain_node;
	struct device_node *of_node;
	struct list_head list;
	const struct drm_bridge_timings *timings;
	const struct drm_bridge_funcs *funcs;
	void *driver_private;
	enum drm_bridge_ops ops;
	int type;
	bool interlace_allowed;
	struct i2c_adapter *ddc;
	struct mutex hpd_mutex;
	void (*hpd_cb)(void *, enum drm_connector_status);
	void *hpd_data;
};

struct drm_encoder_funcs {
	void (*reset)(struct drm_encoder *);
	void (*destroy)(struct drm_encoder *);
	int (*late_register)(struct drm_encoder *);
	void (*early_unregister)(struct drm_encoder *);
};

struct drm_encoder_helper_funcs {
	void (*dpms)(struct drm_encoder *, int);
	enum drm_mode_status (*mode_valid)(struct drm_encoder *, const struct drm_display_mode *);
	bool (*mode_fixup)(struct drm_encoder *, const struct drm_display_mode *, struct drm_display_mode *);
	void (*prepare)(struct drm_encoder *);
	void (*commit)(struct drm_encoder *);
	void (*mode_set)(struct drm_encoder *, struct drm_display_mode *, struct drm_display_mode *);
	void (*atomic_mode_set)(struct drm_encoder *, struct drm_crtc_state *, struct drm_connector_state *);
	enum drm_connector_status (*detect)(struct drm_encoder *, struct drm_connector *);
	void (*atomic_disable)(struct drm_encoder *, struct drm_atomic_state *);
	void (*atomic_enable)(struct drm_encoder *, struct drm_atomic_state *);
	void (*disable)(struct drm_encoder *);
	void (*enable)(struct drm_encoder *);
	int (*atomic_check)(struct drm_encoder *, struct drm_crtc_state *, struct drm_connector_state *);
};

enum drm_bridge_attach_flags {
	DRM_BRIDGE_ATTACH_NO_CONNECTOR = 1,
};

struct drm_bridge_funcs {
	int (*attach)(struct drm_bridge *, enum drm_bridge_attach_flags);
	void (*detach)(struct drm_bridge *);
	enum drm_mode_status (*mode_valid)(struct drm_bridge *, const struct drm_display_info *, const struct drm_display_mode *);
	bool (*mode_fixup)(struct drm_bridge *, const struct drm_display_mode *, struct drm_display_mode *);
	void (*disable)(struct drm_bridge *);
	void (*post_disable)(struct drm_bridge *);
	void (*mode_set)(struct drm_bridge *, const struct drm_display_mode *, const struct drm_display_mode *);
	void (*pre_enable)(struct drm_bridge *);
	void (*enable)(struct drm_bridge *);
	void (*atomic_pre_enable)(struct drm_bridge *, struct drm_bridge_state *);
	void (*atomic_enable)(struct drm_bridge *, struct drm_bridge_state *);
	void (*atomic_disable)(struct drm_bridge *, struct drm_bridge_state *);
	void (*atomic_post_disable)(struct drm_bridge *, struct drm_bridge_state *);
	struct drm_bridge_state * (*atomic_duplicate_state)(struct drm_bridge *);
	void (*atomic_destroy_state)(struct drm_bridge *, struct drm_bridge_state *);
	u32 * (*atomic_get_output_bus_fmts)(struct drm_bridge *, struct drm_bridge_state *, struct drm_crtc_state *, struct drm_connector_state *, unsigned int *);
	u32 * (*atomic_get_input_bus_fmts)(struct drm_bridge *, struct drm_bridge_state *, struct drm_crtc_state *, struct drm_connector_state *, u32, unsigned int *);
	int (*atomic_check)(struct drm_bridge *, struct drm_bridge_state *, struct drm_crtc_state *, struct drm_connector_state *);
	struct drm_bridge_state * (*atomic_reset)(struct drm_bridge *);
	enum drm_connector_status (*detect)(struct drm_bridge *);
	int (*get_modes)(struct drm_bridge *, struct drm_connector *);
	struct edid * (*get_edid)(struct drm_bridge *, struct drm_connector *);
	void (*hpd_notify)(struct drm_bridge *, enum drm_connector_status);
	void (*hpd_enable)(struct drm_bridge *);
	void (*hpd_disable)(struct drm_bridge *);
};

struct drm_bridge_timings {
	u32 input_bus_flags;
	u32 setup_time_ps;
	u32 hold_time_ps;
	bool dual_link;
};

struct drm_bridge_connector {
	struct drm_connector base;
	struct drm_encoder *encoder;
	struct drm_bridge *bridge_edid;
	struct drm_bridge *bridge_hpd;
	struct drm_bridge *bridge_detect;
	struct drm_bridge *bridge_modes;
};

typedef unsigned int drm_magic_t;

struct drm_event {
	__u32 type;
	__u32 length;
};

struct drm_event_vblank {
	struct drm_event base;
	__u64 user_data;
	__u32 tv_sec;
	__u32 tv_usec;
	__u32 sequence;
	__u32 crtc_id;
};

struct drm_event_crtc_sequence {
	struct drm_event base;
	__u64 user_data;
	__s64 time_ns;
	__u64 sequence;
};

struct drm_mode_create_dumb {
	__u32 height;
	__u32 width;
	__u32 bpp;
	__u32 flags;
	__u32 handle;
	__u32 pitch;
	__u64 size;
};

struct drm_prime_file_private {
	struct mutex lock;
	struct rb_root dmabufs;
	struct rb_root handles;
};

struct drm_file {
	bool authenticated;
	bool stereo_allowed;
	bool universal_planes;
	bool atomic;
	bool aspect_ratio_allowed;
	bool writeback_connectors;
	bool was_master;
	bool is_master;
	struct drm_master *master;
	struct pid *pid;
	drm_magic_t magic;
	struct list_head lhead;
	struct drm_minor *minor;
	struct idr object_idr;
	spinlock_t table_lock;
	struct idr syncobj_idr;
	spinlock_t syncobj_table_lock;
	struct file *filp;
	void *driver_priv;
	struct list_head fbs;
	struct mutex fbs_lock;
	struct list_head blobs;
	wait_queue_head_t event_wait;
	struct list_head pending_event_list;
	struct list_head event_list;
	int event_space;
	struct mutex event_read_lock;
	struct drm_prime_file_private prime;
};

struct drm_printer {
	void (*printfn)(struct drm_printer *, struct va_format *);
	void (*puts)(struct drm_printer *, const char *);
	void *arg;
	const char *prefix;
};

struct drm_connector_list_iter {
	struct drm_device *dev;
	struct drm_connector *conn;
};

struct drm_ioctl_desc;

struct drm_driver {
	int (*load)(struct drm_device *, long unsigned int);
	int (*open)(struct drm_device *, struct drm_file *);
	void (*postclose)(struct drm_device *, struct drm_file *);
	void (*lastclose)(struct drm_device *);
	void (*unload)(struct drm_device *);
	void (*release)(struct drm_device *);
	irqreturn_t (*irq_handler)(int, void *);
	void (*irq_preinstall)(struct drm_device *);
	int (*irq_postinstall)(struct drm_device *);
	void (*irq_uninstall)(struct drm_device *);
	void (*master_set)(struct drm_device *, struct drm_file *, bool);
	void (*master_drop)(struct drm_device *, struct drm_file *);
	void (*debugfs_init)(struct drm_minor *);
	void (*gem_free_object_unlocked)(struct drm_gem_object *);
	int (*gem_open_object)(struct drm_gem_object *, struct drm_file *);
	void (*gem_close_object)(struct drm_gem_object *, struct drm_file *);
	struct drm_gem_object * (*gem_create_object)(struct drm_device *, size_t);
	int (*prime_handle_to_fd)(struct drm_device *, struct drm_file *, uint32_t, uint32_t, int *);
	int (*prime_fd_to_handle)(struct drm_device *, struct drm_file *, int, uint32_t *);
	struct dma_buf * (*gem_prime_export)(struct drm_gem_object *, int);
	struct drm_gem_object * (*gem_prime_import)(struct drm_device *, struct dma_buf *);
	int (*gem_prime_pin)(struct drm_gem_object *);
	void (*gem_prime_unpin)(struct drm_gem_object *);
	struct sg_table * (*gem_prime_get_sg_table)(struct drm_gem_object *);
	struct drm_gem_object * (*gem_prime_import_sg_table)(struct drm_device *, struct dma_buf_attachment *, struct sg_table *);
	void * (*gem_prime_vmap)(struct drm_gem_object *);
	void (*gem_prime_vunmap)(struct drm_gem_object *, void *);
	int (*gem_prime_mmap)(struct drm_gem_object *, struct vm_area_struct *);
	int (*gem_prime_get_uuid)(struct drm_gem_object *, uuid_t *);
	int (*dumb_create)(struct drm_file *, struct drm_device *, struct drm_mode_create_dumb *);
	int (*dumb_map_offset)(struct drm_file *, struct drm_device *, uint32_t, uint64_t *);
	int (*dumb_destroy)(struct drm_file *, struct drm_device *, uint32_t);
	const struct vm_operations_struct *gem_vm_ops;
	int major;
	int minor;
	int patchlevel;
	char *name;
	char *desc;
	char *date;
	u32 driver_features;
	const struct drm_ioctl_desc *ioctls;
	int num_ioctls;
	const struct file_operations *fops;
	struct list_head legacy_dev_list;
	int (*firstopen)(struct drm_device *);
	void (*preclose)(struct drm_device *, struct drm_file *);
	int (*dma_ioctl)(struct drm_device *, void *, struct drm_file *);
	int (*dma_quiescent)(struct drm_device *);
	int (*context_dtor)(struct drm_device *, int);
	u32 (*get_vblank_counter)(struct drm_device *, unsigned int);
	int (*enable_vblank)(struct drm_device *, unsigned int);
	void (*disable_vblank)(struct drm_device *, unsigned int);
	int dev_priv_size;
};

struct drm_minor {
	int index;
	int type;
	struct device *kdev;
	struct drm_device *dev;
	struct dentry *debugfs_root;
	struct list_head debugfs_list;
	struct mutex debugfs_lock;
};

struct drm_vblank_crtc {
	struct drm_device *dev;
	wait_queue_head_t queue;
	struct timer_list disable_timer;
	seqlock_t seqlock;
	atomic64_t count;
	ktime_t time;
	atomic_t refcount;
	u32 last;
	u32 max_vblank_count;
	unsigned int inmodeset;
	unsigned int pipe;
	int framedur_ns;
	int linedur_ns;
	struct drm_display_mode hwmode;
	bool enabled;
	struct kthread_worker *worker;
	struct list_head pending_work;
	wait_queue_head_t work_wait_queue;
};

struct drm_client_funcs;

struct drm_client_dev {
	struct drm_device *dev;
	const char *name;
	struct list_head list;
	const struct drm_client_funcs *funcs;
	struct drm_file *file;
	struct mutex modeset_mutex;
	struct drm_mode_set *modesets;
};

struct drm_client_buffer;

struct drm_fb_helper_funcs;

struct drm_fb_helper {
	struct drm_client_dev client;
	struct drm_client_buffer *buffer;
	struct drm_framebuffer *fb;
	struct drm_device *dev;
	const struct drm_fb_helper_funcs *funcs;
	struct fb_info *fbdev;
	u32 pseudo_palette[17];
	struct drm_clip_rect dirty_clip;
	spinlock_t dirty_lock;
	struct work_struct dirty_work;
	struct work_struct resume_work;
	struct mutex lock;
	struct list_head kernel_fb_list;
	bool delayed_hotplug;
	bool deferred_setup;
	int preferred_bpp;
};

struct drm_pending_event {
	struct completion *completion;
	void (*completion_release)(struct completion *);
	struct drm_event *event;
	struct dma_fence *fence;
	struct drm_file *file_priv;
	struct list_head link;
	struct list_head pending_link;
};

struct drm_pending_vblank_event {
	struct drm_pending_event base;
	unsigned int pipe;
	u64 sequence;
	union {
		struct drm_event base;
		struct drm_event_vblank vbl;
		struct drm_event_crtc_sequence seq;
	} event;
};

enum drm_driver_feature {
	DRIVER_GEM = 1,
	DRIVER_MODESET = 2,
	DRIVER_RENDER = 8,
	DRIVER_ATOMIC = 16,
	DRIVER_SYNCOBJ = 32,
	DRIVER_SYNCOBJ_TIMELINE = 64,
	DRIVER_USE_AGP = 33554432,
	DRIVER_LEGACY = 67108864,
	DRIVER_PCI_DMA = 134217728,
	DRIVER_SG = 268435456,
	DRIVER_HAVE_DMA = 536870912,
	DRIVER_HAVE_IRQ = 1073741824,
	DRIVER_KMS_LEGACY_CONTEXT = 2147483648,
};

enum drm_ioctl_flags {
	DRM_AUTH = 1,
	DRM_MASTER = 2,
	DRM_ROOT_ONLY = 4,
	DRM_UNLOCKED = 16,
	DRM_RENDER_ALLOW = 32,
};

typedef int drm_ioctl_t(struct drm_device *, void *, struct drm_file *);

struct drm_ioctl_desc {
	unsigned int cmd;
	enum drm_ioctl_flags flags;
	drm_ioctl_t *func;
	const char *name;
};

struct drm_client_funcs {
	struct module *owner;
	void (*unregister)(struct drm_client_dev *);
	int (*restore)(struct drm_client_dev *);
	int (*hotplug)(struct drm_client_dev *);
};

struct drm_client_buffer {
	struct drm_client_dev *client;
	u32 handle;
	u32 pitch;
	struct drm_gem_object *gem;
	void *vaddr;
	struct drm_framebuffer *fb;
};

struct drm_fb_helper_surface_size {
	u32 fb_width;
	u32 fb_height;
	u32 surface_width;
	u32 surface_height;
	u32 surface_bpp;
	u32 surface_depth;
};

struct drm_fb_helper_funcs {
	int (*fb_probe)(struct drm_fb_helper *, struct drm_fb_helper_surface_size *);
};

enum drm_debug_category {
	DRM_UT_CORE = 1,
	DRM_UT_DRIVER = 2,
	DRM_UT_KMS = 4,
	DRM_UT_PRIME = 8,
	DRM_UT_ATOMIC = 16,
	DRM_UT_VBL = 32,
	DRM_UT_STATE = 64,
	DRM_UT_LEASE = 128,
	DRM_UT_DP = 256,
	DRM_UT_DRMRES = 512,
};

enum dp_pixelformat {
	DP_PIXELFORMAT_RGB = 0,
	DP_PIXELFORMAT_YUV444 = 1,
	DP_PIXELFORMAT_YUV422 = 2,
	DP_PIXELFORMAT_YUV420 = 3,
	DP_PIXELFORMAT_Y_ONLY = 4,
	DP_PIXELFORMAT_RAW = 5,
	DP_PIXELFORMAT_RESERVED = 6,
};

enum dp_colorimetry {
	DP_COLORIMETRY_DEFAULT = 0,
	DP_COLORIMETRY_RGB_WIDE_FIXED = 1,
	DP_COLORIMETRY_BT709_YCC = 1,
	DP_COLORIMETRY_RGB_WIDE_FLOAT = 2,
	DP_COLORIMETRY_XVYCC_601 = 2,
	DP_COLORIMETRY_OPRGB = 3,
	DP_COLORIMETRY_XVYCC_709 = 3,
	DP_COLORIMETRY_DCI_P3_RGB = 4,
	DP_COLORIMETRY_SYCC_601 = 4,
	DP_COLORIMETRY_RGB_CUSTOM = 5,
	DP_COLORIMETRY_OPYCC_601 = 5,
	DP_COLORIMETRY_BT2020_RGB = 6,
	DP_COLORIMETRY_BT2020_CYCC = 6,
	DP_COLORIMETRY_BT2020_YCC = 7,
};

enum dp_dynamic_range {
	DP_DYNAMIC_RANGE_VESA = 0,
	DP_DYNAMIC_RANGE_CTA = 1,
};

enum dp_content_type {
	DP_CONTENT_TYPE_NOT_DEFINED = 0,
	DP_CONTENT_TYPE_GRAPHICS = 1,
	DP_CONTENT_TYPE_PHOTO = 2,
	DP_CONTENT_TYPE_VIDEO = 3,
	DP_CONTENT_TYPE_GAME = 4,
};

struct drm_dp_vsc_sdp {
	unsigned char sdp_type;
	unsigned char revision;
	unsigned char length;
	enum dp_pixelformat pixelformat;
	enum dp_colorimetry colorimetry;
	int bpc;
	enum dp_dynamic_range dynamic_range;
	enum dp_content_type content_type;
};

struct drm_dp_aux_msg {
	unsigned int address;
	u8 request;
	u8 reply;
	void *buffer;
	size_t size;
};

struct cec_adapter;

struct drm_dp_aux_cec {
	struct mutex lock;
	struct cec_adapter *adap;
	struct drm_connector *connector;
	struct delayed_work unregister_work;
};

struct drm_dp_aux {
	const char *name;
	struct i2c_adapter ddc;
	struct device *dev;
	struct drm_crtc *crtc;
	struct mutex hw_mutex;
	struct work_struct crc_work;
	u8 crc_count;
	ssize_t (*transfer)(struct drm_dp_aux *, struct drm_dp_aux_msg *);
	unsigned int i2c_nack_count;
	unsigned int i2c_defer_count;
	struct drm_dp_aux_cec cec;
	bool is_remote;
};

struct drm_dp_dpcd_ident {
	u8 oui[3];
	u8 device_id[6];
	u8 hw_rev;
	u8 sw_major_rev;
	u8 sw_minor_rev;
};

struct drm_dp_desc {
	struct drm_dp_dpcd_ident ident;
	u32 quirks;
};

enum drm_dp_quirk {
	DP_DPCD_QUIRK_CONSTANT_N = 0,
	DP_DPCD_QUIRK_NO_PSR = 1,
	DP_DPCD_QUIRK_NO_SINK_COUNT = 2,
	DP_DPCD_QUIRK_DSC_WITHOUT_VIRTUAL_DPCD = 3,
	DP_QUIRK_FORCE_DPCD_BACKLIGHT = 4,
	DP_DPCD_QUIRK_CAN_DO_MAX_LINK_RATE_3_24_GBPS = 5,
};

struct drm_dp_phy_test_params {
	int link_rate;
	u8 num_lanes;
	u8 phy_pattern;
	u8 hbr2_reset[2];
	u8 custom80[10];
	bool enhanced_frame_cap;
};

struct dpcd_quirk {
	u8 oui[3];
	u8 device_id[6];
	bool is_branch;
	u32 quirks;
};

struct edid_quirk {
	u8 mfg_id[2];
	u8 prod_id[2];
	u32 quirks;
};

struct dp_sdp_header {
	u8 HB0;
	u8 HB1;
	u8 HB2;
	u8 HB3;
};

struct drm_dsc_rc_range_parameters {
	u8 range_min_qp;
	u8 range_max_qp;
	u8 range_bpg_offset;
};

struct drm_dsc_config {
	u8 line_buf_depth;
	u8 bits_per_component;
	bool convert_rgb;
	u8 slice_count;
	u16 slice_width;
	u16 slice_height;
	bool simple_422;
	u16 pic_width;
	u16 pic_height;
	u8 rc_tgt_offset_high;
	u8 rc_tgt_offset_low;
	u16 bits_per_pixel;
	u8 rc_edge_factor;
	u8 rc_quant_incr_limit1;
	u8 rc_quant_incr_limit0;
	u16 initial_xmit_delay;
	u16 initial_dec_delay;
	bool block_pred_enable;
	u8 first_line_bpg_offset;
	u16 initial_offset;
	u16 rc_buf_thresh[14];
	struct drm_dsc_rc_range_parameters rc_range_params[15];
	u16 rc_model_size;
	u8 flatness_min_qp;
	u8 flatness_max_qp;
	u8 initial_scale_value;
	u16 scale_decrement_interval;
	u16 scale_increment_interval;
	u16 nfl_bpg_offset;
	u16 slice_bpg_offset;
	u16 final_offset;
	bool vbr_enable;
	u8 mux_word_size;
	u16 slice_chunk_size;
	u16 rc_bits;
	u8 dsc_version_minor;
	u8 dsc_version_major;
	bool native_422;
	bool native_420;
	u8 second_line_bpg_offset;
	u16 nsl_bpg_offset;
	u16 second_line_offset_adj;
};

struct drm_dsc_picture_parameter_set {
	u8 dsc_version;
	u8 pps_identifier;
	u8 pps_reserved;
	u8 pps_3;
	u8 pps_4;
	u8 bits_per_pixel_low;
	__be16 pic_height;
	__be16 pic_width;
	__be16 slice_height;
	__be16 slice_width;
	__be16 chunk_size;
	u8 initial_xmit_delay_high;
	u8 initial_xmit_delay_low;
	__be16 initial_dec_delay;
	u8 pps20_reserved;
	u8 initial_scale_value;
	__be16 scale_increment_interval;
	u8 scale_decrement_interval_high;
	u8 scale_decrement_interval_low;
	u8 pps26_reserved;
	u8 first_line_bpg_offset;
	__be16 nfl_bpg_offset;
	__be16 slice_bpg_offset;
	__be16 initial_offset;
	__be16 final_offset;
	u8 flatness_min_qp;
	u8 flatness_max_qp;
	__be16 rc_model_size;
	u8 rc_edge_factor;
	u8 rc_quant_incr_limit0;
	u8 rc_quant_incr_limit1;
	u8 rc_tgt_offset;
	u8 rc_buf_thresh[14];
	__be16 rc_range_parameters[15];
	u8 native_422_420;
	u8 second_line_bpg_offset;
	__be16 nsl_bpg_offset;
	__be16 second_line_offset_adj;
	u32 pps_long_94_reserved;
	u32 pps_long_98_reserved;
	u32 pps_long_102_reserved;
	u32 pps_long_106_reserved;
	u32 pps_long_110_reserved;
	u32 pps_long_114_reserved;
	u32 pps_long_118_reserved;
	u32 pps_long_122_reserved;
	__be16 pps_short_126_reserved;
} __attribute__((packed));

struct drm_dp_vcpi {
	int vcpi;
	int pbn;
	int aligned_pbn;
	int num_slots;
};

struct drm_dp_mst_branch;

struct drm_dp_mst_topology_mgr;

struct drm_dp_mst_port {
	struct kref topology_kref;
	struct kref malloc_kref;
	u8 port_num;
	bool input;
	bool mcs;
	bool ddps;
	u8 pdt;
	bool ldps;
	u8 dpcd_rev;
	u8 num_sdp_streams;
	u8 num_sdp_stream_sinks;
	uint16_t full_pbn;
	struct list_head next;
	struct drm_dp_mst_branch *mstb;
	struct drm_dp_aux aux;
	struct drm_dp_mst_branch *parent;
	struct drm_dp_vcpi vcpi;
	struct drm_connector *connector;
	struct drm_dp_mst_topology_mgr *mgr;
	struct edid *cached_edid;
	bool has_audio;
	bool fec_capable;
};

struct drm_dp_mst_branch {
	struct kref topology_kref;
	struct kref malloc_kref;
	struct list_head destroy_next;
	u8 rad[8];
	u8 lct;
	int num_ports;
	struct list_head ports;
	struct drm_dp_mst_port *port_parent;
	struct drm_dp_mst_topology_mgr *mgr;
	bool link_address_sent;
	u8 guid[16];
};

struct drm_dp_sideband_msg_hdr {
	u8 lct;
	u8 lcr;
	u8 rad[8];
	bool broadcast;
	bool path_msg;
	u8 msg_len;
	bool somt;
	bool eomt;
	bool seqno;
};

struct drm_dp_sideband_msg_rx {
	u8 chunk[48];
	u8 msg[256];
	u8 curchunk_len;
	u8 curchunk_idx;
	u8 curchunk_hdrlen;
	u8 curlen;
	bool have_somt;
	bool have_eomt;
	struct drm_dp_sideband_msg_hdr initial_hdr;
};

struct drm_dp_mst_topology_cbs;

struct drm_dp_payload;

struct drm_dp_mst_topology_mgr {
	struct drm_private_obj base;
	struct drm_device *dev;
	const struct drm_dp_mst_topology_cbs *cbs;
	int max_dpcd_transaction_bytes;
	struct drm_dp_aux *aux;
	int max_payloads;
	int conn_base_id;
	struct drm_dp_sideband_msg_rx up_req_recv;
	struct drm_dp_sideband_msg_rx down_rep_recv;
	struct mutex lock;
	struct mutex probe_lock;
	bool mst_state: 1;
	bool payload_id_table_cleared: 1;
	struct drm_dp_mst_branch *mst_primary;
	u8 dpcd[15];
	u8 sink_count;
	int pbn_div;
	const struct drm_private_state_funcs *funcs;
	struct mutex qlock;
	struct list_head tx_msg_downq;
	struct mutex payload_lock;
	struct drm_dp_vcpi **proposed_vcpis;
	struct drm_dp_payload *payloads;
	long unsigned int payload_mask;
	long unsigned int vcpi_mask;
	wait_queue_head_t tx_waitq;
	struct work_struct work;
	struct work_struct tx_work;
	struct list_head destroy_port_list;
	struct list_head destroy_branch_device_list;
	struct mutex delayed_destroy_lock;
	struct workqueue_struct *delayed_destroy_wq;
	struct work_struct delayed_destroy_work;
	struct list_head up_req_list;
	struct mutex up_req_lock;
	struct work_struct up_req_work;
};

struct drm_dp_nak_reply {
	u8 guid[16];
	u8 reason;
	u8 nak_data;
};

struct drm_dp_link_addr_reply_port {
	bool input_port;
	u8 peer_device_type;
	u8 port_number;
	bool mcs;
	bool ddps;
	bool legacy_device_plug_status;
	u8 dpcd_revision;
	u8 peer_guid[16];
	u8 num_sdp_streams;
	u8 num_sdp_stream_sinks;
};

struct drm_dp_link_address_ack_reply {
	u8 guid[16];
	u8 nports;
	struct drm_dp_link_addr_reply_port ports[16];
};

struct drm_dp_remote_dpcd_read_ack_reply {
	u8 port_number;
	u8 num_bytes;
	u8 bytes[255];
};

struct drm_dp_remote_dpcd_write_ack_reply {
	u8 port_number;
};

struct drm_dp_remote_dpcd_write_nak_reply {
	u8 port_number;
	u8 reason;
	u8 bytes_written_before_failure;
};

struct drm_dp_remote_i2c_read_ack_reply {
	u8 port_number;
	u8 num_bytes;
	u8 bytes[255];
};

struct drm_dp_remote_i2c_read_nak_reply {
	u8 port_number;
	u8 nak_reason;
	u8 i2c_nak_transaction;
};

struct drm_dp_remote_i2c_write_ack_reply {
	u8 port_number;
};

struct drm_dp_query_stream_enc_status_ack_reply {
	u8 stream_id;
	bool reply_signed;
	bool unauthorizable_device_present;
	bool legacy_device_present;
	bool query_capable_device_present;
	bool hdcp_1x_device_present;
	bool hdcp_2x_device_present;
	bool auth_completed;
	bool encryption_enabled;
	bool repeater_present;
	u8 state;
};

struct drm_dp_allocate_payload {
	u8 port_number;
	u8 number_sdp_streams;
	u8 vcpi;
	u16 pbn;
	u8 sdp_stream_sink[16];
};

struct drm_dp_allocate_payload_ack_reply {
	u8 port_number;
	u8 vcpi;
	u16 allocated_pbn;
};

struct drm_dp_connection_status_notify {
	u8 guid[16];
	u8 port_number;
	bool legacy_device_plug_status;
	bool displayport_device_plug_status;
	bool message_capability_status;
	bool input_port;
	u8 peer_device_type;
};

struct drm_dp_remote_dpcd_read {
	u8 port_number;
	u32 dpcd_address;
	u8 num_bytes;
};

struct drm_dp_remote_dpcd_write {
	u8 port_number;
	u32 dpcd_address;
	u8 num_bytes;
	u8 *bytes;
};

struct drm_dp_remote_i2c_read_tx {
	u8 i2c_dev_id;
	u8 num_bytes;
	u8 *bytes;
	u8 no_stop_bit;
	u8 i2c_transaction_delay;
};

struct drm_dp_remote_i2c_read {
	u8 num_transactions;
	u8 port_number;
	struct drm_dp_remote_i2c_read_tx transactions[4];
	u8 read_i2c_device_id;
	u8 num_bytes_read;
};

struct drm_dp_remote_i2c_write {
	u8 port_number;
	u8 write_i2c_device_id;
	u8 num_bytes;
	u8 *bytes;
};

struct drm_dp_query_stream_enc_status {
	u8 stream_id;
	u8 client_id[7];
	u8 stream_event;
	bool valid_stream_event;
	u8 stream_behavior;
	u8 valid_stream_behavior;
};

struct drm_dp_port_number_req {
	u8 port_number;
};

struct drm_dp_enum_path_resources_ack_reply {
	u8 port_number;
	bool fec_capable;
	u16 full_payload_bw_number;
	u16 avail_payload_bw_number;
};

struct drm_dp_port_number_rep {
	u8 port_number;
};

struct drm_dp_query_payload {
	u8 port_number;
	u8 vcpi;
};

struct drm_dp_resource_status_notify {
	u8 port_number;
	u8 guid[16];
	u16 available_pbn;
};

struct drm_dp_query_payload_ack_reply {
	u8 port_number;
	u16 allocated_pbn;
};

union ack_req {
	struct drm_dp_connection_status_notify conn_stat;
	struct drm_dp_port_number_req port_num;
	struct drm_dp_resource_status_notify resource_stat;
	struct drm_dp_query_payload query_payload;
	struct drm_dp_allocate_payload allocate_payload;
	struct drm_dp_remote_dpcd_read dpcd_read;
	struct drm_dp_remote_dpcd_write dpcd_write;
	struct drm_dp_remote_i2c_read i2c_read;
	struct drm_dp_remote_i2c_write i2c_write;
	struct drm_dp_query_stream_enc_status enc_status;
};

struct drm_dp_sideband_msg_req_body {
	u8 req_type;
	union ack_req u;
};

union ack_replies {
	struct drm_dp_nak_reply nak;
	struct drm_dp_link_address_ack_reply link_addr;
	struct drm_dp_port_number_rep port_number;
	struct drm_dp_enum_path_resources_ack_reply path_resources;
	struct drm_dp_allocate_payload_ack_reply allocate_payload;
	struct drm_dp_query_payload_ack_reply query_payload;
	struct drm_dp_remote_dpcd_read_ack_reply remote_dpcd_read_ack;
	struct drm_dp_remote_dpcd_write_ack_reply remote_dpcd_write_ack;
	struct drm_dp_remote_dpcd_write_nak_reply remote_dpcd_write_nack;
	struct drm_dp_remote_i2c_read_ack_reply remote_i2c_read_ack;
	struct drm_dp_remote_i2c_read_nak_reply remote_i2c_read_nack;
	struct drm_dp_remote_i2c_write_ack_reply remote_i2c_write_ack;
	struct drm_dp_query_stream_enc_status_ack_reply enc_status;
};

struct drm_dp_sideband_msg_reply_body {
	u8 reply_type;
	u8 req_type;
	union ack_replies u;
};

struct drm_dp_sideband_msg_tx {
	u8 msg[256];
	u8 chunk[48];
	u8 cur_offset;
	u8 cur_len;
	struct drm_dp_mst_branch *dst;
	struct list_head next;
	int seqno;
	int state;
	bool path_msg;
	struct drm_dp_sideband_msg_reply_body reply;
};

struct drm_dp_mst_topology_cbs {
	struct drm_connector * (*add_connector)(struct drm_dp_mst_topology_mgr *, struct drm_dp_mst_port *, const char *);
	void (*poll_hpd_irq)(struct drm_dp_mst_topology_mgr *);
};

struct drm_dp_payload {
	int payload_state;
	int start_slot;
	int num_slots;
	int vcpi;
};

struct drm_dp_vcpi_allocation {
	struct drm_dp_mst_port *port;
	int vcpi;
	int pbn;
	bool dsc_enabled;
	struct list_head next;
};

struct drm_dp_mst_topology_state {
	struct drm_private_state base;
	struct list_head vcpis;
	struct drm_dp_mst_topology_mgr *mgr;
};

struct drm_dp_pending_up_req {
	struct drm_dp_sideband_msg_hdr hdr;
	struct drm_dp_sideband_msg_req_body msg;
	struct list_head next;
};

struct drm_color_lut {
	__u16 red;
	__u16 green;
	__u16 blue;
	__u16 reserved;
};

struct drm_writeback_job {
	struct drm_writeback_connector *connector;
	bool prepared;
	struct work_struct cleanup_work;
	struct list_head list_entry;
	struct drm_framebuffer *fb;
	struct dma_fence *out_fence;
	void *priv;
};

struct drm_writeback_connector {
	struct drm_connector base;
	struct drm_encoder encoder;
	struct drm_property_blob *pixel_formats_blob_ptr;
	spinlock_t job_lock;
	struct list_head job_queue;
	unsigned int fence_context;
	spinlock_t fence_lock;
	long unsigned int fence_seqno;
	char timeline_name[32];
};

enum drm_lspcon_mode {
	DRM_LSPCON_MODE_INVALID = 0,
	DRM_LSPCON_MODE_LS = 1,
	DRM_LSPCON_MODE_PCON = 2,
};

enum drm_dp_dual_mode_type {
	DRM_DP_DUAL_MODE_NONE = 0,
	DRM_DP_DUAL_MODE_UNKNOWN = 1,
	DRM_DP_DUAL_MODE_TYPE1_DVI = 2,
	DRM_DP_DUAL_MODE_TYPE1_HDMI = 3,
	DRM_DP_DUAL_MODE_TYPE2_DVI = 4,
	DRM_DP_DUAL_MODE_TYPE2_HDMI = 5,
	DRM_DP_DUAL_MODE_LSPCON = 6,
};

struct drm_simple_display_pipe;

struct drm_simple_display_pipe_funcs {
	enum drm_mode_status (*mode_valid)(struct drm_simple_display_pipe *, const struct drm_display_mode *);
	void (*enable)(struct drm_simple_display_pipe *, struct drm_crtc_state *, struct drm_plane_state *);
	void (*disable)(struct drm_simple_display_pipe *);
	int (*check)(struct drm_simple_display_pipe *, struct drm_plane_state *, struct drm_crtc_state *);
	void (*update)(struct drm_simple_display_pipe *, struct drm_plane_state *);
	int (*prepare_fb)(struct drm_simple_display_pipe *, struct drm_plane_state *);
	void (*cleanup_fb)(struct drm_simple_display_pipe *, struct drm_plane_state *);
	int (*enable_vblank)(struct drm_simple_display_pipe *);
	void (*disable_vblank)(struct drm_simple_display_pipe *);
};

struct drm_simple_display_pipe {
	struct drm_crtc crtc;
	struct drm_plane plane;
	struct drm_encoder encoder;
	struct drm_connector *connector;
	const struct drm_simple_display_pipe_funcs *funcs;
};

struct seqcount_ww_mutex {
	seqcount_t seqcount;
};

typedef struct seqcount_ww_mutex seqcount_ww_mutex_t;

struct dma_resv_list;

struct dma_resv {
	struct ww_mutex lock;
	seqcount_ww_mutex_t seq;
	struct dma_fence *fence_excl;
	struct dma_resv_list *fence;
};

struct dma_resv_list {
	struct callback_head rcu;
	u32 shared_count;
	u32 shared_max;
	struct dma_fence *shared[0];
};

struct drm_mm;

struct drm_mm_node {
	long unsigned int color;
	u64 start;
	u64 size;
	struct drm_mm *mm;
	struct list_head node_list;
	struct list_head hole_stack;
	struct rb_node rb;
	struct rb_node rb_hole_size;
	struct rb_node rb_hole_addr;
	u64 __subtree_last;
	u64 hole_size;
	u64 subtree_max_hole;
	long unsigned int flags;
};

struct drm_vma_offset_node {
	rwlock_t vm_lock;
	struct drm_mm_node vm_node;
	struct rb_root vm_files;
	bool readonly: 1;
};

struct drm_gem_object_funcs;

struct drm_gem_object {
	struct kref refcount;
	unsigned int handle_count;
	struct drm_device *dev;
	struct file *filp;
	struct drm_vma_offset_node vma_node;
	size_t size;
	int name;
	struct dma_buf *dma_buf;
	struct dma_buf_attachment *import_attach;
	struct dma_resv *resv;
	struct dma_resv _resv;
	const struct drm_gem_object_funcs *funcs;
};

struct drm_afbc_framebuffer {
	struct drm_framebuffer base;
	u32 block_width;
	u32 block_height;
	u32 aligned_width;
	u32 aligned_height;
	u32 offset;
	u32 afbc_size;
};

struct drm_mm {
	void (*color_adjust)(const struct drm_mm_node *, long unsigned int, u64 *, u64 *);
	struct list_head hole_stack;
	struct drm_mm_node head_node;
	struct rb_root_cached interval_tree;
	struct rb_root_cached holes_size;
	struct rb_root holes_addr;
	long unsigned int scan_active;
};

struct drm_vma_offset_manager {
	rwlock_t vm_lock;
	struct drm_mm vm_addr_space_mm;
};

struct drm_gem_object_funcs {
	void (*free)(struct drm_gem_object *);
	int (*open)(struct drm_gem_object *, struct drm_file *);
	void (*close)(struct drm_gem_object *, struct drm_file *);
	void (*print_info)(struct drm_printer *, unsigned int, const struct drm_gem_object *);
	struct dma_buf * (*export)(struct drm_gem_object *, int);
	int (*pin)(struct drm_gem_object *);
	void (*unpin)(struct drm_gem_object *);
	struct sg_table * (*get_sg_table)(struct drm_gem_object *);
	void * (*vmap)(struct drm_gem_object *);
	void (*vunmap)(struct drm_gem_object *, void *);
	int (*mmap)(struct drm_gem_object *, struct vm_area_struct *);
	const struct vm_operations_struct *vm_ops;
};

struct drm_mode_rect {
	__s32 x1;
	__s32 y1;
	__s32 x2;
	__s32 y2;
};

struct drm_atomic_helper_damage_iter {
	struct drm_rect plane_src;
	const struct drm_rect *clips;
	uint32_t num_clips;
	uint32_t curr_clip;
	bool full_update;
};

struct ewma_psr_time {
	long unsigned int internal;
};

struct drm_self_refresh_data {
	struct drm_crtc *crtc;
	struct delayed_work entry_work;
	struct mutex avg_mutex;
	struct ewma_psr_time entry_avg_ms;
	struct ewma_psr_time exit_avg_ms;
};

struct drm_panel;

struct drm_panel_funcs {
	int (*prepare)(struct drm_panel *);
	int (*enable)(struct drm_panel *);
	int (*disable)(struct drm_panel *);
	int (*unprepare)(struct drm_panel *);
	int (*get_modes)(struct drm_panel *, struct drm_connector *);
	int (*get_timings)(struct drm_panel *, unsigned int, struct display_timing *);
};

struct drm_panel {
	struct device *dev;
	struct backlight_device *backlight;
	const struct drm_panel_funcs *funcs;
	int connector_type;
	struct list_head list;
};

struct panel_bridge {
	struct drm_bridge bridge;
	struct drm_connector connector;
	struct drm_panel *panel;
	u32 connector_type;
};

struct drm_master {
	struct kref refcount;
	struct drm_device *dev;
	char *unique;
	int unique_len;
	struct idr magic_map;
	void *driver_priv;
	struct drm_master *lessor;
	int lessee_id;
	struct list_head lessee_list;
	struct list_head lessees;
	struct idr leases;
	struct idr lessee_idr;
};

struct drm_auth {
	drm_magic_t magic;
};

enum drm_minor_type {
	DRM_MINOR_PRIMARY = 0,
	DRM_MINOR_CONTROL = 1,
	DRM_MINOR_RENDER = 2,
};

struct drm_gem_close {
	__u32 handle;
	__u32 pad;
};

struct drm_gem_flink {
	__u32 handle;
	__u32 name;
};

struct drm_gem_open {
	__u32 name;
	__u32 handle;
	__u64 size;
};

enum chipset_type {
	NOT_SUPPORTED = 0,
	SUPPORTED = 1,
};

struct agp_version {
	u16 major;
	u16 minor;
};

struct agp_kern_info {
	struct agp_version version;
	struct pci_dev *device;
	enum chipset_type chipset;
	long unsigned int mode;
	long unsigned int aper_base;
	size_t aper_size;
	int max_memory;
	int current_memory;
	bool cant_use_aperture;
	long unsigned int page_mask;
	const struct vm_operations_struct *vm_ops;
};

struct agp_bridge_data;

struct drm_version {
	int version_major;
	int version_minor;
	int version_patchlevel;
	__kernel_size_t name_len;
	char *name;
	__kernel_size_t date_len;
	char *date;
	__kernel_size_t desc_len;
	char *desc;
};

struct drm_unique {
	__kernel_size_t unique_len;
	char *unique;
};

struct drm_client {
	int idx;
	int auth;
	long unsigned int pid;
	long unsigned int uid;
	long unsigned int magic;
	long unsigned int iocs;
};

enum drm_stat_type {
	_DRM_STAT_LOCK = 0,
	_DRM_STAT_OPENS = 1,
	_DRM_STAT_CLOSES = 2,
	_DRM_STAT_IOCTLS = 3,
	_DRM_STAT_LOCKS = 4,
	_DRM_STAT_UNLOCKS = 5,
	_DRM_STAT_VALUE = 6,
	_DRM_STAT_BYTE = 7,
	_DRM_STAT_COUNT = 8,
	_DRM_STAT_IRQ = 9,
	_DRM_STAT_PRIMARY = 10,
	_DRM_STAT_SECONDARY = 11,
	_DRM_STAT_DMA = 12,
	_DRM_STAT_SPECIAL = 13,
	_DRM_STAT_MISSED = 14,
};

struct drm_stats {
	long unsigned int count;
	struct {
		long unsigned int value;
		enum drm_stat_type type;
	} data[15];
};

struct drm_set_version {
	int drm_di_major;
	int drm_di_minor;
	int drm_dd_major;
	int drm_dd_minor;
};

struct drm_get_cap {
	__u64 capability;
	__u64 value;
};

struct drm_set_client_cap {
	__u64 capability;
	__u64 value;
};

struct drm_agp_head {
	struct agp_kern_info agp_info;
	struct list_head memory;
	long unsigned int mode;
	struct agp_bridge_data *bridge;
	int enabled;
	int acquired;
	long unsigned int base;
	int agp_mtrr;
	int cant_use_aperture;
	long unsigned int page_mask;
};

enum drm_map_type {
	_DRM_FRAME_BUFFER = 0,
	_DRM_REGISTERS = 1,
	_DRM_SHM = 2,
	_DRM_AGP = 3,
	_DRM_SCATTER_GATHER = 4,
	_DRM_CONSISTENT = 5,
};

enum drm_map_flags {
	_DRM_RESTRICTED = 1,
	_DRM_READ_ONLY = 2,
	_DRM_LOCKED = 4,
	_DRM_KERNEL = 8,
	_DRM_WRITE_COMBINING = 16,
	_DRM_CONTAINS_LOCK = 32,
	_DRM_REMOVABLE = 64,
	_DRM_DRIVER = 128,
};

struct drm_local_map {
	dma_addr_t offset;
	long unsigned int size;
	enum drm_map_type type;
	enum drm_map_flags flags;
	void *handle;
	int mtrr;
};

struct class_attribute_string {
	struct class_attribute attr;
	char *str;
};

struct drm_hash_item {
	struct hlist_node head;
	long unsigned int key;
};

struct drm_open_hash {
	struct hlist_head *table;
	u8 order;
};

enum drm_mm_insert_mode {
	DRM_MM_INSERT_BEST = 0,
	DRM_MM_INSERT_LOW = 1,
	DRM_MM_INSERT_HIGH = 2,
	DRM_MM_INSERT_EVICT = 3,
	DRM_MM_INSERT_ONCE = 2147483648,
	DRM_MM_INSERT_HIGHEST = 2147483650,
	DRM_MM_INSERT_LOWEST = 2147483649,
};

struct drm_mm_scan {
	struct drm_mm *mm;
	u64 size;
	u64 alignment;
	u64 remainder_mask;
	u64 range_start;
	u64 range_end;
	u64 hit_start;
	u64 hit_end;
	long unsigned int color;
	enum drm_mm_insert_mode mode;
};

struct drm_mode_modeinfo {
	__u32 clock;
	__u16 hdisplay;
	__u16 hsync_start;
	__u16 hsync_end;
	__u16 htotal;
	__u16 hskew;
	__u16 vdisplay;
	__u16 vsync_start;
	__u16 vsync_end;
	__u16 vtotal;
	__u16 vscan;
	__u32 vrefresh;
	__u32 flags;
	__u32 type;
	char name[32];
};

struct drm_mode_crtc {
	__u64 set_connectors_ptr;
	__u32 count_connectors;
	__u32 crtc_id;
	__u32 fb_id;
	__u32 x;
	__u32 y;
	__u32 gamma_size;
	__u32 mode_valid;
	struct drm_mode_modeinfo mode;
};

struct drm_format_name_buf {
	char str[32];
};

enum drm_bus_flags {
	DRM_BUS_FLAG_DE_LOW = 1,
	DRM_BUS_FLAG_DE_HIGH = 2,
	DRM_BUS_FLAG_PIXDATA_DRIVE_POSEDGE = 4,
	DRM_BUS_FLAG_PIXDATA_DRIVE_NEGEDGE = 8,
	DRM_BUS_FLAG_PIXDATA_SAMPLE_POSEDGE = 8,
	DRM_BUS_FLAG_PIXDATA_SAMPLE_NEGEDGE = 4,
	DRM_BUS_FLAG_DATA_MSB_TO_LSB = 16,
	DRM_BUS_FLAG_DATA_LSB_TO_MSB = 32,
	DRM_BUS_FLAG_SYNC_DRIVE_POSEDGE = 64,
	DRM_BUS_FLAG_SYNC_DRIVE_NEGEDGE = 128,
	DRM_BUS_FLAG_SYNC_SAMPLE_POSEDGE = 128,
	DRM_BUS_FLAG_SYNC_SAMPLE_NEGEDGE = 64,
	DRM_BUS_FLAG_SHARP_SIGNALS = 256,
};

struct displayid_hdr {
	u8 rev;
	u8 bytes;
	u8 prod_id;
	u8 ext_count;
};

struct displayid_block {
	u8 tag;
	u8 rev;
	u8 num_bytes;
};

struct displayid_tiled_block {
	struct displayid_block base;
	u8 tile_cap;
	u8 topo[3];
	u8 tile_size[4];
	u8 tile_pixel_bezel[5];
	u8 topology_id[8];
};

struct displayid_detailed_timings_1 {
	u8 pixel_clock[3];
	u8 flags;
	u8 hactive[2];
	u8 hblank[2];
	u8 hsync[2];
	u8 hsw[2];
	u8 vactive[2];
	u8 vblank[2];
	u8 vsync[2];
	u8 vsw[2];
};

struct displayid_detailed_timing_block {
	struct displayid_block base;
	struct displayid_detailed_timings_1 timings[0];
};

struct hdr_metadata_infoframe {
	__u8 eotf;
	__u8 metadata_type;
	struct {
		__u16 x;
		__u16 y;
	} display_primaries[3];
	struct {
		__u16 x;
		__u16 y;
	} white_point;
	__u16 max_display_mastering_luminance;
	__u16 min_display_mastering_luminance;
	__u16 max_cll;
	__u16 max_fall;
};

struct hdr_output_metadata {
	__u32 metadata_type;
	union {
		struct hdr_metadata_infoframe hdmi_metadata_type1;
	};
};

struct cea_sad {
	u8 format;
	u8 channels;
	u8 freq;
	u8 byte2;
};

struct detailed_mode_closure {
	struct drm_connector *connector;
	struct edid *edid;
	bool preferred;
	u32 quirks;
	int modes;
};

struct edid_quirk___2 {
	char vendor[4];
	int product_id;
	u32 quirks;
};

struct minimode {
	short int w;
	short int h;
	short int r;
	short int rb;
};

typedef void detailed_cb(struct detailed_timing *, void *);

struct stereo_mandatory_mode {
	int width;
	int height;
	int vrefresh;
	unsigned int flags;
};

struct drm_encoder_slave_funcs {
	void (*set_config)(struct drm_encoder *, void *);
	void (*destroy)(struct drm_encoder *);
	void (*dpms)(struct drm_encoder *, int);
	void (*save)(struct drm_encoder *);
	void (*restore)(struct drm_encoder *);
	bool (*mode_fixup)(struct drm_encoder *, const struct drm_display_mode *, struct drm_display_mode *);
	int (*mode_valid)(struct drm_encoder *, struct drm_display_mode *);
	void (*mode_set)(struct drm_encoder *, struct drm_display_mode *, struct drm_display_mode *);
	enum drm_connector_status (*detect)(struct drm_encoder *, struct drm_connector *);
	int (*get_modes)(struct drm_encoder *, struct drm_connector *);
	int (*create_resources)(struct drm_encoder *, struct drm_connector *);
	int (*set_property)(struct drm_encoder *, struct drm_connector *, struct drm_property *, uint64_t);
};

struct drm_encoder_slave {
	struct drm_encoder base;
	const struct drm_encoder_slave_funcs *slave_funcs;
	void *slave_priv;
	void *bus_priv;
};

struct drm_i2c_encoder_driver {
	struct i2c_driver i2c_driver;
	int (*encoder_init)(struct i2c_client *, struct drm_device *, struct drm_encoder_slave *);
};

struct trace_event_raw_drm_vblank_event {
	struct trace_entry ent;
	int crtc;
	unsigned int seq;
	ktime_t time;
	bool high_prec;
	char __data[0];
};

struct trace_event_raw_drm_vblank_event_queued {
	struct trace_entry ent;
	struct drm_file *file;
	int crtc;
	unsigned int seq;
	char __data[0];
};

struct trace_event_raw_drm_vblank_event_delivered {
	struct trace_entry ent;
	struct drm_file *file;
	int crtc;
	unsigned int seq;
	char __data[0];
};

struct trace_event_data_offsets_drm_vblank_event {};

struct trace_event_data_offsets_drm_vblank_event_queued {};

struct trace_event_data_offsets_drm_vblank_event_delivered {};

typedef void (*btf_trace_drm_vblank_event)(void *, int, unsigned int, ktime_t, bool);

typedef void (*btf_trace_drm_vblank_event_queued)(void *, struct drm_file *, int, unsigned int);

typedef void (*btf_trace_drm_vblank_event_delivered)(void *, struct drm_file *, int, unsigned int);

struct drm_prime_handle {
	__u32 handle;
	__u32 flags;
	__s32 fd;
};

struct drm_prime_member {
	struct dma_buf *dma_buf;
	uint32_t handle;
	struct rb_node dmabuf_rb;
	struct rb_node handle_rb;
};

struct drm_vma_offset_file {
	struct rb_node vm_rb;
	struct drm_file *vm_tag;
	long unsigned int vm_count;
};

struct drm_flip_work;

typedef void (*drm_flip_func_t)(struct drm_flip_work *, void *);

struct drm_flip_work {
	const char *name;
	drm_flip_func_t func;
	struct work_struct worker;
	struct list_head queued;
	struct list_head commited;
	spinlock_t lock;
};

struct drm_flip_task {
	struct list_head node;
	void *data;
};

struct drm_info_list {
	const char *name;
	int (*show)(struct seq_file *, void *);
	u32 driver_features;
	void *data;
};

struct drm_info_node {
	struct drm_minor *minor;
	const struct drm_info_list *info_ent;
	struct list_head list;
	struct dentry *dent;
};

struct drm_mode_fb_cmd {
	__u32 fb_id;
	__u32 width;
	__u32 height;
	__u32 pitch;
	__u32 bpp;
	__u32 depth;
	__u32 handle;
};

struct drm_mode_fb_dirty_cmd {
	__u32 fb_id;
	__u32 flags;
	__u32 color;
	__u32 num_clips;
	__u64 clips_ptr;
};

struct drm_mode_rmfb_work {
	struct work_struct work;
	struct list_head fbs;
};

struct drm_mode_get_connector {
	__u64 encoders_ptr;
	__u64 modes_ptr;
	__u64 props_ptr;
	__u64 prop_values_ptr;
	__u32 count_modes;
	__u32 count_props;
	__u32 count_encoders;
	__u32 encoder_id;
	__u32 connector_id;
	__u32 connector_type;
	__u32 connector_type_id;
	__u32 connection;
	__u32 mm_width;
	__u32 mm_height;
	__u32 subpixel;
	__u32 pad;
};

struct drm_mode_connector_set_property {
	__u64 value;
	__u32 prop_id;
	__u32 connector_id;
};

struct drm_mode_obj_set_property {
	__u64 value;
	__u32 prop_id;
	__u32 obj_id;
	__u32 obj_type;
};

struct drm_prop_enum_list {
	int type;
	const char *name;
};

struct drm_conn_prop_enum_list {
	int type;
	const char *name;
	struct ida ida;
};

struct drm_mode_get_encoder {
	__u32 encoder_id;
	__u32 encoder_type;
	__u32 crtc_id;
	__u32 possible_crtcs;
	__u32 possible_clones;
};

struct drm_mode_obj_get_properties {
	__u64 props_ptr;
	__u64 prop_values_ptr;
	__u32 count_props;
	__u32 obj_id;
	__u32 obj_type;
};

struct drm_mode_property_enum {
	__u64 value;
	char name[32];
};

struct drm_mode_get_property {
	__u64 values_ptr;
	__u64 enum_blob_ptr;
	__u32 prop_id;
	__u32 flags;
	char name[32];
	__u32 count_values;
	__u32 count_enum_blobs;
};

struct drm_mode_get_blob {
	__u32 blob_id;
	__u32 length;
	__u64 data;
};

struct drm_mode_create_blob {
	__u64 data;
	__u32 length;
	__u32 blob_id;
};

struct drm_mode_destroy_blob {
	__u32 blob_id;
};

struct drm_property_enum {
	uint64_t value;
	struct list_head head;
	char name[32];
};

struct drm_mode_set_plane {
	__u32 plane_id;
	__u32 crtc_id;
	__u32 fb_id;
	__u32 flags;
	__s32 crtc_x;
	__s32 crtc_y;
	__u32 crtc_w;
	__u32 crtc_h;
	__u32 src_x;
	__u32 src_y;
	__u32 src_h;
	__u32 src_w;
};

struct drm_mode_get_plane {
	__u32 plane_id;
	__u32 crtc_id;
	__u32 fb_id;
	__u32 possible_crtcs;
	__u32 gamma_size;
	__u32 count_format_types;
	__u64 format_type_ptr;
};

struct drm_mode_get_plane_res {
	__u64 plane_id_ptr;
	__u32 count_planes;
};

struct drm_mode_cursor {
	__u32 flags;
	__u32 crtc_id;
	__s32 x;
	__s32 y;
	__u32 width;
	__u32 height;
	__u32 handle;
};

struct drm_mode_cursor2 {
	__u32 flags;
	__u32 crtc_id;
	__s32 x;
	__s32 y;
	__u32 width;
	__u32 height;
	__u32 handle;
	__s32 hot_x;
	__s32 hot_y;
};

struct drm_mode_crtc_page_flip_target {
	__u32 crtc_id;
	__u32 fb_id;
	__u32 flags;
	__u32 sequence;
	__u64 user_data;
};

struct drm_format_modifier_blob {
	__u32 version;
	__u32 flags;
	__u32 count_formats;
	__u32 formats_offset;
	__u32 count_modifiers;
	__u32 modifiers_offset;
};

struct drm_format_modifier {
	__u64 formats;
	__u32 offset;
	__u32 pad;
	__u64 modifier;
};

struct drm_mode_crtc_lut {
	__u32 crtc_id;
	__u32 gamma_size;
	__u64 red;
	__u64 green;
	__u64 blue;
};

enum drm_color_lut_tests {
	DRM_COLOR_LUT_EQUAL_CHANNELS = 1,
	DRM_COLOR_LUT_NON_DECREASING = 2,
};

struct drm_print_iterator {
	void *data;
	ssize_t start;
	ssize_t remain;
	ssize_t offset;
};

struct drm_mode_map_dumb {
	__u32 handle;
	__u32 pad;
	__u64 offset;
};

struct drm_mode_destroy_dumb {
	__u32 handle;
};

struct drm_mode_card_res {
	__u64 fb_id_ptr;
	__u64 crtc_id_ptr;
	__u64 connector_id_ptr;
	__u64 encoder_id_ptr;
	__u32 count_fbs;
	__u32 count_crtcs;
	__u32 count_connectors;
	__u32 count_encoders;
	__u32 min_width;
	__u32 max_width;
	__u32 min_height;
	__u32 max_height;
};

enum drm_vblank_seq_type {
	_DRM_VBLANK_ABSOLUTE = 0,
	_DRM_VBLANK_RELATIVE = 1,
	_DRM_VBLANK_HIGH_CRTC_MASK = 62,
	_DRM_VBLANK_EVENT = 67108864,
	_DRM_VBLANK_FLIP = 134217728,
	_DRM_VBLANK_NEXTONMISS = 268435456,
	_DRM_VBLANK_SECONDARY = 536870912,
	_DRM_VBLANK_SIGNAL = 1073741824,
};

struct drm_wait_vblank_request {
	enum drm_vblank_seq_type type;
	unsigned int sequence;
	long unsigned int signal;
};

struct drm_wait_vblank_reply {
	enum drm_vblank_seq_type type;
	unsigned int sequence;
	long int tval_sec;
	long int tval_usec;
};

union drm_wait_vblank {
	struct drm_wait_vblank_request request;
	struct drm_wait_vblank_reply reply;
};

struct drm_modeset_ctl {
	__u32 crtc;
	__u32 cmd;
};

struct drm_crtc_get_sequence {
	__u32 crtc_id;
	__u32 active;
	__u64 sequence;
	__s64 sequence_ns;
};

struct drm_crtc_queue_sequence {
	__u32 crtc_id;
	__u32 flags;
	__u64 sequence;
	__u64 user_data;
};

typedef bool (*drm_vblank_get_scanout_position_func)(struct drm_crtc *, bool, int *, int *, ktime_t *, ktime_t *, const struct drm_display_mode *);

enum dma_fence_flag_bits {
	DMA_FENCE_FLAG_SIGNALED_BIT = 0,
	DMA_FENCE_FLAG_TIMESTAMP_BIT = 1,
	DMA_FENCE_FLAG_ENABLE_SIGNAL_BIT = 2,
	DMA_FENCE_FLAG_USER_BITS = 3,
};

struct sync_file {
	struct file *file;
	char user_name[32];
	struct list_head sync_file_list;
	wait_queue_head_t wq;
	long unsigned int flags;
	struct dma_fence *fence;
	struct dma_fence_cb cb;
};

struct drm_syncobj_create {
	__u32 handle;
	__u32 flags;
};

struct drm_syncobj_destroy {
	__u32 handle;
	__u32 pad;
};

struct drm_syncobj_handle {
	__u32 handle;
	__u32 flags;
	__s32 fd;
	__u32 pad;
};

struct drm_syncobj_transfer {
	__u32 src_handle;
	__u32 dst_handle;
	__u64 src_point;
	__u64 dst_point;
	__u32 flags;
	__u32 pad;
};

struct drm_syncobj_wait {
	__u64 handles;
	__s64 timeout_nsec;
	__u32 count_handles;
	__u32 flags;
	__u32 first_signaled;
	__u32 pad;
};

struct drm_syncobj_timeline_wait {
	__u64 handles;
	__u64 points;
	__s64 timeout_nsec;
	__u32 count_handles;
	__u32 flags;
	__u32 first_signaled;
	__u32 pad;
};

struct drm_syncobj_array {
	__u64 handles;
	__u32 count_handles;
	__u32 pad;
};

struct drm_syncobj_timeline_array {
	__u64 handles;
	__u64 points;
	__u32 count_handles;
	__u32 flags;
};

struct dma_fence_chain {
	struct dma_fence base;
	spinlock_t lock;
	struct dma_fence *prev;
	u64 prev_seqno;
	struct dma_fence *fence;
	struct dma_fence_cb cb;
	struct irq_work work;
};

struct drm_syncobj {
	struct kref refcount;
	struct dma_fence *fence;
	struct list_head cb_list;
	spinlock_t lock;
	struct file *file;
};

struct syncobj_wait_entry {
	struct list_head node;
	struct task_struct *task;
	struct dma_fence *fence;
	struct dma_fence_cb fence_cb;
	u64 point;
};

struct drm_mode_create_lease {
	__u64 object_ids;
	__u32 object_count;
	__u32 flags;
	__u32 lessee_id;
	__u32 fd;
};

struct drm_mode_list_lessees {
	__u32 count_lessees;
	__u32 pad;
	__u64 lessees_ptr;
};

struct drm_mode_get_lease {
	__u32 count_objects;
	__u32 pad;
	__u64 objects_ptr;
};

struct drm_mode_revoke_lease {
	__u32 lessee_id;
};

struct drm_client_offset {
	int x;
	int y;
};

struct drm_mode_atomic {
	__u32 flags;
	__u32 count_objs;
	__u64 objs_ptr;
	__u64 count_props_ptr;
	__u64 props_ptr;
	__u64 prop_values_ptr;
	__u64 reserved;
	__u64 user_data;
};

struct drm_out_fence_state {
	s32 *out_fence_ptr;
	struct sync_file *sync_file;
	int fd;
};

struct firmware {
	size_t size;
	const u8 *data;
	void *priv;
};

struct hdcp_srm_header {
	u8 srm_id;
	u8 reserved;
	__be16 srm_version;
	u8 srm_gen_no;
} __attribute__((packed));

typedef void (*drmres_release_t)(struct drm_device *, void *);

struct drmres_node {
	struct list_head entry;
	drmres_release_t release;
	const char *name;
	size_t size;
};

struct drmres {
	struct drmres_node node;
	long: 64;
	long: 64;
	long: 64;
	u8 data[0];
};

struct drm_vblank_work {
	struct kthread_work base;
	struct drm_vblank_crtc *vblank;
	u64 count;
	int cancelling;
	struct list_head node;
};

struct component_master_ops {
	int (*bind)(struct device *);
	void (*unbind)(struct device *);
};

struct of_endpoint {
	unsigned int port;
	unsigned int id;
	const struct device_node *local_node;
};

enum drm_lvds_dual_link_pixels {
	DRM_LVDS_DUAL_LINK_EVEN_ODD_PIXELS = 0,
	DRM_LVDS_DUAL_LINK_ODD_EVEN_PIXELS = 1,
};

enum drm_of_lvds_pixels {
	DRM_OF_LVDS_EVEN = 1,
	DRM_OF_LVDS_ODD = 2,
};

struct component_match;

struct mipi_dsi_msg {
	u8 channel;
	u8 type;
	u16 flags;
	u32 ctrl;
	u32 wait_ms;
	size_t tx_len;
	const void *tx_buf;
	size_t rx_len;
	void *rx_buf;
};

struct mipi_dsi_packet {
	size_t size;
	u8 header[4];
	size_t payload_length;
	const u8 *payload;
};

struct mipi_dsi_host;

struct mipi_dsi_device;

struct mipi_dsi_host_ops {
	int (*attach)(struct mipi_dsi_host *, struct mipi_dsi_device *);
	int (*detach)(struct mipi_dsi_host *, struct mipi_dsi_device *);
	ssize_t (*transfer)(struct mipi_dsi_host *, const struct mipi_dsi_msg *);
};

struct mipi_dsi_host {
	struct device *dev;
	const struct mipi_dsi_host_ops *ops;
	struct list_head list;
};

enum mipi_dsi_pixel_format {
	MIPI_DSI_FMT_RGB888 = 0,
	MIPI_DSI_FMT_RGB666 = 1,
	MIPI_DSI_FMT_RGB666_PACKED = 2,
	MIPI_DSI_FMT_RGB565 = 3,
};

struct mipi_dsi_device {
	struct mipi_dsi_host *host;
	struct device dev;
	char name[20];
	unsigned int channel;
	unsigned int lanes;
	enum mipi_dsi_pixel_format format;
	long unsigned int mode_flags;
	long unsigned int hs_rate;
	long unsigned int lp_rate;
};

struct mipi_dsi_device_info {
	char type[20];
	u32 channel;
	struct device_node *node;
};

enum mipi_dsi_dcs_tear_mode {
	MIPI_DSI_DCS_TEAR_MODE_VBLANK = 0,
	MIPI_DSI_DCS_TEAR_MODE_VHBLANK = 1,
};

struct mipi_dsi_driver {
	struct device_driver driver;
	int (*probe)(struct mipi_dsi_device *);
	int (*remove)(struct mipi_dsi_device *);
	void (*shutdown)(struct mipi_dsi_device *);
};

enum {
	MIPI_DSI_V_SYNC_START = 1,
	MIPI_DSI_V_SYNC_END = 17,
	MIPI_DSI_H_SYNC_START = 33,
	MIPI_DSI_H_SYNC_END = 49,
	MIPI_DSI_COMPRESSION_MODE = 7,
	MIPI_DSI_END_OF_TRANSMISSION = 8,
	MIPI_DSI_COLOR_MODE_OFF = 2,
	MIPI_DSI_COLOR_MODE_ON = 18,
	MIPI_DSI_SHUTDOWN_PERIPHERAL = 34,
	MIPI_DSI_TURN_ON_PERIPHERAL = 50,
	MIPI_DSI_GENERIC_SHORT_WRITE_0_PARAM = 3,
	MIPI_DSI_GENERIC_SHORT_WRITE_1_PARAM = 19,
	MIPI_DSI_GENERIC_SHORT_WRITE_2_PARAM = 35,
	MIPI_DSI_GENERIC_READ_REQUEST_0_PARAM = 4,
	MIPI_DSI_GENERIC_READ_REQUEST_1_PARAM = 20,
	MIPI_DSI_GENERIC_READ_REQUEST_2_PARAM = 36,
	MIPI_DSI_DCS_SHORT_WRITE = 5,
	MIPI_DSI_DCS_SHORT_WRITE_PARAM = 21,
	MIPI_DSI_DCS_READ = 6,
	MIPI_DSI_EXECUTE_QUEUE = 22,
	MIPI_DSI_SET_MAXIMUM_RETURN_PACKET_SIZE = 55,
	MIPI_DSI_NULL_PACKET = 9,
	MIPI_DSI_BLANKING_PACKET = 25,
	MIPI_DSI_GENERIC_LONG_WRITE = 41,
	MIPI_DSI_DCS_LONG_WRITE = 57,
	MIPI_DSI_PICTURE_PARAMETER_SET = 10,
	MIPI_DSI_COMPRESSED_PIXEL_STREAM = 11,
	MIPI_DSI_LOOSELY_PACKED_PIXEL_STREAM_YCBCR20 = 12,
	MIPI_DSI_PACKED_PIXEL_STREAM_YCBCR24 = 28,
	MIPI_DSI_PACKED_PIXEL_STREAM_YCBCR16 = 44,
	MIPI_DSI_PACKED_PIXEL_STREAM_30 = 13,
	MIPI_DSI_PACKED_PIXEL_STREAM_36 = 29,
	MIPI_DSI_PACKED_PIXEL_STREAM_YCBCR12 = 61,
	MIPI_DSI_PACKED_PIXEL_STREAM_16 = 14,
	MIPI_DSI_PACKED_PIXEL_STREAM_18 = 30,
	MIPI_DSI_PIXEL_STREAM_3BYTE_18 = 46,
	MIPI_DSI_PACKED_PIXEL_STREAM_24 = 62,
};

enum {
	MIPI_DCS_NOP = 0,
	MIPI_DCS_SOFT_RESET = 1,
	MIPI_DCS_GET_COMPRESSION_MODE = 3,
	MIPI_DCS_GET_DISPLAY_ID = 4,
	MIPI_DCS_GET_ERROR_COUNT_ON_DSI = 5,
	MIPI_DCS_GET_RED_CHANNEL = 6,
	MIPI_DCS_GET_GREEN_CHANNEL = 7,
	MIPI_DCS_GET_BLUE_CHANNEL = 8,
	MIPI_DCS_GET_DISPLAY_STATUS = 9,
	MIPI_DCS_GET_POWER_MODE = 10,
	MIPI_DCS_GET_ADDRESS_MODE = 11,
	MIPI_DCS_GET_PIXEL_FORMAT = 12,
	MIPI_DCS_GET_DISPLAY_MODE = 13,
	MIPI_DCS_GET_SIGNAL_MODE = 14,
	MIPI_DCS_GET_DIAGNOSTIC_RESULT = 15,
	MIPI_DCS_ENTER_SLEEP_MODE = 16,
	MIPI_DCS_EXIT_SLEEP_MODE = 17,
	MIPI_DCS_ENTER_PARTIAL_MODE = 18,
	MIPI_DCS_ENTER_NORMAL_MODE = 19,
	MIPI_DCS_GET_IMAGE_CHECKSUM_RGB = 20,
	MIPI_DCS_GET_IMAGE_CHECKSUM_CT = 21,
	MIPI_DCS_EXIT_INVERT_MODE = 32,
	MIPI_DCS_ENTER_INVERT_MODE = 33,
	MIPI_DCS_SET_GAMMA_CURVE = 38,
	MIPI_DCS_SET_DISPLAY_OFF = 40,
	MIPI_DCS_SET_DISPLAY_ON = 41,
	MIPI_DCS_SET_COLUMN_ADDRESS = 42,
	MIPI_DCS_SET_PAGE_ADDRESS = 43,
	MIPI_DCS_WRITE_MEMORY_START = 44,
	MIPI_DCS_WRITE_LUT = 45,
	MIPI_DCS_READ_MEMORY_START = 46,
	MIPI_DCS_SET_PARTIAL_ROWS = 48,
	MIPI_DCS_SET_PARTIAL_COLUMNS = 49,
	MIPI_DCS_SET_SCROLL_AREA = 51,
	MIPI_DCS_SET_TEAR_OFF = 52,
	MIPI_DCS_SET_TEAR_ON = 53,
	MIPI_DCS_SET_ADDRESS_MODE = 54,
	MIPI_DCS_SET_SCROLL_START = 55,
	MIPI_DCS_EXIT_IDLE_MODE = 56,
	MIPI_DCS_ENTER_IDLE_MODE = 57,
	MIPI_DCS_SET_PIXEL_FORMAT = 58,
	MIPI_DCS_WRITE_MEMORY_CONTINUE = 60,
	MIPI_DCS_SET_3D_CONTROL = 61,
	MIPI_DCS_READ_MEMORY_CONTINUE = 62,
	MIPI_DCS_GET_3D_CONTROL = 63,
	MIPI_DCS_SET_VSYNC_TIMING = 64,
	MIPI_DCS_SET_TEAR_SCANLINE = 68,
	MIPI_DCS_GET_SCANLINE = 69,
	MIPI_DCS_SET_DISPLAY_BRIGHTNESS = 81,
	MIPI_DCS_GET_DISPLAY_BRIGHTNESS = 82,
	MIPI_DCS_WRITE_CONTROL_DISPLAY = 83,
	MIPI_DCS_GET_CONTROL_DISPLAY = 84,
	MIPI_DCS_WRITE_POWER_SAVE = 85,
	MIPI_DCS_GET_POWER_SAVE = 86,
	MIPI_DCS_SET_CABC_MIN_BRIGHTNESS = 94,
	MIPI_DCS_GET_CABC_MIN_BRIGHTNESS = 95,
	MIPI_DCS_READ_DDB_START = 161,
	MIPI_DCS_READ_PPS_START = 162,
	MIPI_DCS_READ_DDB_CONTINUE = 168,
	MIPI_DCS_READ_PPS_CONTINUE = 169,
};

struct panel_desc {
	const struct drm_display_mode *modes;
	unsigned int num_modes;
	const struct display_timing *timings;
	unsigned int num_timings;
	unsigned int bpc;
	struct {
		unsigned int width;
		unsigned int height;
	} size;
	struct {
		unsigned int prepare;
		unsigned int hpd_absent_delay;
		unsigned int enable;
		unsigned int disable;
		unsigned int unprepare;
	} delay;
	u32 bus_format;
	u32 bus_flags;
	int connector_type;
};

struct panel_simple {
	struct drm_panel base;
	bool prepared;
	bool enabled;
	bool no_hpd;
	const struct panel_desc *desc;
	struct regulator *supply;
	struct i2c_adapter *ddc;
	struct gpio_desc *enable_gpio;
	struct gpio_desc *hpd_gpio;
	struct drm_display_mode override_mode;
	enum drm_panel_orientation orientation;
};

struct panel_desc_dsi {
	struct panel_desc desc;
	long unsigned int flags;
	enum mipi_dsi_pixel_format format;
	unsigned int lanes;
};

enum ili9881c_op {
	ILI9881C_SWITCH_PAGE = 0,
	ILI9881C_COMMAND = 1,
};

struct cmd {
	u8 cmd;
	u8 data;
};

union arg {
	struct cmd cmd;
	u8 page;
};

struct ili9881c_instr {
	enum ili9881c_op op;
	union arg arg;
};

struct ili9881c_desc {
	const struct ili9881c_instr *init;
	const size_t init_length;
	const struct drm_display_mode *mode;
};

struct ili9881c {
	struct drm_panel panel;
	struct mipi_dsi_device *dsi;
	const struct ili9881c_desc *desc;
	struct gpio_desc *reset;
	struct regulator_bulk_data *supplies;
	unsigned int num_supplies;
	bool prepared;
};

struct input_mt_slot {
	int abs[14];
	unsigned int frame;
	unsigned int key;
};

struct input_mt {
	int trkid;
	int num_slots;
	int slot;
	unsigned int flags;
	unsigned int frame;
	int *red;
	struct input_mt_slot slots[0];
};

struct touchscreen_properties {
	unsigned int max_x;
	unsigned int max_y;
	bool invert_x;
	bool invert_y;
	bool swap_x_y;
};

enum REG_ADDR {
	REG_ID = 128,
	REG_PORTA = 129,
	REG_PORTB = 130,
	REG_PORTC = 131,
	REG_PORTD = 132,
	REG_POWERON = 133,
	REG_PWM = 134,
	REG_DDRA = 135,
	REG_DDRB = 136,
	REG_DDRC = 137,
	REG_DDRD = 138,
	REG_TEST = 139,
	REG_WR_ADDRL = 140,
	REG_WR_ADDRH = 141,
	REG_READH = 142,
	REG_READL = 143,
	REG_WRITEH = 144,
	REG_WRITEL = 145,
	REG_ID2 = 146,
	REG_LCD_RST = 147,
	REG_TP_RST = 148,
	REG_TP_STATUS = 149,
	REG_TP_POINT = 150,
	REG_TP_VERSION = 151,
	REG_ADC1 = 152,
	REG_ADC2 = 153,
	REG_MCU_AUTO_RESET = 154,
	REG_MAX = 155,
};

struct panel_data {
	void (*set_dsi)(struct mipi_dsi_device *);
	const struct drm_panel_funcs *funcs;
};

struct i2c_mipi_dsi {
	struct i2c_client *i2c;
	struct mutex mutex;
	struct drm_panel panel;
	struct panel_data *panel_data;
	struct mipi_dsi_device *dsi;
	struct input_dev *input;
	struct touchscreen_properties prop;
	uint32_t tp_point_rotate;
	int brightness;
	uint32_t mcu_auto_reset;
};

struct hx8394_panel_cmd {
	char cmdlen;
	char cmddata[64];
};

struct hx8394_panel_desc {
	const struct drm_display_mode *display_mode;
	long unsigned int mode_flags;
	enum mipi_dsi_pixel_format format;
	unsigned int lanes;
	const struct hx8394_panel_cmd *on_cmds;
	unsigned int on_cmds_num;
};

struct panel_info {
	struct drm_panel base;
	struct mipi_dsi_device *link;
	const struct hx8394_panel_desc *desc;
	struct gpio_desc *reset;
	struct regulator *hsvcc;
	struct regulator *vspn3v3;
	bool prepared;
	bool enabled;
};

struct extcon_dev;

struct cec_drm_connector_info {
	__u32 card_no;
	__u32 connector_id;
};

struct cec_connector_info {
	__u32 type;
	union {
		struct cec_drm_connector_info drm;
		__u32 raw[16];
	};
};

enum v4l2_preemphasis {
	V4L2_PREEMPHASIS_DISABLED = 0,
	V4L2_PREEMPHASIS_50_uS = 1,
	V4L2_PREEMPHASIS_75_uS = 2,
};

enum v4l2_ycbcr_encoding {
	V4L2_YCBCR_ENC_DEFAULT = 0,
	V4L2_YCBCR_ENC_601 = 1,
	V4L2_YCBCR_ENC_709 = 2,
	V4L2_YCBCR_ENC_XV601 = 3,
	V4L2_YCBCR_ENC_XV709 = 4,
	V4L2_YCBCR_ENC_BT2020 = 6,
	V4L2_YCBCR_ENC_BT2020_CONST_LUM = 7,
	V4L2_YCBCR_ENC_SMPTE240M = 8,
};

enum {
	SNDRV_PCM_STREAM_PLAYBACK = 0,
	SNDRV_PCM_STREAM_CAPTURE = 1,
	SNDRV_PCM_STREAM_LAST = 1,
};

enum {
	SND_CTL_SUBDEV_PCM = 0,
	SND_CTL_SUBDEV_RAWMIDI = 1,
	SND_CTL_SUBDEV_ITEMS = 2,
};

typedef void (*hdmi_codec_plugged_cb)(struct device *, bool);

enum {
	DW_HDMI_RES_8 = 0,
	DW_HDMI_RES_10 = 1,
	DW_HDMI_RES_12 = 2,
	DW_HDMI_RES_MAX = 3,
};

enum dw_hdmi_phy_type {
	DW_HDMI_PHY_DWC_HDMI_TX_PHY = 0,
	DW_HDMI_PHY_DWC_MHL_PHY_HEAC = 178,
	DW_HDMI_PHY_DWC_MHL_PHY = 194,
	DW_HDMI_PHY_DWC_HDMI_3D_TX_PHY_HEAC = 226,
	DW_HDMI_PHY_DWC_HDMI_3D_TX_PHY = 242,
	DW_HDMI_PHY_DWC_HDMI20_TX_PHY = 243,
	DW_HDMI_PHY_VENDOR_PHY = 254,
};

struct dw_hdmi_mpll_config {
	long unsigned int mpixelclock;
	struct {
		u16 cpce;
		u16 gmp;
	} res[3];
};

struct dw_hdmi_curr_ctrl {
	long unsigned int mpixelclock;
	u16 curr[3];
};

struct dw_hdmi_phy_config {
	long unsigned int mpixelclock;
	u16 sym_ctr;
	u16 term;
	u16 vlev_ctr;
};

struct dw_hdmi;

struct dw_hdmi_phy_ops {
	int (*init)(struct dw_hdmi *, void *, const struct drm_display_info *, const struct drm_display_mode *);
	void (*disable)(struct dw_hdmi *, void *);
	enum drm_connector_status (*read_hpd)(struct dw_hdmi *, void *);
	void (*update_hpd)(struct dw_hdmi *, void *, bool, bool, bool);
	void (*setup_hpd)(struct dw_hdmi *, void *);
};

struct hdmi_vmode {
	bool mdataenablepolarity;
	unsigned int mpixelclock;
	unsigned int mpixelrepetitioninput;
	unsigned int mpixelrepetitionoutput;
	unsigned int mtmdsclock;
};

struct hdmi_data_info {
	unsigned int enc_in_bus_format;
	unsigned int enc_out_bus_format;
	unsigned int enc_in_encoding;
	unsigned int enc_out_encoding;
	unsigned int pix_repet_factor;
	unsigned int hdcp_enable;
	struct hdmi_vmode video_mode;
	bool rgb_limited_range;
};

struct cec_notifier;

struct dw_hdmi_i2c;

struct dw_hdmi_plat_data;

struct dw_hdmi {
	struct drm_connector connector;
	struct drm_bridge bridge;
	unsigned int version;
	struct platform_device *audio;
	struct platform_device *cec;
	struct device *dev;
	struct clk *isfr_clk;
	struct clk *iahb_clk;
	struct clk *cec_clk;
	struct clk *pix_clk;
	struct clk *i2s_clk;
	struct dw_hdmi_i2c *i2c;
	struct extcon_dev *edev;
	struct hdmi_data_info hdmi_data;
	const struct dw_hdmi_plat_data *plat_data;
	int vic;
	u8 edid[512];
	struct {
		const struct dw_hdmi_phy_ops *ops;
		const char *name;
		void *data;
		bool enabled;
	} phy;
	struct drm_display_mode previous_mode;
	struct i2c_adapter *ddc;
	void *regs;
	bool sink_is_hdmi;
	bool sink_has_audio;
	struct pinctrl *pinctrl;
	struct pinctrl_state *default_state;
	struct pinctrl_state *unwedge_state;
	struct mutex mutex;
	enum drm_connector_force force;
	struct drm_connector *curr_conn;
	bool disabled;
	bool bridge_is_on;
	bool rxsense;
	u8 phy_mask;
	u8 mc_clkdis;
	spinlock_t audio_lock;
	struct mutex audio_mutex;
	unsigned int sample_rate;
	unsigned int audio_cts;
	unsigned int audio_n;
	bool audio_enable;
	unsigned int reg_shift;
	struct regmap *regm;
	void (*enable_audio)(struct dw_hdmi *);
	void (*disable_audio)(struct dw_hdmi *);
	struct mutex cec_notifier_mutex;
	struct cec_notifier *cec_notifier;
	hdmi_codec_plugged_cb plugged_cb;
	struct device *codec_dev;
	enum drm_connector_status last_connector_result;
};

struct dw_hdmi_plat_data {
	struct regmap *regm;
	long unsigned int input_bus_encoding;
	bool use_drm_infoframe;
	bool ycbcr_420_allowed;
	void *priv_data;
	enum drm_mode_status (*mode_valid)(struct dw_hdmi *, void *, const struct drm_display_info *, const struct drm_display_mode *);
	const struct dw_hdmi_phy_ops *phy_ops;
	const char *phy_name;
	void *phy_data;
	unsigned int phy_force_vendor;
	const struct dw_hdmi_mpll_config *mpll_cfg;
	const struct dw_hdmi_curr_ctrl *cur_ctr;
	const struct dw_hdmi_phy_config *phy_config;
	int (*configure_phy)(struct dw_hdmi *, void *, long unsigned int);
};

struct dw_hdmi_audio_data {
	phys_addr_t phys;
	void *base;
	int irq;
	struct dw_hdmi *hdmi;
	u8 * (*get_eld)(struct dw_hdmi *);
};

struct dw_hdmi_i2s_audio_data {
	struct dw_hdmi *hdmi;
	void (*write)(struct dw_hdmi *, u8, int);
	u8 (*read)(struct dw_hdmi *, int);
	u8 * (*get_eld)(struct dw_hdmi *);
};

struct dw_hdmi_cec_ops {
	void (*write)(struct dw_hdmi *, u8, int);
	u8 (*read)(struct dw_hdmi *, int);
	void (*enable)(struct dw_hdmi *);
	void (*disable)(struct dw_hdmi *);
};

struct dw_hdmi_cec_data {
	struct dw_hdmi *hdmi;
	const struct dw_hdmi_cec_ops *ops;
	int irq;
};

enum {
	HDMI_PRODUCT_ID0_HDMI_TX = 160,
	HDMI_PRODUCT_ID1_HDCP = 192,
	HDMI_PRODUCT_ID1_HDMI_RX = 2,
	HDMI_PRODUCT_ID1_HDMI_TX = 1,
	HDMI_CONFIG0_I2S = 16,
	HDMI_CONFIG0_CEC = 2,
	HDMI_CONFIG1_AHB = 1,
	HDMI_CONFIG3_AHBAUDDMA = 2,
	HDMI_CONFIG3_GPAUD = 1,
	HDMI_IH_FC_INT2_OVERFLOW_MASK = 3,
	HDMI_IH_FC_INT2_LOW_PRIORITY_OVERFLOW = 2,
	HDMI_IH_FC_INT2_HIGH_PRIORITY_OVERFLOW = 1,
	HDMI_IH_FC_STAT2_OVERFLOW_MASK = 3,
	HDMI_IH_FC_STAT2_LOW_PRIORITY_OVERFLOW = 2,
	HDMI_IH_FC_STAT2_HIGH_PRIORITY_OVERFLOW = 1,
	HDMI_IH_PHY_STAT0_RX_SENSE3 = 32,
	HDMI_IH_PHY_STAT0_RX_SENSE2 = 16,
	HDMI_IH_PHY_STAT0_RX_SENSE1 = 8,
	HDMI_IH_PHY_STAT0_RX_SENSE0 = 4,
	HDMI_IH_PHY_STAT0_TX_PHY_LOCK = 2,
	HDMI_IH_PHY_STAT0_HPD = 1,
	HDMI_IH_I2CM_STAT0_DONE = 2,
	HDMI_IH_I2CM_STAT0_ERROR = 1,
	HDMI_IH_MUTE_I2CMPHY_STAT0_I2CMPHYDONE = 2,
	HDMI_IH_MUTE_I2CMPHY_STAT0_I2CMPHYERROR = 1,
	HDMI_IH_AHBDMAAUD_STAT0_ERROR = 32,
	HDMI_IH_AHBDMAAUD_STAT0_LOST = 16,
	HDMI_IH_AHBDMAAUD_STAT0_RETRY = 8,
	HDMI_IH_AHBDMAAUD_STAT0_DONE = 4,
	HDMI_IH_AHBDMAAUD_STAT0_BUFFFULL = 2,
	HDMI_IH_AHBDMAAUD_STAT0_BUFFEMPTY = 1,
	HDMI_IH_MUTE_FC_STAT2_OVERFLOW_MASK = 3,
	HDMI_IH_MUTE_FC_STAT2_LOW_PRIORITY_OVERFLOW = 2,
	HDMI_IH_MUTE_FC_STAT2_HIGH_PRIORITY_OVERFLOW = 1,
	HDMI_IH_MUTE_AHBDMAAUD_STAT0_ERROR = 32,
	HDMI_IH_MUTE_AHBDMAAUD_STAT0_LOST = 16,
	HDMI_IH_MUTE_AHBDMAAUD_STAT0_RETRY = 8,
	HDMI_IH_MUTE_AHBDMAAUD_STAT0_DONE = 4,
	HDMI_IH_MUTE_AHBDMAAUD_STAT0_BUFFFULL = 2,
	HDMI_IH_MUTE_AHBDMAAUD_STAT0_BUFFEMPTY = 1,
	HDMI_IH_MUTE_MUTE_WAKEUP_INTERRUPT = 2,
	HDMI_IH_MUTE_MUTE_ALL_INTERRUPT = 1,
	HDMI_TX_INVID0_INTERNAL_DE_GENERATOR_MASK = 128,
	HDMI_TX_INVID0_INTERNAL_DE_GENERATOR_ENABLE = 128,
	HDMI_TX_INVID0_INTERNAL_DE_GENERATOR_DISABLE = 0,
	HDMI_TX_INVID0_VIDEO_MAPPING_MASK = 31,
	HDMI_TX_INVID0_VIDEO_MAPPING_OFFSET = 0,
	HDMI_TX_INSTUFFING_BDBDATA_STUFFING_MASK = 4,
	HDMI_TX_INSTUFFING_BDBDATA_STUFFING_ENABLE = 4,
	HDMI_TX_INSTUFFING_BDBDATA_STUFFING_DISABLE = 0,
	HDMI_TX_INSTUFFING_RCRDATA_STUFFING_MASK = 2,
	HDMI_TX_INSTUFFING_RCRDATA_STUFFING_ENABLE = 2,
	HDMI_TX_INSTUFFING_RCRDATA_STUFFING_DISABLE = 0,
	HDMI_TX_INSTUFFING_GYDATA_STUFFING_MASK = 1,
	HDMI_TX_INSTUFFING_GYDATA_STUFFING_ENABLE = 1,
	HDMI_TX_INSTUFFING_GYDATA_STUFFING_DISABLE = 0,
	HDMI_VP_PR_CD_COLOR_DEPTH_MASK = 240,
	HDMI_VP_PR_CD_COLOR_DEPTH_OFFSET = 4,
	HDMI_VP_PR_CD_DESIRED_PR_FACTOR_MASK = 15,
	HDMI_VP_PR_CD_DESIRED_PR_FACTOR_OFFSET = 0,
	HDMI_VP_STUFF_IDEFAULT_PHASE_MASK = 32,
	HDMI_VP_STUFF_IDEFAULT_PHASE_OFFSET = 5,
	HDMI_VP_STUFF_IFIX_PP_TO_LAST_MASK = 16,
	HDMI_VP_STUFF_IFIX_PP_TO_LAST_OFFSET = 4,
	HDMI_VP_STUFF_ICX_GOTO_P0_ST_MASK = 8,
	HDMI_VP_STUFF_ICX_GOTO_P0_ST_OFFSET = 3,
	HDMI_VP_STUFF_YCC422_STUFFING_MASK = 4,
	HDMI_VP_STUFF_YCC422_STUFFING_STUFFING_MODE = 4,
	HDMI_VP_STUFF_YCC422_STUFFING_DIRECT_MODE = 0,
	HDMI_VP_STUFF_PP_STUFFING_MASK = 2,
	HDMI_VP_STUFF_PP_STUFFING_STUFFING_MODE = 2,
	HDMI_VP_STUFF_PP_STUFFING_DIRECT_MODE = 0,
	HDMI_VP_STUFF_PR_STUFFING_MASK = 1,
	HDMI_VP_STUFF_PR_STUFFING_STUFFING_MODE = 1,
	HDMI_VP_STUFF_PR_STUFFING_DIRECT_MODE = 0,
	HDMI_VP_CONF_BYPASS_EN_MASK = 64,
	HDMI_VP_CONF_BYPASS_EN_ENABLE = 64,
	HDMI_VP_CONF_BYPASS_EN_DISABLE = 0,
	HDMI_VP_CONF_PP_EN_ENMASK = 32,
	HDMI_VP_CONF_PP_EN_ENABLE = 32,
	HDMI_VP_CONF_PP_EN_DISABLE = 0,
	HDMI_VP_CONF_PR_EN_MASK = 16,
	HDMI_VP_CONF_PR_EN_ENABLE = 16,
	HDMI_VP_CONF_PR_EN_DISABLE = 0,
	HDMI_VP_CONF_YCC422_EN_MASK = 8,
	HDMI_VP_CONF_YCC422_EN_ENABLE = 8,
	HDMI_VP_CONF_YCC422_EN_DISABLE = 0,
	HDMI_VP_CONF_BYPASS_SELECT_MASK = 4,
	HDMI_VP_CONF_BYPASS_SELECT_VID_PACKETIZER = 4,
	HDMI_VP_CONF_BYPASS_SELECT_PIX_REPEATER = 0,
	HDMI_VP_CONF_OUTPUT_SELECTOR_MASK = 3,
	HDMI_VP_CONF_OUTPUT_SELECTOR_BYPASS = 3,
	HDMI_VP_CONF_OUTPUT_SELECTOR_YCC422 = 1,
	HDMI_VP_CONF_OUTPUT_SELECTOR_PP = 0,
	HDMI_VP_REMAP_MASK = 3,
	HDMI_VP_REMAP_YCC422_24bit = 2,
	HDMI_VP_REMAP_YCC422_20bit = 1,
	HDMI_VP_REMAP_YCC422_16bit = 0,
	HDMI_FC_INVIDCONF_HDCP_KEEPOUT_MASK = 128,
	HDMI_FC_INVIDCONF_HDCP_KEEPOUT_ACTIVE = 128,
	HDMI_FC_INVIDCONF_HDCP_KEEPOUT_INACTIVE = 0,
	HDMI_FC_INVIDCONF_VSYNC_IN_POLARITY_MASK = 64,
	HDMI_FC_INVIDCONF_VSYNC_IN_POLARITY_ACTIVE_HIGH = 64,
	HDMI_FC_INVIDCONF_VSYNC_IN_POLARITY_ACTIVE_LOW = 0,
	HDMI_FC_INVIDCONF_HSYNC_IN_POLARITY_MASK = 32,
	HDMI_FC_INVIDCONF_HSYNC_IN_POLARITY_ACTIVE_HIGH = 32,
	HDMI_FC_INVIDCONF_HSYNC_IN_POLARITY_ACTIVE_LOW = 0,
	HDMI_FC_INVIDCONF_DE_IN_POLARITY_MASK = 16,
	HDMI_FC_INVIDCONF_DE_IN_POLARITY_ACTIVE_HIGH = 16,
	HDMI_FC_INVIDCONF_DE_IN_POLARITY_ACTIVE_LOW = 0,
	HDMI_FC_INVIDCONF_DVI_MODEZ_MASK = 8,
	HDMI_FC_INVIDCONF_DVI_MODEZ_HDMI_MODE = 8,
	HDMI_FC_INVIDCONF_DVI_MODEZ_DVI_MODE = 0,
	HDMI_FC_INVIDCONF_R_V_BLANK_IN_OSC_MASK = 2,
	HDMI_FC_INVIDCONF_R_V_BLANK_IN_OSC_ACTIVE_HIGH = 2,
	HDMI_FC_INVIDCONF_R_V_BLANK_IN_OSC_ACTIVE_LOW = 0,
	HDMI_FC_INVIDCONF_IN_I_P_MASK = 1,
	HDMI_FC_INVIDCONF_IN_I_P_INTERLACED = 1,
	HDMI_FC_INVIDCONF_IN_I_P_PROGRESSIVE = 0,
	HDMI_FC_AUDICONF0_CC_OFFSET = 4,
	HDMI_FC_AUDICONF0_CC_MASK = 112,
	HDMI_FC_AUDICONF0_CT_OFFSET = 0,
	HDMI_FC_AUDICONF0_CT_MASK = 15,
	HDMI_FC_AUDICONF1_SS_OFFSET = 3,
	HDMI_FC_AUDICONF1_SS_MASK = 24,
	HDMI_FC_AUDICONF1_SF_OFFSET = 0,
	HDMI_FC_AUDICONF1_SF_MASK = 7,
	HDMI_FC_AUDICONF3_LFEPBL_OFFSET = 5,
	HDMI_FC_AUDICONF3_LFEPBL_MASK = 96,
	HDMI_FC_AUDICONF3_DM_INH_OFFSET = 4,
	HDMI_FC_AUDICONF3_DM_INH_MASK = 16,
	HDMI_FC_AUDICONF3_LSV_OFFSET = 0,
	HDMI_FC_AUDICONF3_LSV_MASK = 15,
	HDMI_FC_AUDSCHNLS0_CGMSA_OFFSET = 4,
	HDMI_FC_AUDSCHNLS0_CGMSA_MASK = 48,
	HDMI_FC_AUDSCHNLS0_COPYRIGHT_OFFSET = 0,
	HDMI_FC_AUDSCHNLS0_COPYRIGHT_MASK = 1,
	HDMI_FC_AUDSCHNLS3_OIEC_CH0_OFFSET = 0,
	HDMI_FC_AUDSCHNLS3_OIEC_CH0_MASK = 15,
	HDMI_FC_AUDSCHNLS3_OIEC_CH1_OFFSET = 4,
	HDMI_FC_AUDSCHNLS3_OIEC_CH1_MASK = 240,
	HDMI_FC_AUDSCHNLS4_OIEC_CH2_OFFSET = 0,
	HDMI_FC_AUDSCHNLS4_OIEC_CH2_MASK = 15,
	HDMI_FC_AUDSCHNLS4_OIEC_CH3_OFFSET = 4,
	HDMI_FC_AUDSCHNLS4_OIEC_CH3_MASK = 240,
	HDMI_FC_AUDSCHNLS5_OIEC_CH0_OFFSET = 0,
	HDMI_FC_AUDSCHNLS5_OIEC_CH0_MASK = 15,
	HDMI_FC_AUDSCHNLS5_OIEC_CH1_OFFSET = 4,
	HDMI_FC_AUDSCHNLS5_OIEC_CH1_MASK = 240,
	HDMI_FC_AUDSCHNLS6_OIEC_CH2_OFFSET = 0,
	HDMI_FC_AUDSCHNLS6_OIEC_CH2_MASK = 15,
	HDMI_FC_AUDSCHNLS6_OIEC_CH3_OFFSET = 4,
	HDMI_FC_AUDSCHNLS6_OIEC_CH3_MASK = 240,
	HDMI_FC_AUDSCHNLS7_ACCURACY_OFFSET = 4,
	HDMI_FC_AUDSCHNLS7_ACCURACY_MASK = 48,
	HDMI_FC_AUDSCHNLS8_ORIGSAMPFREQ_MASK = 240,
	HDMI_FC_AUDSCHNLS8_ORIGSAMPFREQ_OFFSET = 4,
	HDMI_FC_AUDSCHNLS8_WORDLEGNTH_MASK = 15,
	HDMI_FC_AUDSCHNLS8_WORDLEGNTH_OFFSET = 0,
	HDMI_FC_AUDSCONF_AUD_PACKET_SAMPFIT_MASK = 240,
	HDMI_FC_AUDSCONF_AUD_PACKET_SAMPFIT_OFFSET = 4,
	HDMI_FC_AUDSCONF_AUD_PACKET_LAYOUT_MASK = 1,
	HDMI_FC_AUDSCONF_AUD_PACKET_LAYOUT_OFFSET = 0,
	HDMI_FC_AUDSCONF_AUD_PACKET_LAYOUT_LAYOUT1 = 1,
	HDMI_FC_AUDSCONF_AUD_PACKET_LAYOUT_LAYOUT0 = 0,
	HDMI_FC_STAT2_OVERFLOW_MASK = 3,
	HDMI_FC_STAT2_LOW_PRIORITY_OVERFLOW = 2,
	HDMI_FC_STAT2_HIGH_PRIORITY_OVERFLOW = 1,
	HDMI_FC_INT2_OVERFLOW_MASK = 3,
	HDMI_FC_INT2_LOW_PRIORITY_OVERFLOW = 2,
	HDMI_FC_INT2_HIGH_PRIORITY_OVERFLOW = 1,
	HDMI_FC_MASK2_OVERFLOW_MASK = 3,
	HDMI_FC_MASK2_LOW_PRIORITY_OVERFLOW = 2,
	HDMI_FC_MASK2_HIGH_PRIORITY_OVERFLOW = 1,
	HDMI_FC_PRCONF_INCOMING_PR_FACTOR_MASK = 240,
	HDMI_FC_PRCONF_INCOMING_PR_FACTOR_OFFSET = 4,
	HDMI_FC_PRCONF_OUTPUT_PR_FACTOR_MASK = 15,
	HDMI_FC_PRCONF_OUTPUT_PR_FACTOR_OFFSET = 0,
	HDMI_FC_PACKET_TX_EN_DRM_MASK = 128,
	HDMI_FC_PACKET_TX_EN_DRM_ENABLE = 128,
	HDMI_FC_PACKET_TX_EN_DRM_DISABLE = 0,
	HDMI_FC_AVICONF0_PIX_FMT_MASK = 3,
	HDMI_FC_AVICONF0_PIX_FMT_RGB = 0,
	HDMI_FC_AVICONF0_PIX_FMT_YCBCR422 = 1,
	HDMI_FC_AVICONF0_PIX_FMT_YCBCR444 = 2,
	HDMI_FC_AVICONF0_ACTIVE_FMT_MASK = 64,
	HDMI_FC_AVICONF0_ACTIVE_FMT_INFO_PRESENT = 64,
	HDMI_FC_AVICONF0_ACTIVE_FMT_NO_INFO = 0,
	HDMI_FC_AVICONF0_BAR_DATA_MASK = 12,
	HDMI_FC_AVICONF0_BAR_DATA_NO_DATA = 0,
	HDMI_FC_AVICONF0_BAR_DATA_VERT_BAR = 4,
	HDMI_FC_AVICONF0_BAR_DATA_HORIZ_BAR = 8,
	HDMI_FC_AVICONF0_BAR_DATA_VERT_HORIZ_BAR = 12,
	HDMI_FC_AVICONF0_SCAN_INFO_MASK = 48,
	HDMI_FC_AVICONF0_SCAN_INFO_OVERSCAN = 16,
	HDMI_FC_AVICONF0_SCAN_INFO_UNDERSCAN = 32,
	HDMI_FC_AVICONF0_SCAN_INFO_NODATA = 0,
	HDMI_FC_AVICONF1_ACTIVE_ASPECT_RATIO_MASK = 15,
	HDMI_FC_AVICONF1_ACTIVE_ASPECT_RATIO_USE_CODED = 8,
	HDMI_FC_AVICONF1_ACTIVE_ASPECT_RATIO_4_3 = 9,
	HDMI_FC_AVICONF1_ACTIVE_ASPECT_RATIO_16_9 = 10,
	HDMI_FC_AVICONF1_ACTIVE_ASPECT_RATIO_14_9 = 11,
	HDMI_FC_AVICONF1_CODED_ASPECT_RATIO_MASK = 48,
	HDMI_FC_AVICONF1_CODED_ASPECT_RATIO_NO_DATA = 0,
	HDMI_FC_AVICONF1_CODED_ASPECT_RATIO_4_3 = 16,
	HDMI_FC_AVICONF1_CODED_ASPECT_RATIO_16_9 = 32,
	HDMI_FC_AVICONF1_COLORIMETRY_MASK = 192,
	HDMI_FC_AVICONF1_COLORIMETRY_NO_DATA = 0,
	HDMI_FC_AVICONF1_COLORIMETRY_SMPTE = 64,
	HDMI_FC_AVICONF1_COLORIMETRY_ITUR = 128,
	HDMI_FC_AVICONF1_COLORIMETRY_EXTENDED_INFO = 192,
	HDMI_FC_AVICONF2_SCALING_MASK = 3,
	HDMI_FC_AVICONF2_SCALING_NONE = 0,
	HDMI_FC_AVICONF2_SCALING_HORIZ = 1,
	HDMI_FC_AVICONF2_SCALING_VERT = 2,
	HDMI_FC_AVICONF2_SCALING_HORIZ_VERT = 3,
	HDMI_FC_AVICONF2_RGB_QUANT_MASK = 12,
	HDMI_FC_AVICONF2_RGB_QUANT_DEFAULT = 0,
	HDMI_FC_AVICONF2_RGB_QUANT_LIMITED_RANGE = 4,
	HDMI_FC_AVICONF2_RGB_QUANT_FULL_RANGE = 8,
	HDMI_FC_AVICONF2_EXT_COLORIMETRY_MASK = 112,
	HDMI_FC_AVICONF2_EXT_COLORIMETRY_XVYCC601 = 0,
	HDMI_FC_AVICONF2_EXT_COLORIMETRY_XVYCC709 = 16,
	HDMI_FC_AVICONF2_EXT_COLORIMETRY_SYCC601 = 32,
	HDMI_FC_AVICONF2_EXT_COLORIMETRY_ADOBE_YCC601 = 48,
	HDMI_FC_AVICONF2_EXT_COLORIMETRY_ADOBE_RGB = 64,
	HDMI_FC_AVICONF2_IT_CONTENT_MASK = 128,
	HDMI_FC_AVICONF2_IT_CONTENT_NO_DATA = 0,
	HDMI_FC_AVICONF2_IT_CONTENT_VALID = 128,
	HDMI_FC_AVICONF3_IT_CONTENT_TYPE_MASK = 3,
	HDMI_FC_AVICONF3_IT_CONTENT_TYPE_GRAPHICS = 0,
	HDMI_FC_AVICONF3_IT_CONTENT_TYPE_PHOTO = 1,
	HDMI_FC_AVICONF3_IT_CONTENT_TYPE_CINEMA = 2,
	HDMI_FC_AVICONF3_IT_CONTENT_TYPE_GAME = 3,
	HDMI_FC_AVICONF3_QUANT_RANGE_MASK = 12,
	HDMI_FC_AVICONF3_QUANT_RANGE_LIMITED = 0,
	HDMI_FC_AVICONF3_QUANT_RANGE_FULL = 4,
	HDMI_FC_DBGFORCE_FORCEAUDIO = 16,
	HDMI_FC_DBGFORCE_FORCEVIDEO = 1,
	HDMI_FC_DATAUTO0_VSD_MASK = 8,
	HDMI_FC_DATAUTO0_VSD_OFFSET = 3,
	HDMI_PHY_CONF0_PDZ_MASK = 128,
	HDMI_PHY_CONF0_PDZ_OFFSET = 7,
	HDMI_PHY_CONF0_ENTMDS_MASK = 64,
	HDMI_PHY_CONF0_ENTMDS_OFFSET = 6,
	HDMI_PHY_CONF0_SVSRET_MASK = 32,
	HDMI_PHY_CONF0_SVSRET_OFFSET = 5,
	HDMI_PHY_CONF0_GEN2_PDDQ_MASK = 16,
	HDMI_PHY_CONF0_GEN2_PDDQ_OFFSET = 4,
	HDMI_PHY_CONF0_GEN2_TXPWRON_MASK = 8,
	HDMI_PHY_CONF0_GEN2_TXPWRON_OFFSET = 3,
	HDMI_PHY_CONF0_GEN2_ENHPDRXSENSE_MASK = 4,
	HDMI_PHY_CONF0_GEN2_ENHPDRXSENSE_OFFSET = 2,
	HDMI_PHY_CONF0_SELDATAENPOL_MASK = 2,
	HDMI_PHY_CONF0_SELDATAENPOL_OFFSET = 1,
	HDMI_PHY_CONF0_SELDIPIF_MASK = 1,
	HDMI_PHY_CONF0_SELDIPIF_OFFSET = 0,
	HDMI_PHY_TST0_TSTCLR_MASK = 32,
	HDMI_PHY_TST0_TSTCLR_OFFSET = 5,
	HDMI_PHY_TST0_TSTEN_MASK = 16,
	HDMI_PHY_TST0_TSTEN_OFFSET = 4,
	HDMI_PHY_TST0_TSTCLK_MASK = 1,
	HDMI_PHY_TST0_TSTCLK_OFFSET = 0,
	HDMI_PHY_RX_SENSE3 = 128,
	HDMI_PHY_RX_SENSE2 = 64,
	HDMI_PHY_RX_SENSE1 = 32,
	HDMI_PHY_RX_SENSE0 = 16,
	HDMI_PHY_HPD = 2,
	HDMI_PHY_TX_PHY_LOCK = 1,
	HDMI_PHY_I2CM_SLAVE_ADDR_PHY_GEN2 = 105,
	HDMI_PHY_I2CM_SLAVE_ADDR_HEAC_PHY = 73,
	HDMI_PHY_I2CM_OPERATION_ADDR_WRITE = 16,
	HDMI_PHY_I2CM_OPERATION_ADDR_READ = 1,
	HDMI_PHY_I2CM_INT_ADDR_DONE_POL = 8,
	HDMI_PHY_I2CM_INT_ADDR_DONE_MASK = 4,
	HDMI_PHY_I2CM_CTLINT_ADDR_NAC_POL = 128,
	HDMI_PHY_I2CM_CTLINT_ADDR_NAC_MASK = 64,
	HDMI_PHY_I2CM_CTLINT_ADDR_ARBITRATION_POL = 8,
	HDMI_PHY_I2CM_CTLINT_ADDR_ARBITRATION_MASK = 4,
	HDMI_AUD_CONF0_SW_RESET = 128,
	HDMI_AUD_CONF0_I2S_SELECT = 32,
	HDMI_AUD_CONF0_I2S_EN3 = 8,
	HDMI_AUD_CONF0_I2S_EN2 = 4,
	HDMI_AUD_CONF0_I2S_EN1 = 2,
	HDMI_AUD_CONF0_I2S_EN0 = 1,
	HDMI_AUD_CONF1_MODE_I2S = 0,
	HDMI_AUD_CONF1_MODE_RIGHT_J = 32,
	HDMI_AUD_CONF1_MODE_LEFT_J = 64,
	HDMI_AUD_CONF1_MODE_BURST_1 = 96,
	HDMI_AUD_CONF1_MODE_BURST_2 = 128,
	HDMI_AUD_CONF1_WIDTH_16 = 16,
	HDMI_AUD_CONF1_WIDTH_24 = 24,
	HDMI_AUD_CTS3_N_SHIFT_OFFSET = 5,
	HDMI_AUD_CTS3_N_SHIFT_MASK = 224,
	HDMI_AUD_CTS3_N_SHIFT_1 = 0,
	HDMI_AUD_CTS3_N_SHIFT_16 = 32,
	HDMI_AUD_CTS3_N_SHIFT_32 = 64,
	HDMI_AUD_CTS3_N_SHIFT_64 = 96,
	HDMI_AUD_CTS3_N_SHIFT_128 = 128,
	HDMI_AUD_CTS3_N_SHIFT_256 = 160,
	HDMI_AUD_CTS3_CTS_MANUAL = 16,
	HDMI_AUD_CTS3_AUDCTS19_16_MASK = 15,
	HDMI_AUD_INPUTCLKFS_128FS = 0,
	HDMI_AUD_INPUTCLKFS_256FS = 1,
	HDMI_AUD_INPUTCLKFS_512FS = 2,
	HDMI_AUD_INPUTCLKFS_64FS = 4,
	HDMI_AHB_DMA_CONF0_SW_FIFO_RST_OFFSET = 7,
	HDMI_AHB_DMA_CONF0_SW_FIFO_RST_MASK = 128,
	HDMI_AHB_DMA_CONF0_HBR = 16,
	HDMI_AHB_DMA_CONF0_EN_HLOCK_OFFSET = 3,
	HDMI_AHB_DMA_CONF0_EN_HLOCK_MASK = 8,
	HDMI_AHB_DMA_CONF0_INCR_TYPE_OFFSET = 1,
	HDMI_AHB_DMA_CONF0_INCR_TYPE_MASK = 6,
	HDMI_AHB_DMA_CONF0_INCR4 = 0,
	HDMI_AHB_DMA_CONF0_INCR8 = 2,
	HDMI_AHB_DMA_CONF0_INCR16 = 4,
	HDMI_AHB_DMA_CONF0_BURST_MODE = 1,
	HDMI_AHB_DMA_START_START_OFFSET = 0,
	HDMI_AHB_DMA_START_START_MASK = 1,
	HDMI_AHB_DMA_STOP_STOP_OFFSET = 0,
	HDMI_AHB_DMA_STOP_STOP_MASK = 1,
	HDMI_AHB_DMA_DONE = 128,
	HDMI_AHB_DMA_RETRY_SPLIT = 64,
	HDMI_AHB_DMA_LOSTOWNERSHIP = 32,
	HDMI_AHB_DMA_ERROR = 16,
	HDMI_AHB_DMA_FIFO_THREMPTY = 4,
	HDMI_AHB_DMA_FIFO_FULL = 2,
	HDMI_AHB_DMA_FIFO_EMPTY = 1,
	HDMI_AHB_DMA_BUFFSTAT_FULL = 2,
	HDMI_AHB_DMA_BUFFSTAT_EMPTY = 1,
	HDMI_MC_CLKDIS_HDCPCLK_DISABLE = 64,
	HDMI_MC_CLKDIS_CECCLK_DISABLE = 32,
	HDMI_MC_CLKDIS_CSCCLK_DISABLE = 16,
	HDMI_MC_CLKDIS_AUDCLK_DISABLE = 8,
	HDMI_MC_CLKDIS_PREPCLK_DISABLE = 4,
	HDMI_MC_CLKDIS_TMDSCLK_DISABLE = 2,
	HDMI_MC_CLKDIS_PIXELCLK_DISABLE = 1,
	HDMI_MC_SWRSTZ_I2SSWRST_REQ = 8,
	HDMI_MC_SWRSTZ_TMDSSWRST_REQ = 2,
	HDMI_MC_FLOWCTRL_FEED_THROUGH_OFF_MASK = 1,
	HDMI_MC_FLOWCTRL_FEED_THROUGH_OFF_CSC_IN_PATH = 1,
	HDMI_MC_FLOWCTRL_FEED_THROUGH_OFF_CSC_BYPASS = 0,
	HDMI_MC_PHYRSTZ_PHYRSTZ = 1,
	HDMI_MC_HEACPHY_RST_ASSERT = 1,
	HDMI_MC_HEACPHY_RST_DEASSERT = 0,
	HDMI_CSC_CFG_INTMODE_MASK = 48,
	HDMI_CSC_CFG_INTMODE_OFFSET = 4,
	HDMI_CSC_CFG_INTMODE_DISABLE = 0,
	HDMI_CSC_CFG_INTMODE_CHROMA_INT_FORMULA1 = 16,
	HDMI_CSC_CFG_INTMODE_CHROMA_INT_FORMULA2 = 32,
	HDMI_CSC_CFG_DECMODE_MASK = 3,
	HDMI_CSC_CFG_DECMODE_OFFSET = 0,
	HDMI_CSC_CFG_DECMODE_DISABLE = 0,
	HDMI_CSC_CFG_DECMODE_CHROMA_INT_FORMULA1 = 1,
	HDMI_CSC_CFG_DECMODE_CHROMA_INT_FORMULA2 = 2,
	HDMI_CSC_CFG_DECMODE_CHROMA_INT_FORMULA3 = 3,
	HDMI_CSC_SCALE_CSC_COLORDE_PTH_MASK = 240,
	HDMI_CSC_SCALE_CSC_COLORDE_PTH_24BPP = 0,
	HDMI_CSC_SCALE_CSC_COLORDE_PTH_30BPP = 80,
	HDMI_CSC_SCALE_CSC_COLORDE_PTH_36BPP = 96,
	HDMI_CSC_SCALE_CSC_COLORDE_PTH_48BPP = 112,
	HDMI_CSC_SCALE_CSCSCALE_MASK = 3,
	HDMI_A_HDCPCFG0_ELVENA_MASK = 128,
	HDMI_A_HDCPCFG0_ELVENA_ENABLE = 128,
	HDMI_A_HDCPCFG0_ELVENA_DISABLE = 0,
	HDMI_A_HDCPCFG0_I2CFASTMODE_MASK = 64,
	HDMI_A_HDCPCFG0_I2CFASTMODE_ENABLE = 64,
	HDMI_A_HDCPCFG0_I2CFASTMODE_DISABLE = 0,
	HDMI_A_HDCPCFG0_BYPENCRYPTION_MASK = 32,
	HDMI_A_HDCPCFG0_BYPENCRYPTION_ENABLE = 32,
	HDMI_A_HDCPCFG0_BYPENCRYPTION_DISABLE = 0,
	HDMI_A_HDCPCFG0_SYNCRICHECK_MASK = 16,
	HDMI_A_HDCPCFG0_SYNCRICHECK_ENABLE = 16,
	HDMI_A_HDCPCFG0_SYNCRICHECK_DISABLE = 0,
	HDMI_A_HDCPCFG0_AVMUTE_MASK = 8,
	HDMI_A_HDCPCFG0_AVMUTE_ENABLE = 8,
	HDMI_A_HDCPCFG0_AVMUTE_DISABLE = 0,
	HDMI_A_HDCPCFG0_RXDETECT_MASK = 4,
	HDMI_A_HDCPCFG0_RXDETECT_ENABLE = 4,
	HDMI_A_HDCPCFG0_RXDETECT_DISABLE = 0,
	HDMI_A_HDCPCFG0_EN11FEATURE_MASK = 2,
	HDMI_A_HDCPCFG0_EN11FEATURE_ENABLE = 2,
	HDMI_A_HDCPCFG0_EN11FEATURE_DISABLE = 0,
	HDMI_A_HDCPCFG0_HDMIDVI_MASK = 1,
	HDMI_A_HDCPCFG0_HDMIDVI_HDMI = 1,
	HDMI_A_HDCPCFG0_HDMIDVI_DVI = 0,
	HDMI_A_HDCPCFG1_DISSHA1CHECK_MASK = 8,
	HDMI_A_HDCPCFG1_DISSHA1CHECK_DISABLE = 8,
	HDMI_A_HDCPCFG1_DISSHA1CHECK_ENABLE = 0,
	HDMI_A_HDCPCFG1_PH2UPSHFTENC_MASK = 4,
	HDMI_A_HDCPCFG1_PH2UPSHFTENC_ENABLE = 4,
	HDMI_A_HDCPCFG1_PH2UPSHFTENC_DISABLE = 0,
	HDMI_A_HDCPCFG1_ENCRYPTIONDISABLE_MASK = 2,
	HDMI_A_HDCPCFG1_ENCRYPTIONDISABLE_DISABLE = 2,
	HDMI_A_HDCPCFG1_ENCRYPTIONDISABLE_ENABLE = 0,
	HDMI_A_HDCPCFG1_SWRESET_MASK = 1,
	HDMI_A_HDCPCFG1_SWRESET_ASSERT = 0,
	HDMI_A_VIDPOLCFG_UNENCRYPTCONF_MASK = 96,
	HDMI_A_VIDPOLCFG_UNENCRYPTCONF_OFFSET = 5,
	HDMI_A_VIDPOLCFG_DATAENPOL_MASK = 16,
	HDMI_A_VIDPOLCFG_DATAENPOL_ACTIVE_HIGH = 16,
	HDMI_A_VIDPOLCFG_DATAENPOL_ACTIVE_LOW = 0,
	HDMI_A_VIDPOLCFG_VSYNCPOL_MASK = 8,
	HDMI_A_VIDPOLCFG_VSYNCPOL_ACTIVE_HIGH = 8,
	HDMI_A_VIDPOLCFG_VSYNCPOL_ACTIVE_LOW = 0,
	HDMI_A_VIDPOLCFG_HSYNCPOL_MASK = 2,
	HDMI_A_VIDPOLCFG_HSYNCPOL_ACTIVE_HIGH = 2,
	HDMI_A_VIDPOLCFG_HSYNCPOL_ACTIVE_LOW = 0,
	HDMI_I2CM_OPERATION_WRITE = 16,
	HDMI_I2CM_OPERATION_READ_EXT = 2,
	HDMI_I2CM_OPERATION_READ = 1,
	HDMI_I2CM_INT_DONE_POL = 8,
	HDMI_I2CM_INT_DONE_MASK = 4,
	HDMI_I2CM_CTLINT_NAC_POL = 128,
	HDMI_I2CM_CTLINT_NAC_MASK = 64,
	HDMI_I2CM_CTLINT_ARB_POL = 8,
	HDMI_I2CM_CTLINT_ARB_MASK = 4,
};

struct dw_hdmi_i2c {
	struct i2c_adapter adap;
	struct mutex lock;
	struct completion cmp;
	u8 stat;
	u8 slave_reg;
	bool is_regaddr;
	bool is_segment;
};

struct dw_hdmi_phy_data {
	enum dw_hdmi_phy_type type;
	const char *name;
	unsigned int gen;
	bool has_svsret;
	int (*configure)(struct dw_hdmi *, const struct dw_hdmi_plat_data *, long unsigned int);
};

enum drm_vs_degamma_mode {
	VS_DEGAMMA_DISABLE = 0,
	VS_DEGAMMA_BT709 = 1,
	VS_DEGAMMA_BT2020 = 2,
};

enum drm_vs_sync_dc_mode {
	VS_SINGLE_DC = 0,
	VS_MULTI_DC_PRIMARY = 1,
	VS_MULTI_DC_SECONDARY = 2,
};

struct vs_plane_info {
	const char *name;
	u8 id;
	enum drm_plane_type type;
	unsigned int num_formats;
	const u32 *formats;
	u8 num_modifiers;
	const u64 *modifiers;
	unsigned int min_width;
	unsigned int min_height;
	unsigned int max_width;
	unsigned int max_height;
	unsigned int rotation;
	unsigned int blend_mode;
	unsigned int color_encoding;
	unsigned int degamma_size;
	int min_scale;
	int max_scale;
	u8 zpos;
	bool watermark;
	bool color_mgmt;
	bool roi;
};

struct vs_dc_info {
	const char *name;
	u8 panel_num;
	u8 plane_num;
	const struct vs_plane_info *planes;
	u8 layer_num;
	unsigned int max_bpc;
	unsigned int color_formats;
	u16 gamma_size;
	u8 gamma_bits;
	u16 pitch_alignment;
	bool pipe_sync;
	bool mmu_prefetch;
	bool background;
	bool panel_sync;
	bool cap_dec;
};

enum dc_chip_rev {
	DC_REV_0 = 0,
	DC_REV_1 = 1,
	DC_REV_2 = 2,
};

enum dc_hw_plane_id {
	PRIMARY_PLANE_0 = 0,
	OVERLAY_PLANE_0 = 1,
	OVERLAY_PLANE_1 = 2,
	PRIMARY_PLANE_1 = 3,
	OVERLAY_PLANE_2 = 4,
	OVERLAY_PLANE_3 = 5,
	CURSOR_PLANE_0 = 6,
	CURSOR_PLANE_1 = 7,
	PLANE_NUM = 8,
};

enum dc_hw_color_format {
	FORMAT_X4R4G4B4 = 0,
	FORMAT_A4R4G4B4 = 1,
	FORMAT_X1R5G5B5 = 2,
	FORMAT_A1R5G5B5 = 3,
	FORMAT_R5G6B5 = 4,
	FORMAT_X8R8G8B8 = 5,
	FORMAT_A8R8G8B8 = 6,
	FORMAT_YUY2 = 7,
	FORMAT_UYVY = 8,
	FORMAT_INDEX8 = 9,
	FORMAT_MONOCHROME = 10,
	FORMAT_YV12 = 15,
	FORMAT_A8 = 16,
	FORMAT_NV12 = 17,
	FORMAT_NV16 = 18,
	FORMAT_RG16 = 19,
	FORMAT_R8 = 20,
	FORMAT_NV12_10BIT = 21,
	FORMAT_A2R10G10B10 = 22,
	FORMAT_NV16_10BIT = 23,
	FORMAT_INDEX1 = 24,
	FORMAT_INDEX2 = 25,
	FORMAT_INDEX4 = 26,
	FORMAT_P010 = 27,
	FORMAT_YUV444 = 28,
	FORMAT_YUV444_10BIT = 29,
};

enum dc_hw_yuv_color_space {
	COLOR_SPACE_601 = 0,
	COLOR_SPACE_709 = 1,
	COLOR_SPACE_2020 = 3,
};

enum dc_hw_out {
	OUT_DPI = 0,
	OUT_DP = 1,
};

enum dc_hw_blend_mode {
	BLEND_PREMULTI = 0,
	BLEND_COVERAGE = 1,
	BLEND_PIXEL_NONE = 2,
};

struct dc_hw_plane_reg {
	u32 y_address;
	u32 u_address;
	u32 v_address;
	u32 y_stride;
	u32 u_stride;
	u32 v_stride;
	u32 size;
	u32 top_left;
	u32 bottom_right;
	u32 scale_factor_x;
	u32 scale_factor_y;
	u32 h_filter_coef_index;
	u32 h_filter_coef_data;
	u32 v_filter_coef_index;
	u32 v_filter_coef_data;
	u32 init_offset;
	u32 color_key;
	u32 color_key_high;
	u32 clear_value;
	u32 color_table_index;
	u32 color_table_data;
	u32 scale_config;
	u32 water_mark;
	u32 degamma_index;
	u32 degamma_data;
	u32 degamma_ex_data;
	u32 src_global_color;
	u32 dst_global_color;
	u32 blend_config;
	u32 roi_origin;
	u32 roi_size;
	u32 YUVToRGBCoef0;
	u32 YUVToRGBCoef1;
	u32 YUVToRGBCoef2;
	u32 YUVToRGBCoef3;
	u32 YUVToRGBCoef4;
	u32 YUVToRGBCoefD0;
	u32 YUVToRGBCoefD1;
	u32 YUVToRGBCoefD2;
	u32 YClampBound;
	u32 UVClampBound;
	u32 RGBToRGBCoef0;
	u32 RGBToRGBCoef1;
	u32 RGBToRGBCoef2;
	u32 RGBToRGBCoef3;
	u32 RGBToRGBCoef4;
};

struct dc_hw_fb {
	u32 y_address;
	u32 u_address;
	u32 v_address;
	u32 clear_value;
	u32 water_mark;
	u16 y_stride;
	u16 u_stride;
	u16 v_stride;
	u16 width;
	u16 height;
	u8 format;
	u8 tile_mode;
	u8 rotation;
	u8 yuv_color_space;
	u8 swizzle;
	u8 uv_swizzle;
	u8 zpos;
	u8 display_id;
	bool clear_enable;
	bool dec_enable;
	bool enable;
	bool dirty;
};

struct dc_hw_scale {
	u32 scale_factor_x;
	u32 scale_factor_y;
	bool enable;
	bool dirty;
};

struct dc_hw_position {
	u16 start_x;
	u16 start_y;
	u16 end_x;
	u16 end_y;
	bool dirty;
};

struct dc_hw_blend {
	u8 alpha;
	u8 blend_mode;
	bool dirty;
};

struct dc_hw_colorkey {
	u32 colorkey;
	u32 colorkey_high;
	u8 transparency;
	bool dirty;
};

struct dc_hw_roi {
	u16 x;
	u16 y;
	u16 width;
	u16 height;
	bool enable;
	bool dirty;
};

struct dc_hw_cursor {
	u32 address;
	u16 x;
	u16 y;
	u16 hot_x;
	u16 hot_y;
	u8 size;
	u8 display_id;
	bool enable;
	bool dirty;
};

struct dc_hw_display {
	u32 bus_format;
	u16 h_active;
	u16 h_total;
	u16 h_sync_start;
	u16 h_sync_end;
	u16 v_active;
	u16 v_total;
	u16 v_sync_start;
	u16 v_sync_end;
	u16 sync_mode;
	u32 bg_color;
	u8 id;
	bool h_sync_polarity;
	bool v_sync_polarity;
	bool enable;
	bool sync_enable;
	bool dither_enable;
};

struct dc_hw_gamma {
	u16 gamma[900];
	bool enable;
	bool dirty;
};

struct dc_hw_degamma {
	u16 degamma[780];
	u32 mode;
	bool dirty;
};

struct dc_hw_plane {
	struct dc_hw_fb fb;
	struct dc_hw_position pos;
	struct dc_hw_scale scale;
	struct dc_hw_blend blend;
	struct dc_hw_roi roi;
	struct dc_hw_colorkey colorkey;
	struct dc_hw_degamma degamma;
};

struct dc_hw_qos {
	u8 low_value;
	u8 high_value;
	bool dirty;
};

struct dc_hw;

struct dc_hw_funcs {
	void (*gamma)(struct dc_hw *);
	void (*plane)(struct dc_hw *);
	void (*display)(struct dc_hw *, struct dc_hw_display *);
};

struct dc_hw {
	enum dc_chip_rev rev;
	enum dc_hw_out out[2];
	void *hi_base;
	void *reg_base;
	struct dc_hw_display display[2];
	struct dc_hw_gamma gamma[2];
	struct dc_hw_plane plane[6];
	struct dc_hw_cursor cursor[2];
	struct dc_hw_qos qos;
	struct dc_hw_funcs *func;
	struct vs_dc_info *info;
};

struct component_ops {
	int (*bind)(struct device *, struct device *, void *);
	void (*unbind)(struct device *, struct device *, void *);
};

struct drm_vs_watermark {
	__u32 watermark;
	__u8 qos_low;
	__u8 qos_high;
};

struct drm_vs_color_mgmt {
	__u32 colorkey;
	__u32 colorkey_high;
	__u32 clear_value;
	bool clear_enable;
	bool transparency;
};

struct drm_vs_roi {
	bool enable;
	__u16 roi_x;
	__u16 roi_y;
	__u16 roi_w;
	__u16 roi_h;
};

enum dc_hw_rotation {
	ROT_0 = 0,
	ROT_90 = 4,
	ROT_180 = 5,
	ROT_270 = 6,
	FLIP_X = 1,
	FLIP_Y = 2,
	FLIP_XY = 3,
};

enum dc_hw_swizzle {
	SWIZZLE_ARGB = 0,
	SWIZZLE_RGBA = 1,
	SWIZZLE_ABGR = 2,
	SWIZZLE_BGRA = 3,
};

enum dc_hw_cursor_size {
	CURSOR_SIZE_32X32 = 0,
	CURSOR_SIZE_64X64 = 1,
};

struct vs_plane;

struct vs_plane_funcs {
	void (*update)(struct device *, struct vs_plane *);
	void (*disable)(struct device *, struct vs_plane *, struct drm_plane_state *);
	int (*check)(struct device *, struct vs_plane *, struct drm_plane_state *);
};

struct vs_plane {
	struct drm_plane base;
	u8 id;
	dma_addr_t dma_addr[3];
	struct drm_property *degamma_mode;
	struct drm_property *watermark_prop;
	struct drm_property *color_mgmt_prop;
	struct drm_property *roi_prop;
	const struct vs_plane_funcs *funcs;
};

struct vs_plane_status {
	u32 tile_mode;
	struct drm_rect src;
	struct drm_rect dest;
	struct drm_format_name_buf format_name;
};

struct vs_plane_state {
	struct drm_plane_state base;
	struct vs_plane_status status;
	struct drm_property_blob *watermark;
	struct drm_property_blob *color_mgmt;
	struct drm_property_blob *roi;
	u32 degamma;
	bool degamma_changed;
};

struct vs_crtc_funcs {
	void (*enable)(struct device *, struct drm_crtc *);
	void (*disable)(struct device *, struct drm_crtc *);
	bool (*mode_fixup)(struct device *, struct drm_crtc *, const struct drm_display_mode *, struct drm_display_mode *);
	void (*set_gamma)(struct device *, struct drm_crtc *, struct drm_color_lut *, unsigned int);
	void (*enable_gamma)(struct device *, struct drm_crtc *, bool);
	void (*enable_vblank)(struct device *, struct drm_crtc *, bool);
	void (*commit)(struct device *);
};

struct vs_crtc_state {
	struct drm_crtc_state base;
	u32 sync_mode;
	u32 output_fmt;
	u32 bg_color;
	u8 encoder_type;
	u8 mmu_prefetch;
	u8 bpp;
	bool sync_enable;
	bool dither_enable;
	bool underflow;
};

struct vs_crtc {
	struct drm_crtc base;
	struct device *dev;
	struct drm_pending_vblank_event *event;
	unsigned int max_bpc;
	unsigned int color_formats;
	struct drm_property *sync_mode;
	struct drm_property *mmu_prefetch;
	struct drm_property *bg_color;
	struct drm_property *panel_sync;
	struct drm_property *dither;
	const struct vs_crtc_funcs *funcs;
};

struct vs_dc_funcs {
	void (*dump_enable)(struct device *, dma_addr_t, unsigned int);
	void (*dump_disable)(struct device *);
};

struct vs_dc_plane {
	enum dc_hw_plane_id id;
};

struct vs_dc {
	struct vs_crtc *crtc[2];
	struct dc_hw hw;
	struct clk *core_clk;
	struct clk *pix_clk[2];
	struct clk *pixclk[2];
	struct clk *axi_clk;
	struct clk *cfg_clk;
	struct clk *dpu0pll_clk;
	struct clk *dpu1pll_clk;
	unsigned int pix_clk_rate[2];
	bool first_frame;
	bool dpu0pll_on;
	bool dpu1pll_on;
	struct vs_dc_plane planes[8];
	const struct vs_dc_funcs *funcs;
};

struct iommu_group {};

struct iommu_domain;

typedef int (*iommu_fault_handler_t)(struct iommu_domain *, struct device *, long unsigned int, int, void *);

struct iommu_domain_geometry {
	dma_addr_t aperture_start;
	dma_addr_t aperture_end;
	bool force_aperture;
};

struct iommu_domain {
	unsigned int type;
	const struct iommu_ops *ops;
	long unsigned int pgsize_bitmap;
	iommu_fault_handler_t handler;
	void *handler_token;
	struct iommu_domain_geometry geometry;
	void *iova_cookie;
};

struct vs_drm_private {
	struct device *dma_dev;
	struct iommu_domain *domain;
	unsigned int pitch_alignment;
};

struct vs_gem_object {
	struct drm_gem_object base;
	size_t size;
	void *cookie;
	dma_addr_t dma_addr;
	u32 iova;
	long unsigned int dma_attrs;
	bool get_pages;
	struct page **pages;
	struct sg_table *sgt;
};

struct simple_encoder_priv {
	unsigned char encoder_type;
};

struct dss_data {
	u32 mask;
	u32 value;
};

struct simple_encoder {
	struct drm_encoder encoder;
	struct device *dev;
	const struct simple_encoder_priv *priv;
	struct regmap *dss_regmap;
	struct dss_data *dss_regdatas;
};

struct drm_panel;

enum ethtool_link_mode_bit_indices {
	ETHTOOL_LINK_MODE_10baseT_Half_BIT = 0,
	ETHTOOL_LINK_MODE_10baseT_Full_BIT = 1,
	ETHTOOL_LINK_MODE_100baseT_Half_BIT = 2,
	ETHTOOL_LINK_MODE_100baseT_Full_BIT = 3,
	ETHTOOL_LINK_MODE_1000baseT_Half_BIT = 4,
	ETHTOOL_LINK_MODE_1000baseT_Full_BIT = 5,
	ETHTOOL_LINK_MODE_Autoneg_BIT = 6,
	ETHTOOL_LINK_MODE_TP_BIT = 7,
	ETHTOOL_LINK_MODE_AUI_BIT = 8,
	ETHTOOL_LINK_MODE_MII_BIT = 9,
	ETHTOOL_LINK_MODE_FIBRE_BIT = 10,
	ETHTOOL_LINK_MODE_BNC_BIT = 11,
	ETHTOOL_LINK_MODE_10000baseT_Full_BIT = 12,
	ETHTOOL_LINK_MODE_Pause_BIT = 13,
	ETHTOOL_LINK_MODE_Asym_Pause_BIT = 14,
	ETHTOOL_LINK_MODE_2500baseX_Full_BIT = 15,
	ETHTOOL_LINK_MODE_Backplane_BIT = 16,
	ETHTOOL_LINK_MODE_1000baseKX_Full_BIT = 17,
	ETHTOOL_LINK_MODE_10000baseKX4_Full_BIT = 18,
	ETHTOOL_LINK_MODE_10000baseKR_Full_BIT = 19,
	ETHTOOL_LINK_MODE_10000baseR_FEC_BIT = 20,
	ETHTOOL_LINK_MODE_20000baseMLD2_Full_BIT = 21,
	ETHTOOL_LINK_MODE_20000baseKR2_Full_BIT = 22,
	ETHTOOL_LINK_MODE_40000baseKR4_Full_BIT = 23,
	ETHTOOL_LINK_MODE_40000baseCR4_Full_BIT = 24,
	ETHTOOL_LINK_MODE_40000baseSR4_Full_BIT = 25,
	ETHTOOL_LINK_MODE_40000baseLR4_Full_BIT = 26,
	ETHTOOL_LINK_MODE_56000baseKR4_Full_BIT = 27,
	ETHTOOL_LINK_MODE_56000baseCR4_Full_BIT = 28,
	ETHTOOL_LINK_MODE_56000baseSR4_Full_BIT = 29,
	ETHTOOL_LINK_MODE_56000baseLR4_Full_BIT = 30,
	ETHTOOL_LINK_MODE_25000baseCR_Full_BIT = 31,
	ETHTOOL_LINK_MODE_25000baseKR_Full_BIT = 32,
	ETHTOOL_LINK_MODE_25000baseSR_Full_BIT = 33,
	ETHTOOL_LINK_MODE_50000baseCR2_Full_BIT = 34,
	ETHTOOL_LINK_MODE_50000baseKR2_Full_BIT = 35,
	ETHTOOL_LINK_MODE_100000baseKR4_Full_BIT = 36,
	ETHTOOL_LINK_MODE_100000baseSR4_Full_BIT = 37,
	ETHTOOL_LINK_MODE_100000baseCR4_Full_BIT = 38,
	ETHTOOL_LINK_MODE_100000baseLR4_ER4_Full_BIT = 39,
	ETHTOOL_LINK_MODE_50000baseSR2_Full_BIT = 40,
	ETHTOOL_LINK_MODE_1000baseX_Full_BIT = 41,
	ETHTOOL_LINK_MODE_10000baseCR_Full_BIT = 42,
	ETHTOOL_LINK_MODE_10000baseSR_Full_BIT = 43,
	ETHTOOL_LINK_MODE_10000baseLR_Full_BIT = 44,
	ETHTOOL_LINK_MODE_10000baseLRM_Full_BIT = 45,
	ETHTOOL_LINK_MODE_10000baseER_Full_BIT = 46,
	ETHTOOL_LINK_MODE_2500baseT_Full_BIT = 47,
	ETHTOOL_LINK_MODE_5000baseT_Full_BIT = 48,
	ETHTOOL_LINK_MODE_FEC_NONE_BIT = 49,
	ETHTOOL_LINK_MODE_FEC_RS_BIT = 50,
	ETHTOOL_LINK_MODE_FEC_BASER_BIT = 51,
	ETHTOOL_LINK_MODE_50000baseKR_Full_BIT = 52,
	ETHTOOL_LINK_MODE_50000baseSR_Full_BIT = 53,
	ETHTOOL_LINK_MODE_50000baseCR_Full_BIT = 54,
	ETHTOOL_LINK_MODE_50000baseLR_ER_FR_Full_BIT = 55,
	ETHTOOL_LINK_MODE_50000baseDR_Full_BIT = 56,
	ETHTOOL_LINK_MODE_100000baseKR2_Full_BIT = 57,
	ETHTOOL_LINK_MODE_100000baseSR2_Full_BIT = 58,
	ETHTOOL_LINK_MODE_100000baseCR2_Full_BIT = 59,
	ETHTOOL_LINK_MODE_100000baseLR2_ER2_FR2_Full_BIT = 60,
	ETHTOOL_LINK_MODE_100000baseDR2_Full_BIT = 61,
	ETHTOOL_LINK_MODE_200000baseKR4_Full_BIT = 62,
	ETHTOOL_LINK_MODE_200000baseSR4_Full_BIT = 63,
	ETHTOOL_LINK_MODE_200000baseLR4_ER4_FR4_Full_BIT = 64,
	ETHTOOL_LINK_MODE_200000baseDR4_Full_BIT = 65,
	ETHTOOL_LINK_MODE_200000baseCR4_Full_BIT = 66,
	ETHTOOL_LINK_MODE_100baseT1_Full_BIT = 67,
	ETHTOOL_LINK_MODE_1000baseT1_Full_BIT = 68,
	ETHTOOL_LINK_MODE_400000baseKR8_Full_BIT = 69,
	ETHTOOL_LINK_MODE_400000baseSR8_Full_BIT = 70,
	ETHTOOL_LINK_MODE_400000baseLR8_ER8_FR8_Full_BIT = 71,
	ETHTOOL_LINK_MODE_400000baseDR8_Full_BIT = 72,
	ETHTOOL_LINK_MODE_400000baseCR8_Full_BIT = 73,
	ETHTOOL_LINK_MODE_FEC_LLRS_BIT = 74,
	ETHTOOL_LINK_MODE_100000baseKR_Full_BIT = 75,
	ETHTOOL_LINK_MODE_100000baseSR_Full_BIT = 76,
	ETHTOOL_LINK_MODE_100000baseLR_ER_FR_Full_BIT = 77,
	ETHTOOL_LINK_MODE_100000baseCR_Full_BIT = 78,
	ETHTOOL_LINK_MODE_100000baseDR_Full_BIT = 79,
	ETHTOOL_LINK_MODE_200000baseKR2_Full_BIT = 80,
	ETHTOOL_LINK_MODE_200000baseSR2_Full_BIT = 81,
	ETHTOOL_LINK_MODE_200000baseLR2_ER2_FR2_Full_BIT = 82,
	ETHTOOL_LINK_MODE_200000baseDR2_Full_BIT = 83,
	ETHTOOL_LINK_MODE_200000baseCR2_Full_BIT = 84,
	ETHTOOL_LINK_MODE_400000baseKR4_Full_BIT = 85,
	ETHTOOL_LINK_MODE_400000baseSR4_Full_BIT = 86,
	ETHTOOL_LINK_MODE_400000baseLR4_ER4_FR4_Full_BIT = 87,
	ETHTOOL_LINK_MODE_400000baseDR4_Full_BIT = 88,
	ETHTOOL_LINK_MODE_400000baseCR4_Full_BIT = 89,
	ETHTOOL_LINK_MODE_100baseFX_Half_BIT = 90,
	ETHTOOL_LINK_MODE_100baseFX_Full_BIT = 91,
	__ETHTOOL_LINK_MODE_MASK_NBITS = 92,
};

struct dw_mipi_dsi;

struct dw_mipi_dsi_funcs {
	struct dw_mipi_dsi * (*get_dsi)(struct device *);
	int (*bind)(struct dw_mipi_dsi *);
	void (*unbind)(struct dw_mipi_dsi *);
};

struct dw_mipi_dsi {
	struct device *dev;
	struct regmap *regmap;
	struct clk *pclk;
	struct clk *pixclk;
	struct phy *dphy;
	union phy_configure_opts phy_opts;
	struct mipi_dsi_host host;
	unsigned int channel;
	unsigned int lanes;
	enum mipi_dsi_pixel_format format;
	long unsigned int mode_flags;
	unsigned int lane_link_rate;
	const struct dw_mipi_dsi_funcs *funcs;
};

struct dw_mipi_dsi_primary {
	struct dw_mipi_dsi dsi;
	struct dw_mipi_dsi *secondary_dsi;
	struct drm_bridge bridge;
	struct drm_bridge *panel_bridge;
	u32 bus_format;
};

struct dw_hdmi_mpll_gen_config {
	u64 pixelclock;
	u8 colordepth;
	u16 opmode: 2;
	struct {
		u16 prep_div: 2;
		u16 mpll_cko_div: 2;
		u16 ref_cntrl: 2;
		u16 mpll_n_cntrl: 2;
		u16 vco_cntrl: 4;
		char: 4;
		u16 mpll_multiplier: 8;
	} divider;
	struct {
		u16 gmp_cntrl: 2;
		u16 prop_cntrl: 6;
		u16 int_cntrl: 6;
	} charge_pump;
	struct {
		u16 txterm: 3;
		u16 sup_txlvl: 5;
		u16 tx_traon: 1;
		u16 tx_trbon: 1;
		u16 tx_symon: 4;
		char: 2;
		u16 ck_symon: 4;
	} voltage;
};

struct light_hdmi {
	struct device *dev;
	struct drm_encoder encoder;
	struct dw_hdmi *dw_hdmi;
	struct regmap *sysreg;
};

struct component;

struct component_match_array {
	void *data;
	int (*compare)(struct device *, void *);
	int (*compare_typed)(struct device *, int, void *);
	void (*release)(struct device *, void *);
	struct component *component;
	bool duplicate;
};

struct master;

struct component {
	struct list_head node;
	struct master *master;
	bool bound;
	const struct component_ops *ops;
	int subcomponent;
	struct device *dev;
};

struct component_match {
	size_t alloc;
	size_t num;
	struct component_match_array *compare;
};

struct master {
	struct list_head node;
	bool bound;
	const struct component_master_ops *ops;
	struct device *dev;
	struct component_match *match;
	struct dentry *dentry;
};

struct fwnode_link {
	struct fwnode_handle *supplier;
	struct list_head s_hook;
	struct fwnode_handle *consumer;
	struct list_head c_hook;
};

struct wake_irq {
	struct device *dev;
	unsigned int status;
	int irq;
	const char *name;
};

enum dpm_order {
	DPM_ORDER_NONE = 0,
	DPM_ORDER_DEV_AFTER_PARENT = 1,
	DPM_ORDER_PARENT_BEFORE_DEV = 2,
	DPM_ORDER_DEV_LAST = 3,
};

struct subsys_private {
	struct kset subsys;
	struct kset *devices_kset;
	struct list_head interfaces;
	struct mutex mutex;
	struct kset *drivers_kset;
	struct klist klist_devices;
	struct klist klist_drivers;
	struct blocking_notifier_head bus_notifier;
	unsigned int drivers_autoprobe: 1;
	struct bus_type *bus;
	struct kset glue_dirs;
	struct class *class;
};

struct driver_private {
	struct kobject kobj;
	struct klist klist_devices;
	struct klist_node knode_bus;
	struct module_kobject *mkobj;
	struct device_driver *driver;
};

struct dev_ext_attribute {
	struct device_attribute attr;
	void *var;
};

struct device_private {
	struct klist klist_children;
	struct klist_node knode_parent;
	struct klist_node knode_driver;
	struct klist_node knode_bus;
	struct klist_node knode_class;
	struct list_head deferred_probe;
	struct device_driver *async_driver;
	char *deferred_probe_reason;
	struct device *device;
	u8 dead: 1;
};

union device_attr_group_devres {
	const struct attribute_group *group;
	const struct attribute_group **groups;
};

struct class_dir {
	struct kobject kobj;
	struct class *class;
};

struct root_device {
	struct device dev;
	struct module *owner;
};

struct bus_attribute {
	struct attribute attr;
	ssize_t (*show)(struct bus_type *, char *);
	ssize_t (*store)(struct bus_type *, const char *, size_t);
};

struct subsys_dev_iter {
	struct klist_iter ki;
	const struct device_type *type;
};

struct driver_attribute {
	struct attribute attr;
	ssize_t (*show)(struct device_driver *, char *);
	ssize_t (*store)(struct device_driver *, const char *, size_t);
};

struct subsys_interface {
	const char *name;
	struct bus_type *subsys;
	struct list_head node;
	int (*add_dev)(struct device *, struct subsys_interface *);
	void (*remove_dev)(struct device *, struct subsys_interface *);
};

struct device_attach_data {
	struct device *dev;
	bool check_async;
	bool want_async;
	bool have_async;
};

struct class_compat {
	struct kobject *kobj;
};

struct pm_domain_data {
	struct list_head list_node;
	struct device *dev;
};

enum dev_dma_attr {
	DEV_DMA_NOT_SUPPORTED = 0,
	DEV_DMA_NON_COHERENT = 1,
	DEV_DMA_COHERENT = 2,
};

typedef void *acpi_handle;

struct platform_object {
	struct platform_device pdev;
	char name[0];
};

struct cpu_attr {
	struct device_attribute attr;
	const struct cpumask * const map;
};

typedef struct kobject *kobj_probe_t(dev_t, int *, void *);

struct probe {
	struct probe *next;
	dev_t dev;
	long unsigned int range;
	struct module *owner;
	kobj_probe_t *get;
	int (*lock)(dev_t, void *);
	void *data;
};

struct kobj_map {
	struct probe *probes[255];
	struct mutex *lock;
};

typedef int (*dr_match_t)(struct device *, void *, void *);

struct devres_node {
	struct list_head entry;
	dr_release_t release;
};

struct devres {
	struct devres_node node;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	u8 data[0];
};

struct devres_group {
	struct devres_node node[2];
	void *id;
	int color;
};

struct action_devres {
	void *data;
	void (*action)(void *);
};

struct pages_devres {
	long unsigned int addr;
	unsigned int order;
};

struct attribute_container {
	struct list_head node;
	struct klist containers;
	struct class *class;
	const struct attribute_group *grp;
	struct device_attribute **attrs;
	int (*match)(struct attribute_container *, struct device *);
	long unsigned int flags;
};

struct internal_container {
	struct klist_node node;
	struct attribute_container *cont;
	struct device classdev;
};

struct transport_container;

struct transport_class {
	struct class class;
	int (*setup)(struct transport_container *, struct device *, struct device *);
	int (*configure)(struct transport_container *, struct device *, struct device *);
	int (*remove)(struct transport_container *, struct device *, struct device *);
};

struct transport_container {
	struct attribute_container ac;
	const struct attribute_group *statistics;
};

struct anon_transport_class {
	struct transport_class tclass;
	struct attribute_container container;
};

struct container_dev {
	struct device dev;
	int (*offline)(struct container_dev *);
};

typedef void * (*devcon_match_fn_t)(struct fwnode_handle *, const char *, void *);

struct mii_bus;

struct mdio_device {
	struct device dev;
	struct mii_bus *bus;
	char modalias[32];
	int (*bus_match)(struct device *, struct device_driver *);
	void (*device_free)(struct mdio_device *);
	void (*device_remove)(struct mdio_device *);
	int addr;
	int flags;
	struct gpio_desc *reset_gpio;
	struct reset_control *reset_ctrl;
	unsigned int reset_assert_delay;
	unsigned int reset_deassert_delay;
};

struct phy_c45_device_ids {
	u32 devices_in_package;
	u32 mmds_present;
	u32 device_ids[32];
};

enum phy_state {
	PHY_DOWN = 0,
	PHY_READY = 1,
	PHY_HALTED = 2,
	PHY_UP = 3,
	PHY_RUNNING = 4,
	PHY_NOLINK = 5,
	PHY_CABLETEST = 6,
};

typedef enum {
	PHY_INTERFACE_MODE_NA = 0,
	PHY_INTERFACE_MODE_INTERNAL = 1,
	PHY_INTERFACE_MODE_MII = 2,
	PHY_INTERFACE_MODE_GMII = 3,
	PHY_INTERFACE_MODE_SGMII = 4,
	PHY_INTERFACE_MODE_TBI = 5,
	PHY_INTERFACE_MODE_REVMII = 6,
	PHY_INTERFACE_MODE_RMII = 7,
	PHY_INTERFACE_MODE_RGMII = 8,
	PHY_INTERFACE_MODE_RGMII_ID = 9,
	PHY_INTERFACE_MODE_RGMII_RXID = 10,
	PHY_INTERFACE_MODE_RGMII_TXID = 11,
	PHY_INTERFACE_MODE_RTBI = 12,
	PHY_INTERFACE_MODE_SMII = 13,
	PHY_INTERFACE_MODE_XGMII = 14,
	PHY_INTERFACE_MODE_XLGMII = 15,
	PHY_INTERFACE_MODE_MOCA = 16,
	PHY_INTERFACE_MODE_QSGMII = 17,
	PHY_INTERFACE_MODE_TRGMII = 18,
	PHY_INTERFACE_MODE_1000BASEX = 19,
	PHY_INTERFACE_MODE_2500BASEX = 20,
	PHY_INTERFACE_MODE_RXAUI = 21,
	PHY_INTERFACE_MODE_XAUI = 22,
	PHY_INTERFACE_MODE_10GBASER = 23,
	PHY_INTERFACE_MODE_USXGMII = 24,
	PHY_INTERFACE_MODE_10GKR = 25,
	PHY_INTERFACE_MODE_MAX = 26,
} phy_interface_t;

struct phy_driver;

struct phy_package_shared;

struct phylink;

struct mii_timestamper;

struct phy_device {
	struct mdio_device mdio;
	struct phy_driver *drv;
	u32 phy_id;
	struct phy_c45_device_ids c45_ids;
	unsigned int is_c45: 1;
	unsigned int is_internal: 1;
	unsigned int is_pseudo_fixed_link: 1;
	unsigned int is_gigabit_capable: 1;
	unsigned int has_fixups: 1;
	unsigned int suspended: 1;
	unsigned int suspended_by_mdio_bus: 1;
	unsigned int sysfs_links: 1;
	unsigned int loopback_enabled: 1;
	unsigned int downshifted_rate: 1;
	unsigned int autoneg: 1;
	unsigned int link: 1;
	unsigned int autoneg_complete: 1;
	unsigned int interrupts: 1;
	enum phy_state state;
	u32 dev_flags;
	phy_interface_t interface;
	int speed;
	int duplex;
	int port;
	int pause;
	int asym_pause;
	u8 master_slave_get;
	u8 master_slave_set;
	u8 master_slave_state;
	long unsigned int supported[2];
	long unsigned int advertising[2];
	long unsigned int lp_advertising[2];
	long unsigned int adv_old[2];
	u32 eee_broken_modes;
	int irq;
	void *priv;
	struct phy_package_shared *shared;
	struct sk_buff *skb;
	void *ehdr;
	struct nlattr *nest;
	struct delayed_work state_queue;
	struct mutex lock;
	bool sfp_bus_attached;
	struct sfp_bus *sfp_bus;
	struct phylink *phylink;
	struct net_device *attached_dev;
	struct mii_timestamper *mii_ts;
	u8 mdix;
	u8 mdix_ctrl;
	void (*phy_link_change)(struct phy_device *, bool);
	void (*adjust_link)(struct net_device *);
};

struct phy_tdr_config {
	u32 first;
	u32 last;
	u32 step;
	s8 pair;
};

struct mdio_bus_stats {
	u64_stats_t transfers;
	u64_stats_t errors;
	u64_stats_t writes;
	u64_stats_t reads;
	struct u64_stats_sync syncp;
};

struct mii_bus {
	struct module *owner;
	const char *name;
	char id[61];
	void *priv;
	int (*read)(struct mii_bus *, int, int);
	int (*write)(struct mii_bus *, int, int, u16);
	int (*reset)(struct mii_bus *);
	struct mdio_bus_stats stats[32];
	struct mutex mdio_lock;
	struct device *parent;
	enum {
		MDIOBUS_ALLOCATED = 1,
		MDIOBUS_REGISTERED = 2,
		MDIOBUS_UNREGISTERED = 3,
		MDIOBUS_RELEASED = 4,
	} state;
	struct device dev;
	struct mdio_device *mdio_map[32];
	u32 phy_mask;
	u32 phy_ignore_ta_mask;
	int irq[32];
	int reset_delay_us;
	int reset_post_delay_us;
	struct gpio_desc *reset_gpiod;
	enum {
		MDIOBUS_NO_CAP = 0,
		MDIOBUS_C22 = 1,
		MDIOBUS_C45 = 2,
		MDIOBUS_C22_C45 = 3,
	} probe_capabilities;
	struct mutex shared_lock;
	struct phy_package_shared *shared[32];
};

struct mdio_driver_common {
	struct device_driver driver;
	int flags;
};

struct mii_timestamper {
	bool (*rxtstamp)(struct mii_timestamper *, struct sk_buff *, int);
	void (*txtstamp)(struct mii_timestamper *, struct sk_buff *, int);
	int (*hwtstamp)(struct mii_timestamper *, struct ifreq *);
	void (*link_state)(struct mii_timestamper *, struct phy_device *);
	int (*ts_info)(struct mii_timestamper *, struct ethtool_ts_info *);
	struct device *device;
};

struct phy_package_shared {
	int addr;
	refcount_t refcnt;
	long unsigned int flags;
	size_t priv_size;
	void *priv;
};

struct phy_driver {
	struct mdio_driver_common mdiodrv;
	u32 phy_id;
	char *name;
	u32 phy_id_mask;
	const long unsigned int * const features;
	u32 flags;
	const void *driver_data;
	int (*soft_reset)(struct phy_device *);
	int (*config_init)(struct phy_device *);
	int (*probe)(struct phy_device *);
	int (*get_features)(struct phy_device *);
	int (*suspend)(struct phy_device *);
	int (*resume)(struct phy_device *);
	int (*config_aneg)(struct phy_device *);
	int (*aneg_done)(struct phy_device *);
	int (*read_status)(struct phy_device *);
	int (*ack_interrupt)(struct phy_device *);
	int (*config_intr)(struct phy_device *);
	int (*did_interrupt)(struct phy_device *);
	irqreturn_t (*handle_interrupt)(struct phy_device *);
	void (*remove)(struct phy_device *);
	int (*match_phy_device)(struct phy_device *);
	int (*set_wol)(struct phy_device *, struct ethtool_wolinfo *);
	void (*get_wol)(struct phy_device *, struct ethtool_wolinfo *);
	void (*link_change_notify)(struct phy_device *);
	int (*read_mmd)(struct phy_device *, int, u16);
	int (*write_mmd)(struct phy_device *, int, u16, u16);
	int (*read_page)(struct phy_device *);
	int (*write_page)(struct phy_device *, int);
	int (*module_info)(struct phy_device *, struct ethtool_modinfo *);
	int (*module_eeprom)(struct phy_device *, struct ethtool_eeprom *, u8 *);
	int (*cable_test_start)(struct phy_device *);
	int (*cable_test_tdr_start)(struct phy_device *, const struct phy_tdr_config *);
	int (*cable_test_get_status)(struct phy_device *, bool *);
	int (*get_sset_count)(struct phy_device *);
	void (*get_strings)(struct phy_device *, u8 *);
	void (*get_stats)(struct phy_device *, struct ethtool_stats *, u64 *);
	int (*get_tunable)(struct phy_device *, struct ethtool_tunable *, void *);
	int (*set_tunable)(struct phy_device *, struct ethtool_tunable *, const void *);
	int (*set_loopback)(struct phy_device *, bool);
	int (*get_sqi)(struct phy_device *);
	int (*get_sqi_max)(struct phy_device *);
};

struct cache_type_info {
	const char *size_prop;
	const char *line_size_props[2];
	const char *nr_sets_prop;
};

struct software_node;

struct software_node_ref_args {
	const struct software_node *node;
	unsigned int nargs;
	u64 args[8];
};

struct software_node {
	const char *name;
	const struct software_node *parent;
	const struct property_entry *properties;
};

struct swnode {
	int id;
	struct kobject kobj;
	struct fwnode_handle fwnode;
	const struct software_node *node;
	struct ida child_ids;
	struct list_head entry;
	struct list_head children;
	struct swnode *parent;
	unsigned int allocated: 1;
};

struct req {
	struct req *next;
	struct completion done;
	int err;
	const char *name;
	umode_t mode;
	kuid_t uid;
	kgid_t gid;
	struct device *dev;
};

enum pm_qos_flags_status {
	PM_QOS_FLAGS_UNDEFINED = 4294967295,
	PM_QOS_FLAGS_NONE = 0,
	PM_QOS_FLAGS_SOME = 1,
	PM_QOS_FLAGS_ALL = 2,
};

typedef int (*pm_callback_t)(struct device *);

struct of_phandle_iterator {
	const char *cells_name;
	int cell_count;
	const struct device_node *parent;
	const __be32 *list_end;
	const __be32 *phandle_end;
	const __be32 *cur;
	uint32_t cur_count;
	phandle phandle;
	struct device_node *node;
};

enum gpd_status {
	GENPD_STATE_ON = 0,
	GENPD_STATE_OFF = 1,
};

enum genpd_notication {
	GENPD_NOTIFY_PRE_OFF = 0,
	GENPD_NOTIFY_OFF = 1,
	GENPD_NOTIFY_PRE_ON = 2,
	GENPD_NOTIFY_ON = 3,
};

struct dev_power_governor {
	bool (*power_down_ok)(struct dev_pm_domain *);
	bool (*suspend_ok)(struct device *);
};

struct gpd_dev_ops {
	int (*start)(struct device *);
	int (*stop)(struct device *);
};

struct genpd_power_state {
	s64 power_off_latency_ns;
	s64 power_on_latency_ns;
	s64 residency_ns;
	u64 usage;
	u64 rejected;
	struct fwnode_handle *fwnode;
	ktime_t idle_time;
	void *data;
};

struct opp_table;

struct dev_pm_opp;

struct genpd_lock_ops;

struct generic_pm_domain {
	struct device dev;
	struct dev_pm_domain domain;
	struct list_head gpd_list_node;
	struct list_head parent_links;
	struct list_head child_links;
	struct list_head dev_list;
	struct dev_power_governor *gov;
	struct work_struct power_off_work;
	struct fwnode_handle *provider;
	bool has_provider;
	const char *name;
	atomic_t sd_count;
	enum gpd_status status;
	unsigned int device_count;
	unsigned int suspended_count;
	unsigned int prepared_count;
	unsigned int performance_state;
	cpumask_var_t cpus;
	int (*power_off)(struct generic_pm_domain *);
	int (*power_on)(struct generic_pm_domain *);
	struct raw_notifier_head power_notifiers;
	struct opp_table *opp_table;
	unsigned int (*opp_to_performance_state)(struct generic_pm_domain *, struct dev_pm_opp *);
	int (*set_performance_state)(struct generic_pm_domain *, unsigned int);
	struct gpd_dev_ops dev_ops;
	s64 max_off_time_ns;
	ktime_t next_wakeup;
	bool max_off_time_changed;
	bool cached_power_down_ok;
	bool cached_power_down_state_idx;
	int (*attach_dev)(struct generic_pm_domain *, struct device *);
	void (*detach_dev)(struct generic_pm_domain *, struct device *);
	unsigned int flags;
	struct genpd_power_state *states;
	void (*free_states)(struct genpd_power_state *, unsigned int);
	unsigned int state_count;
	unsigned int state_idx;
	ktime_t on_time;
	ktime_t accounting_time;
	const struct genpd_lock_ops *lock_ops;
	union {
		struct mutex mlock;
		struct {
			spinlock_t slock;
			long unsigned int lock_flags;
		};
	};
};

struct genpd_lock_ops {
	void (*lock)(struct generic_pm_domain *);
	void (*lock_nested)(struct generic_pm_domain *, int);
	int (*lock_interruptible)(struct generic_pm_domain *);
	void (*unlock)(struct generic_pm_domain *);
};

struct gpd_link {
	struct generic_pm_domain *parent;
	struct list_head parent_node;
	struct generic_pm_domain *child;
	struct list_head child_node;
	unsigned int performance_state;
	unsigned int prev_performance_state;
};

struct gpd_timing_data {
	s64 suspend_latency_ns;
	s64 resume_latency_ns;
	s64 effective_constraint_ns;
	bool constraint_changed;
	bool cached_suspend_ok;
};

struct generic_pm_domain_data {
	struct pm_domain_data base;
	struct gpd_timing_data td;
	struct notifier_block nb;
	struct notifier_block *power_nb;
	int cpu;
	unsigned int performance_state;
	ktime_t next_wakeup;
	void *data;
};

typedef struct generic_pm_domain * (*genpd_xlate_t)(struct of_phandle_args *, void *);

struct genpd_onecell_data {
	struct generic_pm_domain **domains;
	unsigned int num_domains;
	genpd_xlate_t xlate;
};

struct of_genpd_provider {
	struct list_head link;
	struct device_node *node;
	genpd_xlate_t xlate;
	void *data;
};

struct pm_clk_notifier_block {
	struct notifier_block nb;
	struct dev_pm_domain *pm_domain;
	char *con_ids[0];
};

enum pce_status {
	PCE_STATUS_NONE = 0,
	PCE_STATUS_ACQUIRED = 1,
	PCE_STATUS_ENABLED = 2,
	PCE_STATUS_ERROR = 3,
};

struct pm_clock_entry {
	struct list_head node;
	char *con_id;
	struct clk *clk;
	enum pce_status status;
};

struct builtin_fw {
	char *name;
	void *data;
	long unsigned int size;
};

enum fw_opt {
	FW_OPT_UEVENT = 1,
	FW_OPT_NOWAIT = 2,
	FW_OPT_USERHELPER = 4,
	FW_OPT_NO_WARN = 8,
	FW_OPT_NOCACHE = 16,
	FW_OPT_NOFALLBACK_SYSFS = 32,
	FW_OPT_FALLBACK_PLATFORM = 64,
	FW_OPT_PARTIAL = 128,
};

enum fw_status {
	FW_STATUS_UNKNOWN = 0,
	FW_STATUS_LOADING = 1,
	FW_STATUS_DONE = 2,
	FW_STATUS_ABORTED = 3,
};

struct fw_state {
	struct completion completion;
	enum fw_status status;
};

struct firmware_cache;

struct fw_priv {
	struct kref ref;
	struct list_head list;
	struct firmware_cache *fwc;
	struct fw_state fw_st;
	void *data;
	size_t size;
	size_t allocated_size;
	size_t offset;
	u32 opt_flags;
	const char *fw_name;
};

struct firmware_cache {
	spinlock_t lock;
	struct list_head head;
	int state;
};

struct firmware_work {
	struct work_struct work;
	struct module *module;
	const char *name;
	struct device *device;
	void *context;
	void (*cont)(const struct firmware *, void *);
	u32 opt_flags;
};

struct reg_sequence {
	unsigned int reg;
	unsigned int def;
	unsigned int delay_us;
};

typedef int (*regmap_hw_write)(void *, const void *, size_t);

typedef int (*regmap_hw_gather_write)(void *, const void *, size_t, const void *, size_t);

struct regmap_async;

typedef int (*regmap_hw_async_write)(void *, const void *, size_t, const void *, size_t, struct regmap_async *);

struct regmap;

struct regmap_async {
	struct list_head list;
	struct regmap *map;
	void *work_buf;
};

typedef int (*regmap_hw_read)(void *, const void *, size_t, void *, size_t);

typedef int (*regmap_hw_reg_read)(void *, unsigned int, unsigned int *);

typedef int (*regmap_hw_reg_write)(void *, unsigned int, unsigned int);

typedef int (*regmap_hw_reg_update_bits)(void *, unsigned int, unsigned int, unsigned int);

typedef struct regmap_async * (*regmap_hw_async_alloc)();

typedef void (*regmap_hw_free_context)(void *);

struct regmap_bus {
	bool fast_io;
	regmap_hw_write write;
	regmap_hw_gather_write gather_write;
	regmap_hw_async_write async_write;
	regmap_hw_reg_write reg_write;
	regmap_hw_reg_update_bits reg_update_bits;
	regmap_hw_read read;
	regmap_hw_reg_read reg_read;
	regmap_hw_free_context free_context;
	regmap_hw_async_alloc async_alloc;
	u8 read_flag_mask;
	enum regmap_endian reg_format_endian_default;
	enum regmap_endian val_format_endian_default;
	size_t max_raw_read;
	size_t max_raw_write;
};

struct reg_field {
	unsigned int reg;
	unsigned int lsb;
	unsigned int msb;
	unsigned int id_size;
	unsigned int id_offset;
};

struct regmap_format {
	size_t buf_size;
	size_t reg_bytes;
	size_t pad_bytes;
	size_t val_bytes;
	void (*format_write)(struct regmap *, unsigned int, unsigned int);
	void (*format_reg)(void *, unsigned int, unsigned int);
	void (*format_val)(void *, unsigned int, unsigned int);
	unsigned int (*parse_val)(const void *);
	void (*parse_inplace)(void *);
};

struct hwspinlock;

struct regcache_ops;

struct regmap {
	union {
		struct mutex mutex;
		struct {
			spinlock_t spinlock;
			long unsigned int spinlock_flags;
		};
	};
	regmap_lock lock;
	regmap_unlock unlock;
	void *lock_arg;
	gfp_t alloc_flags;
	struct device *dev;
	void *work_buf;
	struct regmap_format format;
	const struct regmap_bus *bus;
	void *bus_context;
	const char *name;
	bool async;
	spinlock_t async_lock;
	wait_queue_head_t async_waitq;
	struct list_head async_list;
	struct list_head async_free;
	int async_ret;
	bool debugfs_disable;
	struct dentry *debugfs;
	const char *debugfs_name;
	unsigned int debugfs_reg_len;
	unsigned int debugfs_val_len;
	unsigned int debugfs_tot_len;
	struct list_head debugfs_off_cache;
	struct mutex cache_lock;
	unsigned int max_register;
	bool (*writeable_reg)(struct device *, unsigned int);
	bool (*readable_reg)(struct device *, unsigned int);
	bool (*volatile_reg)(struct device *, unsigned int);
	bool (*precious_reg)(struct device *, unsigned int);
	bool (*writeable_noinc_reg)(struct device *, unsigned int);
	bool (*readable_noinc_reg)(struct device *, unsigned int);
	const struct regmap_access_table *wr_table;
	const struct regmap_access_table *rd_table;
	const struct regmap_access_table *volatile_table;
	const struct regmap_access_table *precious_table;
	const struct regmap_access_table *wr_noinc_table;
	const struct regmap_access_table *rd_noinc_table;
	int (*reg_read)(void *, unsigned int, unsigned int *);
	int (*reg_write)(void *, unsigned int, unsigned int);
	int (*reg_update_bits)(void *, unsigned int, unsigned int, unsigned int);
	bool defer_caching;
	long unsigned int read_flag_mask;
	long unsigned int write_flag_mask;
	int reg_shift;
	int reg_stride;
	int reg_stride_order;
	const struct regcache_ops *cache_ops;
	enum regcache_type cache_type;
	unsigned int cache_size_raw;
	unsigned int cache_word_size;
	unsigned int num_reg_defaults;
	unsigned int num_reg_defaults_raw;
	bool cache_only;
	bool cache_bypass;
	bool cache_free;
	struct reg_default *reg_defaults;
	const void *reg_defaults_raw;
	void *cache;
	bool cache_dirty;
	bool no_sync_defaults;
	struct reg_sequence *patch;
	int patch_regs;
	bool use_single_read;
	bool use_single_write;
	bool can_multi_write;
	size_t max_raw_read;
	size_t max_raw_write;
	struct rb_root range_tree;
	void *selector_work_buf;
	struct hwspinlock *hwlock;
	bool can_sleep;
};

struct regcache_ops {
	const char *name;
	enum regcache_type type;
	int (*init)(struct regmap *);
	int (*exit)(struct regmap *);
	void (*debugfs_init)(struct regmap *);
	int (*read)(struct regmap *, unsigned int, unsigned int *);
	int (*write)(struct regmap *, unsigned int, unsigned int);
	int (*sync)(struct regmap *, unsigned int, unsigned int);
	int (*drop)(struct regmap *, unsigned int, unsigned int);
};

struct regmap_range_node {
	struct rb_node node;
	const char *name;
	struct regmap *map;
	unsigned int range_min;
	unsigned int range_max;
	unsigned int selector_reg;
	unsigned int selector_mask;
	int selector_shift;
	unsigned int window_start;
	unsigned int window_len;
};

struct regmap_field {
	struct regmap *regmap;
	unsigned int mask;
	unsigned int shift;
	unsigned int reg;
	unsigned int id_size;
	unsigned int id_offset;
};

struct trace_event_raw_regmap_reg {
	struct trace_entry ent;
	u32 __data_loc_name;
	unsigned int reg;
	unsigned int val;
	char __data[0];
};

struct trace_event_raw_regmap_block {
	struct trace_entry ent;
	u32 __data_loc_name;
	unsigned int reg;
	int count;
	char __data[0];
};

struct trace_event_raw_regcache_sync {
	struct trace_entry ent;
	u32 __data_loc_name;
	u32 __data_loc_status;
	u32 __data_loc_type;
	int type;
	char __data[0];
};

struct trace_event_raw_regmap_bool {
	struct trace_entry ent;
	u32 __data_loc_name;
	int flag;
	char __data[0];
};

struct trace_event_raw_regmap_async {
	struct trace_entry ent;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_regcache_drop_region {
	struct trace_entry ent;
	u32 __data_loc_name;
	unsigned int from;
	unsigned int to;
	char __data[0];
};

struct trace_event_data_offsets_regmap_reg {
	u32 name;
};

struct trace_event_data_offsets_regmap_block {
	u32 name;
};

struct trace_event_data_offsets_regcache_sync {
	u32 name;
	u32 status;
	u32 type;
};

struct trace_event_data_offsets_regmap_bool {
	u32 name;
};

struct trace_event_data_offsets_regmap_async {
	u32 name;
};

struct trace_event_data_offsets_regcache_drop_region {
	u32 name;
};

typedef void (*btf_trace_regmap_reg_write)(void *, struct regmap *, unsigned int, unsigned int);

typedef void (*btf_trace_regmap_reg_read)(void *, struct regmap *, unsigned int, unsigned int);

typedef void (*btf_trace_regmap_reg_read_cache)(void *, struct regmap *, unsigned int, unsigned int);

typedef void (*btf_trace_regmap_hw_read_start)(void *, struct regmap *, unsigned int, int);

typedef void (*btf_trace_regmap_hw_read_done)(void *, struct regmap *, unsigned int, int);

typedef void (*btf_trace_regmap_hw_write_start)(void *, struct regmap *, unsigned int, int);

typedef void (*btf_trace_regmap_hw_write_done)(void *, struct regmap *, unsigned int, int);

typedef void (*btf_trace_regcache_sync)(void *, struct regmap *, const char *, const char *);

typedef void (*btf_trace_regmap_cache_only)(void *, struct regmap *, bool);

typedef void (*btf_trace_regmap_cache_bypass)(void *, struct regmap *, bool);

typedef void (*btf_trace_regmap_async_write_start)(void *, struct regmap *, unsigned int, int);

typedef void (*btf_trace_regmap_async_io_complete)(void *, struct regmap *);

typedef void (*btf_trace_regmap_async_complete_start)(void *, struct regmap *);

typedef void (*btf_trace_regmap_async_complete_done)(void *, struct regmap *);

typedef void (*btf_trace_regcache_drop_region)(void *, struct regmap *, unsigned int, unsigned int);

struct regcache_rbtree_node {
	void *block;
	long int *cache_present;
	unsigned int base_reg;
	unsigned int blklen;
	struct rb_node node;
};

struct regcache_rbtree_ctx {
	struct rb_root root;
	struct regcache_rbtree_node *cached_rbnode;
};

struct regmap_debugfs_off_cache {
	struct list_head list;
	off_t min;
	off_t max;
	unsigned int base_reg;
	unsigned int max_reg;
};

struct regmap_debugfs_node {
	struct regmap *map;
	struct list_head link;
};

struct ptp_system_timestamp {
	struct timespec64 pre_ts;
	struct timespec64 post_ts;
};

struct spi_statistics {
	spinlock_t lock;
	long unsigned int messages;
	long unsigned int transfers;
	long unsigned int errors;
	long unsigned int timedout;
	long unsigned int spi_sync;
	long unsigned int spi_sync_immediate;
	long unsigned int spi_async;
	long long unsigned int bytes;
	long long unsigned int bytes_rx;
	long long unsigned int bytes_tx;
	long unsigned int transfer_bytes_histo[17];
	long unsigned int transfers_split_maxsize;
};

struct spi_delay {
	u16 value;
	u8 unit;
};

struct spi_controller;

struct spi_device {
	struct device dev;
	struct spi_controller *controller;
	struct spi_controller *master;
	u32 max_speed_hz;
	u8 chip_select;
	u8 bits_per_word;
	bool rt;
	u32 mode;
	int irq;
	void *controller_state;
	void *controller_data;
	char modalias[32];
	const char *driver_override;
	int cs_gpio;
	struct gpio_desc *cs_gpiod;
	struct spi_delay word_delay;
	struct spi_statistics statistics;
};

struct spi_message;

struct spi_transfer;

struct spi_controller_mem_ops;

struct spi_controller {
	struct device dev;
	struct list_head list;
	s16 bus_num;
	u16 num_chipselect;
	u16 dma_alignment;
	u32 mode_bits;
	u32 buswidth_override_bits;
	u32 bits_per_word_mask;
	u32 min_speed_hz;
	u32 max_speed_hz;
	u16 flags;
	bool slave;
	size_t (*max_transfer_size)(struct spi_device *);
	size_t (*max_message_size)(struct spi_device *);
	struct mutex io_mutex;
	spinlock_t bus_lock_spinlock;
	struct mutex bus_lock_mutex;
	bool bus_lock_flag;
	int (*setup)(struct spi_device *);
	int (*set_cs_timing)(struct spi_device *, struct spi_delay *, struct spi_delay *, struct spi_delay *);
	int (*transfer)(struct spi_device *, struct spi_message *);
	void (*cleanup)(struct spi_device *);
	bool (*can_dma)(struct spi_controller *, struct spi_device *, struct spi_transfer *);
	bool queued;
	struct kthread_worker *kworker;
	struct kthread_work pump_messages;
	spinlock_t queue_lock;
	struct list_head queue;
	struct spi_message *cur_msg;
	bool idling;
	bool busy;
	bool running;
	bool rt;
	bool auto_runtime_pm;
	bool cur_msg_prepared;
	bool cur_msg_mapped;
	bool last_cs_enable;
	bool last_cs_mode_high;
	bool fallback;
	struct completion xfer_completion;
	size_t max_dma_len;
	int (*prepare_transfer_hardware)(struct spi_controller *);
	int (*transfer_one_message)(struct spi_controller *, struct spi_message *);
	int (*unprepare_transfer_hardware)(struct spi_controller *);
	int (*prepare_message)(struct spi_controller *, struct spi_message *);
	int (*unprepare_message)(struct spi_controller *, struct spi_message *);
	int (*slave_abort)(struct spi_controller *);
	void (*set_cs)(struct spi_device *, bool);
	int (*transfer_one)(struct spi_controller *, struct spi_device *, struct spi_transfer *);
	void (*handle_err)(struct spi_controller *, struct spi_message *);
	const struct spi_controller_mem_ops *mem_ops;
	struct spi_delay cs_setup;
	struct spi_delay cs_hold;
	struct spi_delay cs_inactive;
	int *cs_gpios;
	struct gpio_desc **cs_gpiods;
	bool use_gpio_descriptors;
	s8 unused_native_cs;
	s8 max_native_cs;
	struct spi_statistics statistics;
	struct dma_chan *dma_tx;
	struct dma_chan *dma_rx;
	void *dummy_rx;
	void *dummy_tx;
	int (*fw_translate_cs)(struct spi_controller *, unsigned int);
	bool ptp_sts_supported;
	long unsigned int irq_flags;
};

struct spi_message {
	struct list_head transfers;
	struct spi_device *spi;
	unsigned int is_dma_mapped: 1;
	void (*complete)(void *);
	void *context;
	unsigned int frame_length;
	unsigned int actual_length;
	int status;
	struct list_head queue;
	void *state;
	struct list_head resources;
};

struct spi_transfer {
	const void *tx_buf;
	void *rx_buf;
	unsigned int len;
	dma_addr_t tx_dma;
	dma_addr_t rx_dma;
	struct sg_table tx_sg;
	struct sg_table rx_sg;
	unsigned int cs_change: 1;
	unsigned int tx_nbits: 3;
	unsigned int rx_nbits: 3;
	u8 bits_per_word;
	u16 delay_usecs;
	struct spi_delay delay;
	struct spi_delay cs_change_delay;
	struct spi_delay word_delay;
	u32 speed_hz;
	u32 effective_speed_hz;
	unsigned int ptp_sts_word_pre;
	unsigned int ptp_sts_word_post;
	struct ptp_system_timestamp *ptp_sts;
	bool timestamped;
	struct list_head transfer_list;
	u16 error;
};

struct spi_mem;

struct spi_mem_op;

struct spi_mem_dirmap_desc;

struct spi_controller_mem_ops {
	int (*adjust_op_size)(struct spi_mem *, struct spi_mem_op *);
	bool (*supports_op)(struct spi_mem *, const struct spi_mem_op *);
	int (*exec_op)(struct spi_mem *, const struct spi_mem_op *);
	const char * (*get_name)(struct spi_mem *);
	int (*dirmap_create)(struct spi_mem_dirmap_desc *);
	void (*dirmap_destroy)(struct spi_mem_dirmap_desc *);
	ssize_t (*dirmap_read)(struct spi_mem_dirmap_desc *, u64, size_t, void *);
	ssize_t (*dirmap_write)(struct spi_mem_dirmap_desc *, u64, size_t, const void *);
};

struct regmap_async_spi {
	struct regmap_async core;
	struct spi_message m;
	struct spi_transfer t[2];
};

struct regmap_mmio_context {
	void *regs;
	unsigned int val_bytes;
	bool attached_clk;
	struct clk *clk;
	void (*reg_write)(struct regmap_mmio_context *, unsigned int, unsigned int);
	unsigned int (*reg_read)(struct regmap_mmio_context *, unsigned int);
};

typedef unsigned int __kernel_old_dev_t;

enum {
	LO_FLAGS_READ_ONLY = 1,
	LO_FLAGS_AUTOCLEAR = 4,
	LO_FLAGS_PARTSCAN = 8,
	LO_FLAGS_DIRECT_IO = 16,
};

struct loop_info {
	int lo_number;
	__kernel_old_dev_t lo_device;
	long unsigned int lo_inode;
	__kernel_old_dev_t lo_rdevice;
	int lo_offset;
	int lo_encrypt_type;
	int lo_encrypt_key_size;
	int lo_flags;
	char lo_name[64];
	unsigned char lo_encrypt_key[32];
	long unsigned int lo_init[2];
	char reserved[4];
};

struct loop_info64 {
	__u64 lo_device;
	__u64 lo_inode;
	__u64 lo_rdevice;
	__u64 lo_offset;
	__u64 lo_sizelimit;
	__u32 lo_number;
	__u32 lo_encrypt_type;
	__u32 lo_encrypt_key_size;
	__u32 lo_flags;
	__u8 lo_file_name[64];
	__u8 lo_crypt_name[64];
	__u8 lo_encrypt_key[32];
	__u64 lo_init[2];
};

struct loop_config {
	__u32 fd;
	__u32 block_size;
	struct loop_info64 info;
	__u64 __reserved[8];
};

enum {
	Lo_unbound = 0,
	Lo_bound = 1,
	Lo_rundown = 2,
};

struct loop_func_table;

struct loop_device {
	int lo_number;
	atomic_t lo_refcnt;
	loff_t lo_offset;
	loff_t lo_sizelimit;
	int lo_flags;
	int (*transfer)(struct loop_device *, int, struct page *, unsigned int, struct page *, unsigned int, int, sector_t);
	char lo_file_name[64];
	char lo_crypt_name[64];
	char lo_encrypt_key[32];
	int lo_encrypt_key_size;
	struct loop_func_table *lo_encryption;
	__u32 lo_init[2];
	kuid_t lo_key_owner;
	int (*ioctl)(struct loop_device *, int, long unsigned int);
	struct file *lo_backing_file;
	struct block_device *lo_device;
	void *key_data;
	gfp_t old_gfp_mask;
	spinlock_t lo_lock;
	int lo_state;
	struct kthread_worker worker;
	struct task_struct *worker_task;
	bool use_dio;
	bool sysfs_inited;
	struct request_queue *lo_queue;
	struct blk_mq_tag_set tag_set;
	struct gendisk *lo_disk;
};

struct loop_func_table {
	int number;
	int (*transfer)(struct loop_device *, int, struct page *, unsigned int, struct page *, unsigned int, int, sector_t);
	int (*init)(struct loop_device *, const struct loop_info64 *);
	int (*release)(struct loop_device *);
	int (*ioctl)(struct loop_device *, int, long unsigned int);
	struct module *owner;
};

struct loop_cmd {
	struct kthread_work work;
	bool use_aio;
	atomic_t ref;
	long int ret;
	struct kiocb iocb;
	struct bio_vec *bvec;
	struct cgroup_subsys_state *css;
};

struct virtio_blk_geometry {
	__virtio16 cylinders;
	__u8 heads;
	__u8 sectors;
};

struct virtio_blk_config {
	__virtio64 capacity;
	__virtio32 size_max;
	__virtio32 seg_max;
	struct virtio_blk_geometry geometry;
	__virtio32 blk_size;
	__u8 physical_block_exp;
	__u8 alignment_offset;
	__virtio16 min_io_size;
	__virtio32 opt_io_size;
	__u8 wce;
	__u8 unused;
	__virtio16 num_queues;
	__virtio32 max_discard_sectors;
	__virtio32 max_discard_seg;
	__virtio32 discard_sector_alignment;
	__virtio32 max_write_zeroes_sectors;
	__virtio32 max_write_zeroes_seg;
	__u8 write_zeroes_may_unmap;
	__u8 unused1[3];
} __attribute__((packed));

struct virtio_blk_outhdr {
	__virtio32 type;
	__virtio32 ioprio;
	__virtio64 sector;
};

struct virtio_blk_discard_write_zeroes {
	__le64 sector;
	__le32 num_sectors;
	__le32 flags;
};

struct virtio_blk_vq {
	struct virtqueue *vq;
	spinlock_t lock;
	char name[16];
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct virtio_blk {
	struct mutex vdev_mutex;
	struct virtio_device *vdev;
	struct gendisk *disk;
	struct blk_mq_tag_set tag_set;
	struct work_struct config_work;
	refcount_t refs;
	unsigned int sg_elems;
	int index;
	int num_vqs;
	struct virtio_blk_vq *vqs;
};

struct virtblk_req {
	struct virtio_blk_outhdr out_hdr;
	u8 status;
	struct scatterlist sg[0];
};

typedef int (*nvmem_reg_read_t)(void *, unsigned int, void *, size_t);

typedef int (*nvmem_reg_write_t)(void *, unsigned int, void *, size_t);

enum nvmem_type {
	NVMEM_TYPE_UNKNOWN = 0,
	NVMEM_TYPE_EEPROM = 1,
	NVMEM_TYPE_OTP = 2,
	NVMEM_TYPE_BATTERY_BACKED = 3,
};

struct nvmem_cell_info;

struct nvmem_config {
	struct device *dev;
	const char *name;
	int id;
	struct module *owner;
	struct gpio_desc *wp_gpio;
	const struct nvmem_cell_info *cells;
	int ncells;
	enum nvmem_type type;
	bool read_only;
	bool root_only;
	bool no_of_node;
	nvmem_reg_read_t reg_read;
	nvmem_reg_write_t reg_write;
	int size;
	int word_size;
	int stride;
	void *priv;
	bool compat;
	struct device *base_dev;
};

struct nvmem_cell_info {
	const char *name;
	unsigned int offset;
	unsigned int bytes;
	unsigned int bit_offset;
	unsigned int nbits;
};

struct at24_client {
	struct i2c_client *client;
	struct regmap *regmap;
};

struct at24_data {
	struct mutex lock;
	unsigned int write_max;
	unsigned int num_addresses;
	unsigned int offset_adj;
	u32 byte_len;
	u16 page_size;
	u8 flags;
	struct nvmem_device *nvmem;
	struct regulator *vcc_reg;
	void (*read_post)(unsigned int, char *, size_t);
	struct at24_client client[0];
};

struct at24_chip_data {
	u32 byte_len;
	u8 flags;
	void (*read_post)(unsigned int, char *, size_t);
};

struct dsmart_card_atr {
	unsigned char atr_buffer[64];
	unsigned int len;
	int errval;
};

struct dsmart_card_rcv {
	unsigned char rcv_buffer[256];
	int rcv_length;
	int time_out;
	int errval;
};

struct dsmart_card_xmt {
	unsigned char xmt_buffer[256];
	int xmt_length;
	int time_out;
	int errval;
};

struct dsmart_card_timing {
	unsigned int wwt;
	unsigned int cwt;
	unsigned int bwt;
	unsigned int bgt;
	unsigned int egt;
};

struct dsmart_card_baud {
	unsigned char di;
	unsigned char fi;
};

enum trans_direction {
	RECEIVER_MOD = 0,
	TRANSMITTER_MOD = 1,
};

enum card_staus {
	DEACTIVATE = 0,
	ACTIVATING = 1,
	PSS_TRF = 2,
	PSS_RECV = 3,
	ACTIVATE = 4,
};

struct dsmart_card {
	struct device *dev;
	void *base;
	struct clk *clk;
	int irq;
	spinlock_t lock;
	u8 rcv_buffer[400];
	u8 xmt_buffer[300];
	struct completion xfer_done;
	enum card_staus card_sta;
	int protocol_type;
	int present;
	u32 expected_rcv_cnt;
	u32 rx_threshold;
	u32 tx_threshold;
	bool is_fixed_len;
	int rcv_head;
	int rcv_count;
	int xmt_head;
	int xmt_count;
	int xmt_remainning_count;
	int errval;
	struct dsmart_card_timing timing_data;
	int state;
	struct dsmart_card_baud baud_rate;
};

struct abx500_ops {
	int (*get_chip_id)(struct device *);
	int (*get_register)(struct device *, u8, u8, u8 *);
	int (*set_register)(struct device *, u8, u8, u8);
	int (*get_register_page)(struct device *, u8, u8, u8 *, u8);
	int (*set_register_page)(struct device *, u8, u8, u8 *, u8);
	int (*mask_and_set_register)(struct device *, u8, u8, u8, u8);
	int (*event_registers_startup_state_get)(struct device *, u8 *);
	int (*startup_irq_enabled)(struct device *, unsigned int);
	void (*dump_all_banks)(struct device *);
};

struct abx500_device_entry {
	struct list_head list;
	struct abx500_ops ops;
	struct device *dev;
};

struct syscon_platform_data {
	const char *label;
};

struct syscon {
	struct device_node *np;
	struct regmap *regmap;
	struct list_head list;
};

enum offsets_index {
	CHAN_NUM = 0,
	MSG_SIZE = 1,
	MSG_G = 2,
	MSG_H = 3,
	ACK_G = 4,
	ACK_H = 5,
};

struct mbox_chan;

struct mbox_chan_ops {
	int (*send_data)(struct mbox_chan *, void *);
	int (*flush)(struct mbox_chan *, long unsigned int);
	int (*startup)(struct mbox_chan *);
	void (*shutdown)(struct mbox_chan *);
	bool (*last_tx_done)(struct mbox_chan *);
	bool (*peek_data)(struct mbox_chan *);
};

struct mbox_controller;

struct mbox_client;

struct mbox_chan {
	struct mbox_controller *mbox;
	unsigned int txdone_method;
	struct mbox_client *cl;
	struct completion tx_complete;
	void *active_req;
	unsigned int msg_count;
	unsigned int msg_free;
	void *msg_data[20];
	spinlock_t lock;
	void *con_priv;
};

struct mbox_controller {
	struct device *dev;
	const struct mbox_chan_ops *ops;
	struct mbox_chan *chans;
	int num_chans;
	bool txdone_irq;
	bool txdone_poll;
	unsigned int txpoll_period;
	struct mbox_chan * (*of_xlate)(struct mbox_controller *, const struct of_phandle_args *);
	struct hrtimer poll_hrt;
	struct list_head node;
};

struct vhost_iotlb_map {
	struct rb_node rb;
	struct list_head link;
	u64 start;
	u64 last;
	u64 size;
	u64 addr;
	u32 perm;
	u32 flags_padding;
	u64 __subtree_last;
};

struct vhost_iotlb {
	struct rb_root_cached root;
	struct list_head list;
	unsigned int limit;
	unsigned int nmaps;
	unsigned int flags;
};

struct vringh {
	bool little_endian;
	bool event_indices;
	bool weak_barriers;
	u16 last_avail_idx;
	u16 last_used_idx;
	u32 completed;
	struct vring vring;
	struct vhost_iotlb *iotlb;
	void (*notify)(struct vringh *);
};

struct vringh_kiov {
	struct kvec *iov;
	size_t consumed;
	unsigned int i;
	unsigned int used;
	unsigned int max_num;
};

struct vhost_iotlb_msg {
	__u64 iova;
	__u64 size;
	__u64 uaddr;
	__u8 perm;
	__u8 type;
};

struct irq_bypass_consumer;

struct irq_bypass_producer {
	struct list_head node;
	void *token;
	int irq;
	int (*add_consumer)(struct irq_bypass_producer *, struct irq_bypass_consumer *);
	void (*del_consumer)(struct irq_bypass_producer *, struct irq_bypass_consumer *);
	void (*stop)(struct irq_bypass_producer *);
	void (*start)(struct irq_bypass_producer *);
};

struct irq_bypass_consumer {
	struct list_head node;
	void *token;
	int (*add_producer)(struct irq_bypass_consumer *, struct irq_bypass_producer *);
	void (*del_producer)(struct irq_bypass_consumer *, struct irq_bypass_producer *);
	void (*stop)(struct irq_bypass_consumer *);
	void (*start)(struct irq_bypass_consumer *);
};

struct vhost_work;

typedef void (*vhost_work_fn_t)(struct vhost_work *);

struct vhost_work {
	struct llist_node node;
	vhost_work_fn_t fn;
	long unsigned int flags;
};

struct vhost_dev;

struct vhost_poll {
	poll_table table;
	wait_queue_head_t *wqh;
	wait_queue_entry_t wait;
	struct vhost_work work;
	__poll_t mask;
	struct vhost_dev *dev;
};

struct vhost_virtqueue;

struct vhost_dev {
	struct mm_struct *mm;
	struct mutex mutex;
	struct vhost_virtqueue **vqs;
	int nvqs;
	struct eventfd_ctx *log_ctx;
	struct llist_head work_list;
	struct task_struct *worker;
	struct vhost_iotlb *umem;
	struct vhost_iotlb *iotlb;
	spinlock_t iotlb_lock;
	struct list_head read_list;
	struct list_head pending_list;
	wait_queue_head_t wait;
	int iov_limit;
	int weight;
	int byte_weight;
	u64 kcov_handle;
	bool use_worker;
	int (*msg_handler)(struct vhost_dev *, struct vhost_iotlb_msg *);
};

struct vhost_log {
	u64 addr;
	u64 len;
};

struct vhost_vring_call {
	struct eventfd_ctx *ctx;
	struct irq_bypass_producer producer;
};

struct vhost_virtqueue {
	struct vhost_dev *dev;
	struct mutex mutex;
	unsigned int num;
	vring_desc_t *desc;
	vring_avail_t *avail;
	vring_used_t *used;
	const struct vhost_iotlb_map *meta_iotlb[3];
	struct file *kick;
	struct vhost_vring_call call_ctx;
	struct eventfd_ctx *error_ctx;
	struct eventfd_ctx *log_ctx;
	struct vhost_poll poll;
	vhost_work_fn_t handle_kick;
	u16 last_avail_idx;
	u16 avail_idx;
	u16 last_used_idx;
	u16 used_flags;
	u16 signalled_used;
	bool signalled_used_valid;
	bool log_used;
	u64 log_addr;
	struct iovec iov[1024];
	struct iovec iotlb_iov[64];
	struct iovec *indirect;
	struct vring_used_elem *heads;
	struct vhost_iotlb *umem;
	struct vhost_iotlb *iotlb;
	void *private_data;
	u64 acked_features;
	u64 acked_backend_features;
	void *log_base;
	struct vhost_log *log;
	struct iovec log_iov[64];
	bool is_le;
	u32 busyloop_timeout;
};

struct light_vring {
	struct vring vr;
	void *va;
	int len;
};

struct light_vdev;

struct light_vringh {
	struct light_vring vring;
	struct vringh vrh;
	struct vringh_kiov riov;
	struct vringh_kiov wiov;
	u16 head;
	struct mutex vr_mutex;
	struct light_vdev *vdev;
};

struct light_vdev {
	int virtio_id;
	struct device dev;
	struct device *device;
	wait_queue_head_t waitq;
	long unsigned int out_bytes;
	long unsigned int in_bytes;
	long unsigned int out_bytes_dma;
	long unsigned int in_bytes_dma;
	struct mutex mutex;
	spinlock_t lock;
	int wakeup;
	volatile unsigned char *frontend_intr_reg;
	volatile unsigned char *backend_intr_reg;
	u32 enable_intr;
	u32 clear_intr;
	int irq;
	struct work_struct work;
	struct dma_chan *dma_ch[2];
	struct list_head list;
	struct task_struct *task;
	struct vhost_virtqueue vqs[1];
	struct vhost_dev vhost_dev;
	struct block_device *this_bdev;
	void *priv;
	int vq_num;
	int index;
	void (*kick)(void *);
	void (*notify)(struct light_vdev *);
	struct light_vringh vvr[32];
};

struct virtio_chan;

struct virtio_mbox {
	struct mbox_controller controller;
	struct light_vdev *vdev;
	unsigned int chan_num;
	struct mbox_chan *chans;
	struct virtio_chan *vchans;
	struct light_vringh *vrh;
	bool ready;
};

struct virtio_chan {
	struct light_vringh *in_vrh;
	struct light_vringh *out_vrh;
	struct virtio_mbox *vmbox;
	struct mbox_chan *chan;
	bool in_use;
	u8 idx;
	spinlock_t lock;
};

struct vhost_vring_state {
	unsigned int index;
	unsigned int num;
};

struct vhost_vring_file {
	unsigned int index;
	int fd;
};

struct vhost_vring_addr {
	unsigned int index;
	unsigned int flags;
	__u64 desc_user_addr;
	__u64 used_user_addr;
	__u64 avail_user_addr;
	__u64 log_guest_addr;
};

enum {
	LIGHT_VBLK_VQ_REQ = 0,
	LIGHT_VBLK_VQ_MAX = 1,
};

struct vblk_bio_info {
	struct light_vdev *vdev;
	struct kvec kiov;
	u16 avail_head;
	u8 vring_idx;
};

struct bio_info;

struct dma_buf_sync {
	__u64 flags;
};

struct dma_buf_list {
	struct list_head head;
	struct mutex lock;
};

struct trace_event_raw_dma_fence {
	struct trace_entry ent;
	u32 __data_loc_driver;
	u32 __data_loc_timeline;
	unsigned int context;
	unsigned int seqno;
	char __data[0];
};

struct trace_event_data_offsets_dma_fence {
	u32 driver;
	u32 timeline;
};

typedef void (*btf_trace_dma_fence_emit)(void *, struct dma_fence *);

typedef void (*btf_trace_dma_fence_init)(void *, struct dma_fence *);

typedef void (*btf_trace_dma_fence_destroy)(void *, struct dma_fence *);

typedef void (*btf_trace_dma_fence_enable_signal)(void *, struct dma_fence *);

typedef void (*btf_trace_dma_fence_signaled)(void *, struct dma_fence *);

typedef void (*btf_trace_dma_fence_wait_start)(void *, struct dma_fence *);

typedef void (*btf_trace_dma_fence_wait_end)(void *, struct dma_fence *);

struct default_wait_cb {
	struct dma_fence_cb base;
	struct task_struct *task;
};

struct dma_fence_array;

struct dma_fence_array_cb {
	struct dma_fence_cb cb;
	struct dma_fence_array *array;
};

struct dma_fence_array {
	struct dma_fence base;
	spinlock_t lock;
	unsigned int num_fences;
	atomic_t num_pending;
	struct dma_fence **fences;
	struct irq_work work;
};

enum seqno_fence_condition {
	SEQNO_FENCE_WAIT_GEQUAL = 0,
	SEQNO_FENCE_WAIT_NONZERO = 1,
};

struct seqno_fence {
	struct dma_fence base;
	const struct dma_fence_ops *ops;
	struct dma_buf *sync_buf;
	uint32_t seqno_ofs;
	enum seqno_fence_condition condition;
};

struct sync_merge_data {
	char name[32];
	__s32 fd2;
	__s32 fence;
	__u32 flags;
	__u32 pad;
};

struct sync_fence_info {
	char obj_name[32];
	char driver_name[32];
	__s32 status;
	__u32 flags;
	__u64 timestamp_ns;
};

struct sync_file_info {
	char name[32];
	__s32 status;
	__u32 flags;
	__u32 num_fences;
	__u32 pad;
	__u64 sync_fence_info;
};

struct sync_timeline {
	struct kref kref;
	char name[32];
	u64 context;
	int value;
	struct rb_root pt_tree;
	struct list_head pt_list;
	spinlock_t lock;
	struct list_head sync_timeline_list;
};

struct sync_pt {
	struct dma_fence base;
	struct list_head link;
	struct rb_node node;
};

struct trace_event_raw_sync_timeline {
	struct trace_entry ent;
	u32 __data_loc_name;
	u32 value;
	char __data[0];
};

struct trace_event_data_offsets_sync_timeline {
	u32 name;
};

typedef void (*btf_trace_sync_timeline)(void *, struct sync_timeline *);

struct sw_sync_create_fence_data {
	__u32 value;
	char name[32];
	__s32 fence;
};

struct udmabuf_create {
	__u32 memfd;
	__u32 flags;
	__u64 offset;
	__u64 size;
};

struct udmabuf_create_item {
	__u32 memfd;
	__u32 __pad;
	__u64 offset;
	__u64 size;
};

struct udmabuf_create_list {
	__u32 flags;
	__u32 count;
	struct udmabuf_create_item list[0];
};

struct udmabuf {
	long unsigned int pagecount;
	struct page **pages;
	struct sg_table *sg;
	struct miscdevice *device;
};

struct scsi_sense_hdr {
	u8 response_code;
	u8 sense_key;
	u8 asc;
	u8 ascq;
	u8 byte4;
	u8 byte5;
	u8 byte6;
	u8 additional_length;
};

typedef __u64 blist_flags_t;

enum scsi_device_state {
	SDEV_CREATED = 1,
	SDEV_RUNNING = 2,
	SDEV_CANCEL = 3,
	SDEV_DEL = 4,
	SDEV_QUIESCE = 5,
	SDEV_OFFLINE = 6,
	SDEV_TRANSPORT_OFFLINE = 7,
	SDEV_BLOCK = 8,
	SDEV_CREATED_BLOCK = 9,
};

struct scsi_vpd {
	struct callback_head rcu;
	int len;
	unsigned char data[0];
};

struct Scsi_Host;

struct scsi_target;

struct scsi_device_handler;

struct scsi_device {
	struct Scsi_Host *host;
	struct request_queue *request_queue;
	struct list_head siblings;
	struct list_head same_target_siblings;
	atomic_t device_busy;
	atomic_t device_blocked;
	atomic_t restarts;
	spinlock_t list_lock;
	struct list_head starved_entry;
	short unsigned int queue_depth;
	short unsigned int max_queue_depth;
	short unsigned int last_queue_full_depth;
	short unsigned int last_queue_full_count;
	long unsigned int last_queue_full_time;
	long unsigned int queue_ramp_up_period;
	long unsigned int last_queue_ramp_up;
	unsigned int id;
	unsigned int channel;
	u64 lun;
	unsigned int manufacturer;
	unsigned int sector_size;
	void *hostdata;
	unsigned char type;
	char scsi_level;
	char inq_periph_qual;
	struct mutex inquiry_mutex;
	unsigned char inquiry_len;
	unsigned char *inquiry;
	const char *vendor;
	const char *model;
	const char *rev;
	struct scsi_vpd *vpd_pg0;
	struct scsi_vpd *vpd_pg83;
	struct scsi_vpd *vpd_pg80;
	struct scsi_vpd *vpd_pg89;
	unsigned char current_tag;
	struct scsi_target *sdev_target;
	blist_flags_t sdev_bflags;
	unsigned int eh_timeout;
	unsigned int removable: 1;
	unsigned int changed: 1;
	unsigned int busy: 1;
	unsigned int lockable: 1;
	unsigned int locked: 1;
	unsigned int borken: 1;
	unsigned int disconnect: 1;
	unsigned int soft_reset: 1;
	unsigned int sdtr: 1;
	unsigned int wdtr: 1;
	unsigned int ppr: 1;
	unsigned int tagged_supported: 1;
	unsigned int simple_tags: 1;
	unsigned int was_reset: 1;
	unsigned int expecting_cc_ua: 1;
	unsigned int use_10_for_rw: 1;
	unsigned int use_10_for_ms: 1;
	unsigned int set_dbd_for_ms: 1;
	unsigned int no_report_opcodes: 1;
	unsigned int no_write_same: 1;
	unsigned int use_16_for_rw: 1;
	unsigned int skip_ms_page_8: 1;
	unsigned int skip_ms_page_3f: 1;
	unsigned int skip_vpd_pages: 1;
	unsigned int try_vpd_pages: 1;
	unsigned int use_192_bytes_for_3f: 1;
	unsigned int no_start_on_add: 1;
	unsigned int allow_restart: 1;
	unsigned int manage_start_stop: 1;
	unsigned int start_stop_pwr_cond: 1;
	unsigned int no_uld_attach: 1;
	unsigned int select_no_atn: 1;
	unsigned int fix_capacity: 1;
	unsigned int guess_capacity: 1;
	unsigned int retry_hwerror: 1;
	unsigned int last_sector_bug: 1;
	unsigned int no_read_disc_info: 1;
	unsigned int no_read_capacity_16: 1;
	unsigned int try_rc_10_first: 1;
	unsigned int security_supported: 1;
	unsigned int is_visible: 1;
	unsigned int wce_default_on: 1;
	unsigned int no_dif: 1;
	unsigned int broken_fua: 1;
	unsigned int lun_in_cdb: 1;
	unsigned int unmap_limit_for_ws: 1;
	unsigned int rpm_autosuspend: 1;
	bool offline_already;
	atomic_t disk_events_disable_depth;
	long unsigned int supported_events[1];
	long unsigned int pending_events[1];
	struct list_head event_list;
	struct work_struct event_work;
	unsigned int max_device_blocked;
	atomic_t iorequest_cnt;
	atomic_t iodone_cnt;
	atomic_t ioerr_cnt;
	struct device sdev_gendev;
	struct device sdev_dev;
	struct execute_work ew;
	struct work_struct requeue_work;
	struct scsi_device_handler *handler;
	void *handler_data;
	size_t dma_drain_len;
	void *dma_drain_buf;
	unsigned char access_state;
	struct mutex state_mutex;
	enum scsi_device_state sdev_state;
	struct task_struct *quiesced_by;
	long unsigned int sdev_data[0];
};

enum scsi_host_state {
	SHOST_CREATED = 1,
	SHOST_RUNNING = 2,
	SHOST_CANCEL = 3,
	SHOST_DEL = 4,
	SHOST_RECOVERY = 5,
	SHOST_CANCEL_RECOVERY = 6,
	SHOST_DEL_RECOVERY = 7,
};

struct scsi_host_template;

struct scsi_transport_template;

struct Scsi_Host {
	struct list_head __devices;
	struct list_head __targets;
	struct list_head starved_list;
	spinlock_t default_lock;
	spinlock_t *host_lock;
	struct mutex scan_mutex;
	struct list_head eh_cmd_q;
	struct task_struct *ehandler;
	struct completion *eh_action;
	wait_queue_head_t host_wait;
	struct scsi_host_template *hostt;
	struct scsi_transport_template *transportt;
	struct blk_mq_tag_set tag_set;
	atomic_t host_blocked;
	unsigned int host_failed;
	unsigned int host_eh_scheduled;
	unsigned int host_no;
	int eh_deadline;
	long unsigned int last_reset;
	unsigned int max_channel;
	unsigned int max_id;
	u64 max_lun;
	unsigned int unique_id;
	short unsigned int max_cmd_len;
	int this_id;
	int can_queue;
	short int cmd_per_lun;
	short unsigned int sg_tablesize;
	short unsigned int sg_prot_tablesize;
	unsigned int max_sectors;
	unsigned int max_segment_size;
	long unsigned int dma_boundary;
	long unsigned int virt_boundary_mask;
	unsigned int nr_hw_queues;
	unsigned int active_mode: 2;
	unsigned int unchecked_isa_dma: 1;
	unsigned int host_self_blocked: 1;
	unsigned int reverse_ordering: 1;
	unsigned int tmf_in_progress: 1;
	unsigned int async_scan: 1;
	unsigned int eh_noresume: 1;
	unsigned int no_write_same: 1;
	unsigned int host_tagset: 1;
	unsigned int short_inquiry: 1;
	unsigned int no_scsi2_lun_in_cdb: 1;
	char work_q_name[20];
	struct workqueue_struct *work_q;
	struct workqueue_struct *tmf_work_q;
	unsigned int max_host_blocked;
	unsigned int prot_capabilities;
	unsigned char prot_guard_type;
	long unsigned int base;
	long unsigned int io_port;
	unsigned char n_io_port;
	unsigned char dma_channel;
	unsigned int irq;
	enum scsi_host_state shost_state;
	struct device shost_gendev;
	struct device shost_dev;
	void *shost_data;
	struct device *dma_dev;
	long unsigned int hostdata[0];
};

enum scsi_target_state {
	STARGET_CREATED = 1,
	STARGET_RUNNING = 2,
	STARGET_REMOVE = 3,
	STARGET_CREATED_REMOVE = 4,
	STARGET_DEL = 5,
};

struct scsi_target {
	struct scsi_device *starget_sdev_user;
	struct list_head siblings;
	struct list_head devices;
	struct device dev;
	struct kref reap_ref;
	unsigned int channel;
	unsigned int id;
	unsigned int create: 1;
	unsigned int single_lun: 1;
	unsigned int pdt_1f_for_no_lun: 1;
	unsigned int no_report_luns: 1;
	unsigned int expecting_lun_change: 1;
	atomic_t target_busy;
	atomic_t target_blocked;
	unsigned int can_queue;
	unsigned int max_target_blocked;
	char scsi_level;
	enum scsi_target_state state;
	void *hostdata;
	long unsigned int starget_data[0];
};

struct scsi_data_buffer {
	struct sg_table table;
	unsigned int length;
};

struct scsi_pointer {
	char *ptr;
	int this_residual;
	struct scatterlist *buffer;
	int buffers_residual;
	dma_addr_t dma_handle;
	volatile int Status;
	volatile int Message;
	volatile int have_data_in;
	volatile int sent_command;
	volatile int phase;
};

struct scsi_cmnd {
	struct scsi_request req;
	struct scsi_device *device;
	struct list_head eh_entry;
	struct delayed_work abort_work;
	struct callback_head rcu;
	int eh_eflags;
	long unsigned int jiffies_at_alloc;
	int retries;
	int allowed;
	unsigned char prot_op;
	unsigned char prot_type;
	unsigned char prot_flags;
	short unsigned int cmd_len;
	enum dma_data_direction sc_data_direction;
	unsigned char *cmnd;
	struct scsi_data_buffer sdb;
	struct scsi_data_buffer *prot_sdb;
	unsigned int underflow;
	unsigned int transfersize;
	struct request *request;
	unsigned char *sense_buffer;
	void (*scsi_done)(struct scsi_cmnd *);
	struct scsi_pointer SCp;
	unsigned char *host_scribble;
	int result;
	int flags;
	long unsigned int state;
	unsigned char tag;
	unsigned int extra_len;
};

enum scsi_prot_operations {
	SCSI_PROT_NORMAL = 0,
	SCSI_PROT_READ_INSERT = 1,
	SCSI_PROT_WRITE_STRIP = 2,
	SCSI_PROT_READ_STRIP = 3,
	SCSI_PROT_WRITE_INSERT = 4,
	SCSI_PROT_READ_PASS = 5,
	SCSI_PROT_WRITE_PASS = 6,
};

struct scsi_driver {
	struct device_driver gendrv;
	void (*rescan)(struct device *);
	blk_status_t (*init_command)(struct scsi_cmnd *);
	void (*uninit_command)(struct scsi_cmnd *);
	int (*done)(struct scsi_cmnd *);
	int (*eh_action)(struct scsi_cmnd *, int);
	void (*eh_reset)(struct scsi_cmnd *);
};

struct scsi_host_cmd_pool;

struct scsi_host_template {
	struct module *module;
	const char *name;
	const char * (*info)(struct Scsi_Host *);
	int (*ioctl)(struct scsi_device *, unsigned int, void *);
	int (*init_cmd_priv)(struct Scsi_Host *, struct scsi_cmnd *);
	int (*exit_cmd_priv)(struct Scsi_Host *, struct scsi_cmnd *);
	int (*queuecommand)(struct Scsi_Host *, struct scsi_cmnd *);
	void (*commit_rqs)(struct Scsi_Host *, u16);
	int (*eh_abort_handler)(struct scsi_cmnd *);
	int (*eh_device_reset_handler)(struct scsi_cmnd *);
	int (*eh_target_reset_handler)(struct scsi_cmnd *);
	int (*eh_bus_reset_handler)(struct scsi_cmnd *);
	int (*eh_host_reset_handler)(struct scsi_cmnd *);
	int (*slave_alloc)(struct scsi_device *);
	int (*slave_configure)(struct scsi_device *);
	void (*slave_destroy)(struct scsi_device *);
	int (*target_alloc)(struct scsi_target *);
	void (*target_destroy)(struct scsi_target *);
	int (*scan_finished)(struct Scsi_Host *, long unsigned int);
	void (*scan_start)(struct Scsi_Host *);
	int (*change_queue_depth)(struct scsi_device *, int);
	int (*map_queues)(struct Scsi_Host *);
	bool (*dma_need_drain)(struct request *);
	int (*bios_param)(struct scsi_device *, struct block_device *, sector_t, int *);
	void (*unlock_native_capacity)(struct scsi_device *);
	int (*show_info)(struct seq_file *, struct Scsi_Host *);
	int (*write_info)(struct Scsi_Host *, char *, int);
	enum blk_eh_timer_return (*eh_timed_out)(struct scsi_cmnd *);
	int (*host_reset)(struct Scsi_Host *, int);
	const char *proc_name;
	struct proc_dir_entry *proc_dir;
	int can_queue;
	int this_id;
	short unsigned int sg_tablesize;
	short unsigned int sg_prot_tablesize;
	unsigned int max_sectors;
	unsigned int max_segment_size;
	long unsigned int dma_boundary;
	long unsigned int virt_boundary_mask;
	short int cmd_per_lun;
	unsigned char present;
	int tag_alloc_policy;
	unsigned int track_queue_depth: 1;
	unsigned int supported_mode: 2;
	unsigned int unchecked_isa_dma: 1;
	unsigned int emulated: 1;
	unsigned int skip_settle_delay: 1;
	unsigned int no_write_same: 1;
	unsigned int host_tagset: 1;
	unsigned int max_host_blocked;
	struct device_attribute **shost_attrs;
	struct device_attribute **sdev_attrs;
	const struct attribute_group **sdev_groups;
	u64 vendor_id;
	unsigned int cmd_size;
	struct scsi_host_cmd_pool *cmd_pool;
	int rpm_autosuspend_delay;
};

struct trace_event_raw_scsi_dispatch_cmd_start {
	struct trace_entry ent;
	unsigned int host_no;
	unsigned int channel;
	unsigned int id;
	unsigned int lun;
	unsigned int opcode;
	unsigned int cmd_len;
	unsigned int data_sglen;
	unsigned int prot_sglen;
	unsigned char prot_op;
	u32 __data_loc_cmnd;
	char __data[0];
};

struct trace_event_raw_scsi_dispatch_cmd_error {
	struct trace_entry ent;
	unsigned int host_no;
	unsigned int channel;
	unsigned int id;
	unsigned int lun;
	int rtn;
	unsigned int opcode;
	unsigned int cmd_len;
	unsigned int data_sglen;
	unsigned int prot_sglen;
	unsigned char prot_op;
	u32 __data_loc_cmnd;
	char __data[0];
};

struct trace_event_raw_scsi_cmd_done_timeout_template {
	struct trace_entry ent;
	unsigned int host_no;
	unsigned int channel;
	unsigned int id;
	unsigned int lun;
	int result;
	unsigned int opcode;
	unsigned int cmd_len;
	unsigned int data_sglen;
	unsigned int prot_sglen;
	unsigned char prot_op;
	u32 __data_loc_cmnd;
	char __data[0];
};

struct trace_event_raw_scsi_eh_wakeup {
	struct trace_entry ent;
	unsigned int host_no;
	char __data[0];
};

struct trace_event_data_offsets_scsi_dispatch_cmd_start {
	u32 cmnd;
};

struct trace_event_data_offsets_scsi_dispatch_cmd_error {
	u32 cmnd;
};

struct trace_event_data_offsets_scsi_cmd_done_timeout_template {
	u32 cmnd;
};

struct trace_event_data_offsets_scsi_eh_wakeup {};

typedef void (*btf_trace_scsi_dispatch_cmd_start)(void *, struct scsi_cmnd *);

typedef void (*btf_trace_scsi_dispatch_cmd_error)(void *, struct scsi_cmnd *, int);

typedef void (*btf_trace_scsi_dispatch_cmd_done)(void *, struct scsi_cmnd *);

typedef void (*btf_trace_scsi_dispatch_cmd_timeout)(void *, struct scsi_cmnd *);

typedef void (*btf_trace_scsi_eh_wakeup)(void *, struct Scsi_Host *);

struct scsi_transport_template {
	struct transport_container host_attrs;
	struct transport_container target_attrs;
	struct transport_container device_attrs;
	int (*user_scan)(struct Scsi_Host *, uint, uint, u64);
	int device_size;
	int device_private_offset;
	int target_size;
	int target_private_offset;
	int host_size;
	unsigned int create_work_queue: 1;
	void (*eh_strategy_handler)(struct Scsi_Host *);
};

struct scsi_host_busy_iter_data {
	bool (*fn)(struct scsi_cmnd *, void *, bool);
	void *priv;
};

struct scsi_idlun {
	__u32 dev_id;
	__u32 host_unique_id;
};

typedef void (*activate_complete)(void *, int);

struct scsi_device_handler {
	struct list_head list;
	struct module *module;
	const char *name;
	int (*check_sense)(struct scsi_device *, struct scsi_sense_hdr *);
	int (*attach)(struct scsi_device *);
	void (*detach)(struct scsi_device *);
	int (*activate)(struct scsi_device *, activate_complete, void *);
	blk_status_t (*prep_fn)(struct scsi_device *, struct request *);
	int (*set_params)(struct scsi_device *, const char *);
	void (*rescan)(struct scsi_device *);
};

struct scsi_eh_save {
	int result;
	unsigned int resid_len;
	int eh_eflags;
	enum dma_data_direction data_direction;
	unsigned int underflow;
	unsigned char cmd_len;
	unsigned char prot_op;
	unsigned char *cmnd;
	struct scsi_data_buffer sdb;
	unsigned char eh_cmnd[16];
	struct scatterlist sense_sgl;
};

struct scsi_mode_data {
	__u32 length;
	__u16 block_descriptor_length;
	__u8 medium_type;
	__u8 device_specific;
	__u8 header_length;
	__u8 longlba: 1;
};

struct scsi_event {
	enum scsi_device_event evt_type;
	struct list_head node;
};

enum scsi_host_prot_capabilities {
	SHOST_DIF_TYPE1_PROTECTION = 1,
	SHOST_DIF_TYPE2_PROTECTION = 2,
	SHOST_DIF_TYPE3_PROTECTION = 4,
	SHOST_DIX_TYPE0_PROTECTION = 8,
	SHOST_DIX_TYPE1_PROTECTION = 16,
	SHOST_DIX_TYPE2_PROTECTION = 32,
	SHOST_DIX_TYPE3_PROTECTION = 64,
};

enum {
	ACTION_FAIL = 0,
	ACTION_REPREP = 1,
	ACTION_RETRY = 2,
	ACTION_DELAYED_RETRY = 3,
};

struct scsi_lun {
	__u8 scsi_lun[8];
};

enum scsi_timeouts {
	SCSI_DEFAULT_EH_TIMEOUT = 2500,
};

enum scsi_scan_mode {
	SCSI_SCAN_INITIAL = 0,
	SCSI_SCAN_RESCAN = 1,
	SCSI_SCAN_MANUAL = 2,
};

struct async_scan_data {
	struct list_head list;
	struct Scsi_Host *shost;
	struct completion prev_finished;
};

enum scsi_devinfo_key {
	SCSI_DEVINFO_GLOBAL = 0,
	SCSI_DEVINFO_SPI = 1,
};

struct scsi_dev_info_list {
	struct list_head dev_info_list;
	char vendor[8];
	char model[16];
	blist_flags_t flags;
	unsigned int compatible;
};

struct scsi_dev_info_list_table {
	struct list_head node;
	struct list_head scsi_dev_info_list;
	const char *name;
	int key;
};

struct double_list {
	struct list_head *top;
	struct list_head *bottom;
};

struct scsi_varlen_cdb_hdr {
	__u8 opcode;
	__u8 control;
	__u8 misc[5];
	__u8 additional_cdb_length;
	__be16 service_action;
};

enum bip_flags {
	BIP_BLOCK_INTEGRITY = 1,
	BIP_MAPPED_INTEGRITY = 2,
	BIP_CTRL_NOCHECK = 4,
	BIP_DISK_NOCHECK = 8,
	BIP_IP_CHECKSUM = 16,
};

enum t10_dif_type {
	T10_PI_TYPE0_PROTECTION = 0,
	T10_PI_TYPE1_PROTECTION = 1,
	T10_PI_TYPE2_PROTECTION = 2,
	T10_PI_TYPE3_PROTECTION = 3,
};

enum scsi_prot_flags {
	SCSI_PROT_TRANSFER_PI = 1,
	SCSI_PROT_GUARD_CHECK = 2,
	SCSI_PROT_REF_CHECK = 4,
	SCSI_PROT_REF_INCREMENT = 8,
	SCSI_PROT_IP_CHECKSUM = 16,
};

enum {
	SD_EXT_CDB_SIZE = 32,
	SD_MEMPOOL_SIZE = 2,
};

enum {
	SD_DEF_XFER_BLOCKS = 65535,
	SD_MAX_XFER_BLOCKS = 4294967295,
	SD_MAX_WS10_BLOCKS = 65535,
	SD_MAX_WS16_BLOCKS = 8388607,
};

enum {
	SD_LBP_FULL = 0,
	SD_LBP_UNMAP = 1,
	SD_LBP_WS16 = 2,
	SD_LBP_WS10 = 3,
	SD_LBP_ZERO = 4,
	SD_LBP_DISABLE = 5,
};

enum {
	SD_ZERO_WRITE = 0,
	SD_ZERO_WS = 1,
	SD_ZERO_WS16_UNMAP = 2,
	SD_ZERO_WS10_UNMAP = 3,
};

struct opal_dev;

struct scsi_disk {
	struct scsi_driver *driver;
	struct scsi_device *device;
	struct device dev;
	struct gendisk *disk;
	struct opal_dev *opal_dev;
	atomic_t openers;
	sector_t capacity;
	int max_retries;
	u32 max_xfer_blocks;
	u32 opt_xfer_blocks;
	u32 max_ws_blocks;
	u32 max_unmap_blocks;
	u32 unmap_granularity;
	u32 unmap_alignment;
	u32 index;
	unsigned int physical_block_size;
	unsigned int max_medium_access_timeouts;
	unsigned int medium_access_timed_out;
	u8 media_present;
	u8 write_prot;
	u8 protection_type;
	u8 provisioning_mode;
	u8 zeroing_mode;
	unsigned int ATO: 1;
	unsigned int cache_override: 1;
	unsigned int WCE: 1;
	unsigned int RCD: 1;
	unsigned int DPOFUA: 1;
	unsigned int first_scan: 1;
	unsigned int lbpme: 1;
	unsigned int lbprz: 1;
	unsigned int lbpu: 1;
	unsigned int lbpws: 1;
	unsigned int lbpws10: 1;
	unsigned int lbpvpd: 1;
	unsigned int ws10: 1;
	unsigned int ws16: 1;
	unsigned int rc_basis: 2;
	unsigned int zoned: 2;
	unsigned int urswrz: 1;
	unsigned int security: 1;
	unsigned int ignore_medium_access_errors: 1;
};

struct mtd_notifier {
	void (*add)(struct mtd_info *);
	void (*remove)(struct mtd_info *);
	struct list_head list;
};

struct mtd_partition {
	const char *name;
	const char * const *types;
	uint64_t size;
	uint64_t offset;
	uint32_t mask_flags;
	uint32_t add_flags;
	struct device_node *of_node;
};

struct mtd_part_parser_data {
	long unsigned int origin;
};

struct mtd_concat {
	struct mtd_info mtd;
	int num_subdev;
	struct mtd_info **subdev;
};

struct mtd_part_parser {
	struct list_head list;
	struct module *owner;
	const char *name;
	const struct of_device_id *of_match_table;
	int (*parse_fn)(struct mtd_info *, const struct mtd_partition **, struct mtd_part_parser_data *);
	void (*cleanup)(const struct mtd_partition *, int);
};

struct mtd_partitions {
	const struct mtd_partition *parts;
	int nr_parts;
	const struct mtd_part_parser *parser;
};

typedef long unsigned int u_long;

struct erase_info_user {
	__u32 start;
	__u32 length;
};

struct erase_info_user64 {
	__u64 start;
	__u64 length;
};

struct mtd_oob_buf {
	__u32 start;
	__u32 length;
	unsigned char *ptr;
};

struct mtd_oob_buf64 {
	__u64 start;
	__u32 pad;
	__u32 length;
	__u64 usr_ptr;
};

struct mtd_write_req {
	__u64 start;
	__u64 len;
	__u64 ooblen;
	__u64 usr_data;
	__u64 usr_oob;
	__u8 mode;
	__u8 padding[7];
};

struct mtd_info_user {
	__u8 type;
	__u32 flags;
	__u32 size;
	__u32 erasesize;
	__u32 writesize;
	__u32 oobsize;
	__u64 padding;
};

struct region_info_user {
	__u32 offset;
	__u32 erasesize;
	__u32 numblocks;
	__u32 regionindex;
};

struct nand_oobinfo {
	__u32 useecc;
	__u32 eccbytes;
	__u32 oobfree[16];
	__u32 eccpos[32];
};

struct nand_oobfree {
	__u32 offset;
	__u32 length;
};

struct nand_ecclayout_user {
	__u32 eccbytes;
	__u32 eccpos[64];
	__u32 oobavail;
	struct nand_oobfree oobfree[8];
};

enum mtd_file_modes {
	MTD_FILE_MODE_NORMAL = 0,
	MTD_FILE_MODE_OTP_FACTORY = 1,
	MTD_FILE_MODE_OTP_USER = 2,
	MTD_FILE_MODE_RAW = 3,
};

struct mtd_chip_driver;

struct map_info___2 {
	const char *name;
	long unsigned int size;
	resource_size_t phys;
	void *virt;
	void *cached;
	int swap;
	int bankwidth;
	void (*inval_cache)(struct map_info___2 *, long unsigned int, ssize_t);
	void (*set_vpp)(struct map_info___2 *, int);
	long unsigned int pfow_base;
	long unsigned int map_priv_1;
	long unsigned int map_priv_2;
	struct device_node *device_node;
	void *fldrv_priv;
	struct mtd_chip_driver *fldrv;
};

struct mtd_chip_driver {
	struct mtd_info * (*probe)(struct map_info___2 *);
	void (*destroy)(struct mtd_info *);
	struct module *module;
	char *name;
	struct list_head list;
};

struct mtd_file_info {
	struct mtd_info *mtd;
	enum mtd_file_modes mode;
};

struct mtd_blktrans_ops;

struct mtd_blktrans_dev {
	struct mtd_blktrans_ops *tr;
	struct list_head list;
	struct mtd_info *mtd;
	struct mutex lock;
	int devnum;
	bool bg_stop;
	long unsigned int size;
	int readonly;
	int open;
	struct kref ref;
	struct gendisk *disk;
	struct attribute_group *disk_attributes;
	struct request_queue *rq;
	struct list_head rq_list;
	struct blk_mq_tag_set *tag_set;
	spinlock_t queue_lock;
	void *priv;
	fmode_t file_mode;
};

struct mtd_blktrans_ops {
	char *name;
	int major;
	int part_bits;
	int blksize;
	int blkshift;
	int (*readsect)(struct mtd_blktrans_dev *, long unsigned int, char *);
	int (*writesect)(struct mtd_blktrans_dev *, long unsigned int, char *);
	int (*discard)(struct mtd_blktrans_dev *, long unsigned int, unsigned int);
	void (*background)(struct mtd_blktrans_dev *);
	int (*getgeo)(struct mtd_blktrans_dev *, struct hd_geometry *);
	int (*flush)(struct mtd_blktrans_dev *);
	int (*open)(struct mtd_blktrans_dev *);
	void (*release)(struct mtd_blktrans_dev *);
	void (*add_mtd)(struct mtd_blktrans_ops *, struct mtd_info *);
	void (*remove_dev)(struct mtd_blktrans_dev *);
	struct list_head devs;
	struct list_head list;
	struct module *owner;
};

struct mtdblk_dev {
	struct mtd_blktrans_dev mbd;
	int count;
	struct mutex cache_mutex;
	unsigned char *cache_data;
	long unsigned int cache_offset;
	unsigned int cache_size;
	enum {
		STATE_EMPTY = 0,
		STATE_CLEAN = 1,
		STATE_DIRTY = 2,
	} cache_state;
};

struct nand_memory_organization {
	unsigned int bits_per_cell;
	unsigned int pagesize;
	unsigned int oobsize;
	unsigned int pages_per_eraseblock;
	unsigned int eraseblocks_per_lun;
	unsigned int max_bad_eraseblocks_per_lun;
	unsigned int planes_per_lun;
	unsigned int luns_per_target;
	unsigned int ntargets;
};

struct nand_row_converter {
	unsigned int lun_addr_shift;
	unsigned int eraseblock_addr_shift;
};

struct nand_pos {
	unsigned int target;
	unsigned int lun;
	unsigned int plane;
	unsigned int eraseblock;
	unsigned int page;
};

enum nand_page_io_req_type {
	NAND_PAGE_READ = 0,
	NAND_PAGE_WRITE = 1,
};

struct nand_page_io_req {
	enum nand_page_io_req_type type;
	struct nand_pos pos;
	unsigned int dataoffs;
	unsigned int datalen;
	union {
		const void *out;
		void *in;
	} databuf;
	unsigned int ooboffs;
	unsigned int ooblen;
	union {
		const void *out;
		void *in;
	} oobbuf;
	int mode;
};

enum nand_ecc_engine_type {
	NAND_ECC_ENGINE_TYPE_INVALID = 0,
	NAND_ECC_ENGINE_TYPE_NONE = 1,
	NAND_ECC_ENGINE_TYPE_SOFT = 2,
	NAND_ECC_ENGINE_TYPE_ON_HOST = 3,
	NAND_ECC_ENGINE_TYPE_ON_DIE = 4,
};

enum nand_ecc_placement {
	NAND_ECC_PLACEMENT_UNKNOWN = 0,
	NAND_ECC_PLACEMENT_OOB = 1,
	NAND_ECC_PLACEMENT_INTERLEAVED = 2,
};

enum nand_ecc_algo {
	NAND_ECC_ALGO_UNKNOWN = 0,
	NAND_ECC_ALGO_HAMMING = 1,
	NAND_ECC_ALGO_BCH = 2,
	NAND_ECC_ALGO_RS = 3,
};

struct nand_ecc_props {
	enum nand_ecc_engine_type engine_type;
	enum nand_ecc_placement placement;
	enum nand_ecc_algo algo;
	unsigned int strength;
	unsigned int step_size;
	unsigned int flags;
};

struct nand_bbt {
	long unsigned int *cache;
};

struct nand_device;

struct nand_ops {
	int (*erase)(struct nand_device *, const struct nand_pos *);
	int (*markbad)(struct nand_device *, const struct nand_pos *);
	bool (*isbad)(struct nand_device *, const struct nand_pos *);
};

struct nand_ecc_context {
	struct nand_ecc_props conf;
	unsigned int total;
	void *priv;
};

struct nand_ecc_engine;

struct nand_ecc {
	struct nand_ecc_props defaults;
	struct nand_ecc_props requirements;
	struct nand_ecc_props user_conf;
	struct nand_ecc_context ctx;
	struct nand_ecc_engine *ondie_engine;
	struct nand_ecc_engine *engine;
};

struct nand_device {
	struct mtd_info mtd;
	struct nand_memory_organization memorg;
	struct nand_ecc ecc;
	struct nand_row_converter rowconv;
	struct nand_bbt bbt;
	const struct nand_ops *ops;
};

struct nand_ecc_engine_ops {
	int (*init_ctx)(struct nand_device *);
	void (*cleanup_ctx)(struct nand_device *);
	int (*prepare_io_req)(struct nand_device *, struct nand_page_io_req *);
	int (*finish_io_req)(struct nand_device *, struct nand_page_io_req *);
};

struct nand_ecc_engine {
	struct nand_ecc_engine_ops *ops;
};

enum nand_bbt_block_status {
	NAND_BBT_BLOCK_STATUS_UNKNOWN = 0,
	NAND_BBT_BLOCK_GOOD = 1,
	NAND_BBT_BLOCK_WORN = 2,
	NAND_BBT_BLOCK_RESERVED = 3,
	NAND_BBT_BLOCK_FACTORY_BAD = 4,
	NAND_BBT_BLOCK_NUM_STATUS = 5,
};

struct spi_device_id {
	char name[32];
	kernel_ulong_t driver_data;
};

struct nand_io_iter {
	struct nand_page_io_req req;
	unsigned int oobbytes_per_page;
	unsigned int dataleft;
	unsigned int oobleft;
};

struct spi_driver {
	const struct spi_device_id *id_table;
	int (*probe)(struct spi_device *);
	int (*remove)(struct spi_device *);
	void (*shutdown)(struct spi_device *);
	struct device_driver driver;
};

enum spi_mem_data_dir {
	SPI_MEM_NO_DATA = 0,
	SPI_MEM_DATA_IN = 1,
	SPI_MEM_DATA_OUT = 2,
};

struct spi_mem_op {
	struct {
		u8 nbytes;
		u8 buswidth;
		u8 dtr: 1;
		u16 opcode;
	} cmd;
	struct {
		u8 nbytes;
		u8 buswidth;
		u8 dtr: 1;
		u64 val;
	} addr;
	struct {
		u8 nbytes;
		u8 buswidth;
		u8 dtr: 1;
	} dummy;
	struct {
		u8 buswidth;
		u8 dtr: 1;
		enum spi_mem_data_dir dir;
		unsigned int nbytes;
		union {
			void *in;
			const void *out;
		} buf;
	} data;
};

struct spi_mem_dirmap_info {
	struct spi_mem_op op_tmpl;
	u64 offset;
	u64 length;
};

struct spi_mem_dirmap_desc {
	struct spi_mem *mem;
	struct spi_mem_dirmap_info info;
	unsigned int nodirmap;
	void *priv;
};

struct spi_mem {
	struct spi_device *spi;
	void *drvpriv;
	const char *name;
};

struct spi_mem_driver {
	struct spi_driver spidrv;
	int (*probe)(struct spi_mem *);
	int (*remove)(struct spi_mem *);
	void (*shutdown)(struct spi_mem *);
};

struct spinand_id {
	u8 data[4];
	int len;
};

enum spinand_readid_method {
	SPINAND_READID_METHOD_OPCODE = 0,
	SPINAND_READID_METHOD_OPCODE_ADDR = 1,
	SPINAND_READID_METHOD_OPCODE_DUMMY = 2,
};

struct spinand_devid {
	const u8 *id;
	const u8 len;
	const enum spinand_readid_method method;
};

struct spinand_device;

struct spinand_manufacturer_ops {
	int (*init)(struct spinand_device *);
	void (*cleanup)(struct spinand_device *);
};

struct spinand_ecc_info {
	int (*get_status)(struct spinand_device *, u8);
	const struct mtd_ooblayout_ops *ooblayout;
};

struct spinand_dirmap;

struct spinand_manufacturer;

struct spinand_device {
	struct nand_device base;
	struct spi_mem *spimem;
	struct mutex lock;
	struct spinand_id id;
	u32 flags;
	struct {
		const struct spi_mem_op *read_cache;
		const struct spi_mem_op *write_cache;
		const struct spi_mem_op *update_cache;
	} op_templates;
	struct spinand_dirmap *dirmaps;
	int (*select_target)(struct spinand_device *, unsigned int);
	unsigned int cur_target;
	struct spinand_ecc_info eccinfo;
	u8 *cfg_cache;
	u8 *databuf;
	u8 *oobbuf;
	u8 *scratchbuf;
	const struct spinand_manufacturer *manufacturer;
	void *priv;
};

struct spinand_info;

struct spinand_manufacturer {
	u8 id;
	char *name;
	const struct spinand_info *chips;
	const size_t nchips;
	const struct spinand_manufacturer_ops *ops;
};

struct spinand_op_variants;

struct spinand_info {
	const char *model;
	struct spinand_devid devid;
	u32 flags;
	struct nand_memory_organization memorg;
	struct nand_ecc_props eccreq;
	struct spinand_ecc_info eccinfo;
	struct {
		const struct spinand_op_variants *read_cache;
		const struct spinand_op_variants *write_cache;
		const struct spinand_op_variants *update_cache;
	} op_variants;
	int (*select_target)(struct spinand_device *, unsigned int);
};

struct spinand_op_variants {
	const struct spi_mem_op *ops;
	unsigned int nops;
};

struct spinand_dirmap {
	struct spi_mem_dirmap_desc *wdesc;
	struct spi_mem_dirmap_desc *rdesc;
};

struct mtd_partition;

struct flash_platform_data {
	char *name;
	struct mtd_partition *parts;
	unsigned int nr_parts;
	char *type;
};

enum spi_nor_protocol {
	SNOR_PROTO_1_1_1 = 65793,
	SNOR_PROTO_1_1_2 = 65794,
	SNOR_PROTO_1_1_4 = 65796,
	SNOR_PROTO_1_1_8 = 65800,
	SNOR_PROTO_1_2_2 = 66050,
	SNOR_PROTO_1_4_4 = 66564,
	SNOR_PROTO_1_8_8 = 67592,
	SNOR_PROTO_2_2_2 = 131586,
	SNOR_PROTO_4_4_4 = 263172,
	SNOR_PROTO_8_8_8 = 526344,
	SNOR_PROTO_1_1_1_DTR = 16843009,
	SNOR_PROTO_1_2_2_DTR = 16843266,
	SNOR_PROTO_1_4_4_DTR = 16843780,
	SNOR_PROTO_1_8_8_DTR = 16844808,
};

struct spi_nor_hwcaps {
	u32 mask;
};

struct spi_nor;

struct spi_nor_controller_ops {
	int (*prepare)(struct spi_nor *);
	void (*unprepare)(struct spi_nor *);
	int (*read_reg)(struct spi_nor *, u8, u8 *, size_t);
	int (*write_reg)(struct spi_nor *, u8, const u8 *, size_t);
	ssize_t (*read)(struct spi_nor *, loff_t, size_t, u8 *);
	ssize_t (*write)(struct spi_nor *, loff_t, size_t, const u8 *);
	int (*erase)(struct spi_nor *, loff_t);
};

struct flash_info;

struct spi_nor_manufacturer;

struct spi_nor_flash_parameter;

struct spi_nor {
	struct mtd_info mtd;
	struct mutex lock;
	struct device *dev;
	struct spi_mem *spimem;
	u8 *bouncebuf;
	size_t bouncebuf_size;
	const struct flash_info *info;
	const struct spi_nor_manufacturer *manufacturer;
	u32 page_size;
	u8 addr_width;
	u8 erase_opcode;
	u8 read_opcode;
	u8 read_dummy;
	u8 program_opcode;
	enum spi_nor_protocol read_proto;
	enum spi_nor_protocol write_proto;
	enum spi_nor_protocol reg_proto;
	bool sst_write_second;
	u32 flags;
	const struct spi_nor_controller_ops *controller_ops;
	struct spi_nor_flash_parameter *params;
	struct {
		struct spi_mem_dirmap_desc *rdesc;
		struct spi_mem_dirmap_desc *wdesc;
	} dirmap;
	void *priv;
};

struct spi_nor_fixups;

struct flash_info {
	char *name;
	u8 id[6];
	u8 id_len;
	unsigned int sector_size;
	u16 n_sectors;
	u16 page_size;
	u16 addr_width;
	u32 flags;
	const struct spi_nor_fixups *fixups;
};

struct spi_nor_manufacturer {
	const char *name;
	const struct flash_info *parts;
	unsigned int nparts;
	const struct spi_nor_fixups *fixups;
};

struct spi_nor_read_command {
	u8 num_mode_clocks;
	u8 num_wait_states;
	u8 opcode;
	enum spi_nor_protocol proto;
};

struct spi_nor_pp_command {
	u8 opcode;
	enum spi_nor_protocol proto;
};

struct spi_nor_erase_region {
	u64 offset;
	u64 size;
};

struct spi_nor_erase_type {
	u32 size;
	u32 size_shift;
	u32 size_mask;
	u8 opcode;
	u8 idx;
};

struct spi_nor_erase_map {
	struct spi_nor_erase_region *regions;
	struct spi_nor_erase_region uniform_region;
	struct spi_nor_erase_type erase_type[4];
	u8 uniform_erase_type;
};

struct spi_nor_locking_ops;

struct spi_nor_flash_parameter {
	u64 size;
	u32 page_size;
	struct spi_nor_hwcaps hwcaps;
	struct spi_nor_read_command reads[15];
	struct spi_nor_pp_command page_programs[7];
	struct spi_nor_erase_map erase_map;
	int (*quad_enable)(struct spi_nor *);
	int (*set_4byte_addr_mode)(struct spi_nor *, bool);
	u32 (*convert_addr)(struct spi_nor *, u32);
	int (*setup)(struct spi_nor *, const struct spi_nor_hwcaps *);
	const struct spi_nor_locking_ops *locking_ops;
};

struct sfdp_bfpt {
	u32 dwords[20];
};

struct sfdp_parameter_header {
	u8 id_lsb;
	u8 minor;
	u8 major;
	u8 length;
	u8 parameter_table_pointer[3];
	u8 id_msb;
};

enum spi_nor_option_flags {
	SNOR_F_USE_FSR = 1,
	SNOR_F_HAS_SR_TB = 2,
	SNOR_F_NO_OP_CHIP_ERASE = 4,
	SNOR_F_READY_XSR_RDY = 8,
	SNOR_F_USE_CLSR = 16,
	SNOR_F_BROKEN_RESET = 32,
	SNOR_F_4B_OPCODES = 64,
	SNOR_F_HAS_4BAIT = 128,
	SNOR_F_HAS_LOCK = 256,
	SNOR_F_HAS_16BIT_SR = 512,
	SNOR_F_NO_READ_CR = 1024,
	SNOR_F_HAS_SR_TB_BIT6 = 2048,
	SNOR_F_HAS_4BIT_BP = 4096,
	SNOR_F_HAS_SR_BP3_BIT6 = 8192,
};

enum spi_nor_read_command_index {
	SNOR_CMD_READ = 0,
	SNOR_CMD_READ_FAST = 1,
	SNOR_CMD_READ_1_1_1_DTR = 2,
	SNOR_CMD_READ_1_1_2 = 3,
	SNOR_CMD_READ_1_2_2 = 4,
	SNOR_CMD_READ_2_2_2 = 5,
	SNOR_CMD_READ_1_2_2_DTR = 6,
	SNOR_CMD_READ_1_1_4 = 7,
	SNOR_CMD_READ_1_4_4 = 8,
	SNOR_CMD_READ_4_4_4 = 9,
	SNOR_CMD_READ_1_4_4_DTR = 10,
	SNOR_CMD_READ_1_1_8 = 11,
	SNOR_CMD_READ_1_8_8 = 12,
	SNOR_CMD_READ_8_8_8 = 13,
	SNOR_CMD_READ_1_8_8_DTR = 14,
	SNOR_CMD_READ_MAX = 15,
};

enum spi_nor_pp_command_index {
	SNOR_CMD_PP = 0,
	SNOR_CMD_PP_1_1_4 = 1,
	SNOR_CMD_PP_1_4_4 = 2,
	SNOR_CMD_PP_4_4_4 = 3,
	SNOR_CMD_PP_1_1_8 = 4,
	SNOR_CMD_PP_1_8_8 = 5,
	SNOR_CMD_PP_8_8_8 = 6,
	SNOR_CMD_PP_MAX = 7,
};

struct spi_nor_erase_command {
	struct list_head list;
	u32 count;
	u32 size;
	u8 opcode;
};

struct spi_nor_locking_ops {
	int (*lock)(struct spi_nor *, loff_t, uint64_t);
	int (*unlock)(struct spi_nor *, loff_t, uint64_t);
	int (*is_locked)(struct spi_nor *, loff_t, uint64_t);
};

struct spi_nor_fixups {
	void (*default_init)(struct spi_nor *);
	int (*post_bfpt)(struct spi_nor *, const struct sfdp_parameter_header *, const struct sfdp_bfpt *, struct spi_nor_flash_parameter *);
	void (*post_sfdp)(struct spi_nor *);
};

struct sfdp_header {
	u32 signature;
	u8 minor;
	u8 major;
	u8 nph;
	u8 unused;
	struct sfdp_parameter_header bfpt_header;
};

struct sfdp_bfpt_read {
	u32 hwcaps;
	u32 supported_dword;
	u32 supported_bit;
	u32 settings_dword;
	u32 settings_shift;
	enum spi_nor_protocol proto;
};

struct sfdp_bfpt_erase {
	u32 dword;
	u32 shift;
};

struct sfdp_4bait {
	u32 hwcaps;
	u32 supported_bit;
};

enum {
	UBI_VID_DYNAMIC = 1,
	UBI_VID_STATIC = 2,
};

enum {
	UBI_VTBL_AUTORESIZE_FLG = 1,
	UBI_VTBL_SKIP_CRC_CHECK_FLG = 2,
};

enum {
	UBI_COMPAT_DELETE = 1,
	UBI_COMPAT_RO = 2,
	UBI_COMPAT_PRESERVE = 4,
	UBI_COMPAT_REJECT = 5,
};

struct ubi_ec_hdr {
	__be32 magic;
	__u8 version;
	__u8 padding1[3];
	__be64 ec;
	__be32 vid_hdr_offset;
	__be32 data_offset;
	__be32 image_seq;
	__u8 padding2[32];
	__be32 hdr_crc;
};

struct ubi_vid_hdr {
	__be32 magic;
	__u8 version;
	__u8 vol_type;
	__u8 copy_flag;
	__u8 compat;
	__be32 vol_id;
	__be32 lnum;
	__u8 padding1[4];
	__be32 data_size;
	__be32 used_ebs;
	__be32 data_pad;
	__be32 data_crc;
	__u8 padding2[4];
	__be64 sqnum;
	__u8 padding3[12];
	__be32 hdr_crc;
};

struct ubi_vtbl_record {
	__be32 reserved_pebs;
	__be32 alignment;
	__be32 data_pad;
	__u8 vol_type;
	__u8 upd_marker;
	__be16 name_len;
	__u8 name[128];
	__u8 flags;
	__u8 padding[23];
	__be32 crc;
};

enum {
	UBI_IO_FF = 1,
	UBI_IO_FF_BITFLIPS = 2,
	UBI_IO_BAD_HDR = 3,
	UBI_IO_BAD_HDR_EBADMSG = 4,
	UBI_IO_BITFLIPS = 5,
};

struct ubi_vid_io_buf {
	struct ubi_vid_hdr *hdr;
	void *buffer;
};

struct ubi_wl_entry {
	union {
		struct rb_node rb;
		struct list_head list;
	} u;
	int ec;
	int pnum;
};

struct ubi_volume_desc;

struct ubi_rename_entry {
	int new_name_len;
	char new_name[128];
	int remove;
	struct ubi_volume_desc *desc;
	struct list_head list;
};

struct ubi_volume;

struct ubi_volume_desc {
	struct ubi_volume *vol;
	int mode;
};

struct ubi_fastmap_layout {
	struct ubi_wl_entry *e[32];
	int to_be_tortured[32];
	int used_blocks;
	int max_pool_size;
	int max_wl_pool_size;
};

struct ubi_fm_pool {
	int pebs[256];
	int used;
	int size;
	int max_size;
};

struct ubi_device;

struct ubi_eba_table;

struct ubi_volume {
	struct device dev;
	struct cdev cdev;
	struct ubi_device *ubi;
	int vol_id;
	int ref_count;
	int readers;
	int writers;
	int exclusive;
	int metaonly;
	int reserved_pebs;
	int vol_type;
	int usable_leb_size;
	int used_ebs;
	int last_eb_bytes;
	long long int used_bytes;
	int alignment;
	int data_pad;
	int name_len;
	char name[128];
	int upd_ebs;
	int ch_lnum;
	long long int upd_bytes;
	long long int upd_received;
	void *upd_buf;
	struct ubi_eba_table *eba_tbl;
	unsigned int skip_check: 1;
	unsigned int checked: 1;
	unsigned int corrupted: 1;
	unsigned int upd_marker: 1;
	unsigned int updating: 1;
	unsigned int changing_leb: 1;
	unsigned int direct_writes: 1;
};

struct ubi_debug_info {
	unsigned int chk_gen: 1;
	unsigned int chk_io: 1;
	unsigned int chk_fastmap: 1;
	unsigned int disable_bgt: 1;
	unsigned int emulate_bitflips: 1;
	unsigned int emulate_io_failures: 1;
	unsigned int emulate_power_cut: 2;
	unsigned int power_cut_counter;
	unsigned int power_cut_min;
	unsigned int power_cut_max;
	char dfs_dir_name[7];
	struct dentry *dfs_dir;
	struct dentry *dfs_chk_gen;
	struct dentry *dfs_chk_io;
	struct dentry *dfs_chk_fastmap;
	struct dentry *dfs_disable_bgt;
	struct dentry *dfs_emulate_bitflips;
	struct dentry *dfs_emulate_io_failures;
	struct dentry *dfs_emulate_power_cut;
	struct dentry *dfs_power_cut_min;
	struct dentry *dfs_power_cut_max;
};

struct ubi_device {
	struct cdev cdev;
	struct device dev;
	int ubi_num;
	char ubi_name[9];
	int vol_count;
	struct ubi_volume *volumes[129];
	spinlock_t volumes_lock;
	int ref_count;
	int image_seq;
	int rsvd_pebs;
	int avail_pebs;
	int beb_rsvd_pebs;
	int beb_rsvd_level;
	int bad_peb_limit;
	int autoresize_vol_id;
	int vtbl_slots;
	int vtbl_size;
	struct ubi_vtbl_record *vtbl;
	struct mutex device_mutex;
	int max_ec;
	int mean_ec;
	long long unsigned int global_sqnum;
	spinlock_t ltree_lock;
	struct rb_root ltree;
	struct mutex alc_mutex;
	int fm_disabled;
	struct ubi_fastmap_layout *fm;
	struct ubi_fm_pool fm_pool;
	struct ubi_fm_pool fm_wl_pool;
	struct rw_semaphore fm_eba_sem;
	struct rw_semaphore fm_protect;
	void *fm_buf;
	size_t fm_size;
	struct work_struct fm_work;
	int fm_work_scheduled;
	int fast_attach;
	struct ubi_wl_entry *fm_anchor;
	struct ubi_wl_entry *fm_next_anchor;
	int fm_do_produce_anchor;
	struct rb_root used;
	struct rb_root erroneous;
	struct rb_root free;
	int free_count;
	struct rb_root scrub;
	struct list_head pq[10];
	int pq_head;
	spinlock_t wl_lock;
	struct mutex move_mutex;
	struct rw_semaphore work_sem;
	int wl_scheduled;
	struct ubi_wl_entry **lookuptbl;
	struct ubi_wl_entry *move_from;
	struct ubi_wl_entry *move_to;
	int move_to_put;
	struct list_head works;
	int works_count;
	struct task_struct *bgt_thread;
	int thread_enabled;
	char bgt_name[13];
	long long int flash_size;
	int peb_count;
	int peb_size;
	int bad_peb_count;
	int good_peb_count;
	int corr_peb_count;
	int erroneous_peb_count;
	int max_erroneous;
	int min_io_size;
	int hdrs_min_io_size;
	int ro_mode;
	int leb_size;
	int leb_start;
	int ec_hdr_alsize;
	int vid_hdr_alsize;
	int vid_hdr_offset;
	int vid_hdr_aloffset;
	int vid_hdr_shift;
	unsigned int bad_allowed: 1;
	unsigned int nor_flash: 1;
	int max_write_size;
	struct mtd_info *mtd;
	void *peb_buf;
	struct mutex buf_mutex;
	struct mutex ckvol_mutex;
	struct ubi_debug_info dbg;
};

struct ubi_ainf_peb {
	int ec;
	int pnum;
	int vol_id;
	int lnum;
	unsigned int scrub: 1;
	unsigned int copy_flag: 1;
	long long unsigned int sqnum;
	union {
		struct rb_node rb;
		struct list_head list;
	} u;
};

struct ubi_ainf_volume {
	int vol_id;
	int highest_lnum;
	int leb_count;
	int vol_type;
	int used_ebs;
	int last_data_size;
	int data_pad;
	int compat;
	struct rb_node rb;
	struct rb_root root;
};

struct ubi_attach_info {
	struct rb_root volumes;
	struct list_head corr;
	struct list_head free;
	struct list_head erase;
	struct list_head alien;
	struct list_head fastmap;
	int corr_peb_count;
	int empty_peb_count;
	int alien_peb_count;
	int bad_peb_count;
	int maybe_bad_peb_count;
	int vols_found;
	int highest_vol_id;
	int is_empty;
	int force_full_scan;
	int min_ec;
	int max_ec;
	long long unsigned int max_sqnum;
	int mean_ec;
	uint64_t ec_sum;
	int ec_count;
	struct kmem_cache *aeb_slab_cache;
	struct ubi_ec_hdr *ech;
	struct ubi_vid_io_buf *vidb;
};

enum {
	UBI_VOL_SKIP_CRC_CHECK_FLG = 1,
};

struct ubi_mkvol_req {
	__s32 vol_id;
	__s32 alignment;
	__s64 bytes;
	__s8 vol_type;
	__u8 flags;
	__s16 name_len;
	__s8 padding2[4];
	char name[128];
};

enum {
	UBI_VOLUME_ADDED = 0,
	UBI_VOLUME_REMOVED = 1,
	UBI_VOLUME_RESIZED = 2,
	UBI_VOLUME_RENAMED = 3,
	UBI_VOLUME_UPDATED = 4,
};

struct ubi_leb_change_req {
	__s32 lnum;
	__s32 bytes;
	__s8 dtype;
	__s8 padding[7];
};

struct ubi_notification {
	struct ubi_device_info di;
	struct ubi_volume_info vi;
};

struct mtd_dev_param {
	char name[64];
	int ubi_num;
	int vid_hdr_offs;
	int max_beb_per1024;
};

enum {
	UBI_VOL_PROP_DIRECT_WRITE = 1,
};

struct ubi_attach_req {
	__s32 ubi_num;
	__s32 mtd_num;
	__s32 vid_hdr_offset;
	__s16 max_beb_per1024;
	__s8 padding[10];
};

struct ubi_rsvol_req {
	__s64 bytes;
	__s32 vol_id;
} __attribute__((packed));

struct ubi_rnvol_req {
	__s32 count;
	__s8 padding1[12];
	struct {
		__s32 vol_id;
		__s16 name_len;
		__s8 padding2[2];
		char name[128];
	} ents[32];
};

struct ubi_map_req {
	__s32 lnum;
	__s8 dtype;
	__s8 padding[3];
};

struct ubi_set_vol_prop_req {
	__u8 property;
	__u8 padding[7];
	__u64 value;
};

struct ubi_sgl {
	int list_pos;
	int page_pos;
	struct scatterlist sg[64];
};

enum {
	MOVE_CANCEL_RACE = 1,
	MOVE_SOURCE_RD_ERR = 2,
	MOVE_TARGET_RD_ERR = 3,
	MOVE_TARGET_WR_ERR = 4,
	MOVE_TARGET_BITFLIPS = 5,
	MOVE_RETRY = 6,
};

struct ubi_ltree_entry {
	struct rb_node rb;
	int vol_id;
	int lnum;
	int users;
	struct rw_semaphore mutex;
};

struct ubi_eba_leb_desc {
	int lnum;
	int pnum;
};

struct ubi_eba_entry;

struct ubi_eba_table {
	struct ubi_eba_entry *entries;
};

struct ubi_eba_entry {
	int pnum;
};

enum {
	POWER_CUT_EC_WRITE = 1,
	POWER_CUT_VID_WRITE = 2,
};

struct ubi_work {
	struct list_head list;
	int (*func)(struct ubi_device *, struct ubi_work *, int);
	struct ubi_wl_entry *e;
	int vol_id;
	int lnum;
	int torture;
};

typedef void (*spi_res_release_t)(struct spi_controller *, struct spi_message *, void *);

struct spi_res {
	struct list_head entry;
	spi_res_release_t release;
	long long unsigned int data[0];
};

struct spi_replaced_transfers;

typedef void (*spi_replaced_release_t)(struct spi_controller *, struct spi_message *, struct spi_replaced_transfers *);

struct spi_replaced_transfers {
	spi_replaced_release_t release;
	void *extradata;
	struct list_head replaced_transfers;
	struct list_head *replaced_after;
	size_t inserted;
	struct spi_transfer inserted_transfers[0];
};

struct spi_board_info {
	char modalias[32];
	const void *platform_data;
	const struct property_entry *properties;
	void *controller_data;
	int irq;
	u32 max_speed_hz;
	u16 bus_num;
	u16 chip_select;
	u32 mode;
};

struct trace_event_raw_spi_controller {
	struct trace_entry ent;
	int bus_num;
	char __data[0];
};

struct trace_event_raw_spi_message {
	struct trace_entry ent;
	int bus_num;
	int chip_select;
	struct spi_message *msg;
	char __data[0];
};

struct trace_event_raw_spi_message_done {
	struct trace_entry ent;
	int bus_num;
	int chip_select;
	struct spi_message *msg;
	unsigned int frame;
	unsigned int actual;
	char __data[0];
};

struct trace_event_raw_spi_transfer {
	struct trace_entry ent;
	int bus_num;
	int chip_select;
	struct spi_transfer *xfer;
	int len;
	u32 __data_loc_rx_buf;
	u32 __data_loc_tx_buf;
	char __data[0];
};

struct trace_event_data_offsets_spi_controller {};

struct trace_event_data_offsets_spi_message {};

struct trace_event_data_offsets_spi_message_done {};

struct trace_event_data_offsets_spi_transfer {
	u32 rx_buf;
	u32 tx_buf;
};

typedef void (*btf_trace_spi_controller_idle)(void *, struct spi_controller *);

typedef void (*btf_trace_spi_controller_busy)(void *, struct spi_controller *);

typedef void (*btf_trace_spi_message_submit)(void *, struct spi_message *);

typedef void (*btf_trace_spi_message_start)(void *, struct spi_message *);

typedef void (*btf_trace_spi_message_done)(void *, struct spi_message *);

typedef void (*btf_trace_spi_transfer_start)(void *, struct spi_message *, struct spi_transfer *);

typedef void (*btf_trace_spi_transfer_stop)(void *, struct spi_message *, struct spi_transfer *);

struct boardinfo {
	struct list_head list;
	struct spi_board_info board_info;
};

struct spi_ioc_transfer {
	__u64 tx_buf;
	__u64 rx_buf;
	__u32 len;
	__u32 speed_hz;
	__u16 delay_usecs;
	__u8 bits_per_word;
	__u8 cs_change;
	__u8 tx_nbits;
	__u8 rx_nbits;
	__u8 word_delay_usecs;
	__u8 pad;
};

struct spidev_data {
	dev_t devt;
	spinlock_t spi_lock;
	struct spi_device *spi;
	struct list_head device_entry;
	struct mutex buf_lock;
	unsigned int users;
	u8 *tx_buffer;
	u8 *rx_buffer;
	u32 speed_hz;
};

enum dw_ssi_type {
	SSI_MOTO_SPI = 0,
	SSI_TI_SSP = 1,
	SSI_NS_MICROWIRE = 2,
};

struct dw_spi;

struct dw_spi_dma_ops {
	int (*dma_init)(struct dw_spi *);
	void (*dma_exit)(struct dw_spi *);
	int (*dma_setup)(struct dw_spi *, struct spi_transfer *);
	bool (*can_dma)(struct spi_controller *, struct spi_device *, struct spi_transfer *);
	int (*dma_transfer)(struct dw_spi *, struct spi_transfer *);
	void (*dma_stop)(struct dw_spi *);
};

struct xfer_pre_t {
	u8 xfer_pre[32];
	u32 xfer_pre_len;
};

struct dw_spi {
	struct spi_controller *master;
	enum dw_ssi_type type;
	void *regs;
	long unsigned int paddr;
	int irq;
	u32 fifo_len;
	u32 max_freq;
	int cs_override;
	u32 reg_io_width;
	u16 bus_num;
	u16 num_cs;
	u16 rx_sample_delay;
	struct gpio_desc *slave_cs;
	void (*set_cs)(struct spi_device *, bool);
	struct xfer_pre_t xfer_data_pre;
	size_t len;
	void *tx;
	void *tx_end;
	spinlock_t buf_lock;
	void *rx;
	void *rx_end;
	int dma_mapped;
	u8 n_bytes;
	u32 dma_width;
	irqreturn_t (*transfer_handler)(struct dw_spi *);
	u32 current_freq;
	int dma_inited;
	struct dma_chan *txchan;
	struct dma_chan *rxchan;
	long unsigned int dma_chan_busy;
	dma_addr_t dma_addr;
	const struct dw_spi_dma_ops *dma_ops;
	void *dma_tx;
	void *dma_rx;
	void *priv;
	struct dentry *debugfs;
};

struct dw_qspi_mmio {
	struct dw_spi dws;
	struct clk *clk;
	struct clk *pclk;
	void *priv;
};

struct dw_spi_chip {
	u8 poll_mode;
	u8 type;
	void (*cs_control)(u32);
};

struct chip_data {
	u8 tmode;
	u8 type;
	u8 poll_mode;
	u16 clk_div;
	u32 speed_hz;
	void (*cs_control)(u32);
};

struct dw_spi_cfg {
	u8 tmode;
	u8 dfs;
	u32 ndf;
	u32 freq;
};

struct dw_spi___2;

struct dw_spi_dma_ops___2 {
	int (*dma_init)(struct device *, struct dw_spi___2 *);
	void (*dma_exit)(struct dw_spi___2 *);
	int (*dma_setup)(struct dw_spi___2 *, struct spi_transfer *);
	bool (*can_dma)(struct spi_controller *, struct spi_device *, struct spi_transfer *);
	int (*dma_transfer)(struct dw_spi___2 *, struct spi_transfer *);
	void (*dma_stop)(struct dw_spi___2 *);
};

struct dw_spi___2 {
	struct spi_controller *master;
	void *regs;
	long unsigned int paddr;
	int irq;
	u32 fifo_len;
	u32 max_mem_freq;
	u32 max_freq;
	u32 caps;
	u32 reg_io_width;
	u16 bus_num;
	u16 num_cs;
	void (*set_cs)(struct spi_device *, bool);
	void *tx;
	unsigned int tx_len;
	void *rx;
	unsigned int rx_len;
	u8 buf[266];
	int dma_mapped;
	u8 n_bytes;
	irqreturn_t (*transfer_handler)(struct dw_spi___2 *);
	u32 current_freq;
	u32 cur_rx_sample_dly;
	u32 def_rx_sample_dly_ns;
	struct spi_controller_mem_ops mem_ops;
	struct dma_chan *txchan;
	u32 txburst;
	struct dma_chan *rxchan;
	u32 rxburst;
	u32 dma_sg_burst;
	long unsigned int dma_chan_busy;
	dma_addr_t dma_addr;
	const struct dw_spi_dma_ops___2 *dma_ops;
	struct completion dma_completion;
	struct dentry *debugfs;
	struct debugfs_regset32 regset;
};

struct chip_data___2 {
	u32 cr0;
	u32 rx_sample_dly;
};

struct dw_spi_mmio {
	struct dw_spi___2 dws;
	struct clk *clk;
	struct clk *pclk;
	void *priv;
	struct reset_control *rstc;
};

struct dw_spi_mscc {
	struct regmap *syscon;
	void *spi_mst;
};

struct ethtool_cmd {
	__u32 cmd;
	__u32 supported;
	__u32 advertising;
	__u16 speed;
	__u8 duplex;
	__u8 port;
	__u8 phy_address;
	__u8 transceiver;
	__u8 autoneg;
	__u8 mdio_support;
	__u32 maxtxpkt;
	__u32 maxrxpkt;
	__u16 speed_hi;
	__u8 eth_tp_mdix;
	__u8 eth_tp_mdix_ctrl;
	__u32 lp_advertising;
	__u32 reserved[2];
};

enum netdev_state_t {
	__LINK_STATE_START = 0,
	__LINK_STATE_PRESENT = 1,
	__LINK_STATE_NOCARRIER = 2,
	__LINK_STATE_LINKWATCH_PENDING = 3,
	__LINK_STATE_DORMANT = 4,
	__LINK_STATE_TESTING = 5,
};

struct mii_ioctl_data {
	__u16 phy_id;
	__u16 reg_num;
	__u16 val_in;
	__u16 val_out;
};

struct mii_if_info {
	int phy_id;
	int advertising;
	int phy_id_mask;
	int reg_num_mask;
	unsigned int full_duplex: 1;
	unsigned int force_media: 1;
	unsigned int supports_gmii: 1;
	struct net_device *dev;
	int (*mdio_read)(struct net_device *, int, int);
	void (*mdio_write)(struct net_device *, int, int, int);
};

struct devprobe2 {
	struct net_device * (*probe)(int);
	int status;
};

enum {
	NETIF_F_SG_BIT = 0,
	NETIF_F_IP_CSUM_BIT = 1,
	__UNUSED_NETIF_F_1 = 2,
	NETIF_F_HW_CSUM_BIT = 3,
	NETIF_F_IPV6_CSUM_BIT = 4,
	NETIF_F_HIGHDMA_BIT = 5,
	NETIF_F_FRAGLIST_BIT = 6,
	NETIF_F_HW_VLAN_CTAG_TX_BIT = 7,
	NETIF_F_HW_VLAN_CTAG_RX_BIT = 8,
	NETIF_F_HW_VLAN_CTAG_FILTER_BIT = 9,
	NETIF_F_VLAN_CHALLENGED_BIT = 10,
	NETIF_F_GSO_BIT = 11,
	NETIF_F_LLTX_BIT = 12,
	NETIF_F_NETNS_LOCAL_BIT = 13,
	NETIF_F_GRO_BIT = 14,
	NETIF_F_LRO_BIT = 15,
	NETIF_F_GSO_SHIFT = 16,
	NETIF_F_TSO_BIT = 16,
	NETIF_F_GSO_ROBUST_BIT = 17,
	NETIF_F_TSO_ECN_BIT = 18,
	NETIF_F_TSO_MANGLEID_BIT = 19,
	NETIF_F_TSO6_BIT = 20,
	NETIF_F_FSO_BIT = 21,
	NETIF_F_GSO_GRE_BIT = 22,
	NETIF_F_GSO_GRE_CSUM_BIT = 23,
	NETIF_F_GSO_IPXIP4_BIT = 24,
	NETIF_F_GSO_IPXIP6_BIT = 25,
	NETIF_F_GSO_UDP_TUNNEL_BIT = 26,
	NETIF_F_GSO_UDP_TUNNEL_CSUM_BIT = 27,
	NETIF_F_GSO_PARTIAL_BIT = 28,
	NETIF_F_GSO_TUNNEL_REMCSUM_BIT = 29,
	NETIF_F_GSO_SCTP_BIT = 30,
	NETIF_F_GSO_ESP_BIT = 31,
	NETIF_F_GSO_UDP_BIT = 32,
	NETIF_F_GSO_UDP_L4_BIT = 33,
	NETIF_F_GSO_FRAGLIST_BIT = 34,
	NETIF_F_GSO_LAST = 34,
	NETIF_F_FCOE_CRC_BIT = 35,
	NETIF_F_SCTP_CRC_BIT = 36,
	NETIF_F_FCOE_MTU_BIT = 37,
	NETIF_F_NTUPLE_BIT = 38,
	NETIF_F_RXHASH_BIT = 39,
	NETIF_F_RXCSUM_BIT = 40,
	NETIF_F_NOCACHE_COPY_BIT = 41,
	NETIF_F_LOOPBACK_BIT = 42,
	NETIF_F_RXFCS_BIT = 43,
	NETIF_F_RXALL_BIT = 44,
	NETIF_F_HW_VLAN_STAG_TX_BIT = 45,
	NETIF_F_HW_VLAN_STAG_RX_BIT = 46,
	NETIF_F_HW_VLAN_STAG_FILTER_BIT = 47,
	NETIF_F_HW_L2FW_DOFFLOAD_BIT = 48,
	NETIF_F_HW_TC_BIT = 49,
	NETIF_F_HW_ESP_BIT = 50,
	NETIF_F_HW_ESP_TX_CSUM_BIT = 51,
	NETIF_F_RX_UDP_TUNNEL_PORT_BIT = 52,
	NETIF_F_HW_TLS_TX_BIT = 53,
	NETIF_F_HW_TLS_RX_BIT = 54,
	NETIF_F_GRO_HW_BIT = 55,
	NETIF_F_HW_TLS_RECORD_BIT = 56,
	NETIF_F_GRO_FRAGLIST_BIT = 57,
	NETIF_F_HW_MACSEC_BIT = 58,
	NETDEV_FEATURE_COUNT = 59,
};

enum {
	SKBTX_HW_TSTAMP = 1,
	SKBTX_SW_TSTAMP = 2,
	SKBTX_IN_PROGRESS = 4,
	SKBTX_DEV_ZEROCOPY = 8,
	SKBTX_WIFI_STATUS = 16,
	SKBTX_SHARED_FRAG = 32,
	SKBTX_SCHED_TSTAMP = 64,
};

enum netdev_priv_flags {
	IFF_802_1Q_VLAN = 1,
	IFF_EBRIDGE = 2,
	IFF_BONDING = 4,
	IFF_ISATAP = 8,
	IFF_WAN_HDLC = 16,
	IFF_XMIT_DST_RELEASE = 32,
	IFF_DONT_BRIDGE = 64,
	IFF_DISABLE_NETPOLL = 128,
	IFF_MACVLAN_PORT = 256,
	IFF_BRIDGE_PORT = 512,
	IFF_OVS_DATAPATH = 1024,
	IFF_TX_SKB_SHARING = 2048,
	IFF_UNICAST_FLT = 4096,
	IFF_TEAM_PORT = 8192,
	IFF_SUPP_NOFCS = 16384,
	IFF_LIVE_ADDR_CHANGE = 32768,
	IFF_MACVLAN = 65536,
	IFF_XMIT_DST_RELEASE_PERM = 131072,
	IFF_L3MDEV_MASTER = 262144,
	IFF_NO_QUEUE = 524288,
	IFF_OPENVSWITCH = 1048576,
	IFF_L3MDEV_SLAVE = 2097152,
	IFF_TEAM = 4194304,
	IFF_RXFH_CONFIGURED = 8388608,
	IFF_PHONY_HEADROOM = 16777216,
	IFF_MACSEC = 33554432,
	IFF_NO_RX_HANDLER = 67108864,
	IFF_FAILOVER = 134217728,
	IFF_FAILOVER_SLAVE = 268435456,
	IFF_L3MDEV_RX_HANDLER = 536870912,
	IFF_LIVE_RENAME_OK = 1073741824,
};

struct mdio_board_info {
	const char *bus_id;
	char modalias[32];
	int mdio_addr;
	const void *platform_data;
};

struct mdio_board_entry {
	struct list_head list;
	struct mdio_board_info board_info;
};

struct mdiobus_devres {
	struct mii_bus *mii;
};

struct phylink_link_state {
	long unsigned int advertising[2];
	long unsigned int lp_advertising[2];
	phy_interface_t interface;
	int speed;
	int duplex;
	int pause;
	unsigned int link: 1;
	unsigned int an_enabled: 1;
	unsigned int an_complete: 1;
};

struct phylink_mac_ops;

struct phylink_pcs_ops;

struct phylink_config;

struct phylink_pcs;

struct phylink {
	struct net_device *netdev;
	const struct phylink_mac_ops *mac_ops;
	const struct phylink_pcs_ops *pcs_ops;
	struct phylink_config *config;
	struct phylink_pcs *pcs;
	struct device *dev;
	unsigned int old_link_state: 1;
	long unsigned int phylink_disable_state;
	struct phy_device *phydev;
	phy_interface_t link_interface;
	u8 cfg_link_an_mode;
	u8 cur_link_an_mode;
	u8 link_port;
	long unsigned int supported[2];
	struct phylink_link_state link_config;
	phy_interface_t cur_interface;
	struct gpio_desc *link_gpio;
	unsigned int link_irq;
	struct timer_list link_poll;
	void (*get_fixed_state)(struct net_device *, struct phylink_link_state *);
	struct mutex state_mutex;
	struct phylink_link_state phy_state;
	struct work_struct resolve;
	bool mac_link_dropped;
	struct sfp_bus *sfp_bus;
	bool sfp_may_have_phy;
	long unsigned int sfp_support[2];
	u8 sfp_port;
};

struct phy_setting {
	u32 speed;
	u8 duplex;
	u8 bit;
};

struct fixed_phy_status {
	int link;
	int speed;
	int duplex;
	int pause;
	int asym_pause;
};

enum {
	MLO_PAUSE_NONE = 0,
	MLO_PAUSE_RX = 1,
	MLO_PAUSE_TX = 2,
	MLO_PAUSE_TXRX_MASK = 3,
	MLO_PAUSE_AN = 4,
	MLO_AN_PHY = 0,
	MLO_AN_FIXED = 1,
	MLO_AN_INBAND = 2,
};

enum phylink_op_type {
	PHYLINK_NETDEV = 0,
	PHYLINK_DEV = 1,
};

struct phylink_config {
	struct device *dev;
	enum phylink_op_type type;
	bool pcs_poll;
	bool poll_fixed_state;
	void (*get_fixed_state)(struct phylink_config *, struct phylink_link_state *);
};

struct phylink_mac_ops {
	void (*validate)(struct phylink_config *, long unsigned int *, struct phylink_link_state *);
	void (*mac_pcs_get_state)(struct phylink_config *, struct phylink_link_state *);
	int (*mac_prepare)(struct phylink_config *, unsigned int, phy_interface_t);
	void (*mac_config)(struct phylink_config *, unsigned int, const struct phylink_link_state *);
	int (*mac_finish)(struct phylink_config *, unsigned int, phy_interface_t);
	void (*mac_an_restart)(struct phylink_config *);
	void (*mac_link_down)(struct phylink_config *, unsigned int, phy_interface_t);
	void (*mac_link_up)(struct phylink_config *, struct phy_device *, unsigned int, phy_interface_t, int, int, bool, bool);
};

struct phylink_pcs {
	const struct phylink_pcs_ops *ops;
	bool poll;
};

struct phylink_pcs_ops {
	void (*pcs_get_state)(struct phylink_pcs *, struct phylink_link_state *);
	int (*pcs_config)(struct phylink_pcs *, unsigned int, phy_interface_t, const long unsigned int *, bool);
	void (*pcs_an_restart)(struct phylink_pcs *);
	void (*pcs_link_up)(struct phylink_pcs *, unsigned int, phy_interface_t, int, int);
};

struct sfp_eeprom_base {
	u8 phys_id;
	u8 phys_ext_id;
	u8 connector;
	u8 if_1x_copper_passive: 1;
	u8 if_1x_copper_active: 1;
	u8 if_1x_lx: 1;
	u8 if_1x_sx: 1;
	u8 e10g_base_sr: 1;
	u8 e10g_base_lr: 1;
	u8 e10g_base_lrm: 1;
	u8 e10g_base_er: 1;
	u8 sonet_oc3_short_reach: 1;
	u8 sonet_oc3_smf_intermediate_reach: 1;
	u8 sonet_oc3_smf_long_reach: 1;
	u8 unallocated_5_3: 1;
	u8 sonet_oc12_short_reach: 1;
	u8 sonet_oc12_smf_intermediate_reach: 1;
	u8 sonet_oc12_smf_long_reach: 1;
	u8 unallocated_5_7: 1;
	u8 sonet_oc48_short_reach: 1;
	u8 sonet_oc48_intermediate_reach: 1;
	u8 sonet_oc48_long_reach: 1;
	u8 sonet_reach_bit2: 1;
	u8 sonet_reach_bit1: 1;
	u8 sonet_oc192_short_reach: 1;
	u8 escon_smf_1310_laser: 1;
	u8 escon_mmf_1310_led: 1;
	u8 e1000_base_sx: 1;
	u8 e1000_base_lx: 1;
	u8 e1000_base_cx: 1;
	u8 e1000_base_t: 1;
	u8 e100_base_lx: 1;
	u8 e100_base_fx: 1;
	u8 e_base_bx10: 1;
	u8 e_base_px: 1;
	u8 fc_tech_electrical_inter_enclosure: 1;
	u8 fc_tech_lc: 1;
	u8 fc_tech_sa: 1;
	u8 fc_ll_m: 1;
	u8 fc_ll_l: 1;
	u8 fc_ll_i: 1;
	u8 fc_ll_s: 1;
	u8 fc_ll_v: 1;
	u8 unallocated_8_0: 1;
	u8 unallocated_8_1: 1;
	u8 sfp_ct_passive: 1;
	u8 sfp_ct_active: 1;
	u8 fc_tech_ll: 1;
	u8 fc_tech_sl: 1;
	u8 fc_tech_sn: 1;
	u8 fc_tech_electrical_intra_enclosure: 1;
	u8 fc_media_sm: 1;
	u8 unallocated_9_1: 1;
	u8 fc_media_m5: 1;
	u8 fc_media_m6: 1;
	u8 fc_media_tv: 1;
	u8 fc_media_mi: 1;
	u8 fc_media_tp: 1;
	u8 fc_media_tw: 1;
	u8 fc_speed_100: 1;
	u8 unallocated_10_1: 1;
	u8 fc_speed_200: 1;
	u8 fc_speed_3200: 1;
	u8 fc_speed_400: 1;
	u8 fc_speed_1600: 1;
	u8 fc_speed_800: 1;
	u8 fc_speed_1200: 1;
	u8 encoding;
	u8 br_nominal;
	u8 rate_id;
	u8 link_len[6];
	char vendor_name[16];
	u8 extended_cc;
	char vendor_oui[3];
	char vendor_pn[16];
	char vendor_rev[4];
	union {
		__be16 optical_wavelength;
		__be16 cable_compliance;
		struct {
			u8 sff8431_app_e: 1;
			u8 fc_pi_4_app_h: 1;
			u8 reserved60_2: 6;
			u8 reserved61: 8;
		} passive;
		struct {
			u8 sff8431_app_e: 1;
			u8 fc_pi_4_app_h: 1;
			u8 sff8431_lim: 1;
			u8 fc_pi_4_lim: 1;
			u8 reserved60_4: 4;
			u8 reserved61: 8;
		} active;
	};
	u8 reserved62;
	u8 cc_base;
};

struct sfp_eeprom_ext {
	__be16 options;
	u8 br_max;
	u8 br_min;
	char vendor_sn[16];
	char datecode[8];
	u8 diagmon;
	u8 enhopts;
	u8 sff8472_compliance;
	u8 cc_ext;
};

struct sfp_eeprom_id {
	struct sfp_eeprom_base base;
	struct sfp_eeprom_ext ext;
};

struct sfp_upstream_ops {
	void (*attach)(void *, struct sfp_bus *);
	void (*detach)(void *, struct sfp_bus *);
	int (*module_insert)(void *, const struct sfp_eeprom_id *);
	void (*module_remove)(void *);
	int (*module_start)(void *);
	void (*module_stop)(void *);
	void (*link_down)(void *);
	void (*link_up)(void *);
	int (*connect_phy)(void *, struct phy_device *);
	void (*disconnect_phy)(void *);
};

enum {
	PHYLINK_DISABLE_STOPPED = 0,
	PHYLINK_DISABLE_LINK = 1,
};

enum {
	ETHTOOL_MSG_KERNEL_NONE = 0,
	ETHTOOL_MSG_STRSET_GET_REPLY = 1,
	ETHTOOL_MSG_LINKINFO_GET_REPLY = 2,
	ETHTOOL_MSG_LINKINFO_NTF = 3,
	ETHTOOL_MSG_LINKMODES_GET_REPLY = 4,
	ETHTOOL_MSG_LINKMODES_NTF = 5,
	ETHTOOL_MSG_LINKSTATE_GET_REPLY = 6,
	ETHTOOL_MSG_DEBUG_GET_REPLY = 7,
	ETHTOOL_MSG_DEBUG_NTF = 8,
	ETHTOOL_MSG_WOL_GET_REPLY = 9,
	ETHTOOL_MSG_WOL_NTF = 10,
	ETHTOOL_MSG_FEATURES_GET_REPLY = 11,
	ETHTOOL_MSG_FEATURES_SET_REPLY = 12,
	ETHTOOL_MSG_FEATURES_NTF = 13,
	ETHTOOL_MSG_PRIVFLAGS_GET_REPLY = 14,
	ETHTOOL_MSG_PRIVFLAGS_NTF = 15,
	ETHTOOL_MSG_RINGS_GET_REPLY = 16,
	ETHTOOL_MSG_RINGS_NTF = 17,
	ETHTOOL_MSG_CHANNELS_GET_REPLY = 18,
	ETHTOOL_MSG_CHANNELS_NTF = 19,
	ETHTOOL_MSG_COALESCE_GET_REPLY = 20,
	ETHTOOL_MSG_COALESCE_NTF = 21,
	ETHTOOL_MSG_PAUSE_GET_REPLY = 22,
	ETHTOOL_MSG_PAUSE_NTF = 23,
	ETHTOOL_MSG_EEE_GET_REPLY = 24,
	ETHTOOL_MSG_EEE_NTF = 25,
	ETHTOOL_MSG_TSINFO_GET_REPLY = 26,
	ETHTOOL_MSG_CABLE_TEST_NTF = 27,
	ETHTOOL_MSG_CABLE_TEST_TDR_NTF = 28,
	ETHTOOL_MSG_TUNNEL_INFO_GET_REPLY = 29,
	__ETHTOOL_MSG_KERNEL_CNT = 30,
	ETHTOOL_MSG_KERNEL_MAX = 29,
};

struct ethtool_phy_ops {
	int (*get_sset_count)(struct phy_device *);
	int (*get_strings)(struct phy_device *, u8 *);
	int (*get_stats)(struct phy_device *, struct ethtool_stats *, u64 *);
	int (*start_cable_test)(struct phy_device *, struct netlink_ext_ack *);
	int (*start_cable_test_tdr)(struct phy_device *, struct netlink_ext_ack *, const struct phy_tdr_config *);
};

struct phy_fixup {
	struct list_head list;
	char bus_id[64];
	u32 phy_uid;
	u32 phy_uid_mask;
	int (*run)(struct phy_device *);
};

struct trace_event_raw_mdio_access {
	struct trace_entry ent;
	char busid[61];
	char read;
	u8 addr;
	u16 val;
	unsigned int regnum;
	char __data[0];
};

struct trace_event_data_offsets_mdio_access {};

typedef void (*btf_trace_mdio_access)(void *, struct mii_bus *, char, u8, unsigned int, u16, int);

struct mdio_bus_stat_attr {
	int addr;
	unsigned int field_offset;
};

struct mdio_driver {
	struct mdio_driver_common mdiodrv;
	int (*probe)(struct mdio_device *);
	void (*remove)(struct mdio_device *);
	void (*shutdown)(struct mdio_device *);
};

struct swmii_regs {
	u16 bmsr;
	u16 lpa;
	u16 lpagb;
	u16 estat;
};

enum {
	SWMII_SPEED_10 = 0,
	SWMII_SPEED_100 = 1,
	SWMII_SPEED_1000 = 2,
	SWMII_DUPLEX_HALF = 0,
	SWMII_DUPLEX_FULL = 1,
};

struct fixed_mdio_bus {
	struct mii_bus *mii_bus;
	struct list_head phys;
};

struct fixed_phy {
	int addr;
	struct phy_device *phydev;
	struct fixed_phy_status status;
	bool no_carrier;
	int (*link_update)(struct net_device *, struct fixed_phy_status *);
	struct list_head node;
	struct gpio_desc *link_gpiod;
};

enum phy_tunable_id {
	ETHTOOL_PHY_ID_UNSPEC = 0,
	ETHTOOL_PHY_DOWNSHIFT = 1,
	ETHTOOL_PHY_FAST_LINK_DOWN = 2,
	ETHTOOL_PHY_EDPD = 3,
	__ETHTOOL_PHY_TUNABLE_COUNT = 4,
};

struct mdio_device_id {
	__u32 phy_id;
	__u32 phy_id_mask;
};

enum rgmii_clock_delay {
	RGMII_CLK_DELAY_0_2_NS = 0,
	RGMII_CLK_DELAY_0_8_NS = 1,
	RGMII_CLK_DELAY_1_1_NS = 2,
	RGMII_CLK_DELAY_1_7_NS = 3,
	RGMII_CLK_DELAY_2_0_NS = 4,
	RGMII_CLK_DELAY_2_3_NS = 5,
	RGMII_CLK_DELAY_2_6_NS = 6,
	RGMII_CLK_DELAY_3_4_NS = 7,
};

struct reg_val {
	u16 reg;
	u32 val;
};

struct vsc85xx_hw_stat {
	const char *string;
	u8 reg;
	u16 page;
	u16 mask;
};

struct vsc85xx_ptp;

struct vsc8531_private {
	int rate_magic;
	u16 supp_led_modes;
	u32 leds_mode[4];
	u8 nleds;
	const struct vsc85xx_hw_stat *hw_stats;
	u64 *stats;
	int nstats;
	u8 addr;
	unsigned int base_addr;
	struct mii_timestamper mii_ts;
	bool input_clk_init;
	struct vsc85xx_ptp *ptp;
	struct gpio_desc *load_save;
	unsigned int ts_base_addr;
	u8 ts_base_phy;
	struct mutex ts_lock;
	struct mutex phc_lock;
};

struct vsc8531_edge_rate_table {
	u32 vddmac;
	u32 slowdown[8];
};

enum csr_target {
	MACRO_CTRL = 7,
};

struct mdio_xpcs_args {
	long unsigned int supported[2];
	struct mii_bus *bus;
	int addr;
};

struct mdio_xpcs_ops {
	int (*validate)(struct mdio_xpcs_args *, long unsigned int *, struct phylink_link_state *);
	int (*config)(struct mdio_xpcs_args *, const struct phylink_link_state *);
	int (*get_state)(struct mdio_xpcs_args *, struct phylink_link_state *);
	int (*link_up)(struct mdio_xpcs_args *, int, phy_interface_t);
	int (*probe)(struct mdio_xpcs_args *, phy_interface_t);
};

struct xpcs_id {
	u32 id;
	u32 mask;
	const int *supported;
	const phy_interface_t *interface;
};

struct flow_dissector_key_control {
	u16 thoff;
	u16 addr_type;
	u32 flags;
};

struct flow_dissector_key_basic {
	__be16 n_proto;
	u8 ip_proto;
	u8 padding;
};

struct flow_dissector {
	unsigned int used_keys;
	short unsigned int offset[28];
};

struct flow_keys_basic {
	struct flow_dissector_key_control control;
	struct flow_dissector_key_basic basic;
};

struct mmpin {
	struct user_struct *user;
	unsigned int num_pg;
};

struct ubuf_info {
	void (*callback)(struct ubuf_info *, bool);
	union {
		struct {
			long unsigned int desc;
			void *ctx;
		};
		struct {
			u32 id;
			u16 len;
			u16 zerocopy: 1;
			u32 bytelen;
		};
	};
	refcount_t refcnt;
	struct mmpin mmp;
};

enum {
	SKB_GSO_TCPV4 = 1,
	SKB_GSO_DODGY = 2,
	SKB_GSO_TCP_ECN = 4,
	SKB_GSO_TCP_FIXEDID = 8,
	SKB_GSO_TCPV6 = 16,
	SKB_GSO_FCOE = 32,
	SKB_GSO_GRE = 64,
	SKB_GSO_GRE_CSUM = 128,
	SKB_GSO_IPXIP4 = 256,
	SKB_GSO_IPXIP6 = 512,
	SKB_GSO_UDP_TUNNEL = 1024,
	SKB_GSO_UDP_TUNNEL_CSUM = 2048,
	SKB_GSO_PARTIAL = 4096,
	SKB_GSO_TUNNEL_REMCSUM = 8192,
	SKB_GSO_SCTP = 16384,
	SKB_GSO_ESP = 32768,
	SKB_GSO_UDP = 65536,
	SKB_GSO_UDP_L4 = 131072,
	SKB_GSO_FRAGLIST = 262144,
};

struct rt6key {
	struct in6_addr addr;
	int plen;
};

struct rtable;

struct fnhe_hash_bucket;

struct fib_nh_common {
	struct net_device *nhc_dev;
	int nhc_oif;
	unsigned char nhc_scope;
	u8 nhc_family;
	u8 nhc_gw_family;
	unsigned char nhc_flags;
	struct lwtunnel_state *nhc_lwtstate;
	union {
		__be32 ipv4;
		struct in6_addr ipv6;
	} nhc_gw;
	int nhc_weight;
	atomic_t nhc_upper_bound;
	struct rtable **nhc_pcpu_rth_output;
	struct rtable *nhc_rth_input;
	struct fnhe_hash_bucket *nhc_exceptions;
};

struct rt6_exception_bucket;

struct fib6_nh {
	struct fib_nh_common nh_common;
	struct rt6_info **rt6i_pcpu;
	struct rt6_exception_bucket *rt6i_exception_bucket;
};

struct fib6_node;

struct dst_metrics;

struct nexthop;

struct fib6_info {
	struct fib6_table *fib6_table;
	struct fib6_info *fib6_next;
	struct fib6_node *fib6_node;
	union {
		struct list_head fib6_siblings;
		struct list_head nh_list;
	};
	unsigned int fib6_nsiblings;
	refcount_t fib6_ref;
	long unsigned int expires;
	struct dst_metrics *fib6_metrics;
	struct rt6key fib6_dst;
	u32 fib6_flags;
	struct rt6key fib6_src;
	struct rt6key fib6_prefsrc;
	u32 fib6_metric;
	u8 fib6_protocol;
	u8 fib6_type;
	u8 should_flush: 1;
	u8 dst_nocount: 1;
	u8 dst_nopolicy: 1;
	u8 fib6_destroying: 1;
	u8 offload: 1;
	u8 trap: 1;
	u8 unused: 2;
	struct callback_head rcu;
	struct nexthop *nh;
	struct fib6_nh fib6_nh[0];
};

struct uncached_list;

struct rt6_info {
	struct dst_entry dst;
	struct fib6_info *from;
	int sernum;
	struct rt6key rt6i_dst;
	struct rt6key rt6i_src;
	struct in6_addr rt6i_gateway;
	struct inet6_dev *rt6i_idev;
	u32 rt6i_flags;
	struct list_head rt6i_uncached;
	struct uncached_list *rt6i_uncached_list;
	short unsigned int rt6i_nfheader_len;
};

struct rt6_statistics {
	__u32 fib_nodes;
	__u32 fib_route_nodes;
	__u32 fib_rt_entries;
	__u32 fib_rt_cache;
	__u32 fib_discarded_routes;
	atomic_t fib_rt_alloc;
	atomic_t fib_rt_uncache;
};

struct fib6_node {
	struct fib6_node *parent;
	struct fib6_node *left;
	struct fib6_node *right;
	struct fib6_info *leaf;
	__u16 fn_bit;
	__u16 fn_flags;
	int fn_sernum;
	struct fib6_info *rr_ptr;
	struct callback_head rcu;
};

struct fib6_table {
	struct hlist_node tb6_hlist;
	u32 tb6_id;
	spinlock_t tb6_lock;
	struct fib6_node tb6_root;
	struct inet_peer_base tb6_peers;
	unsigned int flags;
	unsigned int fib_seq;
};

enum {
	IFLA_TUN_UNSPEC = 0,
	IFLA_TUN_OWNER = 1,
	IFLA_TUN_GROUP = 2,
	IFLA_TUN_TYPE = 3,
	IFLA_TUN_PI = 4,
	IFLA_TUN_VNET_HDR = 5,
	IFLA_TUN_PERSIST = 6,
	IFLA_TUN_MULTI_QUEUE = 7,
	IFLA_TUN_NUM_QUEUES = 8,
	IFLA_TUN_NUM_DISABLED_QUEUES = 9,
	__IFLA_TUN_MAX = 10,
};

struct gro_list {
	struct list_head list;
	int count;
};

struct napi_struct {
	struct list_head poll_list;
	long unsigned int state;
	int weight;
	int defer_hard_irqs_count;
	long unsigned int gro_bitmask;
	int (*poll)(struct napi_struct *, int);
	struct net_device *dev;
	struct gro_list gro_hash[8];
	struct sk_buff *skb;
	struct list_head rx_list;
	int rx_count;
	struct hrtimer timer;
	struct list_head dev_list;
	struct hlist_node napi_hash_node;
	unsigned int napi_id;
};

enum netdev_queue_state_t {
	__QUEUE_STATE_DRV_XOFF = 0,
	__QUEUE_STATE_STACK_XOFF = 1,
	__QUEUE_STATE_FROZEN = 2,
};

struct rps_sock_flow_table {
	u32 mask;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	u32 ents[0];
};

struct iphdr {
	__u8 ihl: 4;
	__u8 version: 4;
	__u8 tos;
	__be16 tot_len;
	__be16 id;
	__be16 frag_off;
	__u8 ttl;
	__u8 protocol;
	__sum16 check;
	__be32 saddr;
	__be32 daddr;
};

struct ip_tunnel_parm {
	char name[16];
	int link;
	__be16 i_flags;
	__be16 o_flags;
	__be32 i_key;
	__be32 o_key;
	struct iphdr iph;
};

struct wpan_phy;

struct wpan_dev_header_ops;

struct wpan_dev {
	struct wpan_phy *wpan_phy;
	int iftype;
	struct list_head list;
	struct net_device *netdev;
	const struct wpan_dev_header_ops *header_ops;
	struct net_device *lowpan_dev;
	u32 identifier;
	__le16 pan_id;
	__le16 short_addr;
	__le64 extended_addr;
	atomic_t bsn;
	atomic_t dsn;
	u8 min_be;
	u8 max_be;
	u8 csma_retries;
	s8 frame_retries;
	bool lbt;
	bool promiscuous_mode;
	bool ackreq;
};

struct qdisc_skb_cb {
	struct {
		unsigned int pkt_len;
		u16 slave_dev_queue_mapping;
		u16 tc_classid;
	};
	unsigned char data[20];
	u16 mru;
};

struct tun_pi {
	__u16 flags;
	__be16 proto;
};

struct tun_filter {
	__u16 flags;
	__u16 count;
	__u8 addr[0];
};

struct virtio_net_hdr {
	__u8 flags;
	__u8 gso_type;
	__virtio16 hdr_len;
	__virtio16 gso_size;
	__virtio16 csum_start;
	__virtio16 csum_offset;
};

struct tun_msg_ctl {
	short unsigned int type;
	short unsigned int num;
	void *ptr;
};

struct tun_xdp_hdr {
	int buflen;
	struct virtio_net_hdr gso;
};

struct dst_metrics {
	u32 metrics[17];
	refcount_t refcnt;
};

struct fib_nh_exception {
	struct fib_nh_exception *fnhe_next;
	int fnhe_genid;
	__be32 fnhe_daddr;
	u32 fnhe_pmtu;
	bool fnhe_mtu_locked;
	__be32 fnhe_gw;
	long unsigned int fnhe_expires;
	struct rtable *fnhe_rth_input;
	struct rtable *fnhe_rth_output;
	long unsigned int fnhe_stamp;
	struct callback_head rcu;
};

struct rtable {
	struct dst_entry dst;
	int rt_genid;
	unsigned int rt_flags;
	__u16 rt_type;
	__u8 rt_is_input;
	__u8 rt_uses_gateway;
	int rt_iif;
	u8 rt_gw_family;
	union {
		__be32 rt_gw4;
		struct in6_addr rt_gw6;
	};
	u32 rt_mtu_locked: 1;
	u32 rt_pmtu: 31;
	struct list_head rt_uncached;
	struct uncached_list *rt_uncached_list;
};

struct fnhe_hash_bucket {
	struct fib_nh_exception *chain;
};

struct fib_info;

struct fib_nh {
	struct fib_nh_common nh_common;
	struct hlist_node nh_hash;
	struct fib_info *nh_parent;
	__be32 nh_saddr;
	int nh_saddr_genid;
};

struct fib_info {
	struct hlist_node fib_hash;
	struct hlist_node fib_lhash;
	struct list_head nh_list;
	struct net *fib_net;
	int fib_treeref;
	refcount_t fib_clntref;
	unsigned int fib_flags;
	unsigned char fib_dead;
	unsigned char fib_protocol;
	unsigned char fib_scope;
	unsigned char fib_type;
	__be32 fib_prefsrc;
	u32 fib_tb_id;
	u32 fib_priority;
	struct dst_metrics *fib_metrics;
	int fib_nhs;
	bool fib_nh_is_v6;
	bool nh_updated;
	struct nexthop *nh;
	struct callback_head rcu;
	struct fib_nh fib_nh[0];
};

struct nh_info;

struct nh_group;

struct nexthop {
	struct rb_node rb_node;
	struct list_head fi_list;
	struct list_head f6i_list;
	struct list_head fdb_list;
	struct list_head grp_list;
	struct net *net;
	u32 id;
	u8 protocol;
	u8 nh_flags;
	bool is_group;
	refcount_t refcnt;
	struct callback_head rcu;
	union {
		struct nh_info *nh_info;
		struct nh_group *nh_grp;
	};
};

struct rt6_exception_bucket {
	struct hlist_head chain;
	int depth;
};

struct nh_info {
	struct hlist_node dev_hash;
	struct nexthop *nh_parent;
	u8 family;
	bool reject_nh;
	bool fdb_nh;
	union {
		struct fib_nh_common fib_nhc;
		struct fib_nh fib_nh;
		struct fib6_nh fib6_nh;
	};
};

struct nh_grp_entry {
	struct nexthop *nh;
	u8 weight;
	atomic_t upper_bound;
	struct list_head nh_list;
	struct nexthop *nh_parent;
};

struct nh_group {
	struct nh_group *spare;
	u16 num_nh;
	bool mpath;
	bool fdb_nh;
	bool has_v4;
	struct nh_grp_entry nh_entries[0];
};

enum {
	AX25_VALUES_IPDEFMODE = 0,
	AX25_VALUES_AXDEFMODE = 1,
	AX25_VALUES_BACKOFF = 2,
	AX25_VALUES_CONMODE = 3,
	AX25_VALUES_WINDOW = 4,
	AX25_VALUES_EWINDOW = 5,
	AX25_VALUES_T1 = 6,
	AX25_VALUES_T2 = 7,
	AX25_VALUES_T3 = 8,
	AX25_VALUES_IDLE = 9,
	AX25_VALUES_N2 = 10,
	AX25_VALUES_PACLEN = 11,
	AX25_VALUES_PROTOCOL = 12,
	AX25_VALUES_DS_TIMEOUT = 13,
	AX25_MAX_VALUES = 14,
};

enum nl802154_cca_modes {
	__NL802154_CCA_INVALID = 0,
	NL802154_CCA_ENERGY = 1,
	NL802154_CCA_CARRIER = 2,
	NL802154_CCA_ENERGY_CARRIER = 3,
	NL802154_CCA_ALOHA = 4,
	NL802154_CCA_UWB_SHR = 5,
	NL802154_CCA_UWB_MULTIPLEXED = 6,
	__NL802154_CCA_ATTR_AFTER_LAST = 7,
	NL802154_CCA_ATTR_MAX = 6,
};

enum nl802154_cca_opts {
	NL802154_CCA_OPT_ENERGY_CARRIER_AND = 0,
	NL802154_CCA_OPT_ENERGY_CARRIER_OR = 1,
	__NL802154_CCA_OPT_ATTR_AFTER_LAST = 2,
	NL802154_CCA_OPT_ATTR_MAX = 1,
};

enum nl802154_supported_bool_states {
	NL802154_SUPPORTED_BOOL_FALSE = 0,
	NL802154_SUPPORTED_BOOL_TRUE = 1,
	__NL802154_SUPPORTED_BOOL_INVALD = 2,
	NL802154_SUPPORTED_BOOL_BOTH = 3,
	__NL802154_SUPPORTED_BOOL_AFTER_LAST = 4,
	NL802154_SUPPORTED_BOOL_MAX = 3,
};

struct wpan_phy_supported {
	u32 channels[32];
	u32 cca_modes;
	u32 cca_opts;
	u32 iftypes;
	enum nl802154_supported_bool_states lbt;
	u8 min_minbe;
	u8 max_minbe;
	u8 min_maxbe;
	u8 max_maxbe;
	u8 min_csma_backoffs;
	u8 max_csma_backoffs;
	s8 min_frame_retries;
	s8 max_frame_retries;
	size_t tx_powers_size;
	size_t cca_ed_levels_size;
	const s32 *tx_powers;
	const s32 *cca_ed_levels;
};

struct wpan_phy_cca {
	enum nl802154_cca_modes mode;
	enum nl802154_cca_opts opt;
};

struct wpan_phy {
	const void *privid;
	u32 flags;
	u8 current_channel;
	u8 current_page;
	struct wpan_phy_supported supported;
	s32 transmit_power;
	struct wpan_phy_cca cca;
	__le64 perm_extended_addr;
	s32 cca_ed_level;
	u8 symbol_duration;
	u16 lifs_period;
	u16 sifs_period;
	struct device dev;
	possible_net_t _net;
	char priv[0];
};

struct ieee802154_addr {
	u8 mode;
	__le16 pan_id;
	union {
		__le16 short_addr;
		__le64 extended_addr;
	};
};

struct wpan_dev_header_ops {
	int (*create)(struct sk_buff *, struct net_device *, const struct ieee802154_addr *, const struct ieee802154_addr *, unsigned int);
};

struct tap_filter {
	unsigned int count;
	u32 mask[2];
	unsigned char addr[48];
};

struct tun_pcpu_stats {
	u64_stats_t rx_packets;
	u64_stats_t rx_bytes;
	u64_stats_t tx_packets;
	u64_stats_t tx_bytes;
	struct u64_stats_sync syncp;
	u32 rx_dropped;
	u32 tx_dropped;
	u32 rx_frame_errors;
};

struct tun_struct;

struct tun_file {
	struct sock sk;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct socket socket;
	struct tun_struct *tun;
	struct fasync_struct *fasync;
	unsigned int flags;
	union {
		u16 queue_index;
		unsigned int ifindex;
	};
	struct napi_struct napi;
	bool napi_enabled;
	bool napi_frags_enabled;
	struct mutex napi_mutex;
	struct list_head next;
	struct tun_struct *detached;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct ptr_ring tx_ring;
	struct xdp_rxq_info xdp_rxq;
};

struct tun_prog;

struct tun_struct {
	struct tun_file *tfiles[256];
	unsigned int numqueues;
	unsigned int flags;
	kuid_t owner;
	kgid_t group;
	struct net_device *dev;
	netdev_features_t set_features;
	int align;
	int vnet_hdr_sz;
	int sndbuf;
	struct tap_filter txflt;
	struct sock_fprog fprog;
	bool filter_attached;
	u32 msg_enable;
	spinlock_t lock;
	struct hlist_head flows[1024];
	struct timer_list flow_gc_timer;
	long unsigned int ageing_time;
	unsigned int numdisabled;
	struct list_head disabled;
	void *security;
	u32 flow_count;
	u32 rx_batched;
	struct tun_pcpu_stats *pcpu_stats;
	struct bpf_prog *xdp_prog;
	struct tun_prog *steering_prog;
	struct tun_prog *filter_prog;
	struct ethtool_link_ksettings link_ksettings;
};

struct tun_page {
	struct page *page;
	int count;
};

struct tun_flow_entry {
	struct hlist_node hash_link;
	struct callback_head rcu;
	struct tun_struct *tun;
	u32 rxhash;
	u32 rps_rxhash;
	int queue_index;
	long: 32;
	long: 64;
	long unsigned int updated;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct tun_prog {
	struct callback_head rcu;
	struct bpf_prog *prog;
};

struct veth {
	__be16 h_vlan_proto;
	__be16 h_vlan_TCI;
};

enum ethtool_stringset {
	ETH_SS_TEST = 0,
	ETH_SS_STATS = 1,
	ETH_SS_PRIV_FLAGS = 2,
	ETH_SS_NTUPLE_FILTERS = 3,
	ETH_SS_FEATURES = 4,
	ETH_SS_RSS_HASH_FUNCS = 5,
	ETH_SS_TUNABLES = 6,
	ETH_SS_PHY_STATS = 7,
	ETH_SS_PHY_TUNABLES = 8,
	ETH_SS_LINK_MODES = 9,
	ETH_SS_MSG_CLASSES = 10,
	ETH_SS_WOL_MODES = 11,
	ETH_SS_SOF_TIMESTAMPING = 12,
	ETH_SS_TS_TX_TYPES = 13,
	ETH_SS_TS_RX_FILTERS = 14,
	ETH_SS_UDP_TUNNEL_TYPES = 15,
	ETH_SS_COUNT = 16,
};

struct netdev_hw_addr {
	struct list_head list;
	unsigned char addr[32];
	unsigned char type;
	bool global_use;
	int sync_cnt;
	int refcount;
	int synced;
	struct callback_head callback_head;
};

struct rx_queue_attribute {
	struct attribute attr;
	ssize_t (*show)(struct netdev_rx_queue *, char *);
	ssize_t (*store)(struct netdev_rx_queue *, const char *, size_t);
};

struct sd_flow_limit {
	u64 count;
	unsigned int num_buckets;
	unsigned int history_head;
	u16 history[128];
	u8 buckets[0];
};

struct softnet_data {
	struct list_head poll_list;
	struct sk_buff_head process_queue;
	unsigned int processed;
	unsigned int time_squeeze;
	unsigned int received_rps;
	struct softnet_data *rps_ipi_list;
	struct sd_flow_limit *flow_limit;
	struct Qdisc *output_queue;
	struct Qdisc **output_queue_tailp;
	struct sk_buff *completion_queue;
	struct {
		u16 recursion;
		u8 more;
	} xmit;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	unsigned int input_queue_head;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	call_single_data_t csd;
	struct softnet_data *rps_ipi_next;
	unsigned int cpu;
	unsigned int input_queue_tail;
	unsigned int dropped;
	struct sk_buff_head input_pkt_queue;
	struct napi_struct backlog;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

enum skb_free_reason {
	SKB_REASON_CONSUMED = 0,
	SKB_REASON_DROPPED = 1,
};

struct virtio_net_config {
	__u8 mac[6];
	__virtio16 status;
	__virtio16 max_virtqueue_pairs;
	__virtio16 mtu;
	__le32 speed;
	__u8 duplex;
	__u8 rss_max_key_size;
	__le16 rss_max_indirection_table_length;
	__le32 supported_hash_types;
};

struct virtio_net_hdr_mrg_rxbuf {
	struct virtio_net_hdr hdr;
	__virtio16 num_buffers;
};

struct virtio_net_ctrl_hdr {
	__u8 class;
	__u8 cmd;
};

typedef __u8 virtio_net_ctrl_ack;

struct virtio_net_ctrl_mac {
	__virtio32 entries;
	__u8 macs[0];
};

struct virtio_net_ctrl_mq {
	__virtio16 virtqueue_pairs;
};

struct failover_ops {
	int (*slave_pre_register)(struct net_device *, struct net_device *);
	int (*slave_register)(struct net_device *, struct net_device *);
	int (*slave_pre_unregister)(struct net_device *, struct net_device *);
	int (*slave_unregister)(struct net_device *, struct net_device *);
	int (*slave_link_change)(struct net_device *, struct net_device *);
	int (*slave_name_change)(struct net_device *, struct net_device *);
	rx_handler_result_t (*slave_handle_frame)(struct sk_buff **);
};

struct failover {
	struct list_head list;
	struct net_device *failover_dev;
	struct failover_ops *ops;
};

struct ewma_pkt_len {
	long unsigned int internal;
};

struct virtnet_stat_desc {
	char desc[32];
	size_t offset;
};

struct virtnet_sq_stats {
	struct u64_stats_sync syncp;
	u64 packets;
	u64 bytes;
	u64 xdp_tx;
	u64 xdp_tx_drops;
	u64 kicks;
};

struct virtnet_rq_stats {
	struct u64_stats_sync syncp;
	u64 packets;
	u64 bytes;
	u64 drops;
	u64 xdp_packets;
	u64 xdp_tx;
	u64 xdp_redirects;
	u64 xdp_drops;
	u64 kicks;
};

struct send_queue {
	struct virtqueue *vq;
	struct scatterlist sg[19];
	char name[40];
	struct virtnet_sq_stats stats;
	struct napi_struct napi;
};

struct receive_queue {
	struct virtqueue *vq;
	struct napi_struct napi;
	struct bpf_prog *xdp_prog;
	struct virtnet_rq_stats stats;
	struct page *pages;
	struct ewma_pkt_len mrg_avg_pkt_len;
	struct page_frag alloc_frag;
	struct scatterlist sg[19];
	unsigned int min_buf_len;
	char name[40];
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	struct xdp_rxq_info xdp_rxq;
};

struct control_buf {
	struct virtio_net_ctrl_hdr hdr;
	virtio_net_ctrl_ack status;
	struct virtio_net_ctrl_mq mq;
	u8 promisc;
	u8 allmulti;
	__virtio16 vid;
	__virtio64 offloads;
};

struct virtnet_info {
	struct virtio_device *vdev;
	struct virtqueue *cvq;
	struct net_device *dev;
	struct send_queue *sq;
	struct receive_queue *rq;
	unsigned int status;
	u16 max_queue_pairs;
	u16 curr_queue_pairs;
	u16 xdp_queue_pairs;
	bool xdp_enabled;
	bool big_packets;
	bool mergeable_rx_bufs;
	bool has_cvq;
	bool any_header_sg;
	u8 hdr_len;
	struct delayed_work refill;
	struct work_struct config_work;
	bool affinity_hint_set;
	struct hlist_node node;
	struct hlist_node node_dead;
	struct control_buf *ctrl;
	u8 duplex;
	u32 speed;
	long unsigned int guest_offloads;
	long unsigned int guest_offloads_capable;
	struct failover *failover;
};

struct hwtstamp_config {
	int flags;
	int tx_type;
	int rx_filter;
};

struct tcphdr {
	__be16 source;
	__be16 dest;
	__be32 seq;
	__be32 ack_seq;
	__u16 res1: 4;
	__u16 doff: 4;
	__u16 fin: 1;
	__u16 syn: 1;
	__u16 rst: 1;
	__u16 psh: 1;
	__u16 ack: 1;
	__u16 urg: 1;
	__u16 ece: 1;
	__u16 cwr: 1;
	__be16 window;
	__sum16 check;
	__be16 urg_ptr;
};

struct ptp_clock_time {
	__s64 sec;
	__u32 nsec;
	__u32 reserved;
};

struct ptp_extts_request {
	unsigned int index;
	unsigned int flags;
	unsigned int rsv[2];
};

struct ptp_perout_request {
	union {
		struct ptp_clock_time start;
		struct ptp_clock_time phase;
	};
	struct ptp_clock_time period;
	unsigned int index;
	unsigned int flags;
	union {
		struct ptp_clock_time on;
		unsigned int rsv[4];
	};
};

enum ptp_pin_function {
	PTP_PF_NONE = 0,
	PTP_PF_EXTTS = 1,
	PTP_PF_PEROUT = 2,
	PTP_PF_PHYSYNC = 3,
};

struct ptp_pin_desc {
	char name[64];
	unsigned int index;
	unsigned int func;
	unsigned int chan;
	unsigned int rsv[5];
};

struct ptp_clock_request {
	enum {
		PTP_CLK_REQ_EXTTS = 0,
		PTP_CLK_REQ_PEROUT = 1,
		PTP_CLK_REQ_PPS = 2,
	} type;
	union {
		struct ptp_extts_request extts;
		struct ptp_perout_request perout;
	};
};

struct ptp_clock_info {
	struct module *owner;
	char name[16];
	s32 max_adj;
	int n_alarm;
	int n_ext_ts;
	int n_per_out;
	int n_pins;
	int pps;
	struct ptp_pin_desc *pin_config;
	int (*adjfine)(struct ptp_clock_info *, long int);
	int (*adjfreq)(struct ptp_clock_info *, s32);
	int (*adjphase)(struct ptp_clock_info *, s32);
	int (*adjtime)(struct ptp_clock_info *, s64);
	int (*gettime64)(struct ptp_clock_info *, struct timespec64 *);
	int (*gettimex64)(struct ptp_clock_info *, struct timespec64 *, struct ptp_system_timestamp *);
	int (*getcrosststamp)(struct ptp_clock_info *, struct system_device_crosststamp *);
	int (*settime64)(struct ptp_clock_info *, const struct timespec64 *);
	int (*enable)(struct ptp_clock_info *, struct ptp_clock_request *, int);
	int (*verify)(struct ptp_clock_info *, unsigned int, enum ptp_pin_function, unsigned int);
	long int (*do_aux_work)(struct ptp_clock_info *);
};

struct macb_dma_desc {
	u32 addr;
	u32 ctrl;
};

struct macb_dma_desc_64 {
	u32 addrh;
	u32 resvd;
};

struct macb_tx_skb {
	struct sk_buff *skb;
	dma_addr_t mapping;
	size_t size;
	bool mapped_as_page;
};

struct macb_stats {
	u32 rx_pause_frames;
	u32 tx_ok;
	u32 tx_single_cols;
	u32 tx_multiple_cols;
	u32 rx_ok;
	u32 rx_fcs_errors;
	u32 rx_align_errors;
	u32 tx_deferred;
	u32 tx_late_cols;
	u32 tx_excessive_cols;
	u32 tx_underruns;
	u32 tx_carrier_errors;
	u32 rx_resource_errors;
	u32 rx_overruns;
	u32 rx_symbol_errors;
	u32 rx_oversize_pkts;
	u32 rx_jabbers;
	u32 rx_undersize_pkts;
	u32 sqe_test_errors;
	u32 rx_length_mismatch;
	u32 tx_pause_frames;
};

struct gem_stats {
	u32 tx_octets_31_0;
	u32 tx_octets_47_32;
	u32 tx_frames;
	u32 tx_broadcast_frames;
	u32 tx_multicast_frames;
	u32 tx_pause_frames;
	u32 tx_64_byte_frames;
	u32 tx_65_127_byte_frames;
	u32 tx_128_255_byte_frames;
	u32 tx_256_511_byte_frames;
	u32 tx_512_1023_byte_frames;
	u32 tx_1024_1518_byte_frames;
	u32 tx_greater_than_1518_byte_frames;
	u32 tx_underrun;
	u32 tx_single_collision_frames;
	u32 tx_multiple_collision_frames;
	u32 tx_excessive_collisions;
	u32 tx_late_collisions;
	u32 tx_deferred_frames;
	u32 tx_carrier_sense_errors;
	u32 rx_octets_31_0;
	u32 rx_octets_47_32;
	u32 rx_frames;
	u32 rx_broadcast_frames;
	u32 rx_multicast_frames;
	u32 rx_pause_frames;
	u32 rx_64_byte_frames;
	u32 rx_65_127_byte_frames;
	u32 rx_128_255_byte_frames;
	u32 rx_256_511_byte_frames;
	u32 rx_512_1023_byte_frames;
	u32 rx_1024_1518_byte_frames;
	u32 rx_greater_than_1518_byte_frames;
	u32 rx_undersized_frames;
	u32 rx_oversize_frames;
	u32 rx_jabbers;
	u32 rx_frame_check_sequence_errors;
	u32 rx_length_field_frame_errors;
	u32 rx_symbol_errors;
	u32 rx_alignment_errors;
	u32 rx_resource_errors;
	u32 rx_overruns;
	u32 rx_ip_header_checksum_errors;
	u32 rx_tcp_checksum_errors;
	u32 rx_udp_checksum_errors;
};

struct gem_statistic {
	char stat_string[32];
	int offset;
	u32 stat_bits;
};

struct queue_stats {
	union {
		long unsigned int first;
		long unsigned int rx_packets;
	};
	long unsigned int rx_bytes;
	long unsigned int rx_dropped;
	long unsigned int tx_packets;
	long unsigned int tx_bytes;
	long unsigned int tx_dropped;
};

struct macb;

struct macb_queue;

struct macb_or_gem_ops {
	int (*mog_alloc_rx_buffers)(struct macb *);
	void (*mog_free_rx_buffers)(struct macb *);
	void (*mog_init_rings)(struct macb *);
	int (*mog_rx)(struct macb_queue *, struct napi_struct *, int);
};

struct macb_queue {
	struct macb *bp;
	int irq;
	unsigned int ISR;
	unsigned int IER;
	unsigned int IDR;
	unsigned int IMR;
	unsigned int TBQP;
	unsigned int TBQPH;
	unsigned int RBQS;
	unsigned int RBQP;
	unsigned int RBQPH;
	unsigned int tx_head;
	unsigned int tx_tail;
	struct macb_dma_desc *tx_ring;
	struct macb_tx_skb *tx_skb;
	dma_addr_t tx_ring_dma;
	struct work_struct tx_error_task;
	dma_addr_t rx_ring_dma;
	dma_addr_t rx_buffers_dma;
	unsigned int rx_tail;
	unsigned int rx_prepared_head;
	struct macb_dma_desc *rx_ring;
	struct sk_buff **rx_skbuff;
	void *rx_buffers;
	struct napi_struct napi;
	struct queue_stats stats;
};

struct ptp_clock;

struct tsu_incr {
	u32 sub_ns;
	u32 ns;
};

struct ethtool_rx_fs_list {
	struct list_head list;
	unsigned int count;
};

struct macb_pm_data {
	u32 scrt2;
	u32 usrio;
};

struct macb_ptp_info;

struct macb {
	void *regs;
	bool native_io;
	u32 (*macb_reg_readl)(struct macb *, int);
	void (*macb_reg_writel)(struct macb *, int, u32);
	size_t rx_buffer_size;
	unsigned int rx_ring_size;
	unsigned int tx_ring_size;
	unsigned int num_queues;
	unsigned int queue_mask;
	struct macb_queue queues[8];
	spinlock_t lock;
	struct platform_device *pdev;
	struct clk *pclk;
	struct clk *hclk;
	struct clk *tx_clk;
	struct clk *rx_clk;
	struct clk *tsu_clk;
	struct net_device *dev;
	union {
		struct macb_stats macb;
		struct gem_stats gem;
	} hw_stats;
	struct macb_or_gem_ops macbgem_ops;
	struct mii_bus *mii_bus;
	struct phylink *phylink;
	struct phylink_config phylink_config;
	u32 caps;
	unsigned int dma_burst_length;
	phy_interface_t phy_interface;
	struct macb_tx_skb rm9200_txq[2];
	unsigned int rm9200_tx_tail;
	unsigned int rm9200_tx_len;
	unsigned int max_tx_length;
	u64 ethtool_stats[91];
	unsigned int rx_frm_len_mask;
	unsigned int jumbo_max_len;
	u32 wol;
	struct macb_ptp_info *ptp_info;
	uint8_t hw_dma_cap;
	spinlock_t tsu_clk_lock;
	unsigned int tsu_rate;
	struct ptp_clock *ptp_clock;
	struct ptp_clock_info ptp_clock_info;
	struct tsu_incr tsu_incr;
	struct hwtstamp_config tstamp_config;
	struct ethtool_rx_fs_list rx_fs_list;
	spinlock_t rx_fs_lock;
	unsigned int max_tuples;
	struct tasklet_struct hresp_err_tasklet;
	int rx_bd_rd_prefetch;
	int tx_bd_rd_prefetch;
	u32 rx_intr_mask;
	struct macb_pm_data pm_data;
};

struct macb_ptp_info {
	void (*ptp_init)(struct net_device *);
	void (*ptp_remove)(struct net_device *);
	s32 (*get_ptp_max_adj)();
	unsigned int (*get_tsu_rate)(struct macb *);
	int (*get_ts_info)(struct net_device *, struct ethtool_ts_info *);
	int (*get_hwtst)(struct net_device *, struct ifreq *);
	int (*set_hwtst)(struct net_device *, struct ifreq *, int);
};

struct macb_config {
	u32 caps;
	unsigned int dma_burst_length;
	int (*clk_init)(struct platform_device *, struct clk **, struct clk **, struct clk **, struct clk **, struct clk **);
	int (*init)(struct platform_device *);
	int jumbo_max_len;
};

struct ethtool_rx_fs_item {
	struct ethtool_rx_flow_spec fs;
	struct list_head list;
};

struct macb_platform_data {
	struct clk *pclk;
	struct clk *hclk;
};

struct sifive_fu540_macb_mgmt {
	void *reg;
	long unsigned int rate;
	struct clk_hw hw;
};

enum pkt_hash_types {
	PKT_HASH_TYPE_NONE = 0,
	PKT_HASH_TYPE_L2 = 1,
	PKT_HASH_TYPE_L3 = 2,
	PKT_HASH_TYPE_L4 = 3,
};

struct flow_match {
	struct flow_dissector *dissector;
	void *mask;
	void *key;
};

enum flow_action_id {
	FLOW_ACTION_ACCEPT = 0,
	FLOW_ACTION_DROP = 1,
	FLOW_ACTION_TRAP = 2,
	FLOW_ACTION_GOTO = 3,
	FLOW_ACTION_REDIRECT = 4,
	FLOW_ACTION_MIRRED = 5,
	FLOW_ACTION_REDIRECT_INGRESS = 6,
	FLOW_ACTION_MIRRED_INGRESS = 7,
	FLOW_ACTION_VLAN_PUSH = 8,
	FLOW_ACTION_VLAN_POP = 9,
	FLOW_ACTION_VLAN_MANGLE = 10,
	FLOW_ACTION_TUNNEL_ENCAP = 11,
	FLOW_ACTION_TUNNEL_DECAP = 12,
	FLOW_ACTION_MANGLE = 13,
	FLOW_ACTION_ADD = 14,
	FLOW_ACTION_CSUM = 15,
	FLOW_ACTION_MARK = 16,
	FLOW_ACTION_PTYPE = 17,
	FLOW_ACTION_PRIORITY = 18,
	FLOW_ACTION_WAKE = 19,
	FLOW_ACTION_QUEUE = 20,
	FLOW_ACTION_SAMPLE = 21,
	FLOW_ACTION_POLICE = 22,
	FLOW_ACTION_CT = 23,
	FLOW_ACTION_CT_METADATA = 24,
	FLOW_ACTION_MPLS_PUSH = 25,
	FLOW_ACTION_MPLS_POP = 26,
	FLOW_ACTION_MPLS_MANGLE = 27,
	FLOW_ACTION_GATE = 28,
	NUM_FLOW_ACTIONS = 29,
};

enum flow_action_hw_stats {
	FLOW_ACTION_HW_STATS_IMMEDIATE = 1,
	FLOW_ACTION_HW_STATS_DELAYED = 2,
	FLOW_ACTION_HW_STATS_ANY = 3,
	FLOW_ACTION_HW_STATS_DISABLED = 4,
	FLOW_ACTION_HW_STATS_DONT_CARE = 7,
};

typedef void (*action_destr)(void *);

enum flow_action_mangle_base {
	FLOW_ACT_MANGLE_UNSPEC = 0,
	FLOW_ACT_MANGLE_HDR_TYPE_ETH = 1,
	FLOW_ACT_MANGLE_HDR_TYPE_IP4 = 2,
	FLOW_ACT_MANGLE_HDR_TYPE_IP6 = 3,
	FLOW_ACT_MANGLE_HDR_TYPE_TCP = 4,
	FLOW_ACT_MANGLE_HDR_TYPE_UDP = 5,
};

struct ip_tunnel_info;

struct psample_group;

struct nf_flowtable;

struct action_gate_entry;

struct flow_action_cookie;

struct flow_action_entry {
	enum flow_action_id id;
	enum flow_action_hw_stats hw_stats;
	action_destr destructor;
	void *destructor_priv;
	union {
		u32 chain_index;
		struct net_device *dev;
		struct {
			u16 vid;
			__be16 proto;
			u8 prio;
		} vlan;
		struct {
			enum flow_action_mangle_base htype;
			u32 offset;
			u32 mask;
			u32 val;
		} mangle;
		struct ip_tunnel_info *tunnel;
		u32 csum_flags;
		u32 mark;
		u16 ptype;
		u32 priority;
		struct {
			u32 ctx;
			u32 index;
			u8 vf;
		} queue;
		struct {
			struct psample_group *psample_group;
			u32 rate;
			u32 trunc_size;
			bool truncate;
		} sample;
		struct {
			u32 index;
			u32 burst;
			u64 rate_bytes_ps;
			u32 mtu;
		} police;
		struct {
			int action;
			u16 zone;
			struct nf_flowtable *flow_table;
		} ct;
		struct {
			long unsigned int cookie;
			u32 mark;
			u32 labels[4];
		} ct_metadata;
		struct {
			u32 label;
			__be16 proto;
			u8 tc;
			u8 bos;
			u8 ttl;
		} mpls_push;
		struct {
			__be16 proto;
		} mpls_pop;
		struct {
			u32 label;
			u8 tc;
			u8 bos;
			u8 ttl;
		} mpls_mangle;
		struct {
			u32 index;
			s32 prio;
			u64 basetime;
			u64 cycletime;
			u64 cycletimeext;
			u32 num_entries;
			struct action_gate_entry *entries;
		} gate;
	};
	struct flow_action_cookie *cookie;
};

struct flow_action {
	unsigned int num_entries;
	struct flow_action_entry entries[0];
};

struct flow_rule {
	struct flow_match match;
	struct flow_action action;
};

struct tc_u32_key {
	__be32 mask;
	__be32 val;
	int off;
	int offmask;
};

struct tc_u32_sel {
	unsigned char flags;
	unsigned char offshift;
	unsigned char nkeys;
	__be16 offmask;
	__u16 off;
	short int offoff;
	short int hoff;
	__be32 hmask;
	struct tc_u32_key keys[0];
};

struct vlan_ethhdr {
	unsigned char h_dest[6];
	unsigned char h_source[6];
	__be16 h_vlan_proto;
	__be16 h_vlan_TCI;
	__be16 h_vlan_encapsulated_proto;
};

struct flow_action_cookie {
	u32 cookie_len;
	u8 cookie[0];
};

struct flow_stats {
	u64 pkts;
	u64 bytes;
	u64 drops;
	u64 lastused;
	enum flow_action_hw_stats used_hw_stats;
	bool used_hw_stats_valid;
};

enum flow_cls_command {
	FLOW_CLS_REPLACE = 0,
	FLOW_CLS_DESTROY = 1,
	FLOW_CLS_STATS = 2,
	FLOW_CLS_TMPLT_CREATE = 3,
	FLOW_CLS_TMPLT_DESTROY = 4,
};

struct flow_cls_common_offload {
	u32 chain_index;
	__be16 protocol;
	u32 prio;
	struct netlink_ext_ack *extack;
};

struct flow_cls_offload {
	struct flow_cls_common_offload common;
	enum flow_cls_command command;
	long unsigned int cookie;
	struct flow_rule *rule;
	struct flow_stats stats;
	u32 classid;
};

struct qdisc_walker {
	int stop;
	int skip;
	int count;
	int (*fn)(struct Qdisc *, long unsigned int, struct qdisc_walker *);
};

struct tcf_walker {
	int stop;
	int skip;
	int count;
	bool nonempty;
	long unsigned int cookie;
	int (*fn)(struct tcf_proto *, void *, struct tcf_walker *);
};

enum hwtstamp_tx_types {
	HWTSTAMP_TX_OFF = 0,
	HWTSTAMP_TX_ON = 1,
	HWTSTAMP_TX_ONESTEP_SYNC = 2,
	HWTSTAMP_TX_ONESTEP_P2P = 3,
	__HWTSTAMP_TX_CNT = 4,
};

enum hwtstamp_rx_filters {
	HWTSTAMP_FILTER_NONE = 0,
	HWTSTAMP_FILTER_ALL = 1,
	HWTSTAMP_FILTER_SOME = 2,
	HWTSTAMP_FILTER_PTP_V1_L4_EVENT = 3,
	HWTSTAMP_FILTER_PTP_V1_L4_SYNC = 4,
	HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ = 5,
	HWTSTAMP_FILTER_PTP_V2_L4_EVENT = 6,
	HWTSTAMP_FILTER_PTP_V2_L4_SYNC = 7,
	HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ = 8,
	HWTSTAMP_FILTER_PTP_V2_L2_EVENT = 9,
	HWTSTAMP_FILTER_PTP_V2_L2_SYNC = 10,
	HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ = 11,
	HWTSTAMP_FILTER_PTP_V2_EVENT = 12,
	HWTSTAMP_FILTER_PTP_V2_SYNC = 13,
	HWTSTAMP_FILTER_PTP_V2_DELAY_REQ = 14,
	HWTSTAMP_FILTER_NTP_ALL = 15,
	__HWTSTAMP_FILTER_CNT = 16,
};

struct tc_cbs_qopt_offload {
	u8 enable;
	s32 queue;
	s32 hicredit;
	s32 locredit;
	s32 idleslope;
	s32 sendslope;
};

struct tc_etf_qopt_offload {
	u8 enable;
	s32 queue;
};

struct tc_taprio_sched_entry {
	u8 command;
	u32 gate_mask;
	u32 interval;
};

struct tc_taprio_qopt_offload {
	u8 enable;
	ktime_t base_time;
	u64 cycle_time;
	u64 cycle_time_extension;
	size_t num_entries;
	struct tc_taprio_sched_entry entries[0];
};

struct tcf_exts {
	int action;
	int police;
};

struct tc_cls_u32_knode {
	struct tcf_exts *exts;
	struct tcf_result *res;
	struct tc_u32_sel *sel;
	u32 handle;
	u32 val;
	u32 mask;
	u32 link_handle;
	u8 fshift;
};

struct tc_cls_u32_hnode {
	u32 handle;
	u32 prio;
	unsigned int divisor;
};

enum tc_clsu32_command {
	TC_CLSU32_NEW_KNODE = 0,
	TC_CLSU32_REPLACE_KNODE = 1,
	TC_CLSU32_DELETE_KNODE = 2,
	TC_CLSU32_NEW_HNODE = 3,
	TC_CLSU32_REPLACE_HNODE = 4,
	TC_CLSU32_DELETE_HNODE = 5,
};

struct tc_cls_u32_offload {
	struct flow_cls_common_offload common;
	enum tc_clsu32_command command;
	union {
		struct tc_cls_u32_knode knode;
		struct tc_cls_u32_hnode hnode;
	};
};

struct stmmac_mdio_bus_data {
	unsigned int phy_mask;
	unsigned int has_xpcs;
	int *irqs;
	int probed_phy_irq;
	bool needs_reset;
};

struct stmmac_dma_cfg {
	int pbl;
	int txpbl;
	int rxpbl;
	bool pblx8;
	int fixed_burst;
	int mixed_burst;
	bool aal;
	bool eame;
};

struct stmmac_axi {
	bool axi_lpi_en;
	bool axi_xit_frm;
	u32 axi_wr_osr_lmt;
	u32 axi_rd_osr_lmt;
	bool axi_kbbe;
	u32 axi_blen[7];
	bool axi_fb;
	bool axi_mb;
	bool axi_rb;
};

struct stmmac_est {
	struct mutex lock;
	int enable;
	u32 btr_offset[2];
	u32 btr[2];
	u32 ctr[2];
	u32 ter;
	u32 gcl_unaligned[1024];
	u32 gcl[1024];
	u32 gcl_size;
};

struct stmmac_rxq_cfg {
	u8 mode_to_use;
	u32 chan;
	u8 pkt_route;
	bool use_prio;
	u32 prio;
};

struct stmmac_txq_cfg {
	u32 weight;
	u8 mode_to_use;
	u32 send_slope;
	u32 idle_slope;
	u32 high_credit;
	u32 low_credit;
	bool use_prio;
	u32 prio;
	int tbs_en;
};

struct mac_device_info;

struct plat_stmmacenet_data {
	int bus_id;
	int phy_addr;
	int interface;
	phy_interface_t phy_interface;
	struct stmmac_mdio_bus_data *mdio_bus_data;
	struct device_node *phy_node;
	struct device_node *phylink_node;
	struct device_node *mdio_node;
	struct stmmac_dma_cfg *dma_cfg;
	struct stmmac_est *est;
	int clk_csr;
	int has_gmac;
	int enh_desc;
	int tx_coe;
	int rx_coe;
	int bugged_jumbo;
	int pmt;
	int force_sf_dma_mode;
	int force_thresh_dma_mode;
	int riwt_off;
	int max_speed;
	int maxmtu;
	int multicast_filter_bins;
	int unicast_filter_entries;
	int tx_fifo_size;
	int rx_fifo_size;
	u32 addr64;
	u32 rx_queues_to_use;
	u32 tx_queues_to_use;
	u8 rx_sched_algorithm;
	u8 tx_sched_algorithm;
	struct stmmac_rxq_cfg rx_queues_cfg[8];
	struct stmmac_txq_cfg tx_queues_cfg[8];
	void (*fix_mac_speed)(void *, unsigned int);
	int (*serdes_powerup)(struct net_device *, void *);
	void (*serdes_powerdown)(struct net_device *, void *);
	int (*init)(struct platform_device *, void *);
	void (*exit)(struct platform_device *, void *);
	struct mac_device_info * (*setup)(void *);
	void *bsp_priv;
	struct clk *stmmac_clk;
	struct clk *pclk;
	struct clk *clk_ptp_ref;
	unsigned int clk_ptp_rate;
	unsigned int clk_ref_rate;
	s32 ptp_max_adj;
	struct reset_control *stmmac_rst;
	struct stmmac_axi *axi;
	int has_gmac4;
	bool has_sun8i;
	bool tso_en;
	int rss_en;
	int mac_port_sel_speed;
	bool en_tx_lpi_clockgating;
	int has_xgmac;
	bool vlan_fail_q_en;
	u8 vlan_fail_q;
	unsigned int eee_usecs_rate;
};

struct mii_regs {
	unsigned int addr;
	unsigned int data;
	unsigned int addr_shift;
	unsigned int reg_shift;
	unsigned int addr_mask;
	unsigned int reg_mask;
	unsigned int clk_csr_shift;
	unsigned int clk_csr_mask;
};

struct mac_link {
	u32 speed_mask;
	u32 speed10;
	u32 speed100;
	u32 speed1000;
	u32 speed2500;
	u32 duplex;
	struct {
		u32 speed2500;
		u32 speed5000;
		u32 speed10000;
	} xgmii;
	struct {
		u32 speed25000;
		u32 speed40000;
		u32 speed50000;
		u32 speed100000;
	} xlgmii;
};

struct stmmac_ops;

struct stmmac_desc_ops;

struct stmmac_dma_ops;

struct stmmac_mode_ops;

struct stmmac_hwtimestamp;

struct stmmac_tc_ops;

struct stmmac_mmc_ops;

struct mac_device_info {
	const struct stmmac_ops *mac;
	const struct stmmac_desc_ops *desc;
	const struct stmmac_dma_ops *dma;
	const struct stmmac_mode_ops *mode;
	const struct stmmac_hwtimestamp *ptp;
	const struct stmmac_tc_ops *tc;
	const struct stmmac_mmc_ops *mmc;
	const struct mdio_xpcs_ops *xpcs;
	struct mdio_xpcs_args xpcs_args;
	struct mii_regs mii;
	struct mac_link link;
	void *pcsr;
	unsigned int multicast_filter_bins;
	unsigned int unicast_filter_entries;
	unsigned int mcast_bits_log2;
	unsigned int rx_csum;
	unsigned int pcs;
	unsigned int pmt;
	unsigned int ps;
	unsigned int xlgmac;
	unsigned int num_vlan;
	u32 vlan_filter[32];
	unsigned int promisc;
	bool vlan_fail_q_en;
	u8 vlan_fail_q;
};

struct dma_desc {
	__le32 des0;
	__le32 des1;
	__le32 des2;
	__le32 des3;
};

struct dma_extended_desc {
	struct dma_desc basic;
	__le32 des4;
	__le32 des5;
	__le32 des6;
	__le32 des7;
};

struct dma_edesc {
	__le32 des4;
	__le32 des5;
	__le32 des6;
	__le32 des7;
	struct dma_desc basic;
};

struct stmmac_extra_stats;

struct stmmac_desc_ops {
	void (*init_rx_desc)(struct dma_desc *, int, int, int, int);
	void (*init_tx_desc)(struct dma_desc *, int, int);
	void (*prepare_tx_desc)(struct dma_desc *, int, int, bool, int, bool, bool, unsigned int);
	void (*prepare_tso_tx_desc)(struct dma_desc *, int, int, int, bool, bool, unsigned int, unsigned int);
	void (*set_tx_owner)(struct dma_desc *);
	int (*get_tx_owner)(struct dma_desc *);
	void (*release_tx_desc)(struct dma_desc *, int);
	void (*set_tx_ic)(struct dma_desc *);
	int (*get_tx_ls)(struct dma_desc *);
	int (*tx_status)(void *, struct stmmac_extra_stats *, struct dma_desc *, void *);
	int (*get_tx_len)(struct dma_desc *);
	void (*set_rx_owner)(struct dma_desc *, int);
	int (*get_rx_frame_len)(struct dma_desc *, int);
	int (*rx_status)(void *, struct stmmac_extra_stats *, struct dma_desc *);
	void (*rx_extended_status)(void *, struct stmmac_extra_stats *, struct dma_extended_desc *);
	void (*enable_tx_timestamp)(struct dma_desc *);
	int (*get_tx_timestamp_status)(struct dma_desc *);
	void (*get_timestamp)(void *, u32, u64 *);
	int (*get_rx_timestamp_status)(void *, void *, u32);
	void (*display_ring)(void *, unsigned int, bool, dma_addr_t, unsigned int);
	void (*set_mss)(struct dma_desc *, unsigned int);
	void (*get_addr)(struct dma_desc *, unsigned int *);
	void (*set_addr)(struct dma_desc *, dma_addr_t);
	void (*clear)(struct dma_desc *);
	int (*get_rx_hash)(struct dma_desc *, u32 *, enum pkt_hash_types *);
	void (*get_rx_header_len)(struct dma_desc *, unsigned int *);
	void (*set_sec_addr)(struct dma_desc *, dma_addr_t, bool);
	void (*set_sarc)(struct dma_desc *, u32);
	void (*set_vlan_tag)(struct dma_desc *, u16, u16, u32);
	void (*set_vlan)(struct dma_desc *, u32);
	void (*set_tbs)(struct dma_edesc *, u32, u32);
};

struct stmmac_extra_stats {
	long unsigned int tx_underflow;
	long unsigned int tx_carrier;
	long unsigned int tx_losscarrier;
	long unsigned int vlan_tag;
	long unsigned int tx_deferred;
	long unsigned int tx_vlan;
	long unsigned int tx_jabber;
	long unsigned int tx_frame_flushed;
	long unsigned int tx_payload_error;
	long unsigned int tx_ip_header_error;
	long unsigned int rx_desc;
	long unsigned int sa_filter_fail;
	long unsigned int overflow_error;
	long unsigned int ipc_csum_error;
	long unsigned int rx_collision;
	long unsigned int rx_crc_errors;
	long unsigned int dribbling_bit;
	long unsigned int rx_length;
	long unsigned int rx_mii;
	long unsigned int rx_multicast;
	long unsigned int rx_gmac_overflow;
	long unsigned int rx_watchdog;
	long unsigned int da_rx_filter_fail;
	long unsigned int sa_rx_filter_fail;
	long unsigned int rx_missed_cntr;
	long unsigned int rx_overflow_cntr;
	long unsigned int rx_vlan;
	long unsigned int rx_split_hdr_pkt_n;
	long unsigned int tx_undeflow_irq;
	long unsigned int tx_process_stopped_irq;
	long unsigned int tx_jabber_irq;
	long unsigned int rx_overflow_irq;
	long unsigned int rx_buf_unav_irq;
	long unsigned int rx_process_stopped_irq;
	long unsigned int rx_watchdog_irq;
	long unsigned int tx_early_irq;
	long unsigned int fatal_bus_error_irq;
	long unsigned int rx_early_irq;
	long unsigned int threshold;
	long unsigned int tx_pkt_n;
	long unsigned int rx_pkt_n;
	long unsigned int normal_irq_n;
	long unsigned int rx_normal_irq_n;
	long unsigned int napi_poll;
	long unsigned int tx_normal_irq_n;
	long unsigned int tx_clean;
	long unsigned int tx_set_ic_bit;
	long unsigned int irq_receive_pmt_irq_n;
	long unsigned int mmc_tx_irq_n;
	long unsigned int mmc_rx_irq_n;
	long unsigned int mmc_rx_csum_offload_irq_n;
	long unsigned int irq_tx_path_in_lpi_mode_n;
	long unsigned int irq_tx_path_exit_lpi_mode_n;
	long unsigned int irq_rx_path_in_lpi_mode_n;
	long unsigned int irq_rx_path_exit_lpi_mode_n;
	long unsigned int phy_eee_wakeup_error_n;
	long unsigned int ip_hdr_err;
	long unsigned int ip_payload_err;
	long unsigned int ip_csum_bypassed;
	long unsigned int ipv4_pkt_rcvd;
	long unsigned int ipv6_pkt_rcvd;
	long unsigned int no_ptp_rx_msg_type_ext;
	long unsigned int ptp_rx_msg_type_sync;
	long unsigned int ptp_rx_msg_type_follow_up;
	long unsigned int ptp_rx_msg_type_delay_req;
	long unsigned int ptp_rx_msg_type_delay_resp;
	long unsigned int ptp_rx_msg_type_pdelay_req;
	long unsigned int ptp_rx_msg_type_pdelay_resp;
	long unsigned int ptp_rx_msg_type_pdelay_follow_up;
	long unsigned int ptp_rx_msg_type_announce;
	long unsigned int ptp_rx_msg_type_management;
	long unsigned int ptp_rx_msg_pkt_reserved_type;
	long unsigned int ptp_frame_type;
	long unsigned int ptp_ver;
	long unsigned int timestamp_dropped;
	long unsigned int av_pkt_rcvd;
	long unsigned int av_tagged_pkt_rcvd;
	long unsigned int vlan_tag_priority_val;
	long unsigned int l3_filter_match;
	long unsigned int l4_filter_match;
	long unsigned int l3_l4_filter_no_match;
	long unsigned int irq_pcs_ane_n;
	long unsigned int irq_pcs_link_n;
	long unsigned int irq_rgmii_n;
	long unsigned int pcs_link;
	long unsigned int pcs_duplex;
	long unsigned int pcs_speed;
	long unsigned int mtl_tx_status_fifo_full;
	long unsigned int mtl_tx_fifo_not_empty;
	long unsigned int mmtl_fifo_ctrl;
	long unsigned int mtl_tx_fifo_read_ctrl_write;
	long unsigned int mtl_tx_fifo_read_ctrl_wait;
	long unsigned int mtl_tx_fifo_read_ctrl_read;
	long unsigned int mtl_tx_fifo_read_ctrl_idle;
	long unsigned int mac_tx_in_pause;
	long unsigned int mac_tx_frame_ctrl_xfer;
	long unsigned int mac_tx_frame_ctrl_idle;
	long unsigned int mac_tx_frame_ctrl_wait;
	long unsigned int mac_tx_frame_ctrl_pause;
	long unsigned int mac_gmii_tx_proto_engine;
	long unsigned int mtl_rx_fifo_fill_level_full;
	long unsigned int mtl_rx_fifo_fill_above_thresh;
	long unsigned int mtl_rx_fifo_fill_below_thresh;
	long unsigned int mtl_rx_fifo_fill_level_empty;
	long unsigned int mtl_rx_fifo_read_ctrl_flush;
	long unsigned int mtl_rx_fifo_read_ctrl_read_data;
	long unsigned int mtl_rx_fifo_read_ctrl_status;
	long unsigned int mtl_rx_fifo_read_ctrl_idle;
	long unsigned int mtl_rx_fifo_ctrl_active;
	long unsigned int mac_rx_frame_ctrl_fifo;
	long unsigned int mac_gmii_rx_proto_engine;
	long unsigned int tx_tso_frames;
	long unsigned int tx_tso_nfrags;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct dma_features;

struct stmmac_dma_ops {
	int (*reset)(void *);
	void (*init)(void *, struct stmmac_dma_cfg *, int);
	void (*init_chan)(void *, struct stmmac_dma_cfg *, u32);
	void (*init_rx_chan)(void *, struct stmmac_dma_cfg *, dma_addr_t, u32);
	void (*init_tx_chan)(void *, struct stmmac_dma_cfg *, dma_addr_t, u32);
	void (*axi)(void *, struct stmmac_axi *);
	void (*dump_regs)(void *, u32 *);
	void (*dma_rx_mode)(void *, int, u32, int, u8);
	void (*dma_tx_mode)(void *, int, u32, int, u8);
	void (*dma_diagnostic_fr)(void *, struct stmmac_extra_stats *, void *);
	void (*enable_dma_transmission)(void *);
	void (*enable_dma_irq)(void *, u32, bool, bool);
	void (*disable_dma_irq)(void *, u32, bool, bool);
	void (*start_tx)(void *, u32);
	void (*stop_tx)(void *, u32);
	void (*start_rx)(void *, u32);
	void (*stop_rx)(void *, u32);
	int (*dma_interrupt)(void *, struct stmmac_extra_stats *, u32);
	int (*get_hw_feature)(void *, struct dma_features *);
	void (*rx_watchdog)(void *, u32, u32);
	void (*set_tx_ring_len)(void *, u32, u32);
	void (*set_rx_ring_len)(void *, u32, u32);
	void (*set_rx_tail_ptr)(void *, u32, u32);
	void (*set_tx_tail_ptr)(void *, u32, u32);
	void (*enable_tso)(void *, bool, u32);
	void (*qmode)(void *, u32, u8);
	void (*set_bfsize)(void *, int, u32);
	void (*enable_sph)(void *, bool, u32);
	int (*enable_tbs)(void *, bool, u32);
};

struct dma_features {
	unsigned int mbps_10_100;
	unsigned int mbps_1000;
	unsigned int half_duplex;
	unsigned int hash_filter;
	unsigned int multi_addr;
	unsigned int pcs;
	unsigned int sma_mdio;
	unsigned int pmt_remote_wake_up;
	unsigned int pmt_magic_frame;
	unsigned int rmon;
	unsigned int time_stamp;
	unsigned int atime_stamp;
	unsigned int eee;
	unsigned int av;
	unsigned int hash_tb_sz;
	unsigned int tsoen;
	unsigned int tx_coe;
	unsigned int rx_coe;
	unsigned int rx_coe_type1;
	unsigned int rx_coe_type2;
	unsigned int rxfifo_over_2048;
	unsigned int number_rx_channel;
	unsigned int number_tx_channel;
	unsigned int number_rx_queues;
	unsigned int number_tx_queues;
	unsigned int pps_out_num;
	unsigned int enh_desc;
	unsigned int tx_fifo_size;
	unsigned int rx_fifo_size;
	unsigned int asp;
	unsigned int frpsel;
	unsigned int frpbs;
	unsigned int frpes;
	unsigned int addr64;
	unsigned int rssen;
	unsigned int vlhash;
	unsigned int sphen;
	unsigned int vlins;
	unsigned int dvlan;
	unsigned int l3l4fnum;
	unsigned int arpoffsel;
	unsigned int estwid;
	unsigned int estdep;
	unsigned int estsel;
	unsigned int fpesel;
	unsigned int tbssel;
};

struct rgmii_adv;

struct stmmac_safety_stats;

struct stmmac_tc_entry;

struct stmmac_pps_cfg;

struct stmmac_rss;

struct stmmac_ops {
	void (*core_init)(struct mac_device_info *, struct net_device *);
	void (*set_mac)(void *, bool);
	int (*rx_ipc)(struct mac_device_info *);
	void (*rx_queue_enable)(struct mac_device_info *, u8, u32);
	void (*rx_queue_prio)(struct mac_device_info *, u32, u32);
	void (*tx_queue_prio)(struct mac_device_info *, u32, u32);
	void (*rx_queue_routing)(struct mac_device_info *, u8, u32);
	void (*prog_mtl_rx_algorithms)(struct mac_device_info *, u32);
	void (*prog_mtl_tx_algorithms)(struct mac_device_info *, u32);
	void (*set_mtl_tx_queue_weight)(struct mac_device_info *, u32, u32);
	void (*map_mtl_to_dma)(struct mac_device_info *, u32, u32);
	void (*config_cbs)(struct mac_device_info *, u32, u32, u32, u32, u32);
	void (*dump_regs)(struct mac_device_info *, u32 *);
	int (*host_irq_status)(struct mac_device_info *, struct stmmac_extra_stats *);
	int (*host_mtl_irq_status)(struct mac_device_info *, u32);
	void (*set_filter)(struct mac_device_info *, struct net_device *);
	void (*flow_ctrl)(struct mac_device_info *, unsigned int, unsigned int, unsigned int, u32);
	void (*pmt)(struct mac_device_info *, long unsigned int);
	void (*set_umac_addr)(struct mac_device_info *, unsigned char *, unsigned int);
	void (*get_umac_addr)(struct mac_device_info *, unsigned char *, unsigned int);
	void (*set_eee_mode)(struct mac_device_info *, bool);
	void (*reset_eee_mode)(struct mac_device_info *);
	void (*set_eee_timer)(struct mac_device_info *, int, int);
	void (*set_eee_pls)(struct mac_device_info *, int);
	void (*debug)(void *, struct stmmac_extra_stats *, u32, u32);
	void (*pcs_ctrl_ane)(void *, bool, bool, bool);
	void (*pcs_rane)(void *, bool);
	void (*pcs_get_adv_lp)(void *, struct rgmii_adv *);
	int (*safety_feat_config)(void *, unsigned int);
	int (*safety_feat_irq_status)(struct net_device *, void *, unsigned int, struct stmmac_safety_stats *);
	int (*safety_feat_dump)(struct stmmac_safety_stats *, int, long unsigned int *, const char **);
	int (*rxp_config)(void *, struct stmmac_tc_entry *, unsigned int);
	int (*flex_pps_config)(void *, int, struct stmmac_pps_cfg *, bool, u32, u32);
	void (*set_mac_loopback)(void *, bool);
	int (*rss_configure)(struct mac_device_info *, struct stmmac_rss *, u32);
	void (*update_vlan_hash)(struct mac_device_info *, u32, __le16, bool);
	void (*enable_vlan)(struct mac_device_info *, u32);
	int (*add_hw_vlan_rx_fltr)(struct net_device *, struct mac_device_info *, __be16, u16);
	int (*del_hw_vlan_rx_fltr)(struct net_device *, struct mac_device_info *, __be16, u16);
	void (*restore_hw_vlan_rx_fltr)(struct net_device *, struct mac_device_info *);
	int (*get_mac_tx_timestamp)(struct mac_device_info *, u64 *);
	void (*sarc_configure)(void *, int);
	int (*config_l3_filter)(struct mac_device_info *, u32, bool, bool, bool, bool, u32);
	int (*config_l4_filter)(struct mac_device_info *, u32, bool, bool, bool, bool, u32);
	void (*set_arp_offload)(struct mac_device_info *, bool, u32);
	int (*est_configure)(void *, struct stmmac_est *, unsigned int);
	void (*fpe_configure)(void *, u32, u32, bool);
};

struct rgmii_adv {
	unsigned int pause;
	unsigned int duplex;
	unsigned int lp_pause;
	unsigned int lp_duplex;
};

struct stmmac_safety_stats {
	long unsigned int mac_errors[32];
	long unsigned int mtl_errors[32];
	long unsigned int dma_errors[32];
};

struct stmmac_tc_entry {
	bool in_use;
	bool in_hw;
	bool is_last;
	bool is_frag;
	void *frag_ptr;
	unsigned int table_pos;
	u32 handle;
	u32 prio;
	struct {
		u32 match_data;
		u32 match_en;
		u8 af: 1;
		u8 rf: 1;
		u8 im: 1;
		u8 nc: 1;
		u8 res1: 4;
		u8 frame_offset;
		u8 ok_index;
		u8 dma_ch_no;
		u32 res2;
	} val;
};

struct stmmac_pps_cfg {
	bool available;
	struct timespec64 start;
	struct timespec64 period;
};

struct stmmac_rss {
	int enable;
	u8 key[40];
	u32 table[256];
};

struct stmmac_hwtimestamp {
	void (*config_hw_tstamping)(void *, u32);
	void (*config_sub_second_increment)(void *, u32, int, u32 *);
	int (*init_systime)(void *, u32, u32);
	int (*config_addend)(void *, u32);
	int (*adjust_systime)(void *, u32, u32, int, int);
	void (*get_systime)(void *, u64 *);
};

struct stmmac_mode_ops {
	void (*init)(void *, dma_addr_t, unsigned int, unsigned int);
	unsigned int (*is_jumbo_frm)(int, int);
	int (*jumbo_frm)(void *, struct sk_buff *, int);
	int (*set_16kib_bfsize)(int);
	void (*init_desc3)(struct dma_desc *);
	void (*refill_desc3)(void *, struct dma_desc *);
	void (*clean_desc3)(void *, struct dma_desc *);
};

struct stmmac_priv;

struct stmmac_tc_ops {
	int (*init)(struct stmmac_priv *);
	int (*setup_cls_u32)(struct stmmac_priv *, struct tc_cls_u32_offload *);
	int (*setup_cbs)(struct stmmac_priv *, struct tc_cbs_qopt_offload *);
	int (*setup_cls)(struct stmmac_priv *, struct flow_cls_offload *);
	int (*setup_taprio)(struct stmmac_priv *, struct tc_taprio_qopt_offload *);
	int (*setup_etf)(struct stmmac_priv *, struct tc_etf_qopt_offload *);
};

struct stmmac_rx_buffer;

struct stmmac_rx_skbuffer;

struct stmmac_rx_queue {
	u32 rx_count_frames;
	u32 queue_index;
	struct page_pool *page_pool;
	struct stmmac_rx_buffer *buf_pool;
	struct stmmac_rx_skbuffer *skbuf_pool;
	struct stmmac_priv *priv_data;
	struct dma_extended_desc *dma_erx;
	long: 64;
	long: 64;
	struct dma_desc *dma_rx;
	unsigned int cur_rx;
	unsigned int dirty_rx;
	u32 rx_zeroc_thresh;
	dma_addr_t dma_rx_phy;
	u32 rx_tail_addr;
	unsigned int state_saved;
	struct {
		struct sk_buff *skb;
		unsigned int len;
		unsigned int error;
	} state;
	long: 64;
};

struct stmmac_tx_info;

struct stmmac_tx_queue {
	u32 tx_count_frames;
	int tbs;
	struct timer_list txtimer;
	u32 queue_index;
	struct stmmac_priv *priv_data;
	struct dma_extended_desc *dma_etx;
	struct dma_edesc *dma_entx;
	struct dma_desc *dma_tx;
	struct sk_buff **tx_skbuff;
	struct stmmac_tx_info *tx_skbuff_dma;
	unsigned int cur_tx;
	unsigned int dirty_tx;
	dma_addr_t dma_tx_phy;
	u32 tx_tail_addr;
	u32 mss;
};

struct stmmac_channel {
	struct napi_struct rx_napi;
	struct napi_struct tx_napi;
	struct stmmac_priv *priv_data;
	spinlock_t lock;
	u32 index;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct stmmac_counters {
	unsigned int mmc_tx_octetcount_gb;
	unsigned int mmc_tx_framecount_gb;
	unsigned int mmc_tx_broadcastframe_g;
	unsigned int mmc_tx_multicastframe_g;
	unsigned int mmc_tx_64_octets_gb;
	unsigned int mmc_tx_65_to_127_octets_gb;
	unsigned int mmc_tx_128_to_255_octets_gb;
	unsigned int mmc_tx_256_to_511_octets_gb;
	unsigned int mmc_tx_512_to_1023_octets_gb;
	unsigned int mmc_tx_1024_to_max_octets_gb;
	unsigned int mmc_tx_unicast_gb;
	unsigned int mmc_tx_multicast_gb;
	unsigned int mmc_tx_broadcast_gb;
	unsigned int mmc_tx_underflow_error;
	unsigned int mmc_tx_singlecol_g;
	unsigned int mmc_tx_multicol_g;
	unsigned int mmc_tx_deferred;
	unsigned int mmc_tx_latecol;
	unsigned int mmc_tx_exesscol;
	unsigned int mmc_tx_carrier_error;
	unsigned int mmc_tx_octetcount_g;
	unsigned int mmc_tx_framecount_g;
	unsigned int mmc_tx_excessdef;
	unsigned int mmc_tx_pause_frame;
	unsigned int mmc_tx_vlan_frame_g;
	unsigned int mmc_rx_framecount_gb;
	unsigned int mmc_rx_octetcount_gb;
	unsigned int mmc_rx_octetcount_g;
	unsigned int mmc_rx_broadcastframe_g;
	unsigned int mmc_rx_multicastframe_g;
	unsigned int mmc_rx_crc_error;
	unsigned int mmc_rx_align_error;
	unsigned int mmc_rx_run_error;
	unsigned int mmc_rx_jabber_error;
	unsigned int mmc_rx_undersize_g;
	unsigned int mmc_rx_oversize_g;
	unsigned int mmc_rx_64_octets_gb;
	unsigned int mmc_rx_65_to_127_octets_gb;
	unsigned int mmc_rx_128_to_255_octets_gb;
	unsigned int mmc_rx_256_to_511_octets_gb;
	unsigned int mmc_rx_512_to_1023_octets_gb;
	unsigned int mmc_rx_1024_to_max_octets_gb;
	unsigned int mmc_rx_unicast_g;
	unsigned int mmc_rx_length_error;
	unsigned int mmc_rx_autofrangetype;
	unsigned int mmc_rx_pause_frames;
	unsigned int mmc_rx_fifo_overflow;
	unsigned int mmc_rx_vlan_frames_gb;
	unsigned int mmc_rx_watchdog_error;
	unsigned int mmc_rx_ipc_intr_mask;
	unsigned int mmc_rx_ipc_intr;
	unsigned int mmc_rx_ipv4_gd;
	unsigned int mmc_rx_ipv4_hderr;
	unsigned int mmc_rx_ipv4_nopay;
	unsigned int mmc_rx_ipv4_frag;
	unsigned int mmc_rx_ipv4_udsbl;
	unsigned int mmc_rx_ipv4_gd_octets;
	unsigned int mmc_rx_ipv4_hderr_octets;
	unsigned int mmc_rx_ipv4_nopay_octets;
	unsigned int mmc_rx_ipv4_frag_octets;
	unsigned int mmc_rx_ipv4_udsbl_octets;
	unsigned int mmc_rx_ipv6_gd_octets;
	unsigned int mmc_rx_ipv6_hderr_octets;
	unsigned int mmc_rx_ipv6_nopay_octets;
	unsigned int mmc_rx_ipv6_gd;
	unsigned int mmc_rx_ipv6_hderr;
	unsigned int mmc_rx_ipv6_nopay;
	unsigned int mmc_rx_udp_gd;
	unsigned int mmc_rx_udp_err;
	unsigned int mmc_rx_tcp_gd;
	unsigned int mmc_rx_tcp_err;
	unsigned int mmc_rx_icmp_gd;
	unsigned int mmc_rx_icmp_err;
	unsigned int mmc_rx_udp_gd_octets;
	unsigned int mmc_rx_udp_err_octets;
	unsigned int mmc_rx_tcp_gd_octets;
	unsigned int mmc_rx_tcp_err_octets;
	unsigned int mmc_rx_icmp_gd_octets;
	unsigned int mmc_rx_icmp_err_octets;
	unsigned int mmc_tx_fpe_fragment_cntr;
	unsigned int mmc_tx_hold_req_cntr;
	unsigned int mmc_rx_packet_assembly_err_cntr;
	unsigned int mmc_rx_packet_smd_err_cntr;
	unsigned int mmc_rx_packet_assembly_ok_cntr;
	unsigned int mmc_rx_fpe_fragment_cntr;
};

struct stmmac_flow_entry;

struct stmmac_priv {
	u32 tx_coal_frames;
	u32 tx_coal_timer;
	u32 rx_coal_frames;
	int tx_coalesce;
	int hwts_tx_en;
	bool tx_path_in_lpi_mode;
	bool tso;
	int sph;
	u32 sarc_type;
	unsigned int dma_buf_sz;
	unsigned int rx_copybreak;
	u32 rx_riwt;
	int hwts_rx_en;
	void *ioaddr;
	struct net_device *dev;
	struct device *device;
	struct mac_device_info *hw;
	int (*hwif_quirks)(struct stmmac_priv *);
	struct mutex lock;
	long: 64;
	struct stmmac_rx_queue rx_queue[8];
	unsigned int dma_rx_size;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct stmmac_tx_queue tx_queue[8];
	unsigned int dma_tx_size;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct stmmac_channel channel[8];
	int speed;
	unsigned int flow_ctrl;
	unsigned int pause;
	struct mii_bus *mii;
	int mii_irq[32];
	struct phylink_config phylink_config;
	struct phylink *phylink;
	long: 64;
	struct stmmac_extra_stats xstats;
	struct stmmac_safety_stats sstats;
	struct plat_stmmacenet_data *plat;
	struct dma_features dma_cap;
	struct stmmac_counters mmc;
	int hw_cap_support;
	int synopsys_id;
	u32 msg_enable;
	int wolopts;
	int wol_irq;
	int clk_csr;
	struct timer_list eee_ctrl_timer;
	int lpi_irq;
	int eee_enabled;
	int eee_active;
	int tx_lpi_timer;
	int tx_lpi_enabled;
	int eee_tw_timer;
	unsigned int mode;
	unsigned int chain_mode;
	int extend_desc;
	bool extend_stat_need;
	struct hwtstamp_config tstamp_config;
	struct ptp_clock *ptp_clock;
	struct ptp_clock_info ptp_clock_ops;
	unsigned int default_addend;
	u32 sub_second_inc;
	u32 systime_flags;
	u32 adv_ts;
	int use_riwt;
	int irq_wake;
	spinlock_t ptp_lock;
	void *mmcaddr;
	void *ptpaddr;
	long unsigned int active_vlans[64];
	struct dentry *dbgfs_dir;
	long unsigned int state;
	struct workqueue_struct *wq;
	struct work_struct service_task;
	unsigned int tc_entries_max;
	unsigned int tc_off_max;
	struct stmmac_tc_entry *tc_entries;
	unsigned int flow_entries_max;
	struct stmmac_flow_entry *flow_entries;
	struct stmmac_pps_cfg pps[4];
	struct stmmac_rss rss;
};

struct stmmac_mmc_ops {
	void (*ctrl)(void *, unsigned int);
	void (*intr_all_mask)(void *);
	void (*read)(void *, struct stmmac_counters *);
};

enum rx_frame_status {
	good_frame = 0,
	discard_frame = 1,
	csum_none = 2,
	llc_snap = 4,
	dma_own = 8,
	rx_not_ls = 16,
};

enum tx_frame_status {
	tx_done = 0,
	tx_not_ls = 1,
	tx_err = 2,
	tx_dma_own = 4,
};

enum dma_irq_status {
	tx_hard_error = 1,
	tx_hard_error_bump_tc = 2,
	handle_rx = 4,
	handle_tx = 8,
};

struct pp_alloc_cache {
	u32 count;
	void *cache[128];
};

struct page_pool_params {
	unsigned int flags;
	unsigned int order;
	unsigned int pool_size;
	int nid;
	struct device *dev;
	enum dma_data_direction dma_dir;
	unsigned int max_len;
	unsigned int offset;
};

struct page_pool {
	struct page_pool_params p;
	struct delayed_work release_dw;
	void (*disconnect)(void *);
	long unsigned int defer_start;
	long unsigned int defer_warn;
	u32 pages_state_hold_cnt;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct pp_alloc_cache alloc;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct ptr_ring ring;
	atomic_t pages_state_release_cnt;
	refcount_t user_cnt;
	u64 destroy_cnt;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct stmmac_resources {
	void *addr;
	const char *mac;
	int wol_irq;
	int lpi_irq;
	int irq;
};

struct stmmac_tx_info {
	dma_addr_t buf;
	bool map_as_page;
	unsigned int len;
	bool last_segment;
	bool is_jumbo;
};

struct stmmac_rx_buffer {
	struct page *page;
	struct page *sec_page;
	dma_addr_t addr;
	dma_addr_t sec_addr;
};

struct stmmac_rx_skbuffer {
	struct sk_buff *rx_skbuff;
	struct page *sec_page;
	dma_addr_t addr;
	dma_addr_t sec_addr;
};

struct stmmac_flow_entry {
	long unsigned int cookie;
	long unsigned int action;
	u8 ip_proto;
	int in_use;
	int idx;
	int is_l4;
};

enum stmmac_state {
	STMMAC_DOWN = 0,
	STMMAC_RESET_REQUESTED = 1,
	STMMAC_RESETING = 2,
	STMMAC_SERVICE_SCHED = 3,
};

enum tunable_id {
	ETHTOOL_ID_UNSPEC = 0,
	ETHTOOL_RX_COPYBREAK = 1,
	ETHTOOL_TX_COPYBREAK = 2,
	ETHTOOL_PFC_PREVENTION_TOUT = 3,
	__ETHTOOL_TUNABLE_COUNT = 4,
};

enum {
	ETH_RSS_HASH_TOP_BIT = 0,
	ETH_RSS_HASH_XOR_BIT = 1,
	ETH_RSS_HASH_CRC32_BIT = 2,
	ETH_RSS_HASH_FUNCS_COUNT = 3,
};

enum {
	SOF_TIMESTAMPING_TX_HARDWARE = 1,
	SOF_TIMESTAMPING_TX_SOFTWARE = 2,
	SOF_TIMESTAMPING_RX_HARDWARE = 4,
	SOF_TIMESTAMPING_RX_SOFTWARE = 8,
	SOF_TIMESTAMPING_SOFTWARE = 16,
	SOF_TIMESTAMPING_SYS_HARDWARE = 32,
	SOF_TIMESTAMPING_RAW_HARDWARE = 64,
	SOF_TIMESTAMPING_OPT_ID = 128,
	SOF_TIMESTAMPING_TX_SCHED = 256,
	SOF_TIMESTAMPING_TX_ACK = 512,
	SOF_TIMESTAMPING_OPT_CMSG = 1024,
	SOF_TIMESTAMPING_OPT_TSONLY = 2048,
	SOF_TIMESTAMPING_OPT_STATS = 4096,
	SOF_TIMESTAMPING_OPT_PKTINFO = 8192,
	SOF_TIMESTAMPING_OPT_TX_SWHW = 16384,
	SOF_TIMESTAMPING_LAST = 16384,
	SOF_TIMESTAMPING_MASK = 32767,
};

struct stmmac_stats {
	char stat_string[32];
	int sizeof_stat;
	int stat_offset;
};

enum devlink_port_type {
	DEVLINK_PORT_TYPE_NOTSET = 0,
	DEVLINK_PORT_TYPE_AUTO = 1,
	DEVLINK_PORT_TYPE_ETH = 2,
	DEVLINK_PORT_TYPE_IB = 3,
};

enum devlink_port_flavour {
	DEVLINK_PORT_FLAVOUR_PHYSICAL = 0,
	DEVLINK_PORT_FLAVOUR_CPU = 1,
	DEVLINK_PORT_FLAVOUR_DSA = 2,
	DEVLINK_PORT_FLAVOUR_PCI_PF = 3,
	DEVLINK_PORT_FLAVOUR_PCI_VF = 4,
	DEVLINK_PORT_FLAVOUR_VIRTUAL = 5,
	DEVLINK_PORT_FLAVOUR_UNUSED = 6,
};

struct devlink_port_phys_attrs {
	u32 port_number;
	u32 split_subport_number;
};

struct devlink_port_pci_pf_attrs {
	u32 controller;
	u16 pf;
	u8 external: 1;
};

struct devlink_port_pci_vf_attrs {
	u32 controller;
	u16 pf;
	u16 vf;
	u8 external: 1;
};

struct devlink_port_attrs {
	u8 split: 1;
	u8 splittable: 1;
	u32 lanes;
	enum devlink_port_flavour flavour;
	struct netdev_phys_item_id switch_id;
	union {
		struct devlink_port_phys_attrs phys;
		struct devlink_port_pci_pf_attrs pci_pf;
		struct devlink_port_pci_vf_attrs pci_vf;
	};
};

struct devlink;

struct devlink_port {
	struct list_head list;
	struct list_head param_list;
	struct list_head region_list;
	struct devlink *devlink;
	unsigned int index;
	bool registered;
	spinlock_t type_lock;
	enum devlink_port_type type;
	enum devlink_port_type desired_type;
	void *type_dev;
	struct devlink_port_attrs attrs;
	u8 attrs_set: 1;
	u8 switch_port: 1;
	struct delayed_work type_warn_dw;
	struct list_head reporter_list;
	struct mutex reporters_lock;
};

enum devlink_sb_pool_type {
	DEVLINK_SB_POOL_TYPE_INGRESS = 0,
	DEVLINK_SB_POOL_TYPE_EGRESS = 1,
};

enum devlink_sb_threshold_type {
	DEVLINK_SB_THRESHOLD_TYPE_STATIC = 0,
	DEVLINK_SB_THRESHOLD_TYPE_DYNAMIC = 1,
};

enum devlink_eswitch_encap_mode {
	DEVLINK_ESWITCH_ENCAP_MODE_NONE = 0,
	DEVLINK_ESWITCH_ENCAP_MODE_BASIC = 1,
};

enum devlink_trap_action {
	DEVLINK_TRAP_ACTION_DROP = 0,
	DEVLINK_TRAP_ACTION_TRAP = 1,
	DEVLINK_TRAP_ACTION_MIRROR = 2,
};

enum devlink_trap_type {
	DEVLINK_TRAP_TYPE_DROP = 0,
	DEVLINK_TRAP_TYPE_EXCEPTION = 1,
	DEVLINK_TRAP_TYPE_CONTROL = 2,
};

enum devlink_reload_action {
	DEVLINK_RELOAD_ACTION_UNSPEC = 0,
	DEVLINK_RELOAD_ACTION_DRIVER_REINIT = 1,
	DEVLINK_RELOAD_ACTION_FW_ACTIVATE = 2,
	__DEVLINK_RELOAD_ACTION_MAX = 3,
	DEVLINK_RELOAD_ACTION_MAX = 2,
};

enum devlink_reload_limit {
	DEVLINK_RELOAD_LIMIT_UNSPEC = 0,
	DEVLINK_RELOAD_LIMIT_NO_RESET = 1,
	__DEVLINK_RELOAD_LIMIT_MAX = 2,
	DEVLINK_RELOAD_LIMIT_MAX = 1,
};

enum devlink_dpipe_field_mapping_type {
	DEVLINK_DPIPE_FIELD_MAPPING_TYPE_NONE = 0,
	DEVLINK_DPIPE_FIELD_MAPPING_TYPE_IFINDEX = 1,
};

struct devlink_dev_stats {
	u32 reload_stats[6];
	u32 remote_reload_stats[6];
};

struct devlink_dpipe_headers;

struct devlink_ops;

struct devlink {
	struct list_head list;
	struct list_head port_list;
	struct list_head sb_list;
	struct list_head dpipe_table_list;
	struct list_head resource_list;
	struct list_head param_list;
	struct list_head region_list;
	struct list_head reporter_list;
	struct mutex reporters_lock;
	struct devlink_dpipe_headers *dpipe_headers;
	struct list_head trap_list;
	struct list_head trap_group_list;
	struct list_head trap_policer_list;
	const struct devlink_ops *ops;
	struct xarray snapshot_ids;
	struct devlink_dev_stats stats;
	struct device *dev;
	possible_net_t _net;
	struct mutex lock;
	u8 reload_failed: 1;
	u8 reload_enabled: 1;
	u8 registered: 1;
	long: 61;
	long: 64;
	char priv[0];
};

struct devlink_dpipe_header;

struct devlink_dpipe_headers {
	struct devlink_dpipe_header **headers;
	unsigned int headers_count;
};

struct devlink_info_req;

struct devlink_sb_pool_info;

struct devlink_flash_update_params;

struct devlink_trap;

struct devlink_trap_group;

struct devlink_trap_policer;

struct devlink_ops {
	u32 supported_flash_update_params;
	long unsigned int reload_actions;
	long unsigned int reload_limits;
	int (*reload_down)(struct devlink *, bool, enum devlink_reload_action, enum devlink_reload_limit, struct netlink_ext_ack *);
	int (*reload_up)(struct devlink *, enum devlink_reload_action, enum devlink_reload_limit, u32 *, struct netlink_ext_ack *);
	int (*port_type_set)(struct devlink_port *, enum devlink_port_type);
	int (*port_split)(struct devlink *, unsigned int, unsigned int, struct netlink_ext_ack *);
	int (*port_unsplit)(struct devlink *, unsigned int, struct netlink_ext_ack *);
	int (*sb_pool_get)(struct devlink *, unsigned int, u16, struct devlink_sb_pool_info *);
	int (*sb_pool_set)(struct devlink *, unsigned int, u16, u32, enum devlink_sb_threshold_type, struct netlink_ext_ack *);
	int (*sb_port_pool_get)(struct devlink_port *, unsigned int, u16, u32 *);
	int (*sb_port_pool_set)(struct devlink_port *, unsigned int, u16, u32, struct netlink_ext_ack *);
	int (*sb_tc_pool_bind_get)(struct devlink_port *, unsigned int, u16, enum devlink_sb_pool_type, u16 *, u32 *);
	int (*sb_tc_pool_bind_set)(struct devlink_port *, unsigned int, u16, enum devlink_sb_pool_type, u16, u32, struct netlink_ext_ack *);
	int (*sb_occ_snapshot)(struct devlink *, unsigned int);
	int (*sb_occ_max_clear)(struct devlink *, unsigned int);
	int (*sb_occ_port_pool_get)(struct devlink_port *, unsigned int, u16, u32 *, u32 *);
	int (*sb_occ_tc_port_bind_get)(struct devlink_port *, unsigned int, u16, enum devlink_sb_pool_type, u32 *, u32 *);
	int (*eswitch_mode_get)(struct devlink *, u16 *);
	int (*eswitch_mode_set)(struct devlink *, u16, struct netlink_ext_ack *);
	int (*eswitch_inline_mode_get)(struct devlink *, u8 *);
	int (*eswitch_inline_mode_set)(struct devlink *, u8, struct netlink_ext_ack *);
	int (*eswitch_encap_mode_get)(struct devlink *, enum devlink_eswitch_encap_mode *);
	int (*eswitch_encap_mode_set)(struct devlink *, enum devlink_eswitch_encap_mode, struct netlink_ext_ack *);
	int (*info_get)(struct devlink *, struct devlink_info_req *, struct netlink_ext_ack *);
	int (*flash_update)(struct devlink *, struct devlink_flash_update_params *, struct netlink_ext_ack *);
	int (*trap_init)(struct devlink *, const struct devlink_trap *, void *);
	void (*trap_fini)(struct devlink *, const struct devlink_trap *, void *);
	int (*trap_action_set)(struct devlink *, const struct devlink_trap *, enum devlink_trap_action, struct netlink_ext_ack *);
	int (*trap_group_init)(struct devlink *, const struct devlink_trap_group *);
	int (*trap_group_set)(struct devlink *, const struct devlink_trap_group *, const struct devlink_trap_policer *, struct netlink_ext_ack *);
	int (*trap_group_action_set)(struct devlink *, const struct devlink_trap_group *, enum devlink_trap_action, struct netlink_ext_ack *);
	int (*trap_policer_init)(struct devlink *, const struct devlink_trap_policer *);
	void (*trap_policer_fini)(struct devlink *, const struct devlink_trap_policer *);
	int (*trap_policer_set)(struct devlink *, const struct devlink_trap_policer *, u64, u64, struct netlink_ext_ack *);
	int (*trap_policer_counter_get)(struct devlink *, const struct devlink_trap_policer *, u64 *);
	int (*port_function_hw_addr_get)(struct devlink *, struct devlink_port *, u8 *, int *, struct netlink_ext_ack *);
	int (*port_function_hw_addr_set)(struct devlink *, struct devlink_port *, const u8 *, int, struct netlink_ext_ack *);
};

struct devlink_sb_pool_info {
	enum devlink_sb_pool_type pool_type;
	u32 size;
	enum devlink_sb_threshold_type threshold_type;
	u32 cell_size;
};

struct devlink_dpipe_field {
	const char *name;
	unsigned int id;
	unsigned int bitwidth;
	enum devlink_dpipe_field_mapping_type mapping_type;
};

struct devlink_dpipe_header {
	const char *name;
	unsigned int id;
	struct devlink_dpipe_field *fields;
	unsigned int fields_count;
	bool global;
};

struct devlink_flash_update_params {
	const char *file_name;
	const char *component;
	u32 overwrite_mask;
};

struct devlink_trap_policer {
	u32 id;
	u64 init_rate;
	u64 init_burst;
	u64 max_rate;
	u64 min_rate;
	u64 max_burst;
	u64 min_burst;
};

struct devlink_trap_group {
	const char *name;
	u16 id;
	bool generic;
	u32 init_policer_id;
};

struct devlink_trap {
	enum devlink_trap_type type;
	enum devlink_trap_action init_action;
	bool generic;
	u16 id;
	const char *name;
	u16 init_group_id;
	u32 metadata_cap;
};

enum power_event {
	pointer_reset = 2147483648,
	global_unicast = 512,
	wake_up_rx_frame = 64,
	magic_frame = 32,
	wake_up_frame_en = 4,
	magic_pkt_en = 2,
	power_down = 1,
};

enum ttc_control {
	DMA_CONTROL_TTC_64 = 0,
	DMA_CONTROL_TTC_128 = 16384,
	DMA_CONTROL_TTC_192 = 32768,
	DMA_CONTROL_TTC_256 = 49152,
	DMA_CONTROL_TTC_40 = 65536,
	DMA_CONTROL_TTC_32 = 81920,
	DMA_CONTROL_TTC_24 = 98304,
	DMA_CONTROL_TTC_16 = 114688,
};

enum rtc_control {
	DMA_CONTROL_RTC_64 = 0,
	DMA_CONTROL_RTC_32 = 8,
	DMA_CONTROL_RTC_96 = 16,
	DMA_CONTROL_RTC_128 = 24,
};

enum ttc_control___2 {
	DMA_CONTROL_TTC_DEFAULT = 0,
	DMA_CONTROL_TTC_64___2 = 16384,
	DMA_CONTROL_TTC_128___2 = 32768,
	DMA_CONTROL_TTC_256___2 = 49152,
	DMA_CONTROL_TTC_18 = 4194304,
	DMA_CONTROL_TTC_24___2 = 4210688,
	DMA_CONTROL_TTC_32___2 = 4227072,
	DMA_CONTROL_TTC_40___2 = 4243456,
	DMA_CONTROL_SE = 8,
	DMA_CONTROL_OSF = 4,
};

enum packets_types {
	PACKET_AVCPQ = 1,
	PACKET_PTPQ = 2,
	PACKET_DCBCPQ = 3,
	PACKET_UPQ = 4,
	PACKET_MCBCQ = 5,
};

struct stmmac_rx_routing {
	u32 reg_mask;
	u32 reg_shift;
};

enum dwmac4_irq_status {
	time_stamp_irq = 4096,
	mmc_rx_csum_offload_irq = 2048,
	mmc_tx_irq = 1024,
	mmc_rx_irq = 512,
	mmc_irq = 256,
	lpi_irq = 32,
	pmt_irq = 16,
};

struct dwmac5_error_desc {
	bool valid;
	const char *desc;
	const char *detailed_desc;
};

struct dwmac5_error {
	const struct dwmac5_error_desc *desc;
};

struct stmmac_regs_off {
	u32 ptp_off;
	u32 mmc_off;
};

struct stmmac_hwif_entry {
	bool gmac;
	bool gmac4;
	bool xgmac;
	u32 min_id;
	u32 dev_id;
	const struct stmmac_regs_off regs;
	const void *desc;
	const void *dma;
	const void *mac;
	const void *hwtimestamp;
	const void *mode;
	const void *tc;
	const void *mmc;
	int (*setup)(struct stmmac_priv *);
	int (*quirks)(struct stmmac_priv *);
};

enum {
	TC_TAPRIO_CMD_SET_GATES = 0,
	TC_TAPRIO_CMD_SET_AND_HOLD = 1,
	TC_TAPRIO_CMD_SET_AND_RELEASE = 2,
};

struct tcf_t {
	__u64 install;
	__u64 lastuse;
	__u64 expires;
	__u64 firstuse;
};

struct flow_dissector_key_ipv4_addrs {
	__be32 src;
	__be32 dst;
};

struct flow_dissector_key_ports {
	union {
		__be32 ports;
		struct {
			__be16 src;
			__be16 dst;
		};
	};
};

struct flow_match_basic {
	struct flow_dissector_key_basic *key;
	struct flow_dissector_key_basic *mask;
};

struct flow_match_ipv4_addrs {
	struct flow_dissector_key_ipv4_addrs *key;
	struct flow_dissector_key_ipv4_addrs *mask;
};

struct flow_match_ports {
	struct flow_dissector_key_ports *key;
	struct flow_dissector_key_ports *mask;
};

struct tcf_idrinfo {
	struct mutex lock;
	struct idr action_idr;
	struct net *net;
};

struct tc_action_ops;

struct tc_cookie;

struct tc_action {
	const struct tc_action_ops *ops;
	__u32 type;
	struct tcf_idrinfo *idrinfo;
	u32 tcfa_index;
	refcount_t tcfa_refcnt;
	atomic_t tcfa_bindcnt;
	int tcfa_action;
	struct tcf_t tcfa_tm;
	struct gnet_stats_basic_packed tcfa_bstats;
	struct gnet_stats_basic_packed tcfa_bstats_hw;
	struct gnet_stats_queue tcfa_qstats;
	struct net_rate_estimator *tcfa_rate_est;
	spinlock_t tcfa_lock;
	struct gnet_stats_basic_cpu *cpu_bstats;
	struct gnet_stats_basic_cpu *cpu_bstats_hw;
	struct gnet_stats_queue *cpu_qstats;
	struct tc_cookie *act_cookie;
	struct tcf_chain *goto_chain;
	u32 tcfa_flags;
	u8 hw_stats;
	u8 used_hw_stats;
	bool used_hw_stats_valid;
};

struct tc_cookie {
	u8 *data;
	u32 len;
	struct callback_head rcu;
};

struct dwxgmac3_error_desc {
	bool valid;
	const char *desc;
	const char *detailed_desc;
};

struct dwxgmac3_error {
	const struct dwxgmac3_error_desc *desc;
};

struct thead_dwmac_priv_data {
	int id;
	void *phy_if_reg;
	void *txclk_dir_reg;
	void *gmac_clk_reg;
	phy_interface_t interface;
	struct clk *gmac_pll_clk;
	unsigned int gmac_pll_clk_freq;
};

struct thead_dwmac_ops {
	void (*set_clk_source)(struct plat_stmmacenet_data *);
	void (*set_clk_pll)(struct plat_stmmacenet_data *);
	void (*set_clk_div)(struct plat_stmmacenet_data *, unsigned int);
	void (*enable_clk)(struct plat_stmmacenet_data *);
};

struct thead_dwmac_priv_data___2 {
	int id;
	struct device *dev;
	void *phy_if_reg;
	void *txclk_dir_reg;
	void *gmac_clk_reg;
	phy_interface_t interface;
	struct clk *gmac_pll_clk;
	long unsigned int gmac_pll_clk_freq;
	const struct thead_dwmac_ops *ops;
	struct plat_stmmacenet_data *plat_dat;
};

typedef int sint;

typedef __kernel_size_t SIZE_T;

typedef unsigned char BOOLEAN;

typedef unsigned char boolean;

enum nl80211_iftype {
	NL80211_IFTYPE_UNSPECIFIED = 0,
	NL80211_IFTYPE_ADHOC = 1,
	NL80211_IFTYPE_STATION = 2,
	NL80211_IFTYPE_AP = 3,
	NL80211_IFTYPE_AP_VLAN = 4,
	NL80211_IFTYPE_WDS = 5,
	NL80211_IFTYPE_MONITOR = 6,
	NL80211_IFTYPE_MESH_POINT = 7,
	NL80211_IFTYPE_P2P_CLIENT = 8,
	NL80211_IFTYPE_P2P_GO = 9,
	NL80211_IFTYPE_P2P_DEVICE = 10,
	NL80211_IFTYPE_OCB = 11,
	NL80211_IFTYPE_NAN = 12,
	NUM_NL80211_IFTYPES = 13,
	NL80211_IFTYPE_MAX = 12,
};

enum ieee80211_bss_type {
	IEEE80211_BSS_TYPE_ESS = 0,
	IEEE80211_BSS_TYPE_PBSS = 1,
	IEEE80211_BSS_TYPE_IBSS = 2,
	IEEE80211_BSS_TYPE_MBSS = 3,
	IEEE80211_BSS_TYPE_ANY = 4,
};

enum nl80211_chan_width {
	NL80211_CHAN_WIDTH_20_NOHT = 0,
	NL80211_CHAN_WIDTH_20 = 1,
	NL80211_CHAN_WIDTH_40 = 2,
	NL80211_CHAN_WIDTH_80 = 3,
	NL80211_CHAN_WIDTH_80P80 = 4,
	NL80211_CHAN_WIDTH_160 = 5,
	NL80211_CHAN_WIDTH_5 = 6,
	NL80211_CHAN_WIDTH_10 = 7,
	NL80211_CHAN_WIDTH_1 = 8,
	NL80211_CHAN_WIDTH_2 = 9,
	NL80211_CHAN_WIDTH_4 = 10,
	NL80211_CHAN_WIDTH_8 = 11,
	NL80211_CHAN_WIDTH_16 = 12,
};

enum ieee80211_edmg_bw_config {
	IEEE80211_EDMG_BW_CONFIG_4 = 4,
	IEEE80211_EDMG_BW_CONFIG_5 = 5,
	IEEE80211_EDMG_BW_CONFIG_6 = 6,
	IEEE80211_EDMG_BW_CONFIG_7 = 7,
	IEEE80211_EDMG_BW_CONFIG_8 = 8,
	IEEE80211_EDMG_BW_CONFIG_9 = 9,
	IEEE80211_EDMG_BW_CONFIG_10 = 10,
	IEEE80211_EDMG_BW_CONFIG_11 = 11,
	IEEE80211_EDMG_BW_CONFIG_12 = 12,
	IEEE80211_EDMG_BW_CONFIG_13 = 13,
	IEEE80211_EDMG_BW_CONFIG_14 = 14,
	IEEE80211_EDMG_BW_CONFIG_15 = 15,
};

struct ieee80211_edmg {
	u8 channels;
	enum ieee80211_edmg_bw_config bw_config;
};

struct ieee80211_channel;

struct cfg80211_chan_def {
	struct ieee80211_channel *chan;
	enum nl80211_chan_width width;
	u32 center_freq1;
	u32 center_freq2;
	struct ieee80211_edmg edmg;
	u16 freq1_offset;
};

struct wiphy;

struct cfg80211_conn;

struct cfg80211_cached_keys;

struct cfg80211_internal_bss;

struct cfg80211_cqm_config;

struct wireless_dev {
	struct wiphy *wiphy;
	enum nl80211_iftype iftype;
	struct list_head list;
	struct net_device *netdev;
	u32 identifier;
	struct list_head mgmt_registrations;
	spinlock_t mgmt_registrations_lock;
	u8 mgmt_registrations_need_update: 1;
	struct mutex mtx;
	bool use_4addr;
	bool is_running;
	u8 address[6];
	u8 ssid[32];
	u8 ssid_len;
	u8 mesh_id_len;
	u8 mesh_id_up_len;
	struct cfg80211_conn *conn;
	struct cfg80211_cached_keys *connect_keys;
	enum ieee80211_bss_type conn_bss_type;
	u32 conn_owner_nlportid;
	struct work_struct disconnect_wk;
	u8 disconnect_bssid[6];
	struct list_head event_list;
	spinlock_t event_lock;
	struct cfg80211_internal_bss *current_bss;
	struct cfg80211_chan_def preset_chandef;
	struct cfg80211_chan_def chandef;
	bool ibss_fixed;
	bool ibss_dfs_possible;
	bool ps;
	int ps_timeout;
	int beacon_interval;
	u32 ap_unexpected_nlportid;
	u32 owner_nlportid;
	bool nl_owner_dead;
	bool cac_started;
	long unsigned int cac_start_time;
	unsigned int cac_time_ms;
	struct cfg80211_cqm_config *cqm_config;
	struct list_head pmsr_list;
	spinlock_t pmsr_lock;
	struct work_struct pmsr_free_wk;
	long unsigned int unprot_beacon_reported;
};

struct iw_quality {
	__u8 qual;
	__u8 level;
	__u8 noise;
	__u8 updated;
};

struct iw_discarded {
	__u32 nwid;
	__u32 code;
	__u32 fragment;
	__u32 retries;
	__u32 misc;
};

struct iw_missed {
	__u32 beacon;
};

struct iw_statistics {
	__u16 status;
	struct iw_quality qual;
	struct iw_discarded discard;
	struct iw_missed miss;
};

struct ieee80211_mcs_info {
	u8 rx_mask[10];
	__le16 rx_highest;
	u8 tx_params;
	u8 reserved[3];
};

struct ieee80211_ht_cap {
	__le16 cap_info;
	u8 ampdu_params_info;
	struct ieee80211_mcs_info mcs;
	__le16 extended_ht_cap_info;
	__le32 tx_BF_cap_info;
	u8 antenna_selection_info;
} __attribute__((packed));

struct ieee80211_vht_mcs_info {
	__le16 rx_mcs_map;
	__le16 rx_highest;
	__le16 tx_mcs_map;
	__le16 tx_highest;
};

struct ieee80211_vht_cap {
	__le32 vht_cap_info;
	struct ieee80211_vht_mcs_info supp_mcs;
};

struct ieee80211_he_cap_elem {
	u8 mac_cap_info[6];
	u8 phy_cap_info[11];
};

struct ieee80211_he_mcs_nss_supp {
	__le16 rx_mcs_80;
	__le16 tx_mcs_80;
	__le16 rx_mcs_160;
	__le16 tx_mcs_160;
	__le16 rx_mcs_80p80;
	__le16 tx_mcs_80p80;
};

struct ieee80211_he_6ghz_capa {
	__le16 capa;
};

enum nl80211_reg_initiator {
	NL80211_REGDOM_SET_BY_CORE = 0,
	NL80211_REGDOM_SET_BY_USER = 1,
	NL80211_REGDOM_SET_BY_DRIVER = 2,
	NL80211_REGDOM_SET_BY_COUNTRY_IE = 3,
};

enum nl80211_dfs_regions {
	NL80211_DFS_UNSET = 0,
	NL80211_DFS_FCC = 1,
	NL80211_DFS_ETSI = 2,
	NL80211_DFS_JP = 3,
};

enum nl80211_user_reg_hint_type {
	NL80211_USER_REG_HINT_USER = 0,
	NL80211_USER_REG_HINT_CELL_BASE = 1,
	NL80211_USER_REG_HINT_INDOOR = 2,
};

enum nl80211_mntr_flags {
	__NL80211_MNTR_FLAG_INVALID = 0,
	NL80211_MNTR_FLAG_FCSFAIL = 1,
	NL80211_MNTR_FLAG_PLCPFAIL = 2,
	NL80211_MNTR_FLAG_CONTROL = 3,
	NL80211_MNTR_FLAG_OTHER_BSS = 4,
	NL80211_MNTR_FLAG_COOK_FRAMES = 5,
	NL80211_MNTR_FLAG_ACTIVE = 6,
	__NL80211_MNTR_FLAG_AFTER_LAST = 7,
	NL80211_MNTR_FLAG_MAX = 6,
};

enum nl80211_channel_type {
	NL80211_CHAN_NO_HT = 0,
	NL80211_CHAN_HT20 = 1,
	NL80211_CHAN_HT40MINUS = 2,
	NL80211_CHAN_HT40PLUS = 3,
};

enum nl80211_key_mode {
	NL80211_KEY_RX_TX = 0,
	NL80211_KEY_NO_TX = 1,
	NL80211_KEY_SET_TX = 2,
};

enum nl80211_bss_scan_width {
	NL80211_BSS_CHAN_WIDTH_20 = 0,
	NL80211_BSS_CHAN_WIDTH_10 = 1,
	NL80211_BSS_CHAN_WIDTH_5 = 2,
	NL80211_BSS_CHAN_WIDTH_1 = 3,
	NL80211_BSS_CHAN_WIDTH_2 = 4,
};

enum nl80211_auth_type {
	NL80211_AUTHTYPE_OPEN_SYSTEM = 0,
	NL80211_AUTHTYPE_SHARED_KEY = 1,
	NL80211_AUTHTYPE_FT = 2,
	NL80211_AUTHTYPE_NETWORK_EAP = 3,
	NL80211_AUTHTYPE_SAE = 4,
	NL80211_AUTHTYPE_FILS_SK = 5,
	NL80211_AUTHTYPE_FILS_SK_PFS = 6,
	NL80211_AUTHTYPE_FILS_PK = 7,
	__NL80211_AUTHTYPE_NUM = 8,
	NL80211_AUTHTYPE_MAX = 7,
	NL80211_AUTHTYPE_AUTOMATIC = 8,
};

enum nl80211_mfp {
	NL80211_MFP_NO = 0,
	NL80211_MFP_REQUIRED = 1,
	NL80211_MFP_OPTIONAL = 2,
};

enum nl80211_band {
	NL80211_BAND_2GHZ = 0,
	NL80211_BAND_5GHZ = 1,
	NL80211_BAND_60GHZ = 2,
	NL80211_BAND_6GHZ = 3,
	NL80211_BAND_S1GHZ = 4,
	NUM_NL80211_BANDS = 5,
};

struct nl80211_wowlan_tcp_data_seq {
	__u32 start;
	__u32 offset;
	__u32 len;
};

struct nl80211_wowlan_tcp_data_token {
	__u32 offset;
	__u32 len;
	__u8 token_stream[0];
};

struct nl80211_wowlan_tcp_data_token_feature {
	__u32 min_len;
	__u32 max_len;
	__u32 bufsize;
};

enum nl80211_ext_feature_index {
	NL80211_EXT_FEATURE_VHT_IBSS = 0,
	NL80211_EXT_FEATURE_RRM = 1,
	NL80211_EXT_FEATURE_MU_MIMO_AIR_SNIFFER = 2,
	NL80211_EXT_FEATURE_SCAN_START_TIME = 3,
	NL80211_EXT_FEATURE_BSS_PARENT_TSF = 4,
	NL80211_EXT_FEATURE_SET_SCAN_DWELL = 5,
	NL80211_EXT_FEATURE_BEACON_RATE_LEGACY = 6,
	NL80211_EXT_FEATURE_BEACON_RATE_HT = 7,
	NL80211_EXT_FEATURE_BEACON_RATE_VHT = 8,
	NL80211_EXT_FEATURE_FILS_STA = 9,
	NL80211_EXT_FEATURE_MGMT_TX_RANDOM_TA = 10,
	NL80211_EXT_FEATURE_MGMT_TX_RANDOM_TA_CONNECTED = 11,
	NL80211_EXT_FEATURE_SCHED_SCAN_RELATIVE_RSSI = 12,
	NL80211_EXT_FEATURE_CQM_RSSI_LIST = 13,
	NL80211_EXT_FEATURE_FILS_SK_OFFLOAD = 14,
	NL80211_EXT_FEATURE_4WAY_HANDSHAKE_STA_PSK = 15,
	NL80211_EXT_FEATURE_4WAY_HANDSHAKE_STA_1X = 16,
	NL80211_EXT_FEATURE_FILS_MAX_CHANNEL_TIME = 17,
	NL80211_EXT_FEATURE_ACCEPT_BCAST_PROBE_RESP = 18,
	NL80211_EXT_FEATURE_OCE_PROBE_REQ_HIGH_TX_RATE = 19,
	NL80211_EXT_FEATURE_OCE_PROBE_REQ_DEFERRAL_SUPPRESSION = 20,
	NL80211_EXT_FEATURE_MFP_OPTIONAL = 21,
	NL80211_EXT_FEATURE_LOW_SPAN_SCAN = 22,
	NL80211_EXT_FEATURE_LOW_POWER_SCAN = 23,
	NL80211_EXT_FEATURE_HIGH_ACCURACY_SCAN = 24,
	NL80211_EXT_FEATURE_DFS_OFFLOAD = 25,
	NL80211_EXT_FEATURE_CONTROL_PORT_OVER_NL80211 = 26,
	NL80211_EXT_FEATURE_ACK_SIGNAL_SUPPORT = 27,
	NL80211_EXT_FEATURE_DATA_ACK_SIGNAL_SUPPORT = 27,
	NL80211_EXT_FEATURE_TXQS = 28,
	NL80211_EXT_FEATURE_SCAN_RANDOM_SN = 29,
	NL80211_EXT_FEATURE_SCAN_MIN_PREQ_CONTENT = 30,
	NL80211_EXT_FEATURE_CAN_REPLACE_PTK0 = 31,
	NL80211_EXT_FEATURE_ENABLE_FTM_RESPONDER = 32,
	NL80211_EXT_FEATURE_AIRTIME_FAIRNESS = 33,
	NL80211_EXT_FEATURE_AP_PMKSA_CACHING = 34,
	NL80211_EXT_FEATURE_SCHED_SCAN_BAND_SPECIFIC_RSSI_THOLD = 35,
	NL80211_EXT_FEATURE_EXT_KEY_ID = 36,
	NL80211_EXT_FEATURE_STA_TX_PWR = 37,
	NL80211_EXT_FEATURE_SAE_OFFLOAD = 38,
	NL80211_EXT_FEATURE_VLAN_OFFLOAD = 39,
	NL80211_EXT_FEATURE_AQL = 40,
	NL80211_EXT_FEATURE_BEACON_PROTECTION = 41,
	NL80211_EXT_FEATURE_CONTROL_PORT_NO_PREAUTH = 42,
	NL80211_EXT_FEATURE_PROTECTED_TWT = 43,
	NL80211_EXT_FEATURE_DEL_IBSS_STA = 44,
	NL80211_EXT_FEATURE_MULTICAST_REGISTRATIONS = 45,
	NL80211_EXT_FEATURE_BEACON_PROTECTION_CLIENT = 46,
	NL80211_EXT_FEATURE_SCAN_FREQ_KHZ = 47,
	NL80211_EXT_FEATURE_CONTROL_PORT_OVER_NL80211_TX_STATUS = 48,
	NL80211_EXT_FEATURE_OPERATING_CHANNEL_VALIDATION = 49,
	NL80211_EXT_FEATURE_4WAY_HANDSHAKE_AP_PSK = 50,
	NL80211_EXT_FEATURE_SAE_OFFLOAD_AP = 51,
	NL80211_EXT_FEATURE_FILS_DISCOVERY = 52,
	NL80211_EXT_FEATURE_UNSOL_BCAST_PROBE_RESP = 53,
	NUM_NL80211_EXT_FEATURES = 54,
	MAX_NL80211_EXT_FEATURES = 53,
};

enum nl80211_dfs_state {
	NL80211_DFS_USABLE = 0,
	NL80211_DFS_UNAVAILABLE = 1,
	NL80211_DFS_AVAILABLE = 2,
};

struct nl80211_vendor_cmd_info {
	__u32 vendor_id;
	__u32 subcmd;
};

enum nl80211_bss_select_attr {
	__NL80211_BSS_SELECT_ATTR_INVALID = 0,
	NL80211_BSS_SELECT_ATTR_RSSI = 1,
	NL80211_BSS_SELECT_ATTR_BAND_PREF = 2,
	NL80211_BSS_SELECT_ATTR_RSSI_ADJUST = 3,
	__NL80211_BSS_SELECT_ATTR_AFTER_LAST = 4,
	NL80211_BSS_SELECT_ATTR_MAX = 3,
};

enum nl80211_sae_pwe_mechanism {
	NL80211_SAE_PWE_UNSPECIFIED = 0,
	NL80211_SAE_PWE_HUNT_AND_PECK = 1,
	NL80211_SAE_PWE_HASH_TO_ELEMENT = 2,
	NL80211_SAE_PWE_BOTH = 3,
};

enum environment_cap {
	ENVIRON_ANY = 0,
	ENVIRON_INDOOR = 1,
	ENVIRON_OUTDOOR = 2,
};

struct regulatory_request {
	struct callback_head callback_head;
	int wiphy_idx;
	enum nl80211_reg_initiator initiator;
	enum nl80211_user_reg_hint_type user_reg_hint_type;
	char alpha2[3];
	enum nl80211_dfs_regions dfs_region;
	bool intersect;
	bool processed;
	enum environment_cap country_ie_env;
	struct list_head list;
};

struct ieee80211_freq_range {
	u32 start_freq_khz;
	u32 end_freq_khz;
	u32 max_bandwidth_khz;
};

struct ieee80211_power_rule {
	u32 max_antenna_gain;
	u32 max_eirp;
};

struct ieee80211_wmm_ac {
	u16 cw_min;
	u16 cw_max;
	u16 cot;
	u8 aifsn;
};

struct ieee80211_wmm_rule {
	struct ieee80211_wmm_ac client[4];
	struct ieee80211_wmm_ac ap[4];
};

struct ieee80211_reg_rule {
	struct ieee80211_freq_range freq_range;
	struct ieee80211_power_rule power_rule;
	struct ieee80211_wmm_rule wmm_rule;
	u32 flags;
	u32 dfs_cac_ms;
	bool has_wmm;
};

struct ieee80211_regdomain {
	struct callback_head callback_head;
	u32 n_reg_rules;
	char alpha2[3];
	enum nl80211_dfs_regions dfs_region;
	struct ieee80211_reg_rule reg_rules[0];
};

struct ieee80211_channel {
	enum nl80211_band band;
	u32 center_freq;
	u16 freq_offset;
	u16 hw_value;
	u32 flags;
	int max_antenna_gain;
	int max_power;
	int max_reg_power;
	bool beacon_found;
	u32 orig_flags;
	int orig_mag;
	int orig_mpwr;
	enum nl80211_dfs_state dfs_state;
	long unsigned int dfs_state_entered;
	unsigned int dfs_cac_ms;
};

struct ieee80211_rate {
	u32 flags;
	u16 bitrate;
	u16 hw_value;
	u16 hw_value_short;
};

struct ieee80211_sta_ht_cap {
	u16 cap;
	bool ht_supported;
	u8 ampdu_factor;
	u8 ampdu_density;
	struct ieee80211_mcs_info mcs;
	char: 8;
} __attribute__((packed));

struct ieee80211_sta_vht_cap {
	bool vht_supported;
	u32 cap;
	struct ieee80211_vht_mcs_info vht_mcs;
};

struct ieee80211_sta_he_cap {
	bool has_he;
	struct ieee80211_he_cap_elem he_cap_elem;
	struct ieee80211_he_mcs_nss_supp he_mcs_nss_supp;
	u8 ppe_thres[25];
} __attribute__((packed));

struct ieee80211_sband_iftype_data {
	u16 types_mask;
	struct ieee80211_sta_he_cap he_cap;
	struct ieee80211_he_6ghz_capa he_6ghz_capa;
	char: 8;
} __attribute__((packed));

struct ieee80211_sta_s1g_cap {
	bool s1g;
	u8 cap[10];
	u8 nss_mcs[5];
};

struct ieee80211_supported_band {
	struct ieee80211_channel *channels;
	struct ieee80211_rate *bitrates;
	enum nl80211_band band;
	int n_channels;
	int n_bitrates;
	struct ieee80211_sta_ht_cap ht_cap;
	struct ieee80211_sta_vht_cap vht_cap;
	struct ieee80211_sta_s1g_cap s1g_cap;
	struct ieee80211_edmg edmg_cap;
	u16 n_iftype_data;
	const struct ieee80211_sband_iftype_data *iftype_data;
};

struct key_params {
	const u8 *key;
	const u8 *seq;
	int key_len;
	int seq_len;
	u16 vlan_id;
	u32 cipher;
	enum nl80211_key_mode mode;
};

struct cfg80211_crypto_settings {
	u32 wpa_versions;
	u32 cipher_group;
	int n_ciphers_pairwise;
	u32 ciphers_pairwise[5];
	int n_akm_suites;
	u32 akm_suites[2];
	bool control_port;
	__be16 control_port_ethertype;
	bool control_port_no_encrypt;
	bool control_port_over_nl80211;
	bool control_port_no_preauth;
	struct key_params *wep_keys;
	int wep_tx_key;
	const u8 *psk;
	const u8 *sae_pwd;
	u8 sae_pwd_len;
	enum nl80211_sae_pwe_mechanism sae_pwe;
};

struct mac_address {
	u8 addr[6];
};

struct cfg80211_ssid {
	u8 ssid[32];
	u8 ssid_len;
};

struct cfg80211_scan_info {
	u64 scan_start_tsf;
	u8 tsf_bssid[6];
	bool aborted;
};

struct cfg80211_scan_6ghz_params {
	u32 short_ssid;
	u32 channel_idx;
	u8 bssid[6];
	bool unsolicited_probe;
	bool short_ssid_valid;
	bool psc_no_listen;
};

struct cfg80211_scan_request {
	struct cfg80211_ssid *ssids;
	int n_ssids;
	u32 n_channels;
	enum nl80211_bss_scan_width scan_width;
	const u8 *ie;
	size_t ie_len;
	u16 duration;
	bool duration_mandatory;
	u32 flags;
	u32 rates[5];
	struct wireless_dev *wdev;
	u8 mac_addr[6];
	u8 mac_addr_mask[6];
	u8 bssid[6];
	struct wiphy *wiphy;
	long unsigned int scan_start;
	struct cfg80211_scan_info info;
	bool notified;
	bool no_cck;
	bool scan_6ghz;
	u32 n_6ghz_params;
	struct cfg80211_scan_6ghz_params *scan_6ghz_params;
	struct ieee80211_channel *channels[0];
};

enum cfg80211_signal_type {
	CFG80211_SIGNAL_TYPE_NONE = 0,
	CFG80211_SIGNAL_TYPE_MBM = 1,
	CFG80211_SIGNAL_TYPE_UNSPEC = 2,
};

struct ieee80211_txrx_stypes;

struct ieee80211_iface_combination;

struct wiphy_iftype_akm_suites;

struct wiphy_wowlan_support;

struct cfg80211_wowlan;

struct wiphy_iftype_ext_capab;

struct wiphy_coalesce_support;

struct wiphy_vendor_command;

struct cfg80211_pmsr_capabilities;

struct wiphy {
	u8 perm_addr[6];
	u8 addr_mask[6];
	struct mac_address *addresses;
	const struct ieee80211_txrx_stypes *mgmt_stypes;
	const struct ieee80211_iface_combination *iface_combinations;
	int n_iface_combinations;
	u16 software_iftypes;
	u16 n_addresses;
	u16 interface_modes;
	u16 max_acl_mac_addrs;
	u32 flags;
	u32 regulatory_flags;
	u32 features;
	u8 ext_features[7];
	u32 ap_sme_capa;
	enum cfg80211_signal_type signal_type;
	int bss_priv_size;
	u8 max_scan_ssids;
	u8 max_sched_scan_reqs;
	u8 max_sched_scan_ssids;
	u8 max_match_sets;
	u16 max_scan_ie_len;
	u16 max_sched_scan_ie_len;
	u32 max_sched_scan_plans;
	u32 max_sched_scan_plan_interval;
	u32 max_sched_scan_plan_iterations;
	int n_cipher_suites;
	const u32 *cipher_suites;
	int n_akm_suites;
	const u32 *akm_suites;
	const struct wiphy_iftype_akm_suites *iftype_akm_suites;
	unsigned int num_iftype_akm_suites;
	u8 retry_short;
	u8 retry_long;
	u32 frag_threshold;
	u32 rts_threshold;
	u8 coverage_class;
	char fw_version[32];
	u32 hw_version;
	const struct wiphy_wowlan_support *wowlan;
	struct cfg80211_wowlan *wowlan_config;
	u16 max_remain_on_channel_duration;
	u8 max_num_pmkids;
	u32 available_antennas_tx;
	u32 available_antennas_rx;
	u32 probe_resp_offload;
	const u8 *extended_capabilities;
	const u8 *extended_capabilities_mask;
	u8 extended_capabilities_len;
	const struct wiphy_iftype_ext_capab *iftype_ext_capab;
	unsigned int num_iftype_ext_capab;
	const void *privid;
	struct ieee80211_supported_band *bands[5];
	void (*reg_notifier)(struct wiphy *, struct regulatory_request *);
	const struct ieee80211_regdomain *regd;
	struct device dev;
	bool registered;
	struct dentry *debugfsdir;
	const struct ieee80211_ht_cap *ht_capa_mod_mask;
	const struct ieee80211_vht_cap *vht_capa_mod_mask;
	struct list_head wdev_list;
	possible_net_t _net;
	const struct wiphy_coalesce_support *coalesce;
	const struct wiphy_vendor_command *vendor_commands;
	const struct nl80211_vendor_cmd_info *vendor_events;
	int n_vendor_commands;
	int n_vendor_events;
	u16 max_ap_assoc_sta;
	u8 max_num_csa_counters;
	u32 bss_select_support;
	u8 nan_supported_bands;
	u32 txq_limit;
	u32 txq_memory_limit;
	u32 txq_quantum;
	long unsigned int tx_queue_len;
	u8 support_mbssid: 1;
	u8 support_only_he_mbssid: 1;
	const struct cfg80211_pmsr_capabilities *pmsr_capa;
	struct {
		u64 peer;
		u64 vif;
		u8 max_retry;
	} tid_config_support;
	u8 max_data_retry_count;
	long: 56;
	char priv[0];
};

struct cfg80211_match_set {
	struct cfg80211_ssid ssid;
	u8 bssid[6];
	s32 rssi_thold;
	s32 per_band_rssi_thold[5];
};

struct cfg80211_sched_scan_plan {
	u32 interval;
	u32 iterations;
};

struct cfg80211_bss_select_adjust {
	enum nl80211_band band;
	s8 delta;
};

struct cfg80211_sched_scan_request {
	u64 reqid;
	struct cfg80211_ssid *ssids;
	int n_ssids;
	u32 n_channels;
	enum nl80211_bss_scan_width scan_width;
	const u8 *ie;
	size_t ie_len;
	u32 flags;
	struct cfg80211_match_set *match_sets;
	int n_match_sets;
	s32 min_rssi_thold;
	u32 delay;
	struct cfg80211_sched_scan_plan *scan_plans;
	int n_scan_plans;
	u8 mac_addr[6];
	u8 mac_addr_mask[6];
	bool relative_rssi_set;
	s8 relative_rssi;
	struct cfg80211_bss_select_adjust rssi_adjust;
	struct wiphy *wiphy;
	struct net_device *dev;
	long unsigned int scan_start;
	bool report_results;
	struct callback_head callback_head;
	u32 owner_nlportid;
	bool nl_owner_dead;
	struct list_head list;
	struct ieee80211_channel *channels[0];
};

struct cfg80211_bss_selection {
	enum nl80211_bss_select_attr behaviour;
	union {
		enum nl80211_band band_pref;
		struct cfg80211_bss_select_adjust adjust;
	} param;
};

struct cfg80211_connect_params {
	struct ieee80211_channel *channel;
	struct ieee80211_channel *channel_hint;
	const u8 *bssid;
	const u8 *bssid_hint;
	const u8 *ssid;
	size_t ssid_len;
	enum nl80211_auth_type auth_type;
	int: 32;
	const u8 *ie;
	size_t ie_len;
	bool privacy;
	int: 24;
	enum nl80211_mfp mfp;
	struct cfg80211_crypto_settings crypto;
	const u8 *key;
	u8 key_len;
	u8 key_idx;
	short: 16;
	u32 flags;
	int bg_scan_period;
	struct ieee80211_ht_cap ht_capa;
	struct ieee80211_ht_cap ht_capa_mask;
	struct ieee80211_vht_cap vht_capa;
	struct ieee80211_vht_cap vht_capa_mask;
	bool pbss;
	int: 24;
	struct cfg80211_bss_selection bss_select;
	const u8 *prev_bssid;
	const u8 *fils_erp_username;
	size_t fils_erp_username_len;
	const u8 *fils_erp_realm;
	size_t fils_erp_realm_len;
	u16 fils_erp_next_seq_num;
	long: 48;
	const u8 *fils_erp_rrk;
	size_t fils_erp_rrk_len;
	bool want_1x;
	int: 24;
	struct ieee80211_edmg edmg;
	int: 32;
} __attribute__((packed));

struct cfg80211_pkt_pattern {
	const u8 *mask;
	const u8 *pattern;
	int pattern_len;
	int pkt_offset;
};

struct cfg80211_wowlan_tcp {
	struct socket *sock;
	__be32 src;
	__be32 dst;
	u16 src_port;
	u16 dst_port;
	u8 dst_mac[6];
	int payload_len;
	const u8 *payload;
	struct nl80211_wowlan_tcp_data_seq payload_seq;
	u32 data_interval;
	u32 wake_len;
	const u8 *wake_data;
	const u8 *wake_mask;
	u32 tokens_size;
	struct nl80211_wowlan_tcp_data_token payload_tok;
};

struct cfg80211_wowlan {
	bool any;
	bool disconnect;
	bool magic_pkt;
	bool gtk_rekey_failure;
	bool eap_identity_req;
	bool four_way_handshake;
	bool rfkill_release;
	struct cfg80211_pkt_pattern *patterns;
	struct cfg80211_wowlan_tcp *tcp;
	int n_patterns;
	struct cfg80211_sched_scan_request *nd_config;
};

struct ieee80211_iface_limit {
	u16 max;
	u16 types;
};

struct ieee80211_iface_combination {
	const struct ieee80211_iface_limit *limits;
	u32 num_different_channels;
	u16 max_interfaces;
	u8 n_limits;
	bool beacon_int_infra_match;
	u8 radar_detect_widths;
	u8 radar_detect_regions;
	u32 beacon_int_min_gcd;
};

struct ieee80211_txrx_stypes {
	u16 tx;
	u16 rx;
};

struct wiphy_wowlan_tcp_support {
	const struct nl80211_wowlan_tcp_data_token_feature *tok;
	u32 data_payload_max;
	u32 data_interval_max;
	u32 wake_payload_max;
	bool seq;
};

struct wiphy_wowlan_support {
	u32 flags;
	int n_patterns;
	int pattern_max_len;
	int pattern_min_len;
	int max_pkt_offset;
	int max_nd_match_sets;
	const struct wiphy_wowlan_tcp_support *tcp;
};

struct wiphy_coalesce_support {
	int n_rules;
	int max_delay;
	int n_patterns;
	int pattern_max_len;
	int pattern_min_len;
	int max_pkt_offset;
};

struct wiphy_vendor_command {
	struct nl80211_vendor_cmd_info info;
	u32 flags;
	int (*doit)(struct wiphy *, struct wireless_dev *, const void *, int);
	int (*dumpit)(struct wiphy *, struct wireless_dev *, struct sk_buff *, const void *, int, long unsigned int *);
	const struct nla_policy *policy;
	unsigned int maxattr;
};

struct wiphy_iftype_ext_capab {
	enum nl80211_iftype iftype;
	const u8 *extended_capabilities;
	const u8 *extended_capabilities_mask;
	u8 extended_capabilities_len;
};

struct cfg80211_pmsr_capabilities {
	unsigned int max_peers;
	u8 report_ap_tsf: 1;
	u8 randomize_mac_addr: 1;
	struct {
		u32 preambles;
		u32 bandwidths;
		s8 max_bursts_exponent;
		u8 max_ftms_per_burst;
		u8 supported: 1;
		u8 asap: 1;
		u8 non_asap: 1;
		u8 request_lci: 1;
		u8 request_civicloc: 1;
		u8 trigger_based: 1;
		u8 non_trigger_based: 1;
	} ftm;
};

struct wiphy_iftype_akm_suites {
	u16 iftypes_mask;
	const u32 *akm_suites;
	int n_akm_suites;
};

typedef struct semaphore _sema;

typedef spinlock_t _lock;

typedef struct mutex _mutex;

struct rtw_timer_list {
	struct timer_list timer;
	void (*function)(void *);
	void *arg;
};

typedef struct rtw_timer_list _timer;

struct __queue {
	struct list_head queue;
	_lock lock;
};

typedef struct sk_buff _pkt;

typedef struct __queue _queue;

typedef struct list_head _list;

typedef long unsigned int _irqL;

typedef struct net_device *_nic_hdl;

typedef void *_thread_hdl_;

typedef int thread_return;

typedef void *thread_context;

typedef struct work_struct _workitem;

typedef long unsigned int systime;

typedef struct tasklet_struct _tasklet;

typedef unsigned char NDIS_802_11_MAC_ADDRESS[6];

typedef long int NDIS_802_11_RSSI;

typedef unsigned char NDIS_802_11_RATES_EX[16];

struct _NDIS_802_11_SSID {
	u32 SsidLength;
	u8 Ssid[32];
};

typedef struct _NDIS_802_11_SSID NDIS_802_11_SSID;

struct _NDIS_802_11_CONFIGURATION {
	u32 Length;
	u32 BeaconPeriod;
	u32 ATIMWindow;
	u32 DSConfig;
};

typedef struct _NDIS_802_11_CONFIGURATION NDIS_802_11_CONFIGURATION;

enum _NDIS_802_11_NETWORK_INFRASTRUCTURE {
	Ndis802_11IBSS = 0,
	Ndis802_11Infrastructure = 1,
	Ndis802_11AutoUnknown = 2,
	Ndis802_11InfrastructureMax = 3,
	Ndis802_11APMode = 4,
	Ndis802_11Monitor = 5,
	Ndis802_11_mesh = 6,
};

typedef enum _NDIS_802_11_NETWORK_INFRASTRUCTURE NDIS_802_11_NETWORK_INFRASTRUCTURE;

struct _NDIS_802_11_WEP {
	u32 Length;
	u32 KeyIndex;
	u32 KeyLength;
	u8 KeyMaterial[16];
};

typedef struct _NDIS_802_11_WEP NDIS_802_11_WEP;

struct _WLAN_PHY_INFO {
	u8 SignalStrength;
	u8 SignalQuality;
	u8 Optimum_antenna;
	u8 is_cck_rate;
	s8 rx_snr[4];
};

typedef struct _WLAN_PHY_INFO WLAN_PHY_INFO;

struct _WLAN_BSSID_EX {
	u32 Length;
	NDIS_802_11_MAC_ADDRESS MacAddress;
	u8 Reserved[2];
	NDIS_802_11_SSID Ssid;
	NDIS_802_11_SSID mesh_id;
	u32 Privacy;
	NDIS_802_11_RSSI Rssi;
	NDIS_802_11_CONFIGURATION Configuration;
	NDIS_802_11_NETWORK_INFRASTRUCTURE InfrastructureMode;
	NDIS_802_11_RATES_EX SupportedRates;
	WLAN_PHY_INFO PhyInfo;
	u32 IELength;
	u8 IEs[768];
	u64 tsf;
};

typedef struct _WLAN_BSSID_EX WLAN_BSSID_EX;

struct beacon_keys {
	u8 ssid[32];
	u32 ssid_len;
	u8 ch;
	u8 bw;
	u8 offset;
	u8 proto_cap;
	u8 rate_set[12];
	u8 rate_num;
	int encryp_protocol;
	int pairwise_cipher;
	int group_cipher;
	u32 akm;
};

struct wlan_network {
	_list list;
	int network_type;
	int fixed;
	systime last_scanned;
	systime last_non_hidden_ssid_ap;
	int aid;
	int join_res;
	struct beacon_keys bcn_keys;
	bool bcn_keys_valid;
	WLAN_BSSID_EX network;
	long: 56;
} __attribute__((packed));

enum WIFI_FRAME_TYPE {
	WIFI_MGT_TYPE = 0,
	WIFI_CTRL_TYPE = 4,
	WIFI_DATA_TYPE = 8,
	WIFI_QOS_DATA_TYPE = 136,
};

struct rtw_ieee80211_ht_cap {
	short unsigned int cap_info;
	unsigned char ampdu_params_info;
	unsigned char supp_mcs_set[16];
	short unsigned int extended_ht_cap_info;
	unsigned int tx_BF_cap_info;
	unsigned char antenna_selection_info;
} __attribute__((packed));

struct HT_caps_element {
	union {
		struct {
			short unsigned int HT_caps_info;
			unsigned char AMPDU_para;
			unsigned char MCS_rate[16];
			short unsigned int HT_ext_caps;
			unsigned int Beamforming_caps;
			unsigned char ASEL_caps;
		} HT_cap_element;
		unsigned char HT_cap[26];
	} u;
};

struct HT_info_element {
	unsigned char primary_channel;
	unsigned char infos[5];
	unsigned char MCS_rate[16];
};

struct AC_param {
	unsigned char ACI_AIFSN;
	unsigned char CW;
	short unsigned int TXOP_limit;
};

struct WMM_para_element {
	unsigned char QoS_info;
	unsigned char reserved;
	struct AC_param ac_param[4];
};

struct ADDBA_request {
	unsigned char dialog_token;
	short unsigned int BA_para_set;
	short unsigned int BA_timeout_value;
	short unsigned int BA_starting_seqctrl;
} __attribute__((packed));

enum P2P_ROLE {
	P2P_ROLE_DISABLE = 0,
	P2P_ROLE_DEVICE = 1,
	P2P_ROLE_CLIENT = 2,
	P2P_ROLE_GO = 3,
};

enum P2P_STATE {
	P2P_STATE_NONE = 0,
	P2P_STATE_IDLE = 1,
	P2P_STATE_LISTEN = 2,
	P2P_STATE_SCAN = 3,
	P2P_STATE_FIND_PHASE_LISTEN = 4,
	P2P_STATE_FIND_PHASE_SEARCH = 5,
	P2P_STATE_TX_PROVISION_DIS_REQ = 6,
	P2P_STATE_RX_PROVISION_DIS_RSP = 7,
	P2P_STATE_RX_PROVISION_DIS_REQ = 8,
	P2P_STATE_GONEGO_ING = 9,
	P2P_STATE_GONEGO_OK = 10,
	P2P_STATE_GONEGO_FAIL = 11,
	P2P_STATE_RECV_INVITE_REQ_MATCH = 12,
	P2P_STATE_PROVISIONING_ING = 13,
	P2P_STATE_PROVISIONING_DONE = 14,
	P2P_STATE_TX_INVITE_REQ = 15,
	P2P_STATE_RX_INVITE_RESP_OK = 16,
	P2P_STATE_RECV_INVITE_REQ_DISMATCH = 17,
	P2P_STATE_RECV_INVITE_REQ_GO = 18,
	P2P_STATE_RECV_INVITE_REQ_JOIN = 19,
	P2P_STATE_RX_INVITE_RESP_FAIL = 20,
	P2P_STATE_RX_INFOR_NOREADY = 21,
	P2P_STATE_TX_INFOR_NOREADY = 22,
};

enum P2P_WPSINFO {
	P2P_NO_WPSINFO = 0,
	P2P_GOT_WPSINFO_PEER_DISPLAY_PIN = 1,
	P2P_GOT_WPSINFO_SELF_DISPLAY_PIN = 2,
	P2P_GOT_WPSINFO_PBC = 3,
};

enum P2P_PS_STATE {
	P2P_PS_DISABLE = 0,
	P2P_PS_ENABLE = 1,
	P2P_PS_SCAN = 2,
	P2P_PS_SCAN_DONE = 3,
	P2P_PS_ALLSTASLEEP = 4,
};

enum P2P_PS_MODE {
	P2P_PS_NONE = 0,
	P2P_PS_CTWINDOW = 1,
	P2P_PS_NOA = 2,
	P2P_PS_MIX = 3,
};

enum RTW_ROCH_WK_ID {
	ROCH_RO_CH_WK = 0,
	ROCH_CANCEL_RO_CH_WK = 1,
	ROCH_AP_ROCH_CH_SWITCH_PROCESS_WK = 2,
};

enum NETWORK_TYPE {
	WIRELESS_INVALID = 0,
	WIRELESS_11B = 1,
	WIRELESS_11G = 2,
	WIRELESS_11A = 4,
	WIRELESS_11_24N = 8,
	WIRELESS_11_5N = 16,
	WIRELESS_AUTO = 32,
	WIRELESS_11AC = 64,
	WIRELESS_11BG = 3,
	WIRELESS_11G_24N = 10,
	WIRELESS_11A_5N = 20,
	WIRELESS_11B_24N = 9,
	WIRELESS_11BG_24N = 11,
	WIRELESS_11_24AC = 67,
	WIRELESS_11_5AC = 68,
	WIRELESS_11AGN = 30,
	WIRELESS_11ABGN = 31,
	WIRELESS_MODE_24G = 11,
	WIRELESS_MODE_5G = 84,
	WIRELESS_MODE_MAX = 95,
};

enum MGN_RATE {
	MGN_1M = 2,
	MGN_2M = 4,
	MGN_5_5M = 11,
	MGN_6M = 12,
	MGN_9M = 18,
	MGN_11M = 22,
	MGN_12M = 24,
	MGN_18M = 36,
	MGN_24M = 48,
	MGN_36M = 72,
	MGN_48M = 96,
	MGN_54M = 108,
	MGN_MCS32 = 127,
	MGN_MCS0 = 128,
	MGN_MCS1 = 129,
	MGN_MCS2 = 130,
	MGN_MCS3 = 131,
	MGN_MCS4 = 132,
	MGN_MCS5 = 133,
	MGN_MCS6 = 134,
	MGN_MCS7 = 135,
	MGN_MCS8 = 136,
	MGN_MCS9 = 137,
	MGN_MCS10 = 138,
	MGN_MCS11 = 139,
	MGN_MCS12 = 140,
	MGN_MCS13 = 141,
	MGN_MCS14 = 142,
	MGN_MCS15 = 143,
	MGN_MCS16 = 144,
	MGN_MCS17 = 145,
	MGN_MCS18 = 146,
	MGN_MCS19 = 147,
	MGN_MCS20 = 148,
	MGN_MCS21 = 149,
	MGN_MCS22 = 150,
	MGN_MCS23 = 151,
	MGN_MCS24 = 152,
	MGN_MCS25 = 153,
	MGN_MCS26 = 154,
	MGN_MCS27 = 155,
	MGN_MCS28 = 156,
	MGN_MCS29 = 157,
	MGN_MCS30 = 158,
	MGN_MCS31 = 159,
	MGN_VHT1SS_MCS0 = 160,
	MGN_VHT1SS_MCS1 = 161,
	MGN_VHT1SS_MCS2 = 162,
	MGN_VHT1SS_MCS3 = 163,
	MGN_VHT1SS_MCS4 = 164,
	MGN_VHT1SS_MCS5 = 165,
	MGN_VHT1SS_MCS6 = 166,
	MGN_VHT1SS_MCS7 = 167,
	MGN_VHT1SS_MCS8 = 168,
	MGN_VHT1SS_MCS9 = 169,
	MGN_VHT2SS_MCS0 = 170,
	MGN_VHT2SS_MCS1 = 171,
	MGN_VHT2SS_MCS2 = 172,
	MGN_VHT2SS_MCS3 = 173,
	MGN_VHT2SS_MCS4 = 174,
	MGN_VHT2SS_MCS5 = 175,
	MGN_VHT2SS_MCS6 = 176,
	MGN_VHT2SS_MCS7 = 177,
	MGN_VHT2SS_MCS8 = 178,
	MGN_VHT2SS_MCS9 = 179,
	MGN_VHT3SS_MCS0 = 180,
	MGN_VHT3SS_MCS1 = 181,
	MGN_VHT3SS_MCS2 = 182,
	MGN_VHT3SS_MCS3 = 183,
	MGN_VHT3SS_MCS4 = 184,
	MGN_VHT3SS_MCS5 = 185,
	MGN_VHT3SS_MCS6 = 186,
	MGN_VHT3SS_MCS7 = 187,
	MGN_VHT3SS_MCS8 = 188,
	MGN_VHT3SS_MCS9 = 189,
	MGN_VHT4SS_MCS0 = 190,
	MGN_VHT4SS_MCS1 = 191,
	MGN_VHT4SS_MCS2 = 192,
	MGN_VHT4SS_MCS3 = 193,
	MGN_VHT4SS_MCS4 = 194,
	MGN_VHT4SS_MCS5 = 195,
	MGN_VHT4SS_MCS6 = 196,
	MGN_VHT4SS_MCS7 = 197,
	MGN_VHT4SS_MCS8 = 198,
	MGN_VHT4SS_MCS9 = 199,
	MGN_UNKNOWN = 200,
};

enum _RATE_SECTION {
	CCK = 0,
	OFDM = 1,
	HT_MCS0_MCS7 = 2,
	HT_MCS8_MCS15 = 3,
	HT_MCS16_MCS23 = 4,
	HT_MCS24_MCS31 = 5,
	HT_1SS = 2,
	HT_2SS = 3,
	HT_3SS = 4,
	HT_4SS = 5,
	VHT_1SSMCS0_1SSMCS9 = 6,
	VHT_2SSMCS0_2SSMCS9 = 7,
	VHT_3SSMCS0_3SSMCS9 = 8,
	VHT_4SSMCS0_4SSMCS9 = 9,
	VHT_1SS = 6,
	VHT_2SS = 7,
	VHT_3SS = 8,
	VHT_4SS = 9,
	RATE_SECTION_NUM = 10,
};

typedef enum _RATE_SECTION RATE_SECTION;

struct rtw_ieee80211_channel {
	u16 hw_value;
	u32 flags;
};

struct qos_priv {
	unsigned int qos_option;
};

struct ht_priv {
	u8 ht_option;
	u8 ampdu_enable;
	u8 tx_amsdu_enable;
	u8 bss_coexist;
	u32 tx_amsdu_maxlen;
	u32 rx_ampdu_maxlen;
	u8 rx_ampdu_min_spacing;
	u8 ch_offset;
	u8 sgi_20m;
	u8 sgi_40m;
	u8 agg_enable_bitmap;
	u8 candidate_tid_bitmap;
	u8 ldpc_cap;
	u8 stbc_cap;
	u8 beamform_cap;
	u8 smps_cap;
	u8 op_present: 1;
	struct rtw_ieee80211_ht_cap ht_cap;
	u8 ht_op[22];
	char: 8;
} __attribute__((packed));

struct _RT_LINK_DETECT_T {
	u32 NumTxOkInPeriod;
	u32 NumRxOkInPeriod;
	u32 NumRxUnicastOkInPeriod;
	BOOLEAN bBusyTraffic;
	BOOLEAN bTxBusyTraffic;
	BOOLEAN bRxBusyTraffic;
	BOOLEAN bHigherBusyTraffic;
	BOOLEAN bHigherBusyRxTraffic;
	BOOLEAN bHigherBusyTxTraffic;
	u8 TrafficTransitionCount;
	u32 LowPowerTransitionCount;
};

typedef struct _RT_LINK_DETECT_T RT_LINK_DETECT_T;

enum _RT_SCAN_TYPE {
	SCAN_PASSIVE = 0,
	SCAN_ACTIVE = 1,
	SCAN_MIX = 2,
};

typedef enum _RT_SCAN_TYPE RT_SCAN_TYPE;

struct mlme_priv {
	_lock lock;
	sint fw_state;
	u8 to_join;
	u16 join_status;
	u8 to_roam;
	struct wlan_network *roam_network;
	u8 roam_flags;
	u8 roam_rssi_diff_th;
	u32 roam_scan_int;
	u32 roam_scanr_exp_ms;
	u8 roam_tgt_addr[6];
	u8 roam_rssi_threshold;
	systime last_roaming;
	bool need_to_roam;
	_lock clnt_auth_lock;
	u32 defs_lmt_sta;
	u32 defs_lmt_time;
	u8 *nic_hdl;
	u32 max_bss_cnt;
	_list *pscanned;
	_queue free_bss_pool;
	_queue scanned_queue;
	u8 *free_bss_buf;
	u32 num_of_scanned;
	NDIS_802_11_SSID assoc_ssid;
	u8 assoc_bssid[6];
	u16 assoc_ch;
	struct wlan_network cur_network;
	struct wlan_network *cur_network_scanned;
	struct beacon_keys cur_beacon_keys;
	u32 auto_scan_int_ms;
	_timer assoc_timer;
	uint assoc_by_bssid;
	uint assoc_by_rssi;
	_timer scan_to_timer;
	systime scan_start_time;
	_timer set_scan_deny_timer;
	atomic_t set_scan_deny;
	u8 wpa_phase;
	struct qos_priv qospriv;
	bool active_tpc_report;
	int num_sta_no_ht;
	int num_FortyMHzIntolerant;
	struct ht_priv htpriv;
	RT_LINK_DETECT_T LinkDetectInfo;
	u8 acm_mask;
	RT_SCAN_TYPE scan_mode;
	u8 *wps_probe_req_ie;
	u32 wps_probe_req_ie_len;
	u8 ext_capab_ie_data[10];
	u8 ext_capab_ie_len;
	int num_sta_non_erp;
	int num_sta_no_short_slot_time;
	int num_sta_no_short_preamble;
	atomic_t olbc;
	int num_sta_ht_no_gf;
	int num_sta_ht_20mhz;
	int num_sta_40mhz_intolerant;
	atomic_t olbc_ht;
	int ht_20mhz_width_req;
	int ht_intolerant_ch_reported;
	u16 ht_op_mode;
	u8 sw_to_20mhz;
	u8 *assoc_req;
	u32 assoc_req_len;
	u8 *assoc_rsp;
	u32 assoc_rsp_len;
	u8 *wps_beacon_ie;
	u32 wps_beacon_ie_len;
	u8 *wps_probe_resp_ie;
	u32 wps_probe_resp_ie_len;
	u8 *wps_assoc_resp_ie;
	u32 wps_assoc_resp_ie_len;
	u8 *p2p_beacon_ie;
	u32 p2p_beacon_ie_len;
	u8 *p2p_probe_req_ie;
	u32 p2p_probe_req_ie_len;
	u8 *p2p_probe_resp_ie;
	u32 p2p_probe_resp_ie_len;
	u8 *p2p_go_probe_resp_ie;
	u32 p2p_go_probe_resp_ie_len;
	u8 *p2p_assoc_req_ie;
	u32 p2p_assoc_req_ie_len;
	u8 *p2p_assoc_resp_ie;
	u32 p2p_assoc_resp_ie_len;
	_lock bcn_update_lock;
	u8 update_bcn;
	u8 ori_ch;
	u8 ori_bw;
	u8 ori_offset;
	u8 ap_isolate;
	u8 *wfd_beacon_ie;
	u32 wfd_beacon_ie_len;
	u8 *wfd_probe_req_ie;
	u32 wfd_probe_req_ie_len;
	u8 *wfd_probe_resp_ie;
	u32 wfd_probe_resp_ie_len;
	u8 *wfd_go_probe_resp_ie;
	u32 wfd_go_probe_resp_ie_len;
	u8 *wfd_assoc_req_ie;
	u32 wfd_assoc_req_ie_len;
	u8 *wfd_assoc_resp_ie;
	u32 wfd_assoc_resp_ie_len;
	systime lastscantime;
	u8 scanning_via_buddy_intf;
};

struct ss_res {
	u8 state;
	u8 next_state;
	int bss_cnt;
	u8 activate_ch_cnt;
	int channel_idx;
	u8 force_ssid_scan;
	int scan_mode;
	u16 scan_ch_ms;
	u32 scan_timeout_ms;
	u8 rx_ampdu_accept;
	u8 rx_ampdu_size;
	u8 igi_scan;
	u8 igi_before_scan;
	u8 backop_flags_sta;
	u8 backop_flags_ap;
	u8 backop_flags;
	u8 scan_cnt;
	u8 scan_cnt_max;
	systime backop_time;
	u16 backop_ms;
	u8 ssid_num;
	u8 ch_num;
	NDIS_802_11_SSID ssid[9];
	struct rtw_ieee80211_channel ch[51];
	u32 token;
	u16 duration;
	u8 igi;
	u8 bw;
	bool acs;
};

struct mlme_ext_info {
	u32 state;
	u32 reauth_count;
	u32 reassoc_count;
	u32 link_count;
	u32 auth_seq;
	u32 auth_algo;
	u16 auth_status;
	short: 16;
	u32 authModeToggle;
	u32 enc_algo;
	u32 key_index;
	u32 iv;
	u8 chg_txt[128];
	u16 aid;
	u16 bcn_interval;
	u16 capability;
	u8 assoc_AP_vendor;
	u8 slotTime;
	u8 preamble_mode;
	u8 WMM_enable;
	u8 ERP_enable;
	u8 ERP_IE;
	u8 HT_enable;
	u8 HT_caps_enable;
	u8 HT_info_enable;
	u8 HT_protection;
	u8 turboMode_cts2self;
	u8 turboMode_rtsen;
	u8 SM_PS;
	u8 agg_enable_bitmap;
	u8 ADDBA_retry_count;
	u8 candidate_tid_bitmap;
	u8 dialogToken;
	BOOLEAN bAcceptAddbaReq;
	u8 bwmode_updated;
	u8 hidden_ssid_mode;
	u8 VHT_enable;
	u8 ip_addr[4];
	u8 ip6_addr[16];
	struct ADDBA_request ADDBA_req;
	struct WMM_para_element WMM_param;
	struct HT_caps_element HT_caps;
	struct HT_info_element HT_info;
	WLAN_BSSID_EX network;
	short: 16;
} __attribute__((packed));

struct _ADAPTER;

typedef struct _ADAPTER _adapter;

struct mlme_ext_priv {
	_adapter *padapter;
	u8 mlmeext_init;
	atomic_t event_seq;
	u16 mgnt_seq;
	u16 sa_query_seq;
	unsigned char cur_channel;
	unsigned char cur_bwmode;
	unsigned char cur_ch_offset;
	unsigned char cur_wireless_mode;
	unsigned char basicrate[13];
	unsigned char datarate[13];
	unsigned char default_supported_mcs_set[16];
	struct ss_res sitesurvey_res;
	struct mlme_ext_info mlmext_info;
	_timer survey_timer;
	_timer link_timer;
	systime last_scan_time;
	u8 scan_abort;
	u8 join_abort;
	u8 tx_rate;
	RATE_SECTION tx_rate_section;
	u32 retry;
	u64 TSFValue;
	u32 bcn_cnt;
	u32 last_bcn_cnt;
	u8 cur_bcn_cnt;
	u8 dtim;
	unsigned char bstart_bss;
	u8 action_public_dialog_token;
	u16 action_public_rxseq;
	u8 active_keep_alive_check;
	u8 tsf_update_required: 1;
	u8 en_hw_update_tsf: 1;
	systime tsf_update_pause_stime;
	u8 tsf_update_pause_factor;
	u8 tsf_update_restore_factor;
	_timer csa_timer;
};

struct cmd_priv {
	_sema cmd_queue_sema;
	_sema start_cmdthread_sema;
	_queue cmd_queue;
	u8 cmd_seq;
	u8 *cmd_buf;
	u8 *cmd_allocated_buf;
	u8 *rsp_buf;
	u8 *rsp_allocated_buf;
	u32 cmd_issued_cnt;
	u32 cmd_done_cnt;
	u32 rsp_cnt;
	atomic_t cmdthd_running;
	_adapter *padapter;
	_mutex sctx_mutex;
};

struct evt_priv {
	atomic_t event_seq;
	u8 *evt_buf;
	u8 *evt_allocated_buf;
	u32 evt_done_cnt;
	u8 *c2h_mem;
	u8 *allocated_c2h_mem;
};

struct intf_hdl;

struct io_queue;

struct _io_ops {
	u8 (*_read8)(struct intf_hdl *, u32);
	u16 (*_read16)(struct intf_hdl *, u32);
	u32 (*_read32)(struct intf_hdl *, u32);
	int (*_write8)(struct intf_hdl *, u32, u8);
	int (*_write16)(struct intf_hdl *, u32, u16);
	int (*_write32)(struct intf_hdl *, u32, u32);
	int (*_writeN)(struct intf_hdl *, u32, u32, u8 *);
	int (*_write8_async)(struct intf_hdl *, u32, u8);
	int (*_write16_async)(struct intf_hdl *, u32, u16);
	int (*_write32_async)(struct intf_hdl *, u32, u32);
	void (*_read_mem)(struct intf_hdl *, u32, u32, u8 *);
	void (*_write_mem)(struct intf_hdl *, u32, u32, u8 *);
	void (*_sync_irp_protocol_rw)(struct io_queue *);
	u32 (*_read_interrupt)(struct intf_hdl *, u32);
	u32 (*_read_port)(struct intf_hdl *, u32, u32, u8 *);
	u32 (*_write_port)(struct intf_hdl *, u32, u32, u8 *);
	u32 (*_write_scsi)(struct intf_hdl *, u32, u8 *);
	void (*_read_port_cancel)(struct intf_hdl *);
	void (*_write_port_cancel)(struct intf_hdl *);
	u8 (*_sd_f0_read8)(struct intf_hdl *, u32);
};

struct dvobj_priv;

struct intf_hdl {
	_adapter *padapter;
	struct dvobj_priv *pintf_dev;
	struct _io_ops io_ops;
};

struct io_priv {
	_adapter *padapter;
	struct intf_hdl intf;
};

struct submit_ctx;

struct xmit_buf {
	_list list;
	_adapter *padapter;
	u8 *pallocated_buf;
	u8 *pbuf;
	void *priv_data;
	u16 buf_tag;
	u16 flags;
	u32 alloc_sz;
	u32 len;
	struct submit_ctx *sctx;
	u8 *phead;
	u8 *pdata;
	u8 *ptail;
	u8 *pend;
	u32 ff_hwaddr;
	u8 pg_num;
	u8 agg_num;
};

struct submit_ctx {
	systime submit_time;
	u32 timeout_ms;
	int status;
	struct completion done;
};

struct hw_xmit;

struct xmit_priv {
	_lock lock;
	_sema xmit_sema;
	_queue be_pending;
	_queue bk_pending;
	_queue vi_pending;
	_queue vo_pending;
	_queue mgmt_pending;
	u8 *pallocated_frame_buf;
	u8 *pxmit_frame_buf;
	uint free_xmitframe_cnt;
	_queue free_xmit_queue;
	u8 *xframe_ext_alloc_addr;
	u8 *xframe_ext;
	uint free_xframe_ext_cnt;
	_queue free_xframe_ext_queue;
	uint frag_len;
	_adapter *adapter;
	u8 vcs_setting;
	u8 vcs;
	u8 vcs_type;
	u64 tx_bytes;
	u64 tx_pkts;
	u64 tx_drop;
	u64 last_tx_pkts;
	struct hw_xmit *hwxmits;
	u8 hwxmit_entry;
	u8 wmm_para_seq[4];
	_thread_hdl_ SdioXmitThread;
	_sema SdioXmitSema;
	_queue free_xmitbuf_queue;
	_queue pending_xmitbuf_queue;
	u8 *pallocated_xmitbuf;
	u8 *pxmitbuf;
	uint free_xmitbuf_cnt;
	_queue free_xmit_extbuf_queue;
	u8 *pallocated_xmit_extbuf;
	u8 *pxmit_extbuf;
	uint free_xmit_extbuf_cnt;
	struct xmit_buf pcmd_xmitbuf[2];
	u8 hw_ssn_seq_no;
	u16 nqos_ssn;
	int ack_tx;
	_mutex ack_tx_mutex;
	struct submit_ctx ack_tx_ops;
	u8 seq_no;
	_queue rpkt_queue;
	_lock lock_sctx;
};

struct rx_raw_rssi {
	u8 data_rate;
	u8 pwdball;
	s8 pwr_all;
	u8 mimo_signal_strength[4];
	u8 mimo_signal_quality[4];
	s8 ofdm_pwr[4];
	u8 ofdm_snr[4];
};

struct signal_stat {
	u8 update_req;
	u8 avg_val;
	u32 total_num;
	u32 total_val;
};

struct recv_priv {
	_lock lock;
	_sema recv_sema;
	_queue free_recv_queue;
	_queue recv_pending_queue;
	_queue uc_swdec_pending_queue;
	u8 *pallocated_frame_buf;
	u8 *precv_frame_buf;
	uint free_recvframe_cnt;
	_adapter *adapter;
	u32 is_any_non_be_pkts;
	u64 rx_bytes;
	u64 rx_pkts;
	u64 rx_drop;
	u64 dbg_rx_drop_count;
	u64 dbg_rx_ampdu_drop_count;
	u64 dbg_rx_ampdu_forced_indicate_count;
	u64 dbg_rx_ampdu_loss_count;
	u64 dbg_rx_dup_mgt_frame_drop_count;
	u64 dbg_rx_ampdu_window_shift_cnt;
	u64 dbg_rx_conflic_mac_addr_cnt;
	uint rx_icv_err;
	uint rx_largepacket_crcerr;
	uint rx_smallpacket_crcerr;
	uint rx_middlepacket_crcerr;
	_tasklet irq_prepare_beacon_tasklet;
	_tasklet recv_tasklet;
	struct sk_buff_head free_recv_skb_queue;
	struct sk_buff_head rx_skb_queue;
	struct sk_buff_head rx_napi_skb_queue;
	u8 *pallocated_recv_buf;
	u8 *precv_buf;
	_queue free_recv_buf_queue;
	u32 free_recv_buf_queue_cnt;
	_queue recv_buf_pending_queue;
	u8 is_signal_dbg;
	u8 signal_strength_dbg;
	u8 signal_strength;
	u8 signal_qual;
	s8 rssi;
	struct rx_raw_rssi raw_rssi_info;
	_timer signal_stat_timer;
	u32 signal_stat_sampling_interval;
	struct signal_stat signal_qual_data;
	struct signal_stat signal_strength_data;
	u16 sink_udpport;
	u16 pre_rtp_rxseq;
	u16 cur_rtp_rxseq;
	BOOLEAN store_law_data_flag;
};

struct rtw_wlan_acl_node {
	_list list;
	u8 addr[6];
	u8 valid;
};

struct wlan_acl_pool {
	int mode;
	int num;
	struct rtw_wlan_acl_node aclnode[16];
	_queue acl_node_q;
};

struct sta_info;

struct sta_priv {
	u8 *pallocated_stainfo_buf;
	u8 *pstainfo_buf;
	_queue free_sta_queue;
	_lock sta_hash_lock;
	_list sta_hash[32];
	int asoc_sta_count;
	_queue sleep_q;
	_queue wakeup_q;
	_adapter *padapter;
	u32 adhoc_expire_to;
	int rx_chk_limit;
	_list asoc_list;
	_list auth_list;
	_lock asoc_list_lock;
	_lock auth_list_lock;
	u8 asoc_list_cnt;
	u8 auth_list_cnt;
	unsigned int auth_to;
	unsigned int assoc_to;
	unsigned int expire_to;
	struct sta_info **sta_aid;
	u16 max_aid;
	u16 started_aid;
	bool rr_aid;
	u8 aid_bmp_len;
	u8 *sta_dz_bitmap;
	u8 *tim_bitmap;
	u16 max_num_sta;
	struct wlan_acl_pool acl_list[2];
	u8 c2h_sta_mac[6];
	u8 c2h_adapter_id;
	struct submit_ctx *gotc2h;
};

union Keytype {
	u8 skey[32];
};

union pn48 {
	u64 val;
	struct {
		u8 TSC0;
		u8 TSC1;
		u8 TSC2;
		u8 TSC3;
		u8 TSC4;
		u8 TSC5;
		u8 TSC6;
		u8 TSC7;
	} _byte_;
};

enum security_type {
	_NO_PRIVACY_ = 0,
	_WEP40_ = 1,
	_TKIP_ = 2,
	_TKIP_WTMIC_ = 3,
	_AES_ = 4,
	_WEP104_ = 5,
	_SMS4_ = 6,
	_GCMP_ = 7,
	_SEC_TYPE_MAX_ = 8,
	_SEC_TYPE_256_ = 16,
	_CCMP_256_ = 20,
	_GCMP_256_ = 23,
	_SEC_TYPE_BIT_ = 32,
	_BIP_CMAC_128_ = 32,
	_BIP_GMAC_128_ = 33,
	_BIP_GMAC_256_ = 34,
	_BIP_CMAC_256_ = 35,
	_BIP_MAX_ = 36,
};

struct _RT_PMKID_LIST {
	u8 bUsed;
	u8 Bssid[6];
	u8 PMKID[16];
	u8 SsidBuf[33];
	u8 *ssid_octet;
	u16 ssid_length;
};

typedef struct _RT_PMKID_LIST RT_PMKID_LIST;

struct security_priv {
	u32 dot11AuthAlgrthm;
	u32 dot11PrivacyAlgrthm;
	u32 dot11PrivacyKeyIndex;
	union Keytype dot11DefKey[6];
	u32 dot11DefKeylen[6];
	u8 dot11Def_camid[6];
	u8 key_mask;
	u32 dot118021XGrpPrivacy;
	u32 dot118021XGrpKeyid;
	union Keytype dot118021XGrpKey[6];
	union Keytype dot118021XGrptxmickey[6];
	union Keytype dot118021XGrprxmickey[6];
	union pn48 dot11Grptxpn;
	union pn48 dot11Grprxpn;
	u8 iv_seq[32];
	enum security_type dot11wCipher;
	u32 dot11wBIPKeyid;
	union Keytype dot11wBIPKey[6];
	union pn48 dot11wBIPtxpn;
	union pn48 dot11wBIPrxpn;
	unsigned int dot8021xalg;
	unsigned int wpa_psk;
	unsigned int wpa_group_cipher;
	unsigned int wpa2_group_cipher;
	unsigned int wpa_pairwise_cipher;
	unsigned int wpa2_pairwise_cipher;
	unsigned int akmp;
	u8 mfp_opt;
	u8 dot118021x_bmc_cam_id;
	u32 rsn_akm_suite_type;
	u8 wps_ie[512];
	int wps_ie_len;
	u8 owe_ie[128];
	int owe_ie_len;
	u8 binstallGrpkey;
	u8 binstallBIPkey;
	u8 busetkipkey;
	u8 bcheck_grpkey;
	u8 bgrpkey_handshake;
	u8 auth_alg;
	u8 auth_type;
	u8 extauth_status;
	s32 sw_encrypt;
	s32 sw_decrypt;
	s32 hw_decrypted;
	u32 ndisauthtype;
	u32 ndisencryptstatus;
	NDIS_802_11_WEP ndiswep;
	u8 assoc_info[600];
	u8 szofcapability[256];
	u8 oidassociation[512];
	u8 authenticator_ie[256];
	u8 supplicant_ie[256];
	systime last_mic_err_time;
	u8 btkip_countermeasure;
	u8 btkip_wait_report;
	systime btkip_countermeasure_time;
	RT_PMKID_LIST PMKIDList[16];
	u8 PMKIDIndex;
	u8 bWepDefaultKeyIdxSet;
	u64 wep_sw_enc_cnt_bc;
	u64 wep_sw_enc_cnt_mc;
	u64 wep_sw_enc_cnt_uc;
	u64 wep_sw_dec_cnt_bc;
	u64 wep_sw_dec_cnt_mc;
	u64 wep_sw_dec_cnt_uc;
	u64 tkip_sw_enc_cnt_bc;
	u64 tkip_sw_enc_cnt_mc;
	u64 tkip_sw_enc_cnt_uc;
	u64 tkip_sw_dec_cnt_bc;
	u64 tkip_sw_dec_cnt_mc;
	u64 tkip_sw_dec_cnt_uc;
	u64 aes_sw_enc_cnt_bc;
	u64 aes_sw_enc_cnt_mc;
	u64 aes_sw_enc_cnt_uc;
	u64 aes_sw_dec_cnt_bc;
	u64 aes_sw_dec_cnt_mc;
	u64 aes_sw_dec_cnt_uc;
	u64 gcmp_sw_enc_cnt_bc;
	u64 gcmp_sw_enc_cnt_mc;
	u64 gcmp_sw_enc_cnt_uc;
	u64 gcmp_sw_dec_cnt_bc;
	u64 gcmp_sw_dec_cnt_mc;
	u64 gcmp_sw_dec_cnt_uc;
};

struct tx_aclt_conf_t {
	u8 en;
	u32 vo_vi;
	u32 be_bk;
};

struct registry_priv {
	u8 chip_version;
	u8 rfintfs;
	u8 lbkmode;
	u8 hci;
	NDIS_802_11_SSID ssid;
	u8 network_mode;
	u8 channel;
	u8 wireless_mode;
	u8 scan_mode;
	u8 radio_enable;
	u8 preamble;
	u8 vrtl_carrier_sense;
	u8 vcs_type;
	u16 rts_thresh;
	u16 frag_thresh;
	u8 adhoc_tx_pwr;
	u8 soft_ap;
	u8 power_mgnt;
	u8 ips_mode;
	u8 lps_level;
	u8 lps_chk_by_tp;
	u8 smart_ps;
	u8 usb_rxagg_mode;
	u8 dynamic_agg_enable;
	u8 long_retry_lmt;
	u8 short_retry_lmt;
	char: 8;
	u16 busy_thresh;
	u16 max_bss_cnt;
	u8 ack_policy;
	u8 mp_mode;
	u8 mp_customer_str;
	u8 mp_dm;
	u8 software_encrypt;
	u8 software_decrypt;
	u8 acm_method;
	u8 wmm_enable;
	WLAN_BSSID_EX dev_network;
	u8 tx_aclt_flags;
	int: 24;
	struct tx_aclt_conf_t tx_aclt_confs[3];
	u8 tx_bw_mode;
	u8 bmc_tx_rate;
	u8 ap_src_b2u_flags;
	u8 ap_fwd_b2u_flags;
	u8 ht_enable;
	u8 bw_mode;
	u8 ampdu_enable;
	u8 rx_stbc;
	u8 rx_ampdu_amsdu;
	u8 tx_ampdu_amsdu;
	u8 tx_quick_addba_req;
	u8 rx_ampdu_sz_limit_by_nss_bw[16];
	u8 short_gi;
	u8 ldpc_cap;
	u8 stbc_cap;
	u8 beamform_cap;
	u8 beamformer_rf_num;
	u8 beamformee_rf_num;
	u8 low_power;
	u8 wifi_spec;
	u8 trx_path_bmp;
	u8 tx_path_lmt;
	u8 rx_path_lmt;
	u8 tx_nss;
	u8 rx_nss;
	u8 active_tpc_report;
	char alpha2[2];
	u8 channel_plan;
	u8 excl_chs[42];
	u8 full_ch_in_p2p_handshake;
	u8 btcoex;
	u8 bt_iso;
	u8 bt_sco;
	u8 bt_ampdu;
	u8 ant_num;
	u8 single_ant_path;
	BOOLEAN bAcceptAddbaReq;
	u8 antdiv_cfg;
	u8 antdiv_type;
	u8 drv_ant_band_switch;
	u8 switch_usb_mode;
	u8 usbss_enable;
	u8 hwpdn_mode;
	u8 hwpwrp_detect;
	u8 hw_wps_pbc;
	u8 max_roaming_times;
	u8 ifname[16];
	u8 if2name[16];
	u8 notch_filter;
	u8 pll_ref_clk_sel;
	u8 RegEnableTxPowerLimit;
	u8 RegEnableTxPowerByRate;
	u8 target_tx_pwr_valid;
	s8 target_tx_pwr_2g[40];
	s16 antenna_gain;
	u8 tsf_update_pause_factor;
	u8 tsf_update_restore_factor;
	s8 TxBBSwing_2G;
	s8 TxBBSwing_5G;
	u8 AmplifierType_2G;
	u8 AmplifierType_5G;
	u8 bEn_RFE;
	u8 RFE_Type;
	u8 PowerTracking_Type;
	u8 GLNA_Type;
	u8 check_fw_ps;
	u8 RegPwrTrimEnable;
	u8 load_phy_file;
	u8 RegDecryptCustomFile;
	u8 virtual_iface_num;
	u8 sel_p2p_iface;
	u8 qos_opt_enable;
	u8 hiq_filter;
	u8 adaptivity_en;
	u8 adaptivity_mode;
	s8 adaptivity_th_l2h_ini;
	s8 adaptivity_th_edcca_hl_diff;
	u8 boffefusemask;
	BOOLEAN bFileMaskEfuse;
	BOOLEAN bBTFileMaskEfuse;
	char: 8;
	u32 reg_rxgain_offset_2g;
	u32 reg_rxgain_offset_5gl;
	u32 reg_rxgain_offset_5gm;
	u32 reg_rxgain_offset_5gh;
	u8 amsdu_mode;
	u8 en_napi;
	u8 en_gro;
	u8 recvbuf_nr;
	u8 check_hw_status;
	u8 wowlan_sta_mix_mode;
	u8 iqk_fw_offload;
	u8 ch_switch_offload;
	u32 phydm_ability;
	u32 halrf_ability;
	u8 en_dyn_rrsr;
	int: 24;
	u32 set_rrsr_value;
	u32 scan_interval_thr;
} __attribute__((packed));

struct mp_wiparam {
	u32 bcompleted;
	u32 act_type;
	u32 io_offset;
	u32 io_value;
};

struct pkt_attrib {
	u8 type;
	u8 subtype;
	u8 bswenc;
	u8 dhcp_pkt;
	u16 ether_type;
	u16 seqnum;
	u8 hw_ssn_sel;
	u16 pkt_hdrlen;
	u16 hdrlen;
	u32 pktlen;
	u32 last_txcmdsz;
	u8 nr_frags;
	u8 encrypt;
	u8 bmc_camid;
	u8 iv_len;
	u8 icv_len;
	u8 iv[18];
	u8 icv[16];
	u8 priority;
	u8 ack_policy;
	u8 mac_id;
	u8 vcs_mode;
	u8 dst[6];
	u8 src[6];
	u8 ta[6];
	u8 ra[6];
	u8 key_idx;
	u8 qos_en;
	u8 ht_en;
	u8 raid;
	u8 bwmode;
	u8 ch_offset;
	u8 sgi;
	u8 ampdu_en;
	u8 ampdu_spacing;
	u8 amsdu;
	u8 amsdu_ampdu_en;
	u8 mdata;
	u8 pctrl;
	u8 triggered;
	u8 qsel;
	u8 order;
	u8 eosp;
	u8 rate;
	u8 intel_proxim;
	u8 retry_ctrl;
	u8 mbssid;
	u8 ldpc;
	u8 stbc;
	struct sta_info *psta;
	u8 rtsen;
	u8 cts2self;
	union Keytype dot11tkiptxmickey;
	union Keytype dot118021x_UncstKey;
	u8 key_type;
	u8 icmp_pkt;
	u8 hipriority_pkt;
	u8 ps_dontq;
};

struct mp_tx {
	u8 stop;
	u32 count;
	u32 sended;
	u8 payload;
	struct pkt_attrib attrib;
	u8 desc[40];
	u8 *pallocated_buf;
	u8 *buf;
	u32 buf_size;
	u32 write_size;
	_thread_hdl_ PktTxThread;
};

struct recv_stat {
	unsigned int rxdw0;
	unsigned int rxdw1;
	unsigned int rxdw2;
	unsigned int rxdw3;
	unsigned int rxdw4;
	unsigned int rxdw5;
};

typedef void (*MPT_WORK_ITEM_HANDLER)(void *);

enum _WIRELESS_MODE {
	WIRELESS_MODE_UNKNOWN = 0,
	WIRELESS_MODE_A = 1,
	WIRELESS_MODE_B = 2,
	WIRELESS_MODE_G = 4,
	WIRELESS_MODE_AUTO = 8,
	WIRELESS_MODE_N_24G = 16,
	WIRELESS_MODE_N_5G = 32,
	WIRELESS_MODE_AC_5G = 64,
	WIRELESS_MODE_AC_24G = 128,
	WIRELESS_MODE_AC_ONLY = 256,
};

typedef enum _WIRELESS_MODE WIRELESS_MODE;

struct _RT_PMAC_TX_INFO {
	u8 bEnPMacTx: 1;
	u8 Mode: 3;
	u8 Ntx: 4;
	u8 TX_RATE;
	u8 TX_RATE_HEX;
	u8 TX_SC;
	u8 bSGI: 1;
	u8 bSPreamble: 1;
	u8 bSTBC: 1;
	u8 bLDPC: 1;
	u8 NDP_sound: 1;
	u8 BandWidth: 3;
	u8 m_STBC;
	u16 PacketPeriod;
	u32 PacketCount;
	u32 PacketLength;
	u8 PacketPattern;
	u16 SFD;
	u8 SignalField;
	u8 ServiceField;
	u16 LENGTH;
	u8 CRC16[2];
	u8 LSIG[3];
	u8 HT_SIG[6];
	u8 VHT_SIG_A[6];
	u8 VHT_SIG_B[4];
	u8 VHT_SIG_B_CRC;
	u8 VHT_Delimiter[4];
	u8 MacAddress[6];
};

typedef struct _RT_PMAC_TX_INFO RT_PMAC_TX_INFO;

struct _RT_PMAC_PKT_INFO {
	u8 MCS;
	u8 Nss;
	u8 Nsts;
	u32 N_sym;
	u8 SIGA2B3;
};

typedef struct _RT_PMAC_PKT_INFO RT_PMAC_PKT_INFO;

struct _MPT_CONTEXT {
	BOOLEAN bMassProdTest;
	BOOLEAN bMptDrvUnload;
	_sema MPh2c_Sema;
	_timer MPh2c_timeout_timer;
	BOOLEAN MptH2cRspEvent;
	BOOLEAN MptBtC2hEvent;
	BOOLEAN bMPh2c_timeout;
	BOOLEAN bMptWorkItemInProgress;
	MPT_WORK_ITEM_HANDLER CurrMptAct;
	u32 MptTestStart;
	u32 MptTestItem;
	u32 MptActType;
	u32 MptIoOffset;
	u32 MptIoValue;
	u32 mpt_rf_path;
	WIRELESS_MODE MptWirelessModeToSw;
	u8 MptChannelToSw;
	u8 MptInitGainToSet;
	u32 MptBandWidth;
	u32 mpt_rate_index;
	u8 btMpCckTxPower;
	u8 btMpOfdmTxPower;
	u8 TxPwrLevel[4];
	u32 RegTxPwrLimit;
	u32 MptRCR;
	BOOLEAN bMptFilterPattern;
	u32 MptRxOkCnt;
	u32 MptRxCrcErrCnt;
	BOOLEAN bCckContTx;
	BOOLEAN bOfdmContTx;
	BOOLEAN is_start_cont_tx;
	BOOLEAN bSingleCarrier;
	BOOLEAN is_carrier_suppression;
	BOOLEAN is_single_tone;
	BOOLEAN bMptEnableAckCounter;
	u32 MptAckCounter;
	u8 APK_bound[2];
	BOOLEAN bMptIndexEven;
	u8 backup0xc50;
	u8 backup0xc58;
	u8 backup0xc30;
	u8 backup0x52_RF_A;
	u8 backup0x52_RF_B;
	u32 backup0x58_RF_A;
	u32 backup0x58_RF_B;
	u8 h2cReqNum;
	u8 c2hBuf[32];
	u8 btInBuf[100];
	u32 mptOutLen;
	u8 mptOutBuf[100];
	RT_PMAC_TX_INFO PMacTxInfo;
	RT_PMAC_PKT_INFO PMacPktInfo;
	u8 HWTxmode;
	BOOLEAN bldpc;
	BOOLEAN bstbc;
};

typedef struct _MPT_CONTEXT MPT_CONTEXT;

struct mp_priv {
	_adapter *papdater;
	u32 mode;
	u32 prev_fw_state;
	struct mp_wiparam workparam;
	u8 TID;
	u32 tx_pktcount;
	u32 pktInterval;
	u32 pktLength;
	struct mp_tx tx;
	u32 rx_bssidpktcount;
	u32 rx_pktcount;
	u32 rx_pktcount_filter_out;
	u32 rx_crcerrpktcount;
	u32 rx_pktloss;
	BOOLEAN rx_bindicatePkt;
	struct recv_stat rxstat;
	BOOLEAN brx_filter_beacon;
	u8 channel;
	u8 bandwidth;
	u8 prime_channel_offset;
	u8 txpoweridx;
	u8 rateidx;
	u32 preamble;
	u32 CrystalCap;
	u16 antenna_tx;
	u16 antenna_rx;
	u8 check_mp_pkt;
	u8 bSetTxPower;
	u8 mp_dm;
	u8 mac_filter[6];
	u8 bmac_filter;
	u8 rf_path_cfg;
	struct wlan_network mp_network;
	NDIS_802_11_MAC_ADDRESS network_macaddr;
	u8 *pallocated_mp_xmitframe_buf;
	u8 *pmp_xmtframe_buf;
	_queue free_mp_xmitqueue;
	u32 free_mp_xmitframe_cnt;
	BOOLEAN bSetRxBssid;
	BOOLEAN bTxBufCkFail;
	BOOLEAN bRTWSmbCfg;
	BOOLEAN bloopback;
	BOOLEAN bloadefusemap;
	BOOLEAN bloadBTefusemap;
	BOOLEAN bprocess_mp_mode;
	MPT_CONTEXT mpt_ctx;
	u8 *TXradomBuffer;
	u8 CureFuseBTCoex;
	u8 mplink_buf[2048];
	u32 mplink_rx_len;
	BOOLEAN mplink_brx;
	BOOLEAN mplink_btx;
	bool tssitrk_on;
	bool efuse_update_on;
	bool efuse_update_file;
	char efuse_file_path[128];
};

struct roch_info {
	_timer ap_roch_ch_switch_timer;
	u32 min_home_dur;
	u32 max_away_dur;
	_timer remain_on_ch_timer;
	u8 restore_channel;
	struct ieee80211_channel remain_on_ch_channel;
	enum nl80211_channel_type remain_on_ch_type;
	atomic_t ro_ch_cookie_gen;
	u64 remain_on_ch_cookie;
	bool is_ro_ch;
	struct wireless_dev *ro_ch_wdev;
	systime last_ro_ch_time;
};

struct tx_provdisc_req_info {
	u16 wps_config_method_request;
	u16 peer_channel_num[2];
	NDIS_802_11_SSID ssid;
	u8 peerDevAddr[6];
	u8 peerIFAddr[6];
	u8 benable;
};

struct rx_provdisc_req_info {
	u8 peerDevAddr[6];
	u8 strconfig_method_desc_of_prov_disc_req[4];
};

struct tx_invite_req_info {
	u8 token;
	u8 benable;
	u8 go_ssid[32];
	u8 ssidlen;
	u8 go_bssid[6];
	u8 peer_macaddr[6];
	u8 operating_ch;
	u8 peer_ch;
};

struct profile_info {
	u8 ssidlen;
	u8 ssid[32];
	u8 peermac[6];
};

struct tx_invite_resp_info {
	u8 token;
};

struct tx_nego_req_info {
	u16 peer_channel_num[2];
	u8 peerDevAddr[6];
	u8 benable;
	u8 peer_ch;
};

struct group_id_info {
	u8 go_device_addr[6];
	u8 ssid[32];
};

struct scan_limit_info {
	u8 scan_op_ch_only;
	u8 operation_ch[5];
};

struct wifi_display_info;

struct wifidirect_info {
	_adapter *padapter;
	_timer find_phase_timer;
	_timer restore_p2p_state_timer;
	_timer pre_tx_scan_timer;
	_timer reset_ch_sitesurvey;
	_timer reset_ch_sitesurvey2;
	struct tx_provdisc_req_info tx_prov_disc_info;
	struct rx_provdisc_req_info rx_prov_disc_info;
	struct tx_invite_req_info invitereq_info;
	struct profile_info profileinfo[10];
	struct tx_invite_resp_info inviteresp_info;
	struct tx_nego_req_info nego_req_info;
	struct group_id_info groupid_info;
	struct scan_limit_info rx_invitereq_info;
	struct scan_limit_info p2p_info;
	struct wifi_display_info *wfd_info;
	enum P2P_ROLE role;
	enum P2P_STATE pre_p2p_state;
	enum P2P_STATE p2p_state;
	u8 device_addr[6];
	u8 interface_addr[6];
	u8 social_chan[4];
	u8 listen_channel;
	u8 operating_channel;
	u8 listen_dwell;
	u8 support_rate[8];
	u8 p2p_wildcard_ssid[7];
	u8 intent;
	u8 p2p_peer_interface_addr[6];
	u8 p2p_peer_device_addr[6];
	u8 peer_intent;
	u8 device_name[32];
	u16 device_name_len;
	u8 profileindex;
	u8 peer_operating_ch;
	u8 find_phase_state_exchange_cnt;
	u16 device_password_id_for_nego;
	u8 negotiation_dialog_token;
	u8 nego_ssid[32];
	u8 nego_ssidlen;
	u8 p2p_group_ssid[32];
	u8 p2p_group_ssid_len;
	u8 persistent_supported;
	u8 session_available;
	u8 wfd_tdls_enable;
	u8 wfd_tdls_weaksec;
	enum P2P_WPSINFO ui_got_wps_info;
	u16 supported_wps_cm;
	u8 external_uuid;
	u8 uuid[16];
	uint channel_list_attr_len;
	u8 channel_list_attr[100];
	u8 driver_interface;
	u16 ext_listen_interval;
	u16 ext_listen_period;
	enum P2P_PS_MODE p2p_ps_mode;
	enum P2P_PS_STATE p2p_ps_state;
	u8 noa_index;
	u8 ctwindow;
	u8 opp_ps;
	u8 noa_num;
	u8 noa_count[2];
	u32 noa_duration[2];
	u32 noa_interval[2];
	u32 noa_start_time[2];
};

enum SCAN_RESULT_TYPE {
	SCAN_RESULT_P2P_ONLY = 0,
	SCAN_RESULT_ALL = 1,
	SCAN_RESULT_WFD_TYPE = 2,
};

struct wifi_display_info {
	u16 wfd_enable;
	u16 init_rtsp_ctrlport;
	u16 rtsp_ctrlport;
	u16 tdls_rtsp_ctrlport;
	u16 peer_rtsp_ctrlport;
	u8 peer_session_avail;
	u8 ip_address[4];
	u8 peer_ip_address[4];
	u8 wfd_pc;
	u8 wfd_device_type;
	enum SCAN_RESULT_TYPE scan_result_type;
	u8 op_wfd_mode;
	u8 stack_wfd_mode;
};

typedef enum {
	ERR_SUCCESS = 0,
	ERR_DRIVER_FAILURE = 1,
	ERR_IO_FAILURE = 2,
	ERR_WI_TIMEOUT = 3,
	ERR_WI_BUSY = 4,
	ERR_BAD_FORMAT = 5,
	ERR_INVALID_DATA = 6,
	ERR_NOT_ENOUGH_SPACE = 7,
	ERR_WRITE_PROTECT = 8,
	ERR_READ_BACK_FAIL = 9,
	ERR_OUT_OF_RANGE = 10,
} ERROR_CODE;

enum channel_width {
	CHANNEL_WIDTH_20 = 0,
	CHANNEL_WIDTH_40 = 1,
	CHANNEL_WIDTH_80 = 2,
	CHANNEL_WIDTH_160 = 3,
	CHANNEL_WIDTH_80_80 = 4,
	CHANNEL_WIDTH_5 = 5,
	CHANNEL_WIDTH_10 = 6,
	CHANNEL_WIDTH_MAX = 7,
};

enum rf_path {
	RF_PATH_A = 0,
	RF_PATH_B = 1,
	RF_PATH_C = 2,
	RF_PATH_D = 3,
	RF_PATH_AB = 4,
	RF_PATH_AC = 5,
	RF_PATH_AD = 6,
	RF_PATH_BC = 7,
	RF_PATH_BD = 8,
	RF_PATH_CD = 9,
	RF_PATH_ABC = 10,
	RF_PATH_ABD = 11,
	RF_PATH_ACD = 12,
	RF_PATH_BCD = 13,
	RF_PATH_ABCD = 14,
};

enum _BAND_TYPE {
	BAND_ON_2_4G = 0,
	BAND_ON_5G = 1,
	BAND_MAX = 2,
};

typedef enum _BAND_TYPE BAND_TYPE;

enum _HAL_DEF_VARIABLE {
	HAL_DEF_UNDERCORATEDSMOOTHEDPWDB = 0,
	HAL_DEF_IS_SUPPORT_ANT_DIV = 1,
	HAL_DEF_DRVINFO_SZ = 2,
	HAL_DEF_MAX_RECVBUF_SZ = 3,
	HAL_DEF_RX_PACKET_OFFSET = 4,
	HAL_DEF_RX_DMA_SZ_WOW = 5,
	HAL_DEF_RX_DMA_SZ = 6,
	HAL_DEF_RX_PAGE_SIZE = 7,
	HAL_DEF_DBG_DUMP_RXPKT = 8,
	HAL_DEF_RA_DECISION_RATE = 9,
	HAL_DEF_RA_SGI = 10,
	HAL_DEF_PT_PWR_STATUS = 11,
	HAL_DEF_TX_LDPC = 12,
	HAL_DEF_RX_LDPC = 13,
	HAL_DEF_TX_STBC = 14,
	HAL_DEF_RX_STBC = 15,
	HAL_DEF_EXPLICIT_BEAMFORMER = 16,
	HAL_DEF_EXPLICIT_BEAMFORMEE = 17,
	HAL_DEF_VHT_MU_BEAMFORMER = 18,
	HAL_DEF_VHT_MU_BEAMFORMEE = 19,
	HAL_DEF_BEAMFORMER_CAP = 20,
	HAL_DEF_BEAMFORMEE_CAP = 21,
	HW_VAR_MAX_RX_AMPDU_FACTOR = 22,
	HW_DEF_RA_INFO_DUMP = 23,
	HAL_DEF_DBG_DUMP_TXPKT = 24,
	HAL_DEF_TX_PAGE_SIZE = 25,
	HAL_DEF_TX_PAGE_BOUNDARY = 26,
	HAL_DEF_TX_PAGE_BOUNDARY_WOWLAN = 27,
	HAL_DEF_TX_BUFFER_LAST_ENTRY = 28,
	HAL_DEF_ANT_DETECT = 29,
	HAL_DEF_PCI_ASPM_OSC = 30,
	HAL_DEF_EFUSE_USAGE = 31,
	HAL_DEF_EFUSE_BYTES = 32,
	HW_VAR_BEST_AMPDU_DENSITY = 33,
};

typedef enum _HAL_DEF_VARIABLE HAL_DEF_VARIABLE;

enum _HAL_ODM_VARIABLE {
	HAL_ODM_STA_INFO = 0,
	HAL_ODM_P2P_STATE = 1,
	HAL_ODM_WIFI_DISPLAY_STATE = 2,
	HAL_ODM_INITIAL_GAIN = 3,
	HAL_ODM_RX_INFO_DUMP = 4,
	HAL_ODM_RX_Dframe_INFO = 5,
};

typedef enum _HAL_ODM_VARIABLE HAL_ODM_VARIABLE;

enum _HAL_INTF_PS_FUNC {
	HAL_USB_SELECT_SUSPEND = 0,
	HAL_MAX_ID = 1,
};

typedef enum _HAL_INTF_PS_FUNC HAL_INTF_PS_FUNC;

typedef struct _ADAPTER *PADAPTER;

struct xmit_frame;

struct txpwr_idx_comp;

struct hal_ops {
	void (*read_chip_version)(_adapter *);
	void (*init_default_value)(_adapter *);
	void (*intf_chip_configure)(_adapter *);
	u8 (*read_adapter_info)(_adapter *);
	u32 (*hal_power_on)(_adapter *);
	void (*hal_power_off)(_adapter *);
	u32 (*hal_init)(_adapter *);
	u32 (*hal_deinit)(_adapter *);
	void (*dm_init)(_adapter *);
	void (*dm_deinit)(_adapter *);
	s32 (*init_xmit_priv)(_adapter *);
	void (*free_xmit_priv)(_adapter *);
	s32 (*hal_xmit)(_adapter *, struct xmit_frame *);
	s32 (*mgnt_xmit)(_adapter *, struct xmit_frame *);
	s32 (*hal_mgmt_xmitframe_enqueue)(_adapter *, struct xmit_frame *);
	s32 (*hal_xmitframe_enqueue)(_adapter *, struct xmit_frame *);
	s32 (*xmit_thread_handler)(_adapter *);
	void (*run_thread)(_adapter *);
	void (*cancel_thread)(_adapter *);
	s32 (*init_recv_priv)(_adapter *);
	void (*free_recv_priv)(_adapter *);
	s32 (*recv_hdl)(_adapter *);
	void (*enable_interrupt)(_adapter *);
	void (*disable_interrupt)(_adapter *);
	u8 (*check_ips_status)(_adapter *);
	void (*set_chnl_bw_handler)(_adapter *, u8, enum channel_width, u8, u8);
	void (*set_tx_power_level_handler)(_adapter *, u8);
	void (*set_txpwr_done)(_adapter *);
	void (*set_tx_power_index_handler)(_adapter *, u32, enum rf_path, u8);
	u8 (*get_tx_power_index_handler)(_adapter *, enum rf_path, RATE_SECTION, enum MGN_RATE, enum channel_width, BAND_TYPE, u8, u8, struct txpwr_idx_comp *);
	s8 (*get_txpwr_target_extra_bias)(_adapter *, enum rf_path, RATE_SECTION, enum MGN_RATE, enum channel_width, BAND_TYPE, u8);
	void (*hal_dm_watchdog)(_adapter *);
	u8 (*set_hw_reg_handler)(_adapter *, u8, u8 *);
	void (*GetHwRegHandler)(_adapter *, u8, u8 *);
	u8 (*get_hal_def_var_handler)(_adapter *, HAL_DEF_VARIABLE, void *);
	u8 (*SetHalDefVarHandler)(_adapter *, HAL_DEF_VARIABLE, void *);
	void (*GetHalODMVarHandler)(_adapter *, HAL_ODM_VARIABLE, void *, void *);
	void (*SetHalODMVarHandler)(_adapter *, HAL_ODM_VARIABLE, void *, BOOLEAN);
	void (*SetBeaconRelatedRegistersHandler)(_adapter *);
	u8 (*interface_ps_func)(_adapter *, HAL_INTF_PS_FUNC, u8 *);
	u32 (*read_bbreg)(_adapter *, u32, u32);
	void (*write_bbreg)(_adapter *, u32, u32, u32);
	u32 (*read_rfreg)(_adapter *, enum rf_path, u32, u32);
	void (*write_rfreg)(_adapter *, enum rf_path, u32, u32, u32);
	void (*read_wmmedca_reg)(_adapter *, u16 *, u16 *, u16 *, u16 *);
	void (*EfusePowerSwitch)(_adapter *, u8, u8);
	void (*BTEfusePowerSwitch)(_adapter *, u8, u8);
	void (*ReadEFuse)(_adapter *, u8, u16, u16, u8 *, BOOLEAN);
	void (*EFUSEGetEfuseDefinition)(_adapter *, u8, u8, void *, BOOLEAN);
	u16 (*EfuseGetCurrentSize)(_adapter *, u8, BOOLEAN);
	int (*Efuse_PgPacketRead)(_adapter *, u8, u8 *, BOOLEAN);
	int (*Efuse_PgPacketWrite)(_adapter *, u8, u8, u8 *, BOOLEAN);
	u8 (*Efuse_WordEnableDataWrite)(_adapter *, u16, u8, u8 *, BOOLEAN);
	BOOLEAN (*Efuse_PgPacketWrite_BT)(_adapter *, u8, u8, u8 *, BOOLEAN);
	void (*sreset_init_value)(_adapter *);
	void (*sreset_reset_value)(_adapter *);
	void (*silentreset)(_adapter *);
	void (*sreset_xmit_status_check)(_adapter *);
	void (*sreset_linked_status_check)(_adapter *);
	u8 (*sreset_get_wifi_status)(_adapter *);
	bool (*sreset_inprogress)(_adapter *);
	void (*hal_notch_filter)(_adapter *, bool);
	s32 (*c2h_handler)(_adapter *, u8, u8, u8, u8 *);
	void (*reqtxrpt)(_adapter *, u8);
	s32 (*fill_h2c_cmd)(PADAPTER, u8, u32, u8 *);
	void (*fill_fake_txdesc)(PADAPTER, u8 *, u32, u8, u8, u8);
	s32 (*fw_dl)(_adapter *, u8);
	u8 (*hal_get_tx_buff_rsvd_page_num)(_adapter *, bool);
};

struct rtw_wdev_invit_info {
	u8 state;
	u8 peer_mac[6];
	u8 group_bssid[6];
	u8 active;
	u8 token;
	u8 flags;
	u8 status;
	u8 req_op_ch;
	u8 rsp_op_ch;
};

struct rtw_wdev_nego_info {
	u8 state;
	u8 iface_addr[6];
	u8 peer_mac[6];
	u8 peer_iface_addr[6];
	u8 active;
	u8 token;
	u8 status;
	u8 req_intent;
	u8 req_op_ch;
	u8 req_listen_ch;
	u8 rsp_intent;
	u8 rsp_op_ch;
	u8 conf_op_ch;
};

struct rtw_wdev_priv {
	struct wireless_dev *rtw_wdev;
	_adapter *padapter;
	u8 not_indic_disco;
	struct cfg80211_scan_request *scan_request;
	_lock scan_req_lock;
	struct cfg80211_connect_params *connect_req;
	_lock connect_req_lock;
	struct net_device *pmon_ndev;
	char ifname_mon[17];
	u8 p2p_enabled;
	systime probe_resp_ie_update_time;
	u8 provdisc_req_issued;
	struct rtw_wdev_invit_info invit_info;
	struct rtw_wdev_nego_info nego_info;
	u8 bandroid_scan;
	bool block;
	bool block_scan;
	u32 mgmt_regs;
	u8 is_mgmt_tx;
	u16 mgmt_tx_cookie;
	_mutex roch_mutex;
	atomic_t switch_ch_to;
};

struct br_ext_info {
	unsigned int nat25_disable;
	unsigned int macclone_enable;
	unsigned int dhcp_bcst_disable;
	int addPPPoETag;
	unsigned char nat25_dmzMac[6];
	unsigned int nat25sc_disable;
};

struct hostapd_priv;

struct nat25_network_db_entry;

struct _ADAPTER {
	int DriverState;
	int pid[3];
	int bDongle;
	int: 32;
	struct dvobj_priv *dvobj;
	struct mlme_priv mlmepriv;
	struct mlme_ext_priv mlmeextpriv;
	struct cmd_priv cmdpriv;
	struct evt_priv evtpriv;
	struct io_priv iopriv;
	struct xmit_priv xmitpriv;
	struct recv_priv recvpriv;
	struct sta_priv stapriv;
	struct security_priv securitypriv;
	_lock security_key_mutex;
	struct registry_priv registrypriv;
	int: 32;
	struct napi_struct napi;
	u8 napi_state;
	long: 56;
	struct mp_priv mppriv;
	struct hostapd_priv *phostapdpriv;
	struct roch_info rochinfo;
	u32 setband;
	atomic_t bandskip;
	struct wifidirect_info wdinfo;
	struct wifi_display_info wfd_info;
	ERROR_CODE LastError;
	int: 32;
	void *HalData;
	u32 hal_data_sz;
	int: 32;
	struct hal_ops hal_func;
	u32 IsrContent;
	u32 ImrContent;
	u8 EepromAddressSize;
	u8 bDriverIsGoingToUnload;
	u8 init_adpt_in_progress;
	u8 bHaltInProgress;
	int: 32;
	_thread_hdl_ cmdThread;
	_thread_hdl_ xmitThread;
	_thread_hdl_ recvThread;
	u8 registered;
	long: 56;
	void (*intf_start)(_adapter *);
	void (*intf_stop)(_adapter *);
	_nic_hdl pnetdev;
	char old_ifname[16];
	u8 ndev_unregistering;
	int: 24;
	int bup;
	struct net_device_stats stats;
	struct iw_statistics iwstats;
	struct proc_dir_entry *dir_dev;
	struct proc_dir_entry *dir_odm;
	struct wireless_dev *rtw_wdev;
	struct rtw_wdev_priv wdev_data;
	u8 mac_addr[6];
	short: 16;
	int net_closed;
	u8 netif_up;
	u8 bLinkInfoDump;
	u8 bNotifyChannelChange;
	u8 bsta_tp_dump;
	u8 bShowGetP2PState;
	u8 isprimary;
	u8 adapter_type;
	u8 hw_port;
	u8 iface_id;
	int: 24;
	_lock br_ext_lock;
	int: 32;
	struct nat25_network_db_entry *nethash[16];
	int pppoe_connection_in_progress;
	unsigned char pppoe_addr[6];
	unsigned char scdb_mac[6];
	unsigned char scdb_ip[4];
	int: 32;
	struct nat25_network_db_entry *scdb_entry;
	unsigned char br_mac[6];
	unsigned char br_ip[4];
	short: 16;
	struct br_ext_info ethBrExtInfo;
	u8 bmc_tx_rate;
	u8 b2u_flags_ap_src;
	u8 b2u_flags_ap_fwd;
	u8 fix_rate;
	u8 fix_bw;
	u8 data_fb;
	u8 power_offset;
	u8 driver_tx_bw_mode;
	u8 rsvd_page_offset;
	u8 rsvd_page_num;
	u8 ch_clm_ratio;
	u8 ch_nhm_ratio;
	u8 driver_vcs_en;
	u8 driver_vcs_type;
	u8 driver_ampdu_spacing;
	u8 driver_rx_ampdu_factor;
	u8 driver_rx_ampdu_spacing;
	u8 fix_rx_ampdu_accept;
	u8 fix_rx_ampdu_size;
	u8 driver_tx_max_agg_num;
	int: 32;
} __attribute__((packed));

enum {
	_DRV_NONE_ = 0,
	_DRV_ALWAYS_ = 1,
	_DRV_ERR_ = 2,
	_DRV_WARNING_ = 3,
	_DRV_INFO_ = 4,
	_DRV_DEBUG_ = 5,
	_DRV_MAX_ = 6,
};

enum rf_type {
	RF_1T1R = 0,
	RF_1T2R = 1,
	RF_2T2R = 2,
	RF_2T3R = 3,
	RF_2T4R = 4,
	RF_3T3R = 5,
	RF_3T4R = 6,
	RF_4T4R = 7,
	RF_4T3R = 8,
	RF_4T2R = 9,
	RF_4T1R = 10,
	RF_3T2R = 11,
	RF_3T1R = 12,
	RF_2T1R = 13,
	RF_1T4R = 14,
	RF_1T3R = 15,
	RF_TYPE_MAX = 16,
};

enum bb_path {
	BB_PATH_NON = 0,
	BB_PATH_A = 1,
	BB_PATH_B = 2,
	BB_PATH_C = 4,
	BB_PATH_D = 8,
	BB_PATH_AB = 3,
	BB_PATH_AC = 5,
	BB_PATH_AD = 9,
	BB_PATH_BC = 6,
	BB_PATH_BD = 10,
	BB_PATH_CD = 12,
	BB_PATH_ABC = 7,
	BB_PATH_ABD = 11,
	BB_PATH_ACD = 13,
	BB_PATH_BCD = 14,
	BB_PATH_ABCD = 15,
	BB_PATH_AUTO = 255,
};

enum wireless_set {
	WIRELESS_CCK = 1,
	WIRELESS_OFDM = 2,
	WIRELESS_HT = 4,
	WIRELESS_VHT = 8,
};

struct rssi_info {
	s8 rssi;
	s8 rssi_cck;
	s8 rssi_ofdm;
	u8 packet_map;
	u8 ofdm_pkt_cnt;
	u8 cck_pkt_cnt;
	u16 cck_sum_power;
	u8 is_send_rssi;
	u8 valid_bit;
	s16 rssi_acc;
};

struct ra_sta_info {
	u8 rate_id;
	u8 rssi_level;
	u8 is_first_connect: 1;
	u8 is_support_sgi: 1;
	u8 is_vht_enable: 2;
	u8 disable_ra: 1;
	u8 disable_pt: 1;
	u8 txrx_state: 2;
	u8 is_noisy: 1;
	u8 curr_tx_rate;
	enum channel_width ra_bw_mode;
	enum channel_width curr_tx_bw;
	u8 curr_retry_ratio;
	u64 ramask;
};

struct dtp_info {
	u8 dyn_tx_power;
	u8 last_tx_power;
	boolean sta_is_alive;
	u8 sta_tx_high_power_lvl: 4;
	u8 sta_last_dtp_lvl: 4;
};

struct cmn_sta_info {
	u16 dm_ctrl;
	enum channel_width bw_mode;
	u8 mac_id;
	u8 mac_addr[6];
	u16 aid;
	enum rf_type mimo_type;
	struct rssi_info rssi_stat;
	struct ra_sta_info ra_info;
	u16 tx_moving_average_tp;
	u16 rx_moving_average_tp;
	u8 stbc_en: 2;
	u8 ldpc_en: 2;
	enum wireless_set support_wireless_set;
	u8 sm_ps: 2;
	struct dtp_info dtp_stat;
};

enum opc_bw {
	OPC_BW20 = 0,
	OPC_BW40PLUS = 1,
	OPC_BW40MINUS = 2,
	OPC_BW80 = 3,
	OPC_BW160 = 4,
	OPC_BW80P80 = 5,
	OPC_BW_NUM = 6,
};

struct op_ch_t {
	u8 ch;
	u8 static_non_op: 1;
	u8 no_ir: 1;
	s16 max_txpwr;
};

struct op_class_pref_t {
	u8 class_id;
	BAND_TYPE band;
	enum opc_bw bw;
	u8 ch_num;
	u8 op_ch_num;
	u8 ir_ch_num;
	struct op_ch_t chs[28];
};

enum regd_src_t {
	REGD_SRC_RTK_PRIV = 0,
	REGD_SRC_OS = 1,
	REGD_SRC_NUM = 2,
};

enum rtw_regd {
	RTW_REGD_NA = 0,
	RTW_REGD_FCC = 1,
	RTW_REGD_MKK = 2,
	RTW_REGD_ETSI = 3,
	RTW_REGD_IC = 4,
	RTW_REGD_KCC = 5,
	RTW_REGD_NCC = 6,
	RTW_REGD_ACMA = 7,
	RTW_REGD_CHILE = 8,
	RTW_REGD_MEX = 9,
	RTW_REGD_WW = 10,
	RTW_REGD_NUM = 11,
};

struct country_chplan {
	char alpha2[2];
	u8 chplan;
	u8 txpwr_lmt_override;
};

struct cmd_obj {
	_adapter *padapter;
	u16 cmdcode;
	u8 res;
	u8 *parmbuf;
	u32 cmdsz;
	u8 *rsp;
	u32 rspsz;
	struct submit_ctx *sctx;
	u8 no_io;
	_list list;
};

enum {
	RTW_CMDF_DIRECTLY = 1,
	RTW_CMDF_WAIT_ACK = 2,
};

struct rtw_roch_parm {
	u64 cookie;
	struct wireless_dev *wdev;
	struct ieee80211_channel ch;
	enum nl80211_channel_type ch_type;
	unsigned int duration;
};

struct mgnt_tx_parm {
	u8 tx_ch;
	u8 no_cck;
	const u8 *buf;
	size_t len;
	int wait_ack;
};

enum rtw_drvextra_cmd_id {
	NONE_WK_CID = 0,
	STA_MSTATUS_RPT_WK_CID = 1,
	DYNAMIC_CHK_WK_CID = 2,
	DM_CTRL_WK_CID = 3,
	PBC_POLLING_WK_CID = 4,
	POWER_SAVING_CTRL_WK_CID = 5,
	LPS_CTRL_WK_CID = 6,
	ANT_SELECT_WK_CID = 7,
	P2P_PS_WK_CID = 8,
	P2P_PROTO_WK_CID = 9,
	CHECK_HIQ_WK_CID = 10,
	C2H_WK_CID = 11,
	RTP_TIMER_CFG_WK_CID = 12,
	RESET_SECURITYPRIV = 13,
	FREE_ASSOC_RESOURCES = 14,
	DM_IN_LPS_WK_CID = 15,
	DM_RA_MSK_WK_CID = 16,
	BEAMFORMING_WK_CID = 17,
	LPS_CHANGE_DTIM_CID = 18,
	BTINFO_WK_CID = 19,
	BTC_REDUCE_WL_TXPWR_CID = 20,
	DFS_RADAR_DETECT_WK_CID = 21,
	DFS_RADAR_DETECT_EN_DEC_WK_CID = 22,
	SESSION_TRACKER_WK_CID = 23,
	EN_HW_UPDATE_TSF_WK_CID = 24,
	PERIOD_TSF_UPDATE_END_WK_CID = 25,
	TEST_H2C_CID = 26,
	MP_CMD_WK_CID = 27,
	CUSTOMER_STR_WK_CID = 28,
	ROCH_WK_CID = 29,
	MGNT_TX_WK_CID = 30,
	REQ_PER_CMD_WK_CID = 31,
	SSMPS_WK_CID = 32,
	AC_PARM_CMD_WK_CID = 33,
	STOP_AP_WK_CID = 34,
	MAX_WK_CID = 35,
};

enum LPS_CTRL_TYPE {
	LPS_CTRL_SCAN = 0,
	LPS_CTRL_JOINBSS = 1,
	LPS_CTRL_CONNECT = 2,
	LPS_CTRL_DISCONNECT = 3,
	LPS_CTRL_SPECIAL_PACKET = 4,
	LPS_CTRL_LEAVE = 5,
	LPS_CTRL_TRAFFIC_BUSY = 6,
	LPS_CTRL_TX_TRAFFIC_LEAVE = 7,
	LPS_CTRL_RX_TRAFFIC_LEAVE = 8,
	LPS_CTRL_ENTER = 9,
	LPS_CTRL_LEAVE_CFG80211_PWRMGMT = 10,
	LPS_CTRL_LEAVE_SET_OPTION = 11,
};

enum STAKEY_TYPE {
	GROUP_KEY = 0,
	UNICAST_KEY = 1,
	TDLS_KEY = 2,
};

struct disconnect_parm {
	u32 deauth_timeout_ms;
};

struct createbss_parm {
	bool adhoc;
	u8 ifbmp;
	u8 excl_ifbmp;
	s16 req_ch;
	s8 req_bw;
	s8 req_offset;
};

struct setopmode_parm {
	u8 mode;
	u8 rsvd[3];
};

struct sitesurvey_parm {
	sint scan_mode;
	u8 ssid_num;
	u8 ch_num;
	NDIS_802_11_SSID ssid[9];
	struct rtw_ieee80211_channel ch[51];
	u32 token;
	u16 duration;
	u8 igi;
	u8 bw;
	bool acs;
	u8 reason;
};

struct set_stakey_parm {
	u8 addr[6];
	u8 algorithm;
	u8 keyid;
	u8 key[32];
	u8 gk;
};

struct set_stakey_rsp {
	u8 addr[6];
	u8 keyid;
	u8 rsvd;
};

struct drvextra_cmd_parm {
	int ec_id;
	int type;
	int size;
	unsigned char *pbuf;
};

struct addBaReq_parm {
	unsigned int tid;
	u8 addr[6];
};

struct addBaRsp_parm {
	unsigned int tid;
	unsigned int start_seq;
	u8 addr[6];
	u8 status;
	u8 size;
};

struct set_ch_parm {
	u8 ch;
	u8 bw;
	u8 ch_offset;
};

struct SetChannelPlan_param {
	enum regd_src_t regd_src;
	const struct country_chplan *country_ent;
	u8 channel_plan;
};

struct get_chplan_resp;

struct get_channel_plan_param {
	struct get_chplan_resp **resp;
};

struct _RT_CHANNEL_INFO {
	u8 ChannelNum;
	u8 flags;
	u8 hidden_bss_cnt;
	void *os_chan;
};

typedef struct _RT_CHANNEL_INFO RT_CHANNEL_INFO;

struct get_chplan_resp {
	enum regd_src_t regd_src;
	bool has_country;
	struct country_chplan country_ent;
	u8 channel_plan;
	const char *txpwr_lmt_name;
	u8 edcca_mode_2g;
	u8 chset_num;
	RT_CHANNEL_INFO chset[0];
};

struct LedBlink_param {
	void *pLed;
};

struct RunInThread_param {
	void (*func)(void *);
	void *context;
};

struct ssmps_cmd_parm {
	struct sta_info *sta;
	u8 smps;
};

struct tx_servq {
	_list tx_pending;
	_queue sta_pending;
	int qcnt;
};

struct sta_xmit_priv {
	_lock lock;
	sint option;
	sint apsd_setting;
	struct tx_servq be_q;
	struct tx_servq bk_q;
	struct tx_servq vi_q;
	struct tx_servq vo_q;
	struct tx_servq mgmt_q;
	_list legacy_dz;
	_list apsd;
	u16 txseq_tid[16];
};

struct stainfo_rxcache {
	u16 tid_rxseq[16];
	u8 iv[128];
	u8 last_tid;
};

struct sta_recv_priv {
	_lock lock;
	sint option;
	_queue defrag_q;
	struct stainfo_rxcache rxcache;
	u16 bmc_tid_rxseq[16];
	u16 nonqos_rxseq;
	u16 nonqos_bmc_rxseq;
};

struct stainfo_stats {
	systime last_rx_time;
	u64 rx_mgnt_pkts;
	u64 rx_beacon_pkts;
	u64 rx_probereq_pkts;
	u64 rx_probersp_pkts;
	u64 rx_probersp_bm_pkts;
	u64 rx_probersp_uo_pkts;
	u64 rx_ctrl_pkts;
	u64 rx_data_pkts;
	u64 rx_data_bc_pkts;
	u64 rx_data_mc_pkts;
	u64 rx_data_qos_pkts[16];
	u64 last_rx_mgnt_pkts;
	u64 last_rx_beacon_pkts;
	u64 last_rx_probereq_pkts;
	u64 last_rx_probersp_pkts;
	u64 last_rx_probersp_bm_pkts;
	u64 last_rx_probersp_uo_pkts;
	u64 last_rx_ctrl_pkts;
	u64 last_rx_data_pkts;
	u64 last_rx_data_bc_pkts;
	u64 last_rx_data_mc_pkts;
	u64 last_rx_data_qos_pkts[16];
	u64 rx_bytes;
	u64 rx_bc_bytes;
	u64 rx_mc_bytes;
	u64 last_rx_bytes;
	u64 last_rx_bc_bytes;
	u64 last_rx_mc_bytes;
	u64 rx_drops;
	u32 rx_tp_kbits;
	u32 smooth_rx_tp_kbits;
	u64 tx_pkts;
	u64 last_tx_pkts;
	u64 tx_bytes;
	u64 last_tx_bytes;
	u64 tx_drops;
	u32 tx_tp_kbits;
	u32 smooth_tx_tp_kbits;
	u64 last_rx_data_uc_pkts;
	u32 duplicate_cnt;
	u32 rxratecnt[128];
	u32 tx_ok_cnt;
	u32 tx_fail_cnt;
	u32 tx_retry_cnt;
};

struct recv_reorder_ctrl {
	_adapter *padapter;
	u8 tid;
	u8 enable;
	u16 indicate_seq;
	u16 wend_b;
	u8 wsize_b;
	u8 ampdu_size;
	_queue pending_recvframe_queue;
	_timer reordering_ctrl_timer;
	u8 bReorderWaiting;
	long unsigned int rec_abba_rsp_ack;
};

typedef bool (*st_match_rule)(_adapter *, u8 *, u8 *, u8 *, u8 *);

struct st_register {
	u8 s_proto;
	st_match_rule rule;
};

struct st_ctl_t {
	struct st_register reg[1];
	_queue tracker_q;
};

struct sta_info {
	_lock lock;
	_list list;
	_list hash_list;
	_adapter *padapter;
	struct cmn_sta_info cmn;
	struct sta_xmit_priv sta_xmitpriv;
	struct sta_recv_priv sta_recvpriv;
	_queue sleep_q;
	unsigned int sleepq_len;
	_queue mgmt_sleep_q;
	unsigned int mgmt_sleepq_len;
	uint state;
	uint qos_option;
	u16 hwseq;
	systime resp_nonenc_eapol_key_starttime;
	uint ieee8021x_blocked;
	uint dot118021XPrivacy;
	union Keytype dot11tkiptxmickey;
	union Keytype dot11tkiprxmickey;
	union Keytype dot118021x_UncstKey;
	union pn48 dot11txpn;
	union pn48 dot11rxpn;
	atomic_t keytrack;
	_timer dot11w_expire_timer;
	u8 bssrateset[16];
	u32 bssratelen;
	u8 cts2self;
	u8 rtsen;
	u8 init_rate;
	u8 wireless_mode;
	struct stainfo_stats sta_stats;
	_timer addba_retry_timer;
	struct recv_reorder_ctrl recvreorder_ctrl[16];
	atomic_t continual_no_rx_packet[16];
	u16 BA_starting_seqctrl[16];
	struct ht_priv htpriv;
	unsigned int expire_to;
	int flags;
	u8 bpairwise_key_installed;
	_list asoc_list;
	_list auth_list;
	unsigned int auth_seq;
	unsigned int authalg;
	unsigned char chg_txt[128];
	u16 capability;
	int dot8021xalg;
	int wpa_psk;
	int wpa_group_cipher;
	int wpa2_group_cipher;
	int wpa_pairwise_cipher;
	int wpa2_pairwise_cipher;
	u32 akm_suite_type;
	u8 wpa_ie[32];
	u8 nonerp_set;
	u8 no_short_slot_time_set;
	u8 no_short_preamble_set;
	u8 no_ht_gf_set;
	u8 no_ht_set;
	u8 ht_20mhz_set;
	u8 ht_40mhz_intolerant;
	u8 qos_info;
	u8 max_sp_len;
	u8 uapsd_bk;
	u8 uapsd_be;
	u8 uapsd_vi;
	u8 uapsd_vo;
	u8 has_legacy_ac;
	unsigned int sleepq_ac_len;
	u8 is_p2p_device;
	u8 p2p_status_code;
	u8 dev_addr[6];
	u8 dev_cap;
	u16 config_methods;
	u8 primary_dev_type[8];
	u8 num_of_secdev_type;
	u8 secdev_types_list[32];
	u16 dev_name_len;
	u8 dev_name[32];
	u8 op_wfd_mode;
	u8 keep_alive_trycnt;
	u8 *pauth_frame;
	u32 auth_len;
	u8 *passoc_req;
	u32 assoc_req_len;
	u8 IOTPeer;
	u16 RxMgmtFrameSeqNum;
	struct st_ctl_t st_ctl;
	u8 max_agg_num_minimal_record;
	u8 curr_rx_rate;
	u8 curr_rx_rate_bmc;
	bool vendor_8812;
	u8 tx_q_enable;
	struct __queue tx_queue;
	_workitem tx_q_work;
};

enum rtw_cmd_id {
	CMD_JOINBSS = 0,
	CMD_DISCONNECT = 1,
	CMD_CREATE_BSS = 2,
	CMD_SET_OPMODE = 3,
	CMD_SITE_SURVEY = 4,
	CMD_SET_AUTH = 5,
	CMD_SET_KEY = 6,
	CMD_SET_STAKEY = 7,
	CMD_ADD_BAREQ = 8,
	CMD_SET_CHANNEL = 9,
	CMD_TX_BEACON = 10,
	CMD_SET_MLME_EVT = 11,
	CMD_SET_DRV_EXTRA = 12,
	CMD_SET_CHANPLAN = 13,
	CMD_LEDBLINK = 14,
	CMD_SET_CHANSWITCH = 15,
	CMD_TDLS = 16,
	CMD_CHK_BMCSLEEPQ = 17,
	CMD_RUN_INTHREAD = 18,
	CMD_ADD_BARSP = 19,
	CMD_RM_POST_EVENT = 20,
	CMD_SET_MESH_PLINK_STATE = 21,
	CMD_DO_IQK = 22,
	CMD_GET_CHANPLAN = 23,
	CMD_WRITE_BCN_LEN = 24,
	CMD_ID_MAX = 25,
};

struct hw_xmit {
	_queue *sta_queue;
	int accnt;
};

enum {
	RTW_SCTX_SUBMITTED = 4294967295,
	RTW_SCTX_DONE_SUCCESS = 0,
	RTW_SCTX_DONE_UNKNOWN = 1,
	RTW_SCTX_DONE_TIMEOUT = 2,
	RTW_SCTX_DONE_BUF_ALLOC = 3,
	RTW_SCTX_DONE_BUF_FREE = 4,
	RTW_SCTX_DONE_WRITE_PORT_ERR = 5,
	RTW_SCTX_DONE_TX_DESC_NA = 6,
	RTW_SCTX_DONE_TX_DENY = 7,
	RTW_SCTX_DONE_CCX_PKT_FAIL = 8,
	RTW_SCTX_DONE_DRV_STOP = 9,
	RTW_SCTX_DONE_DEV_REMOVE = 10,
	RTW_SCTX_DONE_CMD_ERROR = 11,
	RTW_SCTX_DONE_CMD_DROP = 12,
	RTX_SCTX_CSTR_WAIT_RPT2 = 13,
};

struct xmit_frame {
	_list list;
	struct pkt_attrib attrib;
	u16 os_qid;
	_pkt *pkt;
	int frame_tag;
	_adapter *padapter;
	u8 *buf_addr;
	struct xmit_buf *pxmitbuf;
	u8 pg_num;
	u8 agg_num;
	u8 ack_report;
	u8 *alloc_addr;
	u8 ext_tag;
};

enum cmdbuf_type {
	CMDBUF_BEACON = 0,
	CMDBUF_RSVD = 1,
	CMDBUF_MAX = 2,
};

struct _EFUSE_HAL {
	u8 fakeEfuseBank;
	u32 fakeEfuseUsedBytes;
	u8 fakeEfuseContent[1024];
	u8 fakeEfuseInitMap[1024];
	u8 fakeEfuseModifiedMap[1024];
	u32 EfuseUsedBytes;
	u8 EfuseUsedPercentage;
	u16 BTEfuseUsedBytes;
	u8 BTEfuseUsedPercentage;
	u8 BTEfuseContent[3072];
	u8 BTEfuseInitMap[1024];
	u8 BTEfuseModifiedMap[1024];
	u16 fakeBTEfuseUsedBytes;
	u8 fakeBTEfuseContent[3072];
	u8 fakeBTEfuseInitMap[1024];
	u8 fakeBTEfuseModifiedMap[1024];
	const u16 MaxSecNum_WiFi;
	const u16 MaxSecNum_BT;
	const u16 WordUnit;
	const u16 PhysicalLen_WiFi;
	const u16 PhysicalLen_BT;
	const u16 LogicalLen_WiFi;
	const u16 LogicalLen_BT;
	const u16 BankSize;
	const u16 TotalBankNum;
	const u16 BankNum_WiFi;
	const u16 BankNum_BT;
	const u16 OOBProtectBytes;
	const u16 ProtectBytes;
	const u16 BankAvailBytes;
	const u16 TotalAvailBytes_WiFi;
	const u16 TotalAvailBytes_BT;
	const u16 HeaderRetry;
	const u16 DataRetry;
	ERROR_CODE Status;
};

typedef struct _EFUSE_HAL EFUSE_HAL;

struct sreset_priv {
	_mutex silentreset_mutex;
	u8 silent_reset_inprogress;
	u8 Wifi_Error_Status;
	systime last_tx_time;
	systime last_tx_complete_time;
	s32 dbg_trigger_point;
	u64 self_dect_tx_cnt;
	u64 self_dect_rx_cnt;
	u64 self_dect_fw_cnt;
	u64 tx_dma_status_cnt;
	u64 rx_dma_status_cnt;
	u8 rx_cnt;
	u8 self_dect_fw;
	u8 self_dect_case;
	u16 last_mac_rxff_ptr;
	u8 dbg_sreset_ctrl;
};

enum _HW_VARIABLES {
	HW_VAR_MEDIA_STATUS = 0,
	HW_VAR_SET_OPMODE = 1,
	HW_VAR_MAC_ADDR = 2,
	HW_VAR_BSSID = 3,
	HW_VAR_INIT_RTS_RATE = 4,
	HW_VAR_BASIC_RATE = 5,
	HW_VAR_TXPAUSE = 6,
	HW_VAR_BCN_FUNC = 7,
	HW_VAR_BCN_CTRL_ADDR = 8,
	HW_VAR_CORRECT_TSF = 9,
	HW_VAR_RCR = 10,
	HW_VAR_MLME_DISCONNECT = 11,
	HW_VAR_MLME_SITESURVEY = 12,
	HW_VAR_MLME_JOIN = 13,
	HW_VAR_ON_RCR_AM = 14,
	HW_VAR_OFF_RCR_AM = 15,
	HW_VAR_BEACON_INTERVAL = 16,
	HW_VAR_SLOT_TIME = 17,
	HW_VAR_RESP_SIFS = 18,
	HW_VAR_ACK_PREAMBLE = 19,
	HW_VAR_SEC_CFG = 20,
	HW_VAR_SEC_DK_CFG = 21,
	HW_VAR_BCN_VALID = 22,
	HW_VAR_FREECNT = 23,
	HW_VAR_CAM_EMPTY_ENTRY = 24,
	HW_VAR_CAM_INVALID_ALL = 25,
	HW_VAR_AC_PARAM_VO = 26,
	HW_VAR_AC_PARAM_VI = 27,
	HW_VAR_AC_PARAM_BE = 28,
	HW_VAR_AC_PARAM_BK = 29,
	HW_VAR_ACM_CTRL = 30,
	HW_VAR_AMPDU_MIN_SPACE = 31,
	HW_VAR_AMPDU_FACTOR = 32,
	HW_VAR_RXDMA_AGG_PG_TH = 33,
	HW_VAR_SET_RPWM = 34,
	HW_VAR_CPWM = 35,
	HW_VAR_H2C_FW_PWRMODE = 36,
	HW_VAR_H2C_FW_PWRMODE_RFON_CTRL = 37,
	HW_VAR_H2C_INACTIVE_IPS = 38,
	HW_VAR_H2C_PS_TUNE_PARAM = 39,
	HW_VAR_H2C_FW_JOINBSSRPT = 40,
	HW_VAR_FWLPS_RF_ON = 41,
	HW_VAR_H2C_FW_P2P_PS_OFFLOAD = 42,
	HW_VAR_TRIGGER_GPIO_0 = 43,
	HW_VAR_BT_SET_COEXIST = 44,
	HW_VAR_BT_ISSUE_DELBA = 45,
	HW_VAR_SWITCH_EPHY_WoWLAN = 46,
	HW_VAR_EFUSE_USAGE = 47,
	HW_VAR_EFUSE_BYTES = 48,
	HW_VAR_EFUSE_BT_USAGE = 49,
	HW_VAR_EFUSE_BT_BYTES = 50,
	HW_VAR_FIFO_CLEARN_UP = 51,
	HW_VAR_RESTORE_HW_SEQ = 52,
	HW_VAR_CHECK_TXBUF = 53,
	HW_VAR_PCIE_STOP_TX_DMA = 54,
	HW_VAR_APFM_ON_MAC = 55,
	HW_VAR_HCI_SUS_STATE = 56,
	HW_VAR_RPWM_TOG = 57,
	HW_VAR_SYS_CLKR = 58,
	HW_VAR_NAV_UPPER = 59,
	HW_VAR_RPT_TIMER_SETTING = 60,
	HW_VAR_TX_RPT_MAX_MACID = 61,
	HW_VAR_CHK_HI_QUEUE_EMPTY = 62,
	HW_VAR_CHK_MGQ_CPU_EMPTY = 63,
	HW_VAR_DL_BCN_SEL = 64,
	HW_VAR_AMPDU_MAX_TIME = 65,
	HW_VAR_WIRELESS_MODE = 66,
	HW_VAR_USB_MODE = 67,
	HW_VAR_PORT_SWITCH = 68,
	HW_VAR_PORT_CFG = 69,
	HW_VAR_DO_IQK = 70,
	HW_VAR_DM_IN_LPS_LCLK = 71,
	HW_VAR_SET_REQ_FW_PS = 72,
	HW_VAR_FW_PS_STATE = 73,
	HW_VAR_SOUNDING_ENTER = 74,
	HW_VAR_SOUNDING_LEAVE = 75,
	HW_VAR_SOUNDING_RATE = 76,
	HW_VAR_SOUNDING_STATUS = 77,
	HW_VAR_SOUNDING_FW_NDPA = 78,
	HW_VAR_SOUNDING_CLK = 79,
	HW_VAR_SOUNDING_SET_GID_TABLE = 80,
	HW_VAR_SOUNDING_CSI_REPORT = 81,
	HW_VAR_HW_REG_TIMER_INIT = 82,
	HW_VAR_HW_REG_TIMER_RESTART = 83,
	HW_VAR_HW_REG_TIMER_START = 84,
	HW_VAR_HW_REG_TIMER_STOP = 85,
	HW_VAR_DL_RSVD_PAGE = 86,
	HW_VAR_MACID_LINK = 87,
	HW_VAR_MACID_NOLINK = 88,
	HW_VAR_DUMP_MAC_QUEUE_INFO = 89,
	HW_VAR_ASIX_IOT = 90,
	HW_VAR_EN_HW_UPDATE_TSF = 91,
	HW_VAR_CH_SW_NEED_TO_TAKE_CARE_IQK_INFO = 92,
	HW_VAR_CH_SW_IQK_INFO_BACKUP = 93,
	HW_VAR_CH_SW_IQK_INFO_RESTORE = 94,
	HW_VAR_DBI = 95,
	HW_VAR_MDIO = 96,
	HW_VAR_L1OFF_CAPABILITY = 97,
	HW_VAR_L1OFF_NIC_SUPPORT = 98,
	HW_VAR_BCN_EARLY_C2H_RPT = 99,
	HW_VAR_SET_DRV_ERLY_INT = 100,
	HW_VAR_DUMP_MAC_TXFIFO = 101,
	HW_VAR_PWR_CMD = 102,
	HW_VAR_SET_SOML_PARAM = 103,
	HW_VAR_ENABLE_RX_BAR = 104,
	HW_VAR_TSF_AUTO_SYNC = 105,
	HW_VAR_LPS_STATE_CHK = 106,
	HW_VAR_LPS_RFON_CHK = 107,
	HW_VAR_SET_RTS_BW = 108,
};

struct txpwr_idx_comp {
	u8 ntx_idx;
	s8 target;
	s8 base;
	s8 by_rate;
	s8 btc;
	s8 extra;
	s8 utarget;
	s8 rlimit;
	s8 limit;
	s8 ulimit;
	s8 tpc;
	s8 tpt;
	s8 dpd;
};

enum _HARDWARE_TYPE {
	HARDWARE_TYPE_RTL8188EE = 0,
	HARDWARE_TYPE_RTL8188EU = 1,
	HARDWARE_TYPE_RTL8188ES = 2,
	HARDWARE_TYPE_RTL8192EE = 3,
	HARDWARE_TYPE_RTL8192EU = 4,
	HARDWARE_TYPE_RTL8192ES = 5,
	HARDWARE_TYPE_RTL8812E = 6,
	HARDWARE_TYPE_RTL8812AU = 7,
	HARDWARE_TYPE_RTL8811AU = 8,
	HARDWARE_TYPE_RTL8821E = 9,
	HARDWARE_TYPE_RTL8821U = 10,
	HARDWARE_TYPE_RTL8821S = 11,
	HARDWARE_TYPE_RTL8723BE = 12,
	HARDWARE_TYPE_RTL8723BU = 13,
	HARDWARE_TYPE_RTL8723BS = 14,
	HARDWARE_TYPE_RTL8814AE = 15,
	HARDWARE_TYPE_RTL8814AU = 16,
	HARDWARE_TYPE_RTL8814AS = 17,
	HARDWARE_TYPE_RTL8821BE = 18,
	HARDWARE_TYPE_RTL8821BU = 19,
	HARDWARE_TYPE_RTL8821BS = 20,
	HARDWARE_TYPE_RTL8822BE = 21,
	HARDWARE_TYPE_RTL8822BU = 22,
	HARDWARE_TYPE_RTL8822BS = 23,
	HARDWARE_TYPE_RTL8703BE = 24,
	HARDWARE_TYPE_RTL8703BU = 25,
	HARDWARE_TYPE_RTL8703BS = 26,
	HARDWARE_TYPE_RTL8188FE = 27,
	HARDWARE_TYPE_RTL8188FU = 28,
	HARDWARE_TYPE_RTL8188FS = 29,
	HARDWARE_TYPE_RTL8188GTVU = 30,
	HARDWARE_TYPE_RTL8188GTVS = 31,
	HARDWARE_TYPE_RTL8723DE = 32,
	HARDWARE_TYPE_RTL8723DU = 33,
	HARDWARE_TYPE_RTL8723DS = 34,
	HARDWARE_TYPE_RTL8821CE = 35,
	HARDWARE_TYPE_RTL8821CU = 36,
	HARDWARE_TYPE_RTL8821CS = 37,
	HARDWARE_TYPE_RTL8710BU = 38,
	HARDWARE_TYPE_RTL8192FS = 39,
	HARDWARE_TYPE_RTL8192FU = 40,
	HARDWARE_TYPE_RTL8192FE = 41,
	HARDWARE_TYPE_RTL8822CE = 42,
	HARDWARE_TYPE_RTL8822CU = 43,
	HARDWARE_TYPE_RTL8822CS = 44,
	HARDWARE_TYPE_RTL8814BE = 45,
	HARDWARE_TYPE_RTL8814BU = 46,
	HARDWARE_TYPE_RTL8814BS = 47,
	HARDWARE_TYPE_RTL8723FU = 48,
	HARDWARE_TYPE_RTL8723FS = 49,
	HARDWARE_TYPE_MAX = 50,
};

enum tag_HAL_IC_Type_Definition {
	CHIP_8192S = 0,
	CHIP_8188C = 1,
	CHIP_8192C = 2,
	CHIP_8192D = 3,
	CHIP_8723A = 4,
	CHIP_8188E = 5,
	CHIP_8812 = 6,
	CHIP_8821 = 7,
	CHIP_8723B = 8,
	CHIP_8192E = 9,
	CHIP_8814A = 10,
	CHIP_8703B = 11,
	CHIP_8188F = 12,
	CHIP_8822B = 13,
	CHIP_8723D = 14,
	CHIP_8821C = 15,
	CHIP_8710B = 16,
	CHIP_8192F = 17,
	CHIP_8188GTV = 18,
	CHIP_8822C = 19,
	CHIP_8814B = 20,
	CHIP_8723F = 21,
};

typedef enum tag_HAL_IC_Type_Definition HAL_IC_TYPE_E;

enum tag_HAL_CHIP_Type_Definition {
	TEST_CHIP = 0,
	NORMAL_CHIP = 1,
	FPGA = 2,
};

typedef enum tag_HAL_CHIP_Type_Definition HAL_CHIP_TYPE_E;

enum tag_HAL_Cut_Version_Definition {
	A_CUT_VERSION = 0,
	B_CUT_VERSION = 1,
	C_CUT_VERSION = 2,
	D_CUT_VERSION = 3,
	E_CUT_VERSION = 4,
	F_CUT_VERSION = 5,
	G_CUT_VERSION = 6,
	H_CUT_VERSION = 7,
	I_CUT_VERSION = 8,
	J_CUT_VERSION = 9,
	K_CUT_VERSION = 10,
};

typedef enum tag_HAL_Cut_Version_Definition HAL_CUT_VERSION_E;

enum tag_HAL_Manufacturer_Version_Definition {
	CHIP_VENDOR_TSMC = 0,
	CHIP_VENDOR_UMC = 1,
	CHIP_VENDOR_SMIC = 2,
};

typedef enum tag_HAL_Manufacturer_Version_Definition HAL_VENDOR_E;

enum tag_HAL_RF_Type_Definition {
	RF_TYPE_1T1R = 0,
	RF_TYPE_1T2R = 1,
	RF_TYPE_2T2R = 2,
	RF_TYPE_2T3R = 3,
	RF_TYPE_2T4R = 4,
	RF_TYPE_3T3R = 5,
	RF_TYPE_3T4R = 6,
	RF_TYPE_4T4R = 7,
};

typedef enum tag_HAL_RF_Type_Definition HAL_RF_TYPE_E;

struct tag_HAL_VERSION {
	HAL_IC_TYPE_E ICType;
	HAL_CHIP_TYPE_E ChipType;
	HAL_CUT_VERSION_E CUTVersion;
	HAL_VENDOR_E VendorType;
	HAL_RF_TYPE_E RFType;
	u8 ROMVer;
};

typedef struct tag_HAL_VERSION HAL_VERSION;

struct _BB_REGISTER_DEFINITION {
	u32 rfintfs;
	u32 rfintfo;
	u32 rfintfe;
	u32 rf3wireOffset;
	u32 rfHSSIPara2;
	u32 rfLSSIReadBack;
	u32 rfLSSIReadBackPi;
};

typedef struct _BB_REGISTER_DEFINITION BB_REGISTER_DEFINITION_T;

enum Power_Mgnt {
	PS_MODE_ACTIVE = 0,
	PS_MODE_MIN = 1,
	PS_MODE_MAX = 2,
	PS_MODE_DTIM = 3,
	PS_MODE_VOIP = 4,
	PS_MODE_UAPSD_WMM = 5,
	PS_MODE_UAPSD = 6,
	PS_MODE_IBSS = 7,
	PS_MODE_WWLAN = 8,
	PM_Radio_Off = 9,
	PM_Card_Disable = 10,
	PS_MODE_NUM = 11,
};

typedef _sema _pwrlock;

enum _rt_rf_power_state {
	rf_on = 0,
	rf_sleep = 1,
	rf_off = 2,
	rf_max = 3,
};

typedef enum _rt_rf_power_state rt_rf_power_state;

enum _PS_BBRegBackup_ {
	PSBBREG_RF0 = 0,
	PSBBREG_RF1 = 1,
	PSBBREG_RF2 = 2,
	PSBBREG_AFE0 = 3,
	PSBBREG_TOTALCNT = 4,
};

struct pwrctrl_priv {
	_pwrlock lock;
	_pwrlock check_32k_lock;
	volatile u8 rpwm;
	volatile u8 cpwm;
	volatile u8 tog;
	volatile u8 cpwm_tog;
	u8 rpwm_retry;
	u8 pwr_mode;
	u8 smart_ps;
	u8 bcn_ant_mode;
	u8 dtim;
	u32 alives;
	_workitem cpwm_event;
	_workitem dma_event;
	u8 brpwmtimeout;
	_workitem rpwmtimeoutwi;
	_timer pwr_rpwm_timer;
	u8 bpower_saving;
	u8 b_hw_radio_off;
	u8 reg_rfoff;
	u8 reg_pdnmode;
	u32 rfoff_reason;
	uint ips_enter_cnts;
	uint ips_leave_cnts;
	uint lps_enter_cnts;
	uint lps_leave_cnts;
	u8 ips_mode;
	u8 ips_org_mode;
	u8 ips_mode_req;
	uint bips_processing;
	systime ips_deny_time;
	u8 pre_ips_type;
	u32 ps_deny;
	u8 ps_processing;
	u8 fw_psmode_iface_id;
	u8 bLeisurePs;
	u8 LpsIdleCount;
	u8 power_mgnt;
	u8 org_power_mgnt;
	u8 bFwCurrentInPSMode;
	systime lps_deny_time;
	s32 pnp_current_pwr_state;
	u8 pnp_bstop_trx;
	u8 bInSuspend;
	u8 bAutoResume;
	u8 autopm_cnt;
	u8 bSupportRemoteWakeup;
	u8 wowlan_wake_reason;
	u8 wowlan_last_wake_reason;
	u8 wowlan_ap_mode;
	u8 wowlan_mode;
	u8 wowlan_p2p_mode;
	u8 wowlan_pno_enable;
	u8 wowlan_in_resume;
	u8 hst2dev_high_active;
	_timer pwr_state_check_timer;
	int pwr_state_check_interval;
	u8 pwr_state_check_cnts;
	rt_rf_power_state rf_pwrstate;
	rt_rf_power_state change_rfpwrstate;
	u8 bHWPowerdown;
	u8 bHWPwrPindetect;
	u8 bkeepfwalive;
	u8 brfoffbyhw;
	long unsigned int PS_BBRegBackup[4];
	u8 lps_level_bk;
	u8 lps_level;
	u8 current_lps_hw_port_id;
};

enum dot11AuthAlgrthmNum {
	dot11AuthAlgrthm_Open = 0,
	dot11AuthAlgrthm_Shared = 1,
	dot11AuthAlgrthm_8021X = 2,
	dot11AuthAlgrthm_Auto = 3,
	dot11AuthAlgrthm_WAPI = 4,
	dot11AuthAlgrthm_MaxNum = 5,
};

struct hostapd_priv {
	_adapter *padapter;
};

struct sta_media_status_rpt_cmd_parm {
	struct sta_info *sta;
	bool connected;
};

struct io_queue {
	_lock lock;
	_list free_ioreqs;
	_list pending;
	_list processing;
	u8 *free_ioreqs_buf;
	u8 *pallocated_free_ioreqs_buf;
	struct intf_hdl intf;
};

struct debug_priv {
	u32 dbg_sdio_free_irq_error_cnt;
	u32 dbg_sdio_alloc_irq_error_cnt;
	u32 dbg_sdio_free_irq_cnt;
	u32 dbg_sdio_alloc_irq_cnt;
	u32 dbg_sdio_deinit_error_cnt;
	u32 dbg_sdio_init_error_cnt;
	u32 dbg_suspend_error_cnt;
	u32 dbg_suspend_cnt;
	u32 dbg_resume_cnt;
	u32 dbg_resume_error_cnt;
	u32 dbg_deinit_fail_cnt;
	u32 dbg_carddisable_cnt;
	u32 dbg_carddisable_error_cnt;
	u32 dbg_ps_insuspend_cnt;
	u32 dbg_dev_unload_inIPS_cnt;
	u32 dbg_wow_leave_ps_fail_cnt;
	u32 dbg_scan_pwr_state_cnt;
	u32 dbg_downloadfw_pwr_state_cnt;
	u32 dbg_fw_read_ps_state_fail_cnt;
	u32 dbg_leave_ips_fail_cnt;
	u32 dbg_leave_lps_fail_cnt;
	u32 dbg_h2c_leave32k_fail_cnt;
	u32 dbg_diswow_dload_fw_fail_cnt;
	u32 dbg_enwow_dload_fw_fail_cnt;
	u32 dbg_ips_drvopen_fail_cnt;
	u32 dbg_poll_fail_cnt;
	u32 dbg_rpwm_toogle_cnt;
	u32 dbg_rpwm_timeout_fail_cnt;
	u32 dbg_sreset_cnt;
	u32 dbg_fw_mem_dl_error_cnt;
	u64 dbg_rx_fifo_last_overflow;
	u64 dbg_rx_fifo_curr_overflow;
	u64 dbg_rx_fifo_diff_overflow;
};

struct mi_state {
	u8 sta_num;
	u8 ld_sta_num;
	u8 lg_sta_num;
	u8 ap_num;
	u8 starting_ap_num;
	u8 ld_ap_num;
	u8 adhoc_num;
	u8 ld_adhoc_num;
	u8 scan_num;
	u8 scan_enter_num;
	u8 uwps_num;
	u8 roch_num;
	u8 mgmt_tx_num;
	u8 p2p_device_num;
	u8 p2p_gc;
	u8 p2p_go;
};

struct macid_bmp {
	u32 m0;
};

struct macid_ctl_t {
	_lock lock;
	u8 num;
	struct macid_bmp used;
	struct macid_bmp bmc;
	struct macid_bmp if_g[2];
	struct macid_bmp ch_g[2];
	u8 iface_bmc[2];
	u8 h2c_msr[32];
	u8 bw[32];
	u8 vht_en[32];
	u32 rate_bmp0[32];
	u32 rate_bmp1[32];
	u8 op_num[8];
	struct sta_info *sta[32];
	u8 macid_cap;
	u16 reg_sleep_m0;
	u16 reg_drop_m0;
	u16 macid_txrpt;
	u8 macid_txrpt_pgsz;
};

struct sec_cam_bmp {
	u32 m0;
};

struct cam_ctl_t {
	_lock lock;
	u8 sec_cap;
	u32 flags;
	u8 num;
	struct sec_cam_bmp used;
	_mutex sec_cam_access_mutex;
};

struct sec_cam_ent {
	u16 ctrl;
	u8 mac[6];
	u8 key[16];
};

struct wow_ctl_t {
	u8 wow_cap;
};

struct p2p_reg_class {
	u8 reg_class;
	u8 channel[20];
	size_t channels;
};

struct p2p_channels {
	struct p2p_reg_class reg_class[10];
	size_t reg_classes;
};

struct rf_ctl_t {
	enum regd_src_t regd_src;
	const struct country_chplan *country_ent;
	u8 ChannelPlan;
	u8 max_chan_nums;
	RT_CHANNEL_INFO channel_set[42];
	struct op_class_pref_t **spt_op_class_ch;
	u8 cap_spt_op_class_num;
	u8 reg_spt_op_class_num;
	u8 cur_spt_op_class_num;
	struct p2p_channels channel_list;
	s16 antenna_gain;
	u8 op_class;
	u8 op_ch;
	s16 op_txpwr_max;
	u8 if_op_class[2];
	u8 if_op_ch[2];
	_mutex offch_mutex;
	u8 offch_state;
	u16 rate_bmp_cck_ofdm;
	u32 rate_bmp_ht_by_bw[2];
	u64 rate_bmp_vht_by_bw[4];
	u8 highest_ht_rate_bw_bmp;
	u8 highest_vht_rate_bw_bmp;
	_mutex txpwr_lmt_mutex;
	_list reg_exc_list;
	u8 regd_exc_num;
	_list txpwr_lmt_list;
	u8 txpwr_lmt_num;
	const char *txpwr_lmt_name;
	u8 txpwr_lmt_2g_cck_ofdm_state;
	u8 tpc_mode;
	u16 tpc_manual_constraint;
	bool ch_sel_within_same_band;
	u8 adaptivity_en;
	u8 edcca_mode_2g;
	u8 csa_ch;
	u8 csa_switch_cnt;
	u8 csa_ch_offset;
	u8 csa_ch_width;
	u8 csa_ch_freq_seg0;
	u8 csa_ch_freq_seg1;
};

struct rtw_traffic_statistics {
	u64 tx_bytes;
	u64 tx_pkts;
	u64 tx_drop;
	u64 cur_tx_bytes;
	u64 last_tx_bytes;
	u32 cur_tx_tp;
	u64 rx_bytes;
	u64 rx_pkts;
	u64 rx_drop;
	u64 cur_rx_bytes;
	u64 last_rx_bytes;
	u32 cur_rx_tp;
};

struct mmc_card;

struct sdio_func;

struct sdio_data {
	u8 func_number;
	u8 tx_block_mode;
	u8 rx_block_mode;
	u32 block_transfer_len;
	struct mmc_card *card;
	struct sdio_func *func;
	_thread_hdl_ sys_sdio_irq_thd;
	unsigned int clock;
	unsigned int timing;
	u8 sd3_bus_mode;
};

typedef struct sdio_data SDIO_DATA;

struct rtw_if_operations;

typedef struct rtw_if_operations *PRTW_IF_OPS;

struct dvobj_priv {
	u8 chip_type;
	u8 HardwareType;
	u8 interface_type;
	atomic_t bSurpriseRemoved;
	atomic_t bDriverStopped;
	s32 processing_dev_remove;
	struct debug_priv drv_dbg;
	_mutex hw_init_mutex;
	_mutex h2c_fwcmd_mutex;
	_mutex ioctrl_mutex;
	_mutex customer_str_mutex;
	struct submit_ctx *customer_str_sctx;
	u8 customer_str[16];
	_mutex setch_mutex;
	_mutex setbw_mutex;
	_mutex rf_read_reg_mutex;
	unsigned char oper_channel;
	unsigned char oper_bwmode;
	unsigned char oper_ch_offset;
	systime on_oper_ch_time;
	u8 union_ch;
	u8 union_bw;
	u8 union_offset;
	u8 union_ch_bak;
	u8 union_bw_bak;
	u8 union_offset_bak;
	_adapter *padapters[2];
	u8 iface_nums;
	struct mi_state iface_state;
	systime periodic_tsf_update_etime;
	_timer periodic_tsf_update_end_timer;
	struct macid_ctl_t macid_ctl;
	struct cam_ctl_t cam_ctl;
	struct sec_cam_ent cam_cache[32];
	struct wow_ctl_t wow_ctl;
	struct rf_ctl_t rf_ctl;
	struct tx_aclt_conf_t tx_aclt_force_val;
	u8 tx_aclt_flags;
	struct tx_aclt_conf_t tx_aclt_confs[3];
	int RtInPipe[2];
	int RtOutPipe[4];
	u8 Queue2Pipe[8];
	u8 irq_alloc;
	atomic_t continual_io_error;
	atomic_t disable_func;
	u8 xmit_block;
	_lock xmit_block_lock;
	struct pwrctrl_priv pwrctl_priv;
	struct rtw_traffic_statistics traffic_stat;
	_thread_hdl_ rtnl_lock_holder;
	struct wiphy *wiphy;
	_timer dynamic_chk_timer;
	SDIO_DATA intf_data;
	PRTW_IF_OPS intf_ops;
	u8 tpt_mode;
	u32 edca_be_ul;
	u32 edca_be_dl;
	u8 scan_deny;
};

enum {
	VENDOR_NL80211_SUBCMD_UNSPECIFIED = 0,
	VENDOR_NL80211_SUBCMD_RANGE_START = 1,
	VENDOR_NL80211_SUBCMD_RANGE_END = 4095,
	ANDROID_NL80211_SUBCMD_GSCAN_RANGE_START = 4096,
	ANDROID_NL80211_SUBCMD_GSCAN_RANGE_END = 4351,
	ANDROID_NL80211_SUBCMD_NBD_RANGE_START = 4352,
	ANDROID_NL80211_SUBCMD_NBD_RANGE_END = 4607,
	ANDROID_NL80211_SUBCMD_RTT_RANGE_START = 4352,
	ANDROID_NL80211_SUBCMD_RTT_RANGE_END = 4607,
	ANDROID_NL80211_SUBCMD_LSTATS_RANGE_START = 4608,
	ANDROID_NL80211_SUBCMD_LSTATS_RANGE_END = 4863,
	ANDROID_NL80211_SUBCMD_DEBUG_RANGE_START = 5120,
	ANDROID_NL80211_SUBCMD_DEBUG_RANGE_END = 5375,
	ANDROID_NL80211_SUBCMD_WIFI_OFFLOAD_RANGE_START = 5632,
	ANDROID_NL80211_SUBCMD_WIFI_OFFLOAD_RANGE_END = 5887,
	ANDROID_NL80211_SUBCMD_NAN_RANGE_START = 5888,
	ANDROID_NL80211_SUBCMD_NAN_RANGE_END = 6143,
	ANDROID_NL80211_SUBCMD_PKT_FILTER_RANGE_START = 6144,
	ANDROID_NL80211_SUBCMD_PKT_FILTER_RANGE_END = 6399,
};

struct session_tracker {
	_list list;
	u32 local_naddr;
	u16 local_port;
	u32 remote_naddr;
	u16 remote_port;
	systime set_time;
	u8 status;
};

struct st_cmd_parm {
	u8 cmd;
	struct sta_info *sta;
	u32 local_naddr;
	u16 local_port;
	u32 remote_naddr;
	u16 remote_port;
};

struct rtw_cmd {
	u8 (*cmd_hdl)(_adapter *, u8 *);
	void (*callback)(_adapter *, struct cmd_obj *);
};

struct rtw_evt_header {
	u8 id;
	u8 seq;
	u16 len;
};

enum {
	WRITE_REG = 1,
	READ_REG = 2,
	WRITE_RF = 3,
	READ_RF = 4,
	MP_START = 5,
	MP_STOP = 6,
	MP_RATE = 7,
	MP_CHANNEL = 8,
	MP_CHL_OFFSET = 9,
	MP_BANDWIDTH = 10,
	MP_TXPOWER = 11,
	MP_ANT_TX = 12,
	MP_ANT_RX = 13,
	MP_CTX = 14,
	MP_QUERY = 15,
	MP_ARX = 16,
	MP_PSD = 17,
	MP_PWRTRK = 18,
	MP_THER = 19,
	MP_IOCTL = 20,
	EFUSE_GET = 21,
	EFUSE_SET = 22,
	MP_RESET_STATS = 23,
	MP_DUMP = 24,
	MP_PHYPARA = 25,
	MP_SetRFPathSwh = 26,
	MP_QueryDrvStats = 27,
	CTA_TEST = 28,
	MP_DISABLE_BT_COEXIST = 29,
	MP_PwrCtlDM = 30,
	MP_GETVER = 31,
	MP_MON = 32,
	EFUSE_BT_MASK = 33,
	EFUSE_MASK = 34,
	EFUSE_FILE = 35,
	EFUSE_FILE_STORE = 36,
	MP_TX = 37,
	MP_RX = 38,
	MP_IQK = 39,
	MP_LCK = 40,
	MP_HW_TX_MODE = 41,
	MP_GET_TXPOWER_INX = 42,
	MP_CUSTOMER_STR = 43,
	MP_PWRLMT = 44,
	MP_PWRBYRATE = 45,
	BT_EFUSE_FILE = 46,
	MP_SetBT = 47,
	MP_SWRFPath = 48,
	MP_LINK = 49,
	MP_DPK_TRK = 50,
	MP_DPK = 51,
	MP_GET_TSSIDE = 52,
	MP_SET_TSSIDE = 53,
	MP_NULL = 54,
	MP_SD_IREAD = 55,
	MP_SD_IWRITE = 56,
};

enum _MP_MODE_ {
	MP_OFF = 0,
	MP_ON = 1,
	MP_ERR = 2,
	MP_CONTINUOUS_TX = 3,
	MP_SINGLE_CARRIER_TX = 4,
	MP_CARRIER_SUPPRISSION_TX = 5,
	MP_SINGLE_TONE_TX = 6,
	MP_PACKET_TX = 7,
	MP_PACKET_RX = 8,
};

struct nat25_network_db_entry {
	struct nat25_network_db_entry *next_hash;
	struct nat25_network_db_entry **pprev_hash;
	atomic_t use_count;
	unsigned char macAddr[6];
	long unsigned int ageing_timer;
	unsigned char networkAddr[17];
};

struct rtw_if_operations {
	int (*read)(struct dvobj_priv *, unsigned int, void *, size_t, bool);
	int (*write)(struct dvobj_priv *, unsigned int, void *, size_t, bool);
};

typedef unsigned int mmc_pm_flag_t;

typedef void sdio_irq_handler_t(struct sdio_func *);

struct sdio_func_tuple;

struct sdio_func {
	struct mmc_card *card;
	struct device dev;
	sdio_irq_handler_t *irq_handler;
	unsigned int num;
	unsigned char class;
	short unsigned int vendor;
	short unsigned int device;
	unsigned int max_blksize;
	unsigned int cur_blksize;
	unsigned int enable_timeout;
	unsigned int state;
	u8 *tmpbuf;
	u8 major_rev;
	u8 minor_rev;
	unsigned int num_info;
	const char **info;
	struct sdio_func_tuple *tuples;
};

struct sdio_func_tuple {
	struct sdio_func_tuple *next;
	unsigned char code;
	unsigned char size;
	unsigned char data[0];
};

struct mmc_cid {
	unsigned int manfid;
	char prod_name[8];
	unsigned char prv;
	unsigned int serial;
	short unsigned int oemid;
	short unsigned int year;
	unsigned char hwrev;
	unsigned char fwrev;
	unsigned char month;
};

struct mmc_csd {
	unsigned char structure;
	unsigned char mmca_vsn;
	short unsigned int cmdclass;
	short unsigned int taac_clks;
	unsigned int taac_ns;
	unsigned int c_size;
	unsigned int r2w_factor;
	unsigned int max_dtr;
	unsigned int erase_size;
	unsigned int read_blkbits;
	unsigned int write_blkbits;
	unsigned int capacity;
	unsigned int read_partial: 1;
	unsigned int read_misalign: 1;
	unsigned int write_partial: 1;
	unsigned int write_misalign: 1;
	unsigned int dsr_imp: 1;
};

struct mmc_ext_csd {
	u8 rev;
	u8 erase_group_def;
	u8 sec_feature_support;
	u8 rel_sectors;
	u8 rel_param;
	bool enhanced_rpmb_supported;
	u8 part_config;
	u8 cache_ctrl;
	u8 rst_n_function;
	u8 max_packed_writes;
	u8 max_packed_reads;
	u8 packed_event_en;
	unsigned int part_time;
	unsigned int sa_timeout;
	unsigned int generic_cmd6_time;
	unsigned int power_off_longtime;
	u8 power_off_notification;
	unsigned int hs_max_dtr;
	unsigned int hs200_max_dtr;
	unsigned int sectors;
	unsigned int hc_erase_size;
	unsigned int hc_erase_timeout;
	unsigned int sec_trim_mult;
	unsigned int sec_erase_mult;
	unsigned int trim_timeout;
	bool partition_setting_completed;
	long long unsigned int enhanced_area_offset;
	unsigned int enhanced_area_size;
	unsigned int cache_size;
	bool hpi_en;
	bool hpi;
	unsigned int hpi_cmd;
	bool bkops;
	bool man_bkops_en;
	bool auto_bkops_en;
	unsigned int data_sector_size;
	unsigned int data_tag_unit_size;
	unsigned int boot_ro_lock;
	bool boot_ro_lockable;
	bool ffu_capable;
	bool cmdq_en;
	bool cmdq_support;
	unsigned int cmdq_depth;
	u8 fwrev[8];
	u8 raw_exception_status;
	u8 raw_partition_support;
	u8 raw_rpmb_size_mult;
	u8 raw_erased_mem_count;
	u8 strobe_support;
	u8 raw_ext_csd_structure;
	u8 raw_card_type;
	u8 raw_driver_strength;
	u8 out_of_int_time;
	u8 raw_pwr_cl_52_195;
	u8 raw_pwr_cl_26_195;
	u8 raw_pwr_cl_52_360;
	u8 raw_pwr_cl_26_360;
	u8 raw_s_a_timeout;
	u8 raw_hc_erase_gap_size;
	u8 raw_erase_timeout_mult;
	u8 raw_hc_erase_grp_size;
	u8 raw_sec_trim_mult;
	u8 raw_sec_erase_mult;
	u8 raw_sec_feature_support;
	u8 raw_trim_mult;
	u8 raw_pwr_cl_200_195;
	u8 raw_pwr_cl_200_360;
	u8 raw_pwr_cl_ddr_52_195;
	u8 raw_pwr_cl_ddr_52_360;
	u8 raw_pwr_cl_ddr_200_360;
	u8 raw_bkops_status;
	u8 raw_sectors[4];
	u8 pre_eol_info;
	u8 device_life_time_est_typ_a;
	u8 device_life_time_est_typ_b;
	unsigned int feature_support;
};

struct sd_scr {
	unsigned char sda_vsn;
	unsigned char sda_spec3;
	unsigned char sda_spec4;
	unsigned char sda_specx;
	unsigned char bus_widths;
	unsigned char cmds;
};

struct sd_ssr {
	unsigned int au;
	unsigned int erase_timeout;
	unsigned int erase_offset;
};

struct sd_switch_caps {
	unsigned int hs_max_dtr;
	unsigned int uhs_max_dtr;
	unsigned int sd3_bus_mode;
	unsigned int sd3_drv_type;
	unsigned int sd3_curr_limit;
};

struct sdio_cccr {
	unsigned int sdio_vsn;
	unsigned int sd_vsn;
	unsigned int multi_block: 1;
	unsigned int low_speed: 1;
	unsigned int wide_bus: 1;
	unsigned int high_power: 1;
	unsigned int high_speed: 1;
	unsigned int disable_cd: 1;
};

struct sdio_cis {
	short unsigned int vendor;
	short unsigned int device;
	short unsigned int blksize;
	unsigned int max_dtr;
};

struct mmc_part {
	u64 size;
	unsigned int part_cfg;
	char name[20];
	bool force_ro;
	unsigned int area_type;
};

struct mmc_host;

struct mmc_card {
	struct mmc_host *host;
	struct device dev;
	u32 ocr;
	unsigned int rca;
	unsigned int type;
	unsigned int state;
	unsigned int quirks;
	unsigned int quirk_max_rate;
	bool reenable_cmdq;
	unsigned int erase_size;
	unsigned int erase_shift;
	unsigned int pref_erase;
	unsigned int eg_boundary;
	unsigned int erase_arg;
	u8 erased_byte;
	u32 raw_cid[4];
	u32 raw_csd[4];
	u32 raw_scr[2];
	u32 raw_ssr[16];
	struct mmc_cid cid;
	struct mmc_csd csd;
	struct mmc_ext_csd ext_csd;
	struct sd_scr scr;
	struct sd_ssr ssr;
	struct sd_switch_caps sw_caps;
	unsigned int sdio_funcs;
	atomic_t sdio_funcs_probed;
	struct sdio_cccr cccr;
	struct sdio_cis cis;
	struct sdio_func *sdio_func[7];
	struct sdio_func *sdio_single_irq;
	u8 major_rev;
	u8 minor_rev;
	unsigned int num_info;
	const char **info;
	struct sdio_func_tuple *tuples;
	unsigned int sd_bus_speed;
	unsigned int mmc_avail_type;
	unsigned int drive_strength;
	struct dentry *debugfs_root;
	struct mmc_part part[7];
	unsigned int nr_parts;
	unsigned int bouncesz;
	struct workqueue_struct *complete_wq;
};

struct mmc_data;

struct mmc_request;

struct mmc_command {
	u32 opcode;
	u32 arg;
	u32 resp[4];
	unsigned int flags;
	unsigned int retries;
	int error;
	unsigned int busy_timeout;
	struct mmc_data *data;
	struct mmc_request *mrq;
};

struct mmc_data {
	unsigned int timeout_ns;
	unsigned int timeout_clks;
	unsigned int blksz;
	unsigned int blocks;
	unsigned int blk_addr;
	int error;
	unsigned int flags;
	unsigned int bytes_xfered;
	struct mmc_command *stop;
	struct mmc_request *mrq;
	unsigned int sg_len;
	int sg_count;
	struct scatterlist *sg;
	s32 host_cookie;
};

struct mmc_request {
	struct mmc_command *sbc;
	struct mmc_command *cmd;
	struct mmc_data *data;
	struct mmc_command *stop;
	struct completion completion;
	struct completion cmd_completion;
	void (*done)(struct mmc_request *);
	void (*recovery_notifier)(struct mmc_request *);
	struct mmc_host *host;
	bool cap_cmd_during_tfr;
	int tag;
};

struct mmc_ios {
	unsigned int clock;
	short unsigned int vdd;
	unsigned int power_delay_ms;
	unsigned char bus_mode;
	unsigned char chip_select;
	unsigned char power_mode;
	unsigned char bus_width;
	unsigned char timing;
	unsigned char signal_voltage;
	unsigned char drv_type;
	bool enhanced_strobe;
};

struct mmc_ctx {
	struct task_struct *task;
};

struct mmc_slot {
	int cd_irq;
	bool cd_wake_enabled;
	void *handler_priv;
};

struct mmc_supply {
	struct regulator *vmmc;
	struct regulator *vqmmc;
};

struct mmc_host_ops;

struct mmc_pwrseq;

struct mmc_bus_ops;

struct led_trigger;

struct mmc_cqe_ops;

struct mmc_host {
	struct device *parent;
	struct device class_dev;
	int index;
	const struct mmc_host_ops *ops;
	struct mmc_pwrseq *pwrseq;
	unsigned int f_min;
	unsigned int f_max;
	unsigned int f_init;
	u32 ocr_avail;
	u32 ocr_avail_sdio;
	u32 ocr_avail_sd;
	u32 ocr_avail_mmc;
	struct wakeup_source *ws;
	u32 max_current_330;
	u32 max_current_300;
	u32 max_current_180;
	u32 caps;
	u32 caps2;
	int fixed_drv_type;
	mmc_pm_flag_t pm_caps;
	unsigned int max_seg_size;
	short unsigned int max_segs;
	short unsigned int unused;
	unsigned int max_req_size;
	unsigned int max_blk_size;
	unsigned int max_blk_count;
	unsigned int max_busy_timeout;
	spinlock_t lock;
	struct mmc_ios ios;
	unsigned int use_spi_crc: 1;
	unsigned int claimed: 1;
	unsigned int bus_dead: 1;
	unsigned int doing_init_tune: 1;
	unsigned int can_retune: 1;
	unsigned int doing_retune: 1;
	unsigned int retune_now: 1;
	unsigned int retune_paused: 1;
	unsigned int use_blk_mq: 1;
	unsigned int retune_crc_disable: 1;
	unsigned int can_dma_map_merge: 1;
	int rescan_disable;
	int rescan_entered;
	int need_retune;
	int hold_retune;
	unsigned int retune_period;
	struct timer_list retune_timer;
	bool trigger_card_event;
	struct mmc_card *card;
	wait_queue_head_t wq;
	struct mmc_ctx *claimer;
	int claim_cnt;
	struct mmc_ctx default_ctx;
	struct delayed_work detect;
	int detect_change;
	struct mmc_slot slot;
	const struct mmc_bus_ops *bus_ops;
	unsigned int bus_refs;
	unsigned int sdio_irqs;
	struct task_struct *sdio_irq_thread;
	struct delayed_work sdio_irq_work;
	bool sdio_irq_pending;
	atomic_t sdio_irq_thread_abort;
	mmc_pm_flag_t pm_flags;
	struct led_trigger *led;
	bool regulator_enabled;
	struct mmc_supply supply;
	struct dentry *debugfs_root;
	struct mmc_request *ongoing_mrq;
	unsigned int actual_clock;
	unsigned int slotno;
	int dsr_req;
	u32 dsr;
	const struct mmc_cqe_ops *cqe_ops;
	void *cqe_private;
	int cqe_qdepth;
	bool cqe_enabled;
	bool cqe_on;
	bool hsq_enabled;
	long: 8;
	long: 64;
	long: 64;
	long: 64;
	long unsigned int private[0];
};

struct mmc_host_ops {
	void (*post_req)(struct mmc_host *, struct mmc_request *, int);
	void (*pre_req)(struct mmc_host *, struct mmc_request *);
	void (*request)(struct mmc_host *, struct mmc_request *);
	int (*request_atomic)(struct mmc_host *, struct mmc_request *);
	void (*set_ios)(struct mmc_host *, struct mmc_ios *);
	int (*get_ro)(struct mmc_host *);
	int (*get_cd)(struct mmc_host *);
	void (*enable_sdio_irq)(struct mmc_host *, int);
	void (*ack_sdio_irq)(struct mmc_host *);
	void (*init_card)(struct mmc_host *, struct mmc_card *);
	int (*start_signal_voltage_switch)(struct mmc_host *, struct mmc_ios *);
	int (*card_busy)(struct mmc_host *);
	int (*execute_tuning)(struct mmc_host *, u32);
	int (*prepare_hs400_tuning)(struct mmc_host *, struct mmc_ios *);
	int (*hs400_prepare_ddr)(struct mmc_host *);
	void (*hs400_downgrade)(struct mmc_host *);
	void (*hs400_complete)(struct mmc_host *);
	void (*hs400_enhanced_strobe)(struct mmc_host *, struct mmc_ios *);
	int (*select_drive_strength)(struct mmc_card *, unsigned int, int, int, int *);
	void (*hw_reset)(struct mmc_host *);
	void (*card_event)(struct mmc_host *);
	int (*multi_io_quirk)(struct mmc_card *, unsigned int, int);
};

struct mmc_cqe_ops {
	int (*cqe_enable)(struct mmc_host *, struct mmc_card *);
	void (*cqe_disable)(struct mmc_host *);
	int (*cqe_request)(struct mmc_host *, struct mmc_request *);
	void (*cqe_post_req)(struct mmc_host *, struct mmc_request *);
	void (*cqe_off)(struct mmc_host *);
	int (*cqe_wait_for_idle)(struct mmc_host *);
	bool (*cqe_timeout)(struct mmc_host *, struct mmc_request *, bool *);
	void (*cqe_recovery_start)(struct mmc_host *);
	void (*cqe_recovery_finish)(struct mmc_host *);
};

struct mmc_bus_ops {
	void (*remove)(struct mmc_host *);
	void (*detect)(struct mmc_host *);
	int (*pre_suspend)(struct mmc_host *);
	int (*suspend)(struct mmc_host *);
	int (*resume)(struct mmc_host *);
	int (*runtime_suspend)(struct mmc_host *);
	int (*runtime_resume)(struct mmc_host *);
	int (*alive)(struct mmc_host *);
	int (*shutdown)(struct mmc_host *);
	int (*hw_reset)(struct mmc_host *);
	int (*sw_reset)(struct mmc_host *);
	bool (*cache_enabled)(struct mmc_host *);
};

enum _IFACE_ID {
	IFACE_ID0 = 0,
	IFACE_ID1 = 1,
	IFACE_ID2 = 2,
	IFACE_ID3 = 3,
	IFACE_ID4 = 4,
	IFACE_ID5 = 5,
	IFACE_ID6 = 6,
	IFACE_ID7 = 7,
	IFACE_ID_MAX = 8,
};

enum _hw_port {
	HW_PORT0 = 0,
	HW_PORT1 = 1,
	HW_PORT2 = 2,
	HW_PORT3 = 3,
	HW_PORT4 = 4,
	MAX_HW_PORT = 5,
};

enum _ADAPTER_TYPE {
	PRIMARY_ADAPTER = 0,
	VIRTUAL_ADAPTER = 1,
	MAX_ADAPTER = 255,
};

enum phydm_api_host {
	RUN_IN_FW = 0,
	RUN_IN_DRIVER = 1,
};

enum phydm_phy_sts_type {
	PHYDM_PHYSTS_TYPE_1 = 1,
	PHYDM_PHYSTS_TYPE_2 = 2,
	PHYDM_PHYSTS_TYPE_3 = 3,
};

struct phydm_dig_recorder_strcut {
	u8 igi_bitmap;
	u8 igi_history[4];
	u32 fa_history[4];
	u8 damping_limit_en;
	u8 damping_limit_val;
	u32 limit_time;
	u8 limit_rssi;
};

struct phydm_dig_struct {
	struct phydm_dig_recorder_strcut dig_recorder_t;
	u8 dig_dl_en;
	bool fw_dig_enable;
	bool is_dbg_fa_th;
	u8 cur_ig_value;
	bool igi_dyn_up_hit;
	u8 igi_trend;
	u32 rvrt_val;
	u8 igi_backup;
	u8 rx_gain_range_max;
	u8 rx_gain_range_min;
	u8 dm_dig_max;
	u8 dm_dig_min;
	u8 dig_max_of_min;
	u32 ant_div_rssi_max;
	u8 *is_p2p_in_process;
	u32 fa_th[3];
	u32 dm_dig_fa_th1;
	u8 fa_source;
	u8 upcheck_init_val;
	u8 lv0_ratio_reciprocal;
	u8 lv1_ratio_reciprocal;
};

struct phydm_fa_struct {
	u32 cnt_parity_fail;
	u32 cnt_rate_illegal;
	u32 cnt_crc8_fail;
	u32 cnt_crc8_fail_vhta;
	u32 cnt_crc8_fail_vhtb;
	u32 cnt_mcs_fail;
	u32 cnt_mcs_fail_vht;
	u32 cnt_ofdm_fail;
	u32 cnt_ofdm_fail_pre;
	u32 cnt_cck_fail;
	u32 cnt_all;
	u32 cnt_all_accumulated;
	u32 cnt_all_pre;
	u32 cnt_fast_fsync;
	u32 cnt_sb_search_fail;
	u32 cnt_ofdm_cca;
	u32 cnt_cck_cca;
	u32 cnt_cca_all;
	u32 cnt_bw_usc;
	u32 cnt_bw_lsc;
	u32 cnt_cck_crc32_error;
	u32 cnt_cck_crc32_ok;
	u32 cnt_ofdm_crc32_error;
	u32 cnt_ofdm_crc32_ok;
	u32 cnt_ht_crc32_error;
	u32 cnt_ht_crc32_ok;
	u32 cnt_ht_crc32_error_agg;
	u32 cnt_ht_crc32_ok_agg;
	u32 cnt_vht_crc32_error;
	u32 cnt_vht_crc32_ok;
	u32 cnt_crc32_error_all;
	u32 cnt_crc32_ok_all;
	u32 time_fa_all;
	u32 time_fa_exp;
	u32 time_fa_ifs_clm;
	u32 time_fa_fahm;
	bool cck_block_enable;
	bool ofdm_block_enable;
	u32 dbg_port0;
	bool edcca_flag;
	u8 ofdm2_rate_idx;
	u32 cnt_ofdm2_crc32_error;
	u32 cnt_ofdm2_crc32_ok;
	u8 ofdm2_pcr;
	u8 ht2_rate_idx;
	u32 cnt_ht2_crc32_error;
	u32 cnt_ht2_crc32_ok;
	u8 ht2_pcr;
	u8 vht2_rate_idx;
	u32 cnt_vht2_crc32_error;
	u32 cnt_vht2_crc32_ok;
	u8 vht2_pcr;
	u32 cnt_cck_txen;
	u32 cnt_cck_txon;
	u32 cnt_ofdm_txen;
	u32 cnt_ofdm_txon;
};

struct ra_table {
	u8 highest_client_tx_order;
	u16 highest_client_tx_rate_order;
	u8 power_tracking_flag;
	u8 ra_th_ofst;
	u8 ra_ofst_direc;
	u8 up_ramask_cnt;
	u8 up_ramask_cnt_tmp;
	u32 rrsr_val_init;
	u32 rrsr_val_curr;
	bool dynamic_rrsr_en;
	u8 ra_trigger_mode;
	u8 ra_tx_cls_th;
	u8 ldpc_thres;
	void (*record_ra_info)(void *, u8, struct cmn_sta_info *, u64);
	u8 ra_mask_rpt_stamp;
	u8 ra_mask_buf[8];
};

struct phydm_cfo_track_struct {
	bool is_atc_status;
	bool is_adjust;
	u8 crystal_cap;
	u8 crystal_cap_default;
	u8 def_x_cap;
	s32 CFO_tail[4];
	u32 CFO_cnt[4];
	s32 CFO_ave_pre;
	u32 packet_count;
	u32 packet_count_pre;
};

struct phydm_adaptivity_struct {
	bool mode_cvrt_en;
	s8 th_l2h_ini_backup;
	s8 th_edcca_hl_diff_backup;
	s8 igi_base;
	s8 h2l_lb;
	s8 l2h_lb;
	u8 ap_num_th;
	u8 l2h_dyn_min;
	u32 adaptivity_dbg_port;
	u8 debug_mode;
	u16 igi_up_bound_lmt_cnt;
	u16 igi_up_bound_lmt_val;
	bool igi_lmt_en;
	u8 adapt_igi_up;
	u32 rvrt_val[2];
	s8 th_l2h;
	s8 th_h2l;
	u8 regulation_2g;
	u8 regulation_5g;
	u8 switch_th_l2h_ini_in_band;
};

enum nhm_divider_opt_all {
	NHM_CNT_ALL = 0,
	NHM_VALID = 1,
	NHM_CNT_INIT = 2,
};

enum nhm_option_cca_all {
	NHM_EXCLUDE_CCA = 0,
	NHM_INCLUDE_CCA = 1,
	NHM_CCA_INIT = 2,
};

enum nhm_option_txon_all {
	NHM_EXCLUDE_TXON = 0,
	NHM_INCLUDE_TXON = 1,
	NHM_TXON_INIT = 2,
};

enum nhm_application {
	NHM_BACKGROUND = 0,
	NHM_ACS = 1,
	IEEE_11K_HIGH = 2,
	IEEE_11K_LOW = 3,
	INTEL_XBOX = 4,
	NHM_DBG = 5,
};

enum clm_application {
	CLM_BACKGROUND = 0,
	CLM_ACS = 1,
};

enum clm_monitor_mode {
	CLM_DRIVER_MNTR = 1,
	CLM_FW_MNTR = 2,
};

struct ccx_info {
	u32 nhm_trigger_time;
	u32 clm_trigger_time;
	u32 fahm_trigger_time;
	u32 ifs_clm_trigger_time;
	u64 start_time;
	u8 ccx_watchdog_result;
	enum nhm_application nhm_app;
	enum nhm_option_txon_all nhm_include_txon;
	enum nhm_option_cca_all nhm_include_cca;
	enum nhm_divider_opt_all nhm_divider_opt;
	u8 nhm_th[11];
	u8 nhm_result[12];
	u8 nhm_wgt[12];
	u16 nhm_period;
	u8 nhm_igi;
	u8 nhm_manual_ctrl;
	u8 nhm_ratio;
	u8 nhm_env_ratio;
	u8 nhm_rpt_sum;
	u8 nhm_set_lv;
	bool nhm_ongoing;
	u8 nhm_rpt_stamp;
	u8 nhm_level;
	u8 nhm_level_valid;
	u8 nhm_pwr;
	enum clm_application clm_app;
	u8 clm_manual_ctrl;
	u8 clm_set_lv;
	bool clm_ongoing;
	u16 clm_period;
	u16 clm_result;
	u8 clm_ratio;
	u32 clm_fw_result_acc;
	u8 clm_fw_result_cnt;
	enum clm_monitor_mode clm_mntr_mode;
	u8 clm_rpt_stamp;
};

struct psd_info {
	u8 psd_in_progress;
	u32 psd_reg;
	u32 psd_report_reg;
	u8 psd_pwr_common_offset;
	u16 sw_avg_time;
	u16 fft_smp_point;
	u32 rf_0x18_bkp;
	u32 rf_0x18_bkp_b;
	u16 psd_fc_channel;
	u32 psd_bw_rf_reg;
	u8 psd_result[128];
	u8 noise_k_en;
};

enum cckpd_lv {
	CCK_PD_LV_INIT = 255,
	CCK_PD_LV_0 = 0,
	CCK_PD_LV_1 = 1,
	CCK_PD_LV_2 = 2,
	CCK_PD_LV_3 = 3,
	CCK_PD_LV_4 = 4,
	CCK_PD_LV_MAX = 5,
};

struct phydm_cckpd_struct {
	u8 cckpd_hw_type;
	u8 cur_cck_cca_thres;
	u32 cck_fa_ma;
	u32 rvrt_val;
	u8 pause_lv;
	u8 cck_n_rx;
	u16 cck_fa_th[2];
	enum channel_width cck_bw;
	enum cckpd_lv cck_pd_lv;
	u8 cck_cca_th_aaa;
	u8 aaa_default;
};

enum auto_dbg_type_e {
	AUTO_DBG_STOP = 0,
	AUTO_DBG_CHECK_HANG = 1,
	AUTO_DBG_CHECK_RA = 2,
	AUTO_DBG_CHECK_DIG = 3,
};

struct phydm_auto_dbg_struct {
	enum auto_dbg_type_e auto_dbg_type;
	u8 dbg_step;
	u16 dbg_port_table[6];
	u32 dbg_port_val[6];
	u16 ofdm_t_cnt;
	u16 ofdm_r_cnt;
	u16 cck_t_cnt;
	u16 cck_r_cnt;
	u16 ofdm_crc_error_cnt;
	u16 cck_crc_error_cnt;
};

struct odm_noise_monitor {
	s8 noise[4];
	s16 noise_all;
};

struct phydm_api_stuc {
	u32 rxiqc_reg1;
	u32 rxiqc_reg2;
	u8 tx_queue_bitmap;
	u8 ccktx_path;
	u8 pri_ch_idx;
};

struct phydm_pow_train_stuc {
	u8 pt_state;
	u32 pow_train_score;
};

struct dm_dack_info {
	bool dack_en;
	u16 msbk_d[60];
	u8 dck_d[8];
	u16 biask_d[4];
};

struct dm_iqk_info {
	bool lok_fail[1];
	bool iqk_fail[2];
	u32 iqc_matrix[2];
	u8 iqk_times;
	u32 rf_reg18;
	u32 rf_reg08;
	u32 lna_idx;
	u8 iqk_step;
	u8 rxiqk_step;
	u8 tmp1bcc;
	u8 txgain;
	u32 txgain56;
	u8 kcount;
	u8 rfk_ing;
	bool rfk_forbidden;
	u8 rxbb;
	u32 rf_reg58;
	bool segment_iqk;
	bool is_tssi_mode;
	u8 iqk_band;
	u8 iqk_ch;
	u8 iqk_bw;
};

struct dm_dpk_info {
	bool is_dpk_enable;
	bool is_dpk_pwr_on;
	bool is_dpk_by_channel;
	bool is_tssi_mode;
	u8 dpk_status;
	u16 dpk_path_ok;
	u8 thermal_dpk[1];
	u8 thermal_dpk_avg[8];
	u8 pre_pwsf[1];
	u8 thermal_dpk_avg_index;
	u32 gnt_control;
	u32 gnt_value;
	u8 dpk_ch;
	u8 dpk_band;
	u8 dpk_bw;
	u32 dpk_rf18[2];
	u32 dpk_cal_cnt;
	u32 dpk_ok_cnt;
	u32 dpk_reload_cnt;
};

struct _halrf_psd_data {
	u32 point;
	u32 start_point;
	u32 stop_point;
	u32 average;
	u32 buf_size;
	u32 psd_data[256];
	u32 psd_progress;
};

struct _halrf_tssi_data {
	s32 cck_offset_patha;
	s32 cck_offset_pathb;
	s32 tssi_trk_txagc_offset[4];
	s32 delta_tssi_txagc_offset[4];
	s16 txagc_codeword[84];
	u16 tssi_codeword[84];
	s8 tssi_efuse[100];
	s8 tssi_de_diff_efuse[40];
	s8 tssi_kfree_efuse[16];
	u8 thermal[4];
	u32 index[56];
	u8 do_tssi;
	u8 get_thermal;
	u8 tssi_finish_bit[4];
	u8 thermal_trigger;
	s8 tssi_de;
};

struct _halrf_txgapk_info {
	u32 txgapk_rf3f_bp[240];
	bool txgapk_bp_done;
	s8 offset[48];
	s8 fianl_offset[48];
	u8 read_txgain;
};

struct _hal_rf_ {
	u8 *test1;
	u32 rf_supportability;
	u8 rf_shift_band;
	u8 eeprom_thermal;
	u8 dpk_en;
	bool dpk_done;
	u64 dpk_progressing_time;
	u64 iqk_progressing_time;
	u32 fw_ver;
	bool *is_con_tx;
	bool *is_single_tone;
	bool *is_carrier_suppresion;
	bool is_dpk_in_progress;
	bool is_tssi_in_progress;
	bool is_bt_iqk_timeout;
	bool is_rfk_h2c_timeout;
	bool aac_checked;
	bool is_txgapk_in_progress;
	u8 *mp_rate_index;
	u32 *manual_rf_supportability;
	u32 p_rate_index;
	u8 pwt_type;
	u32 rf_dbg_comp;
	u8 rfk_type;
	u32 gnt_control;
	u8 ext_lna;
	u8 ext_lna_5g;
	u8 ext_pa;
	u8 ext_pa_5g;
	struct _halrf_psd_data halrf_psd_data;
	struct _halrf_tssi_data halrf_tssi_data;
	struct _halrf_txgapk_info halrf_txgapk_info;
	u8 power_track_type;
	u8 mp_pwt_type;
	u8 pre_band_type;
};

struct odm_power_trim_data {
	u8 flag;
	u8 pa_bias_flag;
	u8 lna_flag;
	s8 bb_gain[36];
	s8 tssi_trim[36];
	s8 pa_bias_trim[36];
	s8 lna_trim[4];
	s8 thermal;
	s8 multi_thermal[4];
};

struct iqk_matrix_regs_setting {
	bool is_iqk_done;
	s32 value[24];
	bool is_bw_iqk_result_saved[3];
};

struct dm_rf_calibration_struct {
	u32 rega24;
	s32 rege94;
	s32 rege9c;
	s32 regeb4;
	s32 regebc;
	u8 tx_powercount;
	bool is_txpowertracking_init;
	bool is_txpowertracking;
	u8 txpowertrack_control;
	u8 tm_trigger;
	u8 internal_pa_5g[2];
	u8 thermal_meter[2];
	u8 thermal_value;
	u8 thermal_value_path[4];
	u8 thermal_value_lck;
	u8 thermal_value_iqk;
	s8 thermal_value_delta;
	u8 thermal_value_dpk;
	u8 thermal_value_avg[8];
	u8 thermal_value_avg_path[32];
	u8 thermal_value_avg_index;
	u8 thermal_value_avg_index_path[4];
	u8 thermal_value_rx_gain;
	u8 thermal_value_crystal;
	u8 thermal_value_dpk_store;
	u8 thermal_value_dpk_track;
	bool txpowertracking_in_progress;
	bool is_reloadtxpowerindex;
	u8 is_rf_pi_enable;
	u32 txpowertracking_callback_cnt;
	u8 is_cck_in_ch14;
	u8 CCK_index;
	u8 OFDM_index[4];
	s8 power_index_offset[4];
	s8 delta_power_index[4];
	s8 delta_power_index_last[4];
	bool is_tx_power_changed;
	s8 xtal_offset;
	s8 xtal_offset_last;
	u8 xtal_offset_eanble;
	struct iqk_matrix_regs_setting iqk_matrix_reg_setting[59];
	u8 delta_lck;
	s8 bb_swing_diff_2g;
	s8 bb_swing_diff_5g;
	u8 delta_swing_table_idx_2g_cck_a_p[30];
	u8 delta_swing_table_idx_2g_cck_a_n[30];
	u8 delta_swing_table_idx_2g_cck_b_p[30];
	u8 delta_swing_table_idx_2g_cck_b_n[30];
	u8 delta_swing_table_idx_2g_cck_c_p[30];
	u8 delta_swing_table_idx_2g_cck_c_n[30];
	u8 delta_swing_table_idx_2g_cck_d_p[30];
	u8 delta_swing_table_idx_2g_cck_d_n[30];
	u8 delta_swing_table_idx_2ga_p[30];
	u8 delta_swing_table_idx_2ga_n[30];
	u8 delta_swing_table_idx_2gb_p[30];
	u8 delta_swing_table_idx_2gb_n[30];
	u8 delta_swing_table_idx_2gc_p[30];
	u8 delta_swing_table_idx_2gc_n[30];
	u8 delta_swing_table_idx_2gd_p[30];
	u8 delta_swing_table_idx_2gd_n[30];
	u8 delta_swing_table_idx_5ga_p[120];
	u8 delta_swing_table_idx_5ga_n[120];
	u8 delta_swing_table_idx_5gb_p[120];
	u8 delta_swing_table_idx_5gb_n[120];
	u8 delta_swing_table_idx_5gc_p[120];
	u8 delta_swing_table_idx_5gc_n[120];
	u8 delta_swing_table_idx_5gd_p[120];
	u8 delta_swing_table_idx_5gd_n[120];
	u8 delta_swing_tssi_table_2g_cck_a[61];
	u8 delta_swing_tssi_table_2g_cck_b[61];
	u8 delta_swing_tssi_table_2g_cck_c[61];
	u8 delta_swing_tssi_table_2g_cck_d[61];
	u8 delta_swing_tssi_table_2ga[61];
	u8 delta_swing_tssi_table_2gb[61];
	u8 delta_swing_tssi_table_2gc[61];
	u8 delta_swing_tssi_table_2gd[61];
	u8 delta_swing_tssi_table_5ga[244];
	u8 delta_swing_tssi_table_5gb[244];
	u8 delta_swing_tssi_table_5gc[244];
	u8 delta_swing_tssi_table_5gd[244];
	s8 delta_swing_table_xtal_p[30];
	s8 delta_swing_table_xtal_n[30];
	u8 delta_swing_table_idx_2ga_p_8188e[30];
	u8 delta_swing_table_idx_2ga_n_8188e[30];
	u8 bb_swing_idx_ofdm[4];
	u8 bb_swing_idx_ofdm_current;
	u8 bb_swing_idx_ofdm_base[4];
	bool default_bb_swing_index_flag;
	bool bb_swing_flag_ofdm;
	u8 bb_swing_idx_cck;
	u8 bb_swing_idx_cck_current;
	u8 bb_swing_idx_cck_base;
	u8 default_ofdm_index;
	u8 default_cck_index;
	s8 default_txagc_index;
	bool bb_swing_flag_cck;
	s8 absolute_ofdm_swing_idx[4];
	s8 remnant_ofdm_swing_idx[4];
	s8 absolute_cck_swing_idx[4];
	s8 remnant_cck_swing_idx;
	s8 modify_tx_agc_value;
	bool modify_tx_agc_flag_path_a;
	bool modify_tx_agc_flag_path_b;
	bool modify_tx_agc_flag_path_c;
	bool modify_tx_agc_flag_path_d;
	bool modify_tx_agc_flag_path_a_cck;
	bool modify_tx_agc_flag_path_b_cck;
	s8 kfree_offset[4];
	u32 regc04;
	u32 reg874;
	u32 regc08;
	u32 regb68;
	u32 regb6c;
	u32 reg870;
	u32 reg860;
	u32 reg864;
	bool is_iqk_initialized;
	bool is_lck_in_progress;
	bool is_antenna_detected;
	bool is_need_iqk;
	bool is_iqk_in_progress;
	bool is_iqk_pa_off;
	u8 delta_iqk;
	u32 ADDA_backup[16];
	u32 IQK_MAC_backup[4];
	u32 IQK_BB_backup_recover[9];
	u32 IQK_BB_backup[9];
	u32 tx_iqc_8723b[12];
	u32 rx_iqc_8723b[8];
	u32 tx_iqc_8703b[6];
	u32 rx_iqc_8703b[4];
	u32 tx_iqc_8723d[12];
	u32 rx_iqc_8723d[8];
	u32 tx_iqc_8710b[12];
	u32 rx_iqc_8710b[8];
	u8 iqk_step;
	u8 kcount;
	u8 retry_count[8];
	bool is_mp_mode;
	u64 iqk_start_time;
	u64 iqk_progressing_time;
	u64 iqk_total_progressing_time;
	u64 lck_progressing_time;
	u32 lok_result;
	u32 ap_koutput[4];
	u8 is_ap_kdone;
	u8 is_apk_thermal_meter_ignore;
	bool is_dpk_fail;
	u8 is_dp_done;
	u8 is_dp_path_aok;
	u8 is_dp_path_bok;
	u32 tx_lok[2];
	u32 dpk_tx_agc;
	s32 dpk_gain;
	u32 dpk_thermal[4];
	s8 modify_tx_agc_value_ofdm;
	s8 modify_tx_agc_value_cck;
	u8 reg_rf_kfree_enable;
	u8 rf_kfree_enable;
};

struct phydm_phystatus_statistic {
	u32 rssi_cck_sum;
	u32 rssi_cck_cnt;
	u32 rssi_beacon_sum[1];
	u32 rssi_beacon_cnt;
	u32 rssi_ofdm_sum[1];
	u32 rssi_ofdm_cnt;
	u32 evm_ofdm_sum;
	u32 snr_ofdm_sum[1];
	u16 evm_ofdm_hist[12];
	u16 snr_ofdm_hist[12];
	u32 rssi_1ss_cnt;
	u32 rssi_1ss_sum[1];
	u32 evm_1ss_sum;
	u32 snr_1ss_sum[1];
	u16 evm_1ss_hist[12];
	u16 snr_1ss_hist[12];
};

struct phydm_phystatus_avg {
	u8 rssi_cck_avg;
	u8 rssi_beacon_avg[1];
	u8 rssi_ofdm_avg[1];
	u8 evm_ofdm_avg;
	u8 snr_ofdm_avg[1];
	u8 rssi_1ss_avg[1];
	u8 evm_1ss_avg;
	u8 snr_1ss_avg[1];
};

struct odm_phy_dbg_info {
	u32 num_qry_phy_status_cck;
	u32 num_qry_phy_status_ofdm;
	u32 num_qry_mu_pkt;
	u32 num_qry_bf_pkt;
	u16 num_mu_vht_pkt[10];
	bool is_ldpc_pkt;
	bool is_stbc_pkt;
	u8 num_of_ppdu[4];
	u8 gid_num[4];
	u32 condi_num;
	u8 condi_num_cdf[10];
	u8 num_qry_beacon_pkt;
	u8 beacon_cnt_in_period;
	u8 beacon_phy_rate;
	u8 show_phy_sts_all_pkt;
	u16 show_phy_sts_max_cnt;
	u16 show_phy_sts_cnt;
	u16 num_qry_legacy_pkt[12];
	u16 num_qry_ht_pkt[8];
	u16 num_qry_pkt_sc_20m[10];
	bool ht_pkt_not_zero;
	bool low_bw_20_occur;
	u16 snr_hist_th[11];
	u16 evm_hist_th[11];
	struct phydm_phystatus_statistic physts_statistic_info;
	struct phydm_phystatus_avg phystatus_statistic_avg;
};

enum phy_reg_pg_type {
	PHY_REG_PG_RELATIVE_VALUE = 0,
	PHY_REG_PG_EXACT_VALUE = 1,
};

struct phydm_pause_lv {
	s8 lv_dig;
	s8 lv_cckpd;
	s8 lv_antdiv;
	s8 lv_adapt;
	s8 lv_adsl;
};

struct phydm_func_poiner {
	void (*pause_phydm_handler)(void *, u32 *, u8);
};

struct pkt_process_info {
	u8 lna_idx;
	u8 vga_idx;
};

struct phydm_bt_info {
	bool is_bt_enabled;
	bool is_bt_connect_process;
	u8 bt_hs_rssi;
	bool is_bt_hs_operation;
	bool is_bt_limited_dig;
};

struct phydm_iot_center {
	bool is_linked_cmw500;
	u8 win_patch_id;
	bool patch_id_100f0401;
	bool patch_id_10120200;
	bool patch_id_40010700;
	bool patch_id_021f0800;
	bool patch_id_011f0500;
	u32 phydm_patch_id;
};

struct rtl8192cd_priv;

struct dm_struct {
	void *adapter;
	struct rtl8192cd_priv *priv;
	bool odm_ready;
	enum phy_reg_pg_type phy_reg_pg_value_type;
	u8 phy_reg_pg_version;
	u64 support_ability;
	u64 pause_ability;
	u64 debug_components;
	u8 cmn_dbg_msg_period;
	u8 cmn_dbg_msg_cnt;
	u32 fw_debug_components;
	u32 num_qry_phy_status_all;
	u32 last_num_qry_phy_status_all;
	u32 rx_pwdb_ave;
	bool is_init_hw_info_by_rfe;
	u8 en_tssi_mode;
	bool is_cck_high_power;
	u8 rf_path_rx_enable;
	u8 support_platform;
	u8 normal_rx_path;
	u8 valid_path_set;
	bool brxagcswitch;
	u8 support_interface;
	u32 support_ic_type;
	enum phydm_api_host run_in_drv_fw;
	u8 ic_ip_series;
	enum phydm_phy_sts_type ic_phy_sts_type;
	u8 cut_version;
	u8 fab_version;
	u8 fw_version;
	u8 fw_sub_version;
	u8 rf_type;
	u8 rfe_type;
	u8 board_type;
	u8 package_type;
	u16 type_glna;
	u16 type_gpa;
	u16 type_alna;
	u16 type_apa;
	u8 ext_lna;
	u8 ext_lna_5g;
	u8 ext_pa;
	u8 ext_pa_5g;
	u8 efuse0x3d7;
	u8 efuse0x3d8;
	u8 ext_trsw;
	u8 ext_lna_gain;
	bool is_in_hct_test;
	u8 wifi_test;
	bool is_dual_mac_smart_concurrent;
	u32 bk_support_ability;
	u8 with_extenal_ant_switch;
	bool cck_new_agc;
	s8 cck_lna_gain_table[8];
	u8 cck_sat_cnt_th_init;
	u32 phydm_sys_up_time;
	u8 num_rf_path;
	u32 soft_ap_special_setting;
	bool boolean_dummy;
	s8 s8_dummy;
	u8 u8_dummy;
	u16 u16_dummy;
	u32 u32_dummy;
	u8 rfe_hwsetting_band;
	u8 p_advance_ota;
	bool hp_hw_id;
	bool BOOLEAN_temp;
	bool is_dfs_band;
	u8 is_rx_blocking_en;
	u16 fw_offload_ability;
	bool is_download_fw;
	bool en_dis_dpd;
	u16 dis_dpd_rate;
	u8 en_auto_bw_th;
	bool is_pause_dig;
	u64 *num_tx_bytes_unicast;
	u64 *num_rx_bytes_unicast;
	u8 *band_type;
	u8 *sec_ch_offset;
	u8 *security;
	u8 *band_width;
	u8 *channel;
	bool *is_scan_in_process;
	bool *is_power_saving;
	bool *is_tdma;
	u8 *one_path_cca;
	u8 *antenna_test;
	bool *is_net_closed;
	bool *is_fcs_mode_enable;
	bool *is_1_antenna;
	u8 *rf_default_path;
	u16 *forced_data_rate;
	u8 *enable_antdiv;
	u8 *enable_pathdiv;
	u8 *en_adap_soml;
	u8 *edcca_mode;
	u8 *hub_usb_mode;
	bool *is_fw_dw_rsvd_page_in_progress;
	u32 *current_tx_tp;
	u32 *current_rx_tp;
	u8 *sounding_seq;
	u32 *soft_ap_mode;
	u8 *mp_mode;
	u32 *interrupt_mask;
	u8 *bb_op_mode;
	u32 *manual_supportability;
	u8 *dis_dym_bw_indication;
	u8 disable_phydm_watchdog;
	bool is_link_in_process;
	bool is_wifi_direct;
	bool is_wifi_display;
	bool is_linked;
	bool pre_is_linked;
	bool first_connect;
	bool first_disconnect;
	bool bsta_state;
	u8 rssi_min;
	u8 rssi_min_macid;
	u8 pre_rssi_min;
	u8 rssi_max;
	u8 rssi_max_macid;
	u8 rssi_min_by_path;
	bool is_mp_chip;
	bool is_one_entry_only;
	u32 one_entry_macid;
	u32 one_entry_tp;
	u32 pre_one_entry_tp;
	u8 pre_number_linked_client;
	u8 number_linked_client;
	u8 pre_number_active_client;
	u8 number_active_client;
	bool is_disable_phy_api;
	u8 rssi_a;
	u8 rssi_b;
	u8 rssi_c;
	u8 rssi_d;
	s8 rxsc_80;
	s8 rxsc_40;
	s8 rxsc_20;
	s8 rxsc_l;
	u64 rssi_trsw;
	u64 rssi_trsw_h;
	u64 rssi_trsw_l;
	u64 rssi_trsw_iso;
	u8 tx_ant_status;
	u8 rx_ant_status;
	enum bb_path tx_1ss_status;
	u8 cck_lna_idx;
	u8 cck_vga_idx;
	u8 curr_station_id;
	u8 ofdm_agc_idx[4];
	u8 rx_rate;
	u8 rate_ss;
	u8 tx_rate;
	u8 linked_interval;
	u8 pre_channel;
	u32 txagc_offset_value_a;
	bool is_txagc_offset_positive_a;
	u32 txagc_offset_value_b;
	bool is_txagc_offset_positive_b;
	u8 ap_total_num;
	bool flatness_type;
	u8 traffic_load;
	u8 pre_traffic_load;
	u32 tx_tp;
	u32 rx_tp;
	u32 total_tp;
	u8 txrx_state_all;
	u64 cur_tx_ok_cnt;
	u64 cur_rx_ok_cnt;
	u64 last_tx_ok_cnt;
	u64 last_rx_ok_cnt;
	u16 consecutive_idlel_time;
	bool is_bb_swing_offset_positive_a;
	bool is_bb_swing_offset_positive_b;
	bool MPDIG_2G;
	u8 times_2g;
	u8 force_igi;
	u8 tdma_dig_timer_ms;
	u8 tdma_dig_state_number;
	u8 tdma_dig_low_upper_bond;
	u8 force_tdma_low_igi;
	u8 force_tdma_high_igi;
	u8 fix_expire_to_zero;
	bool original_dig_restore;
	u8 ant_div_type;
	u8 antdiv_rssi;
	u8 fat_comb_a;
	u8 fat_comb_b;
	u8 antdiv_intvl;
	u8 antdiv_delay;
	u8 ant_type;
	u8 ant_type2;
	u8 pre_ant_type;
	u8 pre_ant_type2;
	u8 antdiv_period;
	u8 evm_antdiv_period;
	u8 antdiv_select;
	u8 antdiv_train_num;
	u8 stop_antdiv_rssi_th;
	u16 stop_antdiv_tp_diff_th;
	u16 stop_antdiv_tp_th;
	u8 antdiv_tp_period;
	u16 tp_active_th;
	u8 tp_active_occur;
	u8 path_select;
	u8 antdiv_evm_en;
	u8 bdc_holdstate;
	u8 antdiv_counter;
	u8 ndpa_period;
	bool h2c_rarpt_connect;
	bool cck_agc_report_type;
	u8 print_agc;
	u8 la_mode;
	u8 current_rf_set_8821c;
	u8 default_rf_set_8821c;
	u8 current_ant_num_8821c;
	u8 default_ant_num_8821c;
	u8 rfe_type_expand;
	s8 TH_L2H_default;
	s8 th_edcca_hl_diff_default;
	s8 th_l2h_ini;
	s8 th_edcca_hl_diff;
	bool carrier_sense_enable;
	u8 pre_dbg_priority;
	u8 nbi_set_result;
	u8 c2h_cmd_start;
	u8 fw_debug_trace[60];
	u8 pre_c2h_seq;
	bool fw_buff_is_enpty;
	u32 data_frame_num;
	bool en_reg_mntr_bb;
	bool en_reg_mntr_rf;
	bool en_reg_mntr_mac;
	bool en_reg_mntr_byte;
	bool is_noisy_state;
	bool noisy_decision;
	bool pre_b_noisy;
	u32 noisy_decision_smooth;
	bool is_stop_dym_ant_weighting;
	bool is_disable_dym_ecs;
	bool is_disable_dym_ant_weighting;
	struct cmn_sta_info *phydm_sta_info[32];
	u8 phydm_macid_table[32];
	bool ra_support88e;
	bool *is_driver_stopped;
	bool *is_driver_is_going_to_pnp_set_power_sleep;
	bool *pinit_adpt_in_progress;
	bool is_user_assign_level;
	u8 RSSI_BT;
	bool is_psd_in_process;
	bool is_psd_active;
	bool bsomlenabled;
	u8 no_ndp_cnts;
	u16 ndp_cnt_pre;
	bool is_beamformed;
	u8 linked_bf_support;
	bool bhtstfdisabled;
	u32 n_iqk_cnt;
	u32 n_iqk_ok_cnt;
	u32 n_iqk_fail_cnt;
	bool is_disable_power_training;
	bool is_bt_continuous_turn;
	u8 enhance_pwr_th[3];
	u8 set_pwr_th[3];
	u8 dynamic_tx_high_power_lvl;
	void (*fill_desc_dyntxpwr)(void *, u8 *, u8);
	u8 last_dtp_lvl;
	u8 min_power_index;
	u32 tx_agc_ofdm_18_6;
	u8 rx_pkt_type;
	struct rtw_timer_list mpt_dig_timer;
	struct rtw_timer_list fast_ant_training_timer;
	struct rtw_timer_list sbdcnt_timer;
	struct phydm_func_poiner phydm_func_handler;
	struct phydm_iot_center iot_table;
	struct phydm_bt_info bt_info_table;
	struct pkt_process_info pkt_proc_struct;
	struct phydm_adaptivity_struct adaptivity;
	struct odm_noise_monitor noise_level;
	struct odm_phy_dbg_info phy_dbg_info;
	struct _hal_rf_ rf_table;
	struct dm_rf_calibration_struct rf_calibrate_info;
	struct dm_iqk_info IQK_info;
	struct dm_dpk_info dpk_info;
	struct dm_dack_info dack_info;
	struct phydm_dig_struct dm_dig_table;
	struct phydm_cckpd_struct dm_cckpd_table;
	struct ra_table dm_ra_table;
	struct phydm_fa_struct false_alm_cnt;
	struct phydm_cfo_track_struct dm_cfo_track;
	struct ccx_info dm_ccx_info;
	struct odm_power_trim_data power_trim_data;
	struct psd_info dm_psd_table;
	struct phydm_auto_dbg_struct auto_dbg_table;
	struct phydm_pause_lv pause_lv_table;
	struct phydm_api_stuc api_table;
	struct phydm_pow_train_stuc pow_train_table;
};

struct _BT_COEXIST {
	u8 bBtExist;
	u8 btTotalAntNum;
	u8 btChipType;
	u8 bInitlized;
	u8 btAntisolation;
};

typedef struct _BT_COEXIST BT_COEXIST;

enum _RT_MULTI_FUNC {
	RT_MULTI_FUNC_NONE = 0,
	RT_MULTI_FUNC_WIFI = 1,
	RT_MULTI_FUNC_BT = 2,
	RT_MULTI_FUNC_GPS = 4,
};

typedef enum _RT_MULTI_FUNC RT_MULTI_FUNC;

enum _RT_POLARITY_CTL {
	RT_POLARITY_LOW_ACT = 0,
	RT_POLARITY_HIGH_ACT = 1,
};

typedef enum _RT_POLARITY_CTL RT_POLARITY_CTL;

enum _RT_REGULATOR_MODE {
	RT_SWITCHING_REGULATOR = 0,
	RT_LDO_REGULATOR = 1,
};

typedef enum _RT_REGULATOR_MODE RT_REGULATOR_MODE;

enum _RT_AMPDU_BRUST_MODE {
	RT_AMPDU_BRUST_NONE = 0,
	RT_AMPDU_BRUST_92D = 1,
	RT_AMPDU_BRUST_88E = 2,
	RT_AMPDU_BRUST_8812_4 = 3,
	RT_AMPDU_BRUST_8812_8 = 4,
	RT_AMPDU_BRUST_8812_12 = 5,
	RT_AMPDU_BRUST_8812_15 = 6,
	RT_AMPDU_BRUST_8723B = 7,
};

typedef enum _RT_AMPDU_BRUST_MODE RT_AMPDU_BRUST;

enum _RX_AGG_MODE {
	RX_AGG_DISABLE = 0,
	RX_AGG_DMA = 1,
	RX_AGG_USB = 2,
	RX_AGG_MIX = 3,
};

typedef enum _RX_AGG_MODE RX_AGG_MODE;

struct _BB_INIT_REGISTER {
	u16 offset;
	u32 value;
};

typedef struct _BB_INIT_REGISTER BB_INIT_REGISTER;

struct kfree_data_t {
	u8 flag;
	s8 bb_gain[4];
	s8 thermal;
};

struct hal_spec_t {
	char *ic_name;
	u8 macid_num;
	u8 sec_cam_ent_num;
	u8 sec_cap;
	u8 wow_cap;
	u8 macid_cap;
	u16 macid_txrpt;
	u8 macid_txrpt_pgsz;
	u8 rfpath_num_2g: 4;
	u8 rfpath_num_5g: 4;
	u8 rf_reg_path_num;
	u8 rf_reg_path_avail_num;
	u8 rf_reg_trx_path_bmp;
	u8 max_tx_cnt;
	u8 tx_nss_num: 4;
	u8 rx_nss_num: 4;
	u8 band_cap;
	u8 bw_cap;
	u8 port_num;
	u8 proto_cap;
	u8 txgi_max;
	u8 txgi_pdbm;
	u8 wl_func;
	u8 tx_aclt_unit_factor;
	u8 rx_tsf_filter: 1;
	u8 pg_txpwr_saddr;
	u8 pg_txgi_diff_factor;
	u8 hci_type;
};

struct hal_iqk_reg_backup {
	u8 central_chnl;
	u8 bw_mode;
	u32 reg_backup[40];
};

struct hal_com_data {
	HAL_VERSION version_id;
	RT_MULTI_FUNC MultiFunc;
	RT_POLARITY_CTL PolarityCtl;
	RT_REGULATOR_MODE RegulatorMode;
	u8 hw_init_completed;
	u32 firmware_size;
	u16 firmware_version;
	u16 FirmwareVersionRev;
	u16 firmware_sub_version;
	u16 FirmwareSignature;
	u8 RegFWOffload;
	u8 bFWReady;
	u8 bBTFWReady;
	u8 fw_ractrl;
	u8 LastHMEBoxNum;
	WIRELESS_MODE CurrentWirelessMode;
	enum channel_width current_channel_bw;
	BAND_TYPE current_band_type;
	u8 current_channel;
	u8 cch_20;
	u8 cch_40;
	u8 cch_80;
	u8 CurrentCenterFrequencyIndex1;
	u8 nCur40MhzPrimeSC;
	u8 nCur80MhzPrimeSC;
	BOOLEAN bSwChnlAndSetBWInProgress;
	u8 bDisableSWChannelPlan;
	u16 BasicRateSet;
	u32 ReceiveConfig;
	u8 rx_tsf_addr_filter_config;
	BOOLEAN bSwChnl;
	BOOLEAN bSetChnlBW;
	BOOLEAN bSWToBW40M;
	BOOLEAN bSWToBW80M;
	BOOLEAN bChnlBWInitialized;
	u8 rf_chip;
	u8 trx_path_bmp;
	u8 rf_type;
	u8 NumTotalRFPath;
	u8 max_tx_cnt;
	u8 tx_nss;
	u8 rx_nss;
	u8 txpath_cap_num_nss[4];
	u8 PackageType;
	u8 antenna_test;
	enum bb_path txpath;
	enum bb_path rxpath;
	enum bb_path txpath_nss[4];
	u8 txpath_num_nss[4];
	u16 ForcedDataRate;
	u8 bDumpRxPkt;
	u8 bDumpTxPkt;
	u8 dis_turboedca;
	u32 edca_param_mode;
	u8 bautoload_fail_flag;
	u8 efuse_file_status;
	u8 macaddr_file_status;
	u8 EepromOrEfuse;
	u8 efuse_eeprom_data[1024];
	u8 InterfaceSel;
	u16 CustomerID;
	u16 EEPROMVID;
	u16 EEPROMSVID;
	u8 EEPROMCustomerID;
	u8 EEPROMSubCustomerID;
	u8 EEPROMVersion;
	u8 EEPROMRegulatory;
	u8 eeprom_thermal_meter;
	u8 EEPROMBluetoothCoexist;
	u8 EEPROMBluetoothType;
	u8 EEPROMBluetoothAntNum;
	u8 EEPROMBluetoothAntIsolation;
	u8 EEPROMBluetoothRadioShared;
	u8 EEPROMMACAddr[6];
	u8 eeprom_trx_path_bmp;
	u8 eeprom_max_tx_cnt;
	u8 tx_bbswing_24G;
	u8 tx_bbswing_5G;
	u8 efuse0x3d7;
	u8 efuse0x3d8;
	u8 EEPROMRFGainOffset;
	u8 EEPROMRFGainVal;
	struct kfree_data_t kfree_data;
	u8 adjuseVoltageVal;
	u8 need_restore;
	u8 EfuseUsedPercentage;
	u16 EfuseUsedBytes;
	EFUSE_HAL EfuseHal;
	u8 txpwr_pg_mode;
	u8 Index24G_CCK_Base[56];
	u8 Index24G_BW40_Base[56];
	s8 CCK_24G_Diff[16];
	s8 OFDM_24G_Diff[16];
	s8 BW20_24G_Diff[16];
	s8 BW40_24G_Diff[16];
	u8 txpwr_by_rate_undefined_band_path[8];
	s8 TxPwrByRate[672];
	u8 target_txpwr_2g[40];
	u8 target_txpwr_5g[36];
	bool set_entire_txpwr;
	u8 txpwr_by_rate_loaded: 1;
	u8 txpwr_by_rate_from_file: 1;
	u8 txpwr_limit_loaded: 1;
	u8 txpwr_limit_from_file: 1;
	u8 crystal_cap;
	u8 PAType_2G;
	u8 PAType_5G;
	u8 LNAType_2G;
	u8 LNAType_5G;
	u8 ExternalPA_2G;
	u8 ExternalLNA_2G;
	u8 external_pa_5g;
	u8 external_lna_5g;
	u16 TypeGLNA;
	u16 TypeGPA;
	u16 TypeALNA;
	u16 TypeAPA;
	u16 rfe_type;
	u8 bLedOpenDrain;
	u32 ac_param_be;
	u8 is_turbo_edca;
	u8 prv_traffic_idx;
	BB_REGISTER_DEFINITION_T PHYRegDef[4];
	u32 RfRegChnlVal[4];
	BOOLEAN bRDGEnable;
	u8 AntDivCfg;
	u8 with_extenal_ant_switch;
	u8 b_fix_tx_ant;
	u8 AntDetection;
	u8 TRxAntDivType;
	u8 ant_path;
	u32 antenna_tx_path;
	u32 AntennaRxPath;
	u8 sw_antdiv_bl_state;
	_lock IQKSpinLock;
	u8 INIDATA_RATE[32];
	struct dm_struct odmpriv;
	u64 bk_rf_ability;
	u8 bIQKInitialized;
	u8 bNeedIQK;
	u8 neediqk_24g;
	u8 IQK_MP_Switch;
	u8 bScanInProcess;
	u8 phydm_init_result;
	BOOLEAN pwrdown;
	u8 p2p_ps_offload;
	u8 bMacPwrCtrlOn;
	u8 hci_sus_state;
	u8 RegIQKFWOffload;
	struct submit_ctx iqk_sctx;
	u8 ch_switch_offload;
	struct submit_ctx chsw_sctx;
	RT_AMPDU_BRUST AMPDUBurstMode;
	u8 OutEpQueueSel;
	u8 OutEpNumber;
	RX_AGG_MODE rxagg_mode;
	u8 rxagg_dma_size;
	u8 rxagg_dma_timeout;
	bool intf_start;
	u32 sdio_himr;
	u32 sdio_hisr;
	u8 SdioTxFIFOFreePage[4];
	_lock SdioTxFIFOFreePageLock;
	u8 SdioTxOQTMaxFreeSpace;
	u8 SdioTxOQTFreeSpace;
	u8 SdioRxFIFOCnt;
	u16 SdioRxFIFOSize;
	u32 sdio_tx_max_len[3];
	struct sreset_priv srestpriv;
	BT_COEXIST bt_coexist;
	u32 SysIntrStatus;
	u32 SysIntrMask;
	char para_file_buf[32768];
	char *mac_reg;
	u32 mac_reg_len;
	char *bb_phy_reg;
	u32 bb_phy_reg_len;
	char *bb_agc_tab;
	u32 bb_agc_tab_len;
	char *bb_phy_reg_pg;
	u32 bb_phy_reg_pg_len;
	char *bb_phy_reg_mp;
	u32 bb_phy_reg_mp_len;
	char *rf_radio_a;
	u32 rf_radio_a_len;
	char *rf_radio_b;
	u32 rf_radio_b_len;
	char *rf_tx_pwr_track;
	u32 rf_tx_pwr_track_len;
	char *rf_tx_pwr_lmt;
	u32 rf_tx_pwr_lmt_len;
	struct hal_spec_t hal_spec;
	u8 RfKFreeEnable;
	u8 RfKFree_ch_group;
	BOOLEAN bCCKinCH14;
	BB_INIT_REGISTER RegForRecover[5];
	struct hal_iqk_reg_backup iqk_reg_backup[5];
	u8 not_xmitframe_fw_dl;
	u8 phydm_op_mode;
	u8 in_cta_test;
	u8 multi_ch_switch_mode;
};

typedef struct hal_com_data HAL_DATA_TYPE;

struct lps_ctrl_wk_parm {
	s8 lps_level;
};

struct btinfo {
	u8 cid;
	u8 len;
	u8 bConnection: 1;
	u8 bSCOeSCO: 1;
	u8 bInQPage: 1;
	u8 bACLBusy: 1;
	u8 bSCOBusy: 1;
	u8 bHID: 1;
	u8 bA2DP: 1;
	u8 bFTP: 1;
	u8 retry_cnt: 4;
	u8 rsvd_34: 1;
	u8 rsvd_35: 1;
	u8 rsvd_36: 1;
	u8 rsvd_37: 1;
	u8 rssi;
	u8 rsvd_50: 1;
	u8 rsvd_51: 1;
	u8 rsvd_52: 1;
	u8 rsvd_53: 1;
	u8 rsvd_54: 1;
	u8 rsvd_55: 1;
	u8 eSCO_SCO: 1;
	u8 Master_Slave: 1;
	u8 rsvd_6;
	u8 rsvd_7;
};

struct rtw_ieee80211_hdr {
	u16 frame_ctl;
	u16 duration_id;
	u8 addr1[6];
	u8 addr2[6];
	u8 addr3[6];
	u16 seq_ctl;
	u8 addr4[6];
};

struct phydm_phyinfo_struct {
	boolean physts_rpt_valid;
	u8 rx_pwdb_all;
	u8 signal_quality;
	u8 rx_mimo_signal_strength[4];
	s8 rx_mimo_signal_quality[4];
	u8 rx_mimo_evm_dbm[4];
	s16 cfo_short[4];
	s16 cfo_tail[4];
	s8 rx_power;
	s8 recv_signal_power;
	u8 bt_rx_rssi_percentage;
	u8 signal_strength;
	s8 rx_pwr[4];
	s8 rx_snr[4];
	u8 ant_idx[4];
	u8 rx_count: 2;
	u8 band_width: 3;
	char: 3;
	u8 rxsc: 4;
	u8 channel;
	u8 is_mu_packet: 1;
	u8 is_beamformed: 1;
	u8 cnt_pw2cca;
	u8 cnt_cca2agc_rdy;
	u8 rx_cck_evm;
};

struct mic_data {
	u32 K0;
	u32 K1;
	u32 L;
	u32 R;
	u32 M;
	u32 nBytesInM;
};

struct rx_pkt_attrib {
	u16 pkt_len;
	u8 physt;
	u8 drvinfo_sz;
	u8 shift_sz;
	u8 hdrlen;
	u8 to_fr_ds;
	u8 amsdu;
	u8 qos;
	u8 priority;
	u8 pw_save;
	u8 mdata;
	u16 seq_num;
	u8 frag_num;
	u8 mfrag;
	u8 order;
	u8 privacy;
	u8 bdecrypted;
	u8 encrypt;
	u8 iv_len;
	u8 icv_len;
	u8 crc_err;
	u8 icv_err;
	u8 dst[6];
	u8 src[6];
	u8 ta[6];
	u8 ra[6];
	u8 bssid[6];
	u8 ack_policy;
	u8 key_index;
	u8 data_rate;
	u8 ch;
	u8 bw;
	u8 stbc;
	u8 ldpc;
	u8 sgi;
	u8 pkt_rpt_type;
	u32 MacIDValidEntry[2];
	u8 ampdu;
	u8 ppdu_cnt;
	u8 ampdu_eof;
	u32 free_cnt;
	struct phydm_phyinfo_struct phy_info;
};

struct recv_frame_hdr {
	_list list;
	_pkt *pkt;
	_adapter *adapter;
	u8 fragcnt;
	int frame_tag;
	int keytrack;
	struct rx_pkt_attrib attrib;
	uint len;
	u8 *rx_head;
	u8 *rx_data;
	u8 *rx_tail;
	u8 *rx_end;
	void *precvbuf;
	struct sta_info *psta;
	struct recv_reorder_ctrl *preorder_ctrl;
};

union recv_frame {
	union {
		_list list;
		struct recv_frame_hdr hdr;
		uint mem[32];
	} u;
};

enum blk_crypto_mode_num {
	BLK_ENCRYPTION_MODE_INVALID = 0,
	BLK_ENCRYPTION_MODE_AES_256_XTS = 1,
	BLK_ENCRYPTION_MODE_AES_128_CBC_ESSIV = 2,
	BLK_ENCRYPTION_MODE_ADIANTUM = 3,
	BLK_ENCRYPTION_MODE_MAX = 4,
};

struct arc4context {
	u32 x;
	u32 y;
	u8 state[256];
};

struct rtw_netdev_priv_indicator {
	void *priv;
	u32 sizeof_priv;
};

enum _EFUSE_DEF_TYPE {
	TYPE_EFUSE_MAX_SECTION = 0,
	TYPE_EFUSE_REAL_CONTENT_LEN = 1,
	TYPE_AVAILABLE_EFUSE_BYTES_BANK = 2,
	TYPE_AVAILABLE_EFUSE_BYTES_TOTAL = 3,
	TYPE_EFUSE_MAP_LEN = 4,
	TYPE_EFUSE_PROTECT_BYTES_BANK = 5,
	TYPE_EFUSE_CONTENT_LEN_BANK = 6,
};

typedef struct _EFUSE_HAL *PEFUSE_HAL;

enum {
	SRESET_TGP_NULL = 0,
	SRESET_TGP_XMIT_STATUS = 1,
	SRESET_TGP_LINK_STATUS = 2,
	SRESET_TGP_INFO = 99,
};

enum _ANTENNA_PATH {
	ANTENNA_NONE = 0,
	ANTENNA_D = 1,
	ANTENNA_C = 2,
	ANTENNA_CD = 3,
	ANTENNA_B = 4,
	ANTENNA_BD = 5,
	ANTENNA_BC = 6,
	ANTENNA_BCD = 7,
	ANTENNA_A = 8,
	ANTENNA_AD = 9,
	ANTENNA_AC = 10,
	ANTENNA_ACD = 11,
	ANTENNA_AB = 12,
	ANTENNA_ABD = 13,
	ANTENNA_ABC = 14,
	ANTENNA_ABCD = 15,
};

enum lps_level {
	LPS_NORMAL = 0,
	LPS_LCLK = 1,
	LPS_PG = 2,
	LPS_LEVEL_MAX = 3,
};

enum {
	IPS_NONE = 0,
	IPS_NORMAL = 1,
	IPS_LEVEL_2 = 2,
	IPS_NUM = 3,
};

enum _PS_DENY_REASON {
	PS_DENY_DRV_INITIAL = 0,
	PS_DENY_SCAN = 1,
	PS_DENY_JOIN = 2,
	PS_DENY_DISCONNECT = 3,
	PS_DENY_SUSPEND = 4,
	PS_DENY_IOCTL = 5,
	PS_DENY_MGNT_TX = 6,
	PS_DENY_MONITOR_MODE = 7,
	PS_DENY_BEAMFORMING = 8,
	PS_DENY_DRV_REMOVE = 30,
	PS_DENY_OTHERS = 31,
};

enum {
	SS_DENY_MP_MODE = 0,
	SS_DENY_RSON_SCANING = 1,
	SS_DENY_BLOCK_SCAN = 2,
	SS_DENY_BY_DRV = 3,
	SS_DENY_SELF_AP_UNDER_WPS = 4,
	SS_DENY_SELF_AP_UNDER_LINKING = 5,
	SS_DENY_SELF_AP_UNDER_SURVEY = 6,
	SS_DENY_SELF_STA_UNDER_LINKING = 7,
	SS_DENY_SELF_STA_UNDER_SURVEY = 8,
	SS_DENY_BUDDY_UNDER_LINK_WPS = 9,
	SS_DENY_BUDDY_UNDER_SURVEY = 10,
	SS_DENY_BUSY_TRAFFIC = 11,
	SS_ALLOW = 12,
	SS_DENY_ADAPTIVITY = 13,
};

enum sta_info_update_type {
	STA_INFO_UPDATE_NONE = 0,
	STA_INFO_UPDATE_BW = 1,
	STA_INFO_UPDATE_RATE = 2,
	STA_INFO_UPDATE_PROTECTION_MODE = 4,
	STA_INFO_UPDATE_CAP = 8,
	STA_INFO_UPDATE_HT_CAP = 16,
	STA_INFO_UPDATE_VHT_CAP = 32,
	STA_INFO_UPDATE_ALL = 63,
	STA_INFO_UPDATE_MAX = 64,
};

enum rx_ampdu_reason {
	RX_AMPDU_DRV_FIXED = 1,
	RX_AMPDU_BTCOEX = 2,
	RX_AMPDU_DRV_SCAN = 3,
};

enum halrf_func_idx {
	RF00_PWR_TRK = 0,
	RF01_IQK = 1,
	RF02_LCK = 2,
	RF03_DPK = 3,
	RF04_TXGAPK = 4,
	RF05_DACK = 5,
	RF06_DPK_TRK = 6,
	RF07_2GBAND_SHIFT = 7,
	RF08_RXDCK = 8,
	RF09_RFK = 9,
};

enum phydm_func_idx {
	F00_DIG = 0,
	F01_RA_MASK = 1,
	F02_DYN_TXPWR = 2,
	F03_FA_CNT = 3,
	F04_RSSI_MNTR = 4,
	F05_CCK_PD = 5,
	F06_ANT_DIV = 6,
	F07_SMT_ANT = 7,
	F08_PWR_TRAIN = 8,
	F09_RA = 9,
	F10_PATH_DIV = 10,
	F11_DFS = 11,
	F12_DYN_ARFR = 12,
	F13_ADPTVTY = 13,
	F14_CFO_TRK = 14,
	F15_ENV_MNTR = 15,
	F16_PRI_CCA = 16,
	F17_ADPTV_SOML = 17,
	F18_LNA_SAT_CHK = 18,
};

typedef struct hal_com_data *PHAL_DATA_TYPE;

enum _NDIS_802_11_AUTHENTICATION_MODE {
	Ndis802_11AuthModeOpen = 0,
	Ndis802_11AuthModeShared = 1,
	Ndis802_11AuthModeAutoSwitch = 2,
	Ndis802_11AuthModeWPA = 3,
	Ndis802_11AuthModeWPAPSK = 4,
	Ndis802_11AuthModeWPANone = 5,
	Ndis802_11AuthModeWAPI = 6,
	Ndis802_11AuthModeMax = 7,
};

typedef enum _NDIS_802_11_AUTHENTICATION_MODE NDIS_802_11_AUTHENTICATION_MODE;

struct _NDIS_802_11_VARIABLE_IEs {
	u8 ElementID;
	u8 Length;
	u8 data[1];
};

typedef struct _NDIS_802_11_VARIABLE_IEs *PNDIS_802_11_VARIABLE_IEs;

enum bss_type {
	BSS_TYPE_UNDEF = 0,
	BSS_TYPE_PROB_REQ = 1,
	BSS_TYPE_BCN = 2,
	BSS_TYPE_PROB_RSP = 3,
};

enum _ELEMENT_ID {
	EID_SsId = 0,
	EID_SupRates = 1,
	EID_FHParms = 2,
	EID_DSParms = 3,
	EID_CFParms = 4,
	EID_Tim = 5,
	EID_IbssParms = 6,
	EID_Country = 7,
	EID_QBSSLoad = 11,
	EID_EDCAParms = 12,
	EID_TSpec = 13,
	EID_TClass = 14,
	EID_Schedule = 15,
	EID_Ctext = 16,
	EID_POWER_CONSTRAINT = 32,
	EID_PowerCap = 33,
	EID_TPC = 35,
	EID_SupportedChannels = 36,
	EID_ChlSwitchAnnounce = 37,
	EID_MeasureRequest = 38,
	EID_MeasureReport = 39,
	EID_ERPInfo = 42,
	EID_TSDelay = 43,
	EID_TCLASProc = 44,
	EID_HTCapability = 45,
	EID_QoSCap = 46,
	EID_WPA2 = 48,
	EID_ExtSupRates = 50,
	EID_FTIE = 55,
	EID_Timeout = 56,
	EID_SupRegulatory = 59,
	EID_HTInfo = 61,
	EID_SecondaryChnlOffset = 62,
	EID_BSSCoexistence = 72,
	EID_BSSIntolerantChlReport = 73,
	EID_OBSS = 74,
	EID_LinkIdentifier = 101,
	EID_WakeupSchedule = 102,
	EID_ChnlSwitchTimeing = 104,
	EID_PTIControl = 105,
	EID_PUBufferStatus = 106,
	EID_Aironet = 133,
	EID_CiscoIP = 149,
	EID_CellPwr = 150,
	EID_CCKM = 156,
	EID_Vendor = 221,
	EID_WAPI = 68,
	EID_VHTCapability = 191,
	EID_VHTOperation = 192,
	EID_VHTTransmitPower = 195,
	EID_AID = 197,
	EID_OpModeNotification = 199,
};

struct rtw_ieee80211_hdr_3addr {
	u16 frame_ctl;
	u16 duration_id;
	u8 addr1[6];
	u8 addr2[6];
	u8 addr3[6];
	u16 seq_ctl;
};

struct rate_section_ent {
	u8 tx_num;
	u8 rate_num;
	u8 *rates;
};

enum rtw_ieee80211_category {
	RTW_WLAN_CATEGORY_SPECTRUM_MGMT = 0,
	RTW_WLAN_CATEGORY_QOS = 1,
	RTW_WLAN_CATEGORY_DLS = 2,
	RTW_WLAN_CATEGORY_BACK = 3,
	RTW_WLAN_CATEGORY_PUBLIC = 4,
	RTW_WLAN_CATEGORY_RADIO_MEAS = 5,
	RTW_WLAN_CATEGORY_FT = 6,
	RTW_WLAN_CATEGORY_HT = 7,
	RTW_WLAN_CATEGORY_SA_QUERY = 8,
	RTW_WLAN_CATEGORY_WNM = 10,
	RTW_WLAN_CATEGORY_UNPROTECTED_WNM = 11,
	RTW_WLAN_CATEGORY_TDLS = 12,
	RTW_WLAN_CATEGORY_MESH = 13,
	RTW_WLAN_CATEGORY_MULTIHOP = 14,
	RTW_WLAN_CATEGORY_SELF_PROTECTED = 15,
	RTW_WLAN_CATEGORY_WMM = 17,
	RTW_WLAN_CATEGORY_VHT = 21,
	RTW_WLAN_CATEGORY_P2P = 127,
};

enum _PUBLIC_ACTION {
	ACT_PUBLIC_BSSCOEXIST = 0,
	ACT_PUBLIC_DSE_ENABLE = 1,
	ACT_PUBLIC_DSE_DEENABLE = 2,
	ACT_PUBLIC_DSE_REG_LOCATION = 3,
	ACT_PUBLIC_EXT_CHL_SWITCH = 4,
	ACT_PUBLIC_DSE_MSR_REQ = 5,
	ACT_PUBLIC_DSE_MSR_RPRT = 6,
	ACT_PUBLIC_MP = 7,
	ACT_PUBLIC_DSE_PWR_CONSTRAINT = 8,
	ACT_PUBLIC_VENDOR = 9,
	ACT_PUBLIC_GAS_INITIAL_REQ = 10,
	ACT_PUBLIC_GAS_INITIAL_RSP = 11,
	ACT_PUBLIC_GAS_COMEBACK_REQ = 12,
	ACT_PUBLIC_GAS_COMEBACK_RSP = 13,
	ACT_PUBLIC_TDLS_DISCOVERY_RSP = 14,
	ACT_PUBLIC_LOCATION_TRACK = 15,
	ACT_PUBLIC_QAB_REQ = 16,
	ACT_PUBLIC_QAB_RSP = 17,
	ACT_PUBLIC_QMF_POLICY = 18,
	ACT_PUBLIC_QMF_POLICY_CHANGE = 19,
	ACT_PUBLIC_QLOAD_REQ = 20,
	ACT_PUBLIC_QLOAD_REPORT = 21,
	ACT_PUBLIC_HCCA_TXOP_ADV = 22,
	ACT_PUBLIC_HCCA_TXOP_RSP = 23,
	ACT_PUBLIC_PUBLIC_KEY = 24,
	ACT_PUBLIC_CH_AVAILABILITY_QUERY = 25,
	ACT_PUBLIC_CH_SCHEDULE_MGMT = 26,
	ACT_PUBLIC_CONTACT_VERI_SIGNAL = 27,
	ACT_PUBLIC_GDD_ENABLE_REQ = 28,
	ACT_PUBLIC_GDD_ENABLE_RSP = 29,
	ACT_PUBLIC_NETWORK_CH_CONTROL = 30,
	ACT_PUBLIC_WHITE_SPACE_MAP_ANN = 31,
	ACT_PUBLIC_FTM_REQ = 32,
	ACT_PUBLIC_FTM = 33,
	ACT_PUBLIC_MAX = 34,
};

struct rtw_ieee802_11_elems {
	u8 *ssid;
	u8 ssid_len;
	u8 *supp_rates;
	u8 supp_rates_len;
	u8 *fh_params;
	u8 fh_params_len;
	u8 *ds_params;
	u8 ds_params_len;
	u8 *cf_params;
	u8 cf_params_len;
	u8 *tim;
	u8 tim_len;
	u8 *ibss_params;
	u8 ibss_params_len;
	u8 *challenge;
	u8 challenge_len;
	u8 *erp_info;
	u8 erp_info_len;
	u8 *ext_supp_rates;
	u8 ext_supp_rates_len;
	u8 *wpa_ie;
	u8 wpa_ie_len;
	u8 *rsn_ie;
	u8 rsn_ie_len;
	u8 *wme;
	u8 wme_len;
	u8 *wme_tspec;
	u8 wme_tspec_len;
	u8 *wps_ie;
	u8 wps_ie_len;
	u8 *power_cap;
	u8 power_cap_len;
	u8 *supp_channels;
	u8 supp_channels_len;
	u8 *mdie;
	u8 mdie_len;
	u8 *ftie;
	u8 ftie_len;
	u8 *timeout_int;
	u8 timeout_int_len;
	u8 *ht_capabilities;
	u8 ht_capabilities_len;
	u8 *ht_operation;
	u8 ht_operation_len;
	u8 *vendor_ht_cap;
	u8 vendor_ht_cap_len;
	u8 *vht_capabilities;
	u8 vht_capabilities_len;
	u8 *vht_operation;
	u8 vht_operation_len;
	u8 *vht_op_mode_notify;
	u8 vht_op_mode_notify_len;
	u8 *rm_en_cap;
	u8 rm_en_cap_len;
};

typedef enum {
	ParseOK = 0,
	ParseUnknown = 1,
	ParseFailed = 4294967295,
} ParseRes;

enum secondary_ch_offset {
	SCN = 0,
	SCA = 1,
	SCB = 3,
};

enum rtw_amsdu_mode {
	RTW_AMSDU_MODE_NON_SPP = 0,
	RTW_AMSDU_MODE_SPP = 1,
	RTW_AMSDU_MODE_ALL_DROP = 2,
};

struct rsne_info {
	u8 *gcs;
	u16 pcs_cnt;
	u8 *pcs_list;
	u16 akm_cnt;
	u8 *akm_list;
	u8 *cap;
	u16 pmkid_cnt;
	u8 *pmkid_list;
	u8 *gmcs;
	u8 err;
};

enum _REG_PREAMBLE_MODE {
	PREAMBLE_LONG = 1,
	PREAMBLE_AUTO = 2,
	PREAMBLE_SHORT = 3,
};

enum _RF_TX_NUM {
	RF_1TX = 0,
	RF_2TX = 1,
	RF_3TX = 2,
	RF_4TX = 3,
	RF_MAX_TX_NUM = 4,
	RF_TX_NUM_NONIMPLEMENT = 5,
};

enum _NDIS_802_11_WEP_STATUS {
	Ndis802_11WEPEnabled = 0,
	Ndis802_11Encryption1Enabled = 0,
	Ndis802_11WEPDisabled = 1,
	Ndis802_11EncryptionDisabled = 1,
	Ndis802_11WEPKeyAbsent = 2,
	Ndis802_11Encryption1KeyAbsent = 2,
	Ndis802_11WEPNotSupported = 3,
	Ndis802_11EncryptionNotSupported = 3,
	Ndis802_11Encryption2Enabled = 4,
	Ndis802_11Encryption2KeyAbsent = 5,
	Ndis802_11Encryption3Enabled = 6,
	Ndis802_11Encryption3KeyAbsent = 7,
	Ndis802_11_EncrypteionWAPI = 8,
};

struct ieee80211_ht_addt_info {
	unsigned char control_chan;
	unsigned char ht_param;
	short unsigned int operation_mode;
	short unsigned int stbc_param;
	unsigned char basic_set[16];
};

enum _HT_CAP_AMPDU_FACTOR {
	MAX_AMPDU_FACTOR_8K = 0,
	MAX_AMPDU_FACTOR_16K = 1,
	MAX_AMPDU_FACTOR_32K = 2,
	MAX_AMPDU_FACTOR_64K = 3,
};

typedef enum _HT_CAP_AMPDU_FACTOR HT_CAP_AMPDU_FACTOR;

enum _HT_CAP_AMPDU_DENSITY {
	AMPDU_DENSITY_VALUE_0 = 0,
	AMPDU_DENSITY_VALUE_1 = 1,
	AMPDU_DENSITY_VALUE_2 = 2,
	AMPDU_DENSITY_VALUE_3 = 3,
	AMPDU_DENSITY_VALUE_4 = 4,
	AMPDU_DENSITY_VALUE_5 = 5,
	AMPDU_DENSITY_VALUE_6 = 6,
	AMPDU_DENSITY_VALUE_7 = 7,
};

typedef enum _HT_CAP_AMPDU_DENSITY HT_CAP_AMPDU_DENSITY;

enum EXT_CAP_INFO {
	BSS_COEXT = 0,
	EXT_CH_SWITCH = 2,
	WNM_SLEEP_MODE = 17,
	BSS_TRANSITION = 19,
	MULTI_BSSID = 22,
	TIME_MEASUREMENT = 23,
	SSID_LIST = 25,
	TDLS_PSM = 29,
	TDLS_CH_SWITCH = 30,
	INTERWORKING = 31,
	TDLS_SUPPORT = 37,
	WNM_NOTIFICATION = 46,
	OP_MODE_NOTIFICATION = 62,
	FTM_RESPONDER = 70,
	FTM_INITIATOR = 71,
};

enum rtw_ieee80211_channel_flags {
	RTW_IEEE80211_CHAN_DISABLED = 1,
	RTW_IEEE80211_CHAN_PASSIVE_SCAN = 2,
	RTW_IEEE80211_CHAN_NO_IBSS = 4,
	RTW_IEEE80211_CHAN_RADAR = 8,
	RTW_IEEE80211_CHAN_NO_HT40PLUS = 16,
	RTW_IEEE80211_CHAN_NO_HT40MINUS = 32,
};

enum _EXTCHNL_OFFSET {
	EXTCHNL_OFFSET_NO_EXT = 0,
	EXTCHNL_OFFSET_UPPER = 1,
	EXTCHNL_OFFSET_NO_DEF = 2,
	EXTCHNL_OFFSET_LOWER = 3,
};

struct setauth_parm {
	u8 mode;
	u8 _1x;
	u8 rsvd[2];
};

struct setkey_parm {
	u8 algorithm;
	u8 keyid;
	u8 set_tx;
	u8 key[32];
};

enum addba_rsp_ack_state {
	RTW_RECV_ACK_OR_TIMEOUT = 0,
};

enum {
	RTW_ROAM_ON_EXPIRED = 1,
	RTW_ROAM_ON_RESUME = 2,
	RTW_ROAM_ACTIVE = 4,
};

struct surveydone_event {
	unsigned int bss_cnt;
	u8 activate_ch_cnt;
	bool acs;
};

struct stassoc_event {
	unsigned char macaddr[6];
};

struct stadel_event {
	unsigned char macaddr[6];
	unsigned char rsvd[2];
	unsigned char locally_generated;
	int mac_id;
};

typedef __kernel_ssize_t SSIZE_T;

enum WIFI_FRAME_SUBTYPE {
	WIFI_ASSOCREQ = 0,
	WIFI_ASSOCRSP = 16,
	WIFI_REASSOCREQ = 32,
	WIFI_REASSOCRSP = 48,
	WIFI_PROBEREQ = 64,
	WIFI_PROBERSP = 80,
	WIFI_BEACON = 128,
	WIFI_ATIM = 144,
	WIFI_DISASSOC = 160,
	WIFI_AUTH = 176,
	WIFI_DEAUTH = 192,
	WIFI_ACTION = 208,
	WIFI_ACTION_NOACK = 224,
	WIFI_BF_REPORT_POLL = 68,
	WIFI_NDPA = 84,
	WIFI_BAR = 132,
	WIFI_PSPOLL = 164,
	WIFI_RTS = 180,
	WIFI_CTS = 196,
	WIFI_ACK = 212,
	WIFI_CFEND = 228,
	WIFI_CFEND_CFACK = 244,
	WIFI_DATA = 8,
	WIFI_DATA_CFACK = 24,
	WIFI_DATA_CFPOLL = 40,
	WIFI_DATA_CFACKPOLL = 56,
	WIFI_DATA_NULL = 72,
	WIFI_CF_ACK = 88,
	WIFI_CF_POLL = 104,
	WIFI_CF_ACKPOLL = 120,
	WIFI_QOS_DATA_NULL = 200,
};

enum WIFI_REASON_CODE {
	_RSON_RESERVED_ = 0,
	_RSON_UNSPECIFIED_ = 1,
	_RSON_AUTH_NO_LONGER_VALID_ = 2,
	_RSON_DEAUTH_STA_LEAVING_ = 3,
	_RSON_INACTIVITY_ = 4,
	_RSON_UNABLE_HANDLE_ = 5,
	_RSON_CLS2_ = 6,
	_RSON_CLS3_ = 7,
	_RSON_DISAOC_STA_LEAVING_ = 8,
	_RSON_ASOC_NOT_AUTH_ = 9,
	_RSON_INVALID_IE_ = 13,
	_RSON_MIC_FAILURE_ = 14,
	_RSON_4WAY_HNDSHK_TIMEOUT_ = 15,
	_RSON_GROUP_KEY_UPDATE_TIMEOUT_ = 16,
	_RSON_DIFF_IE_ = 17,
	_RSON_MLTCST_CIPHER_NOT_VALID_ = 18,
	_RSON_UNICST_CIPHER_NOT_VALID_ = 19,
	_RSON_AKMP_NOT_VALID_ = 20,
	_RSON_UNSUPPORT_RSNE_VER_ = 21,
	_RSON_INVALID_RSNE_CAP_ = 22,
	_RSON_IEEE_802DOT1X_AUTH_FAIL_ = 23,
	_RSON_PMK_NOT_AVAILABLE_ = 24,
	_RSON_TDLS_TEAR_TOOFAR_ = 25,
	_RSON_TDLS_TEAR_UN_RSN_ = 26,
};

enum WIFI_STATUS_CODE {
	_STATS_SUCCESSFUL_ = 0,
	_STATS_FAILURE_ = 1,
	_STATS_SEC_DISABLED_ = 5,
	_STATS_NOT_IN_SAME_BSS_ = 7,
	_STATS_CAP_FAIL_ = 10,
	_STATS_NO_ASOC_ = 11,
	_STATS_OTHER_ = 12,
	_STATS_NO_SUPP_ALG_ = 13,
	_STATS_OUT_OF_AUTH_SEQ_ = 14,
	_STATS_CHALLENGE_FAIL_ = 15,
	_STATS_AUTH_TIMEOUT_ = 16,
	_STATS_UNABLE_HANDLE_STA_ = 17,
	_STATS_RATE_FAIL_ = 18,
	_STATS_REFUSED_TEMPORARILY_ = 30,
	_STATS_DECLINE_REQ_ = 37,
	_STATS_INVALID_PARAMETERS_ = 38,
	_STATS_INVALID_RSNIE_ = 72,
};

struct ieee80211_info_element {
	u8 id;
	u8 len;
	u8 data[0];
};

enum rtw_ieee80211_spectrum_mgmt_actioncode {
	RTW_WLAN_ACTION_SPCT_MSR_REQ = 0,
	RTW_WLAN_ACTION_SPCT_MSR_RPRT = 1,
	RTW_WLAN_ACTION_SPCT_TPC_REQ = 2,
	RTW_WLAN_ACTION_SPCT_TPC_RPRT = 3,
	RTW_WLAN_ACTION_SPCT_CHL_SWITCH = 4,
	RTW_WLAN_ACTION_SPCT_EXT_CHL_SWITCH = 5,
};

enum rtw_ieee80211_back_actioncode {
	RTW_WLAN_ACTION_ADDBA_REQ = 0,
	RTW_WLAN_ACTION_ADDBA_RESP = 1,
	RTW_WLAN_ACTION_DELBA = 2,
};

enum rtw_ieee80211_ht_actioncode {
	RTW_WLAN_ACTION_HT_NOTI_CHNL_WIDTH = 0,
	RTW_WLAN_ACTION_HT_SM_PS = 1,
	RTW_WLAN_ACTION_HT_PSMP = 2,
	RTW_WLAN_ACTION_HT_SET_PCO_PHASE = 3,
	RTW_WLAN_ACTION_HT_CSI = 4,
	RTW_WLAN_ACTION_HT_NON_COMPRESS_BEAMFORMING = 5,
	RTW_WLAN_ACTION_HT_COMPRESS_BEAMFORMING = 6,
	RTW_WLAN_ACTION_HT_ASEL_FEEDBACK = 7,
};

struct regd_exc_ent {
	_list list;
	char country[2];
	u8 domain;
	char lmt_name[0];
};

enum rtw_dfs_regd {
	RTW_DFS_REGD_NONE = 0,
	RTW_DFS_REGD_FCC = 1,
	RTW_DFS_REGD_MKK = 2,
	RTW_DFS_REGD_ETSI = 3,
	RTW_DFS_REGD_NUM = 4,
	RTW_DFS_REGD_AUTO = 255,
};

enum _REGULATION_TXPWR_LMT {
	TXPWR_LMT_NONE = 0,
	TXPWR_LMT_FCC = 1,
	TXPWR_LMT_MKK = 2,
	TXPWR_LMT_ETSI = 3,
	TXPWR_LMT_IC = 4,
	TXPWR_LMT_KCC = 5,
	TXPWR_LMT_NCC = 6,
	TXPWR_LMT_ACMA = 7,
	TXPWR_LMT_CHILE = 8,
	TXPWR_LMT_UKRAINE = 9,
	TXPWR_LMT_MEXICO = 10,
	TXPWR_LMT_CN = 11,
	TXPWR_LMT_QATAR = 12,
	TXPWR_LMT_WW = 13,
	TXPWR_LMT_NUM = 14,
	TXPWR_LMT_DEF = 14,
};

typedef enum _REGULATION_TXPWR_LMT REGULATION_TXPWR_LMT;

struct Tx_Beacon_param {
	WLAN_BSSID_EX network;
};

enum RTL871X_HCI_TYPE {
	RTW_PCIE = 1,
	RTW_USB = 2,
	RTW_SDIO = 4,
	RTW_GSPI = 8,
};

enum {
	MLME_ACTION_UNKNOWN = 0,
	MLME_ACTION_NONE = 1,
	MLME_SCAN_ENABLE = 2,
	MLME_SCAN_ENTER = 3,
	MLME_SCAN_DONE = 4,
	MLME_SCAN_DISABLE = 5,
	MLME_STA_CONNECTING = 6,
	MLME_STA_CONNECTED = 7,
	MLME_STA_DISCONNECTED = 8,
	MLME_TDLS_LINKED = 9,
	MLME_TDLS_NOLINK = 10,
	MLME_AP_STARTED = 11,
	MLME_AP_STOPPED = 12,
	MLME_ADHOC_STARTED = 13,
	MLME_ADHOC_STOPPED = 14,
	MLME_MESH_STARTED = 15,
	MLME_MESH_STOPPED = 16,
	MLME_OPCH_SWITCH = 17,
};

enum mlme_auth_type {
	MLME_AUTHTYPE_OPEN_SYSTEM = 0,
	MLME_AUTHTYPE_SHARED_KEY = 1,
	MLME_AUTHTYPE_FT = 2,
	MLME_AUTHTYPE_NETWORK_EAP = 3,
	MLME_AUTHTYPE_SAE = 4,
	MLME_AUTHTYPE_FILS_SK = 5,
	MLME_AUTHTYPE_FILS_SK_PFS = 6,
	MLME_AUTHTYPE_FILS_PK = 7,
	__MLME_AUTHTYPE_NUM = 8,
	MLME_AUTHTYPE_MAX = 7,
	MLME_AUTHTYPE_AUTOMATIC = 8,
};

enum DriverInterface {
	DRIVER_WEXT = 1,
	DRIVER_CFG80211 = 2,
};

enum external_auth_action {
	EXTERNAL_AUTH_START = 0,
	EXTERNAL_AUTH_ABORT = 1,
};

struct rtw_external_auth_params {
	enum external_auth_action action;
	u8 bssid[6];
	struct cfg80211_ssid ssid;
	unsigned int key_mgmt_suite;
	u16 status;
	u8 pmkid[16];
};

struct survey_event {
	WLAN_BSSID_EX bss;
};

struct joinbss_event {
	struct wlan_network network;
};

struct wmm_event {
	unsigned char wmm;
};

struct rtw_event {
	u32 parmsize;
	void (*event_callback)(_adapter *, u8 *);
};

enum _HT_IOT_PEER {
	HT_IOT_PEER_UNKNOWN = 0,
	HT_IOT_PEER_REALTEK = 1,
	HT_IOT_PEER_REALTEK_92SE = 2,
	HT_IOT_PEER_BROADCOM = 3,
	HT_IOT_PEER_RALINK = 4,
	HT_IOT_PEER_ATHEROS = 5,
	HT_IOT_PEER_CISCO = 6,
	HT_IOT_PEER_MERU = 7,
	HT_IOT_PEER_MARVELL = 8,
	HT_IOT_PEER_REALTEK_SOFTAP = 9,
	HT_IOT_PEER_SELF_SOFTAP = 10,
	HT_IOT_PEER_AIRGO = 11,
	HT_IOT_PEER_INTEL = 12,
	HT_IOT_PEER_RTK_APCLIENT = 13,
	HT_IOT_PEER_REALTEK_81XX = 14,
	HT_IOT_PEER_REALTEK_WOW = 15,
	HT_IOT_PEER_REALTEK_JAGUAR_BCUTAP = 16,
	HT_IOT_PEER_REALTEK_JAGUAR_CCUTAP = 17,
	HT_IOT_PEER_MAX = 18,
};

struct mlme_handler {
	unsigned int num;
	char *str;
	unsigned int (*func)(_adapter *, union recv_frame *);
};

struct action_handler {
	unsigned int num;
	char *str;
	unsigned int (*func)(_adapter *, union recv_frame *);
};

enum SCAN_STATE {
	SCAN_DISABLE = 0,
	SCAN_START = 1,
	SCAN_PS_ANNC_WAIT = 2,
	SCAN_ENTER = 3,
	SCAN_PROCESS = 4,
	SCAN_BACKING_OP = 5,
	SCAN_BACK_OP = 6,
	SCAN_LEAVING_OP = 7,
	SCAN_LEAVE_OP = 8,
	SCAN_SW_ANTDIV_BL = 9,
	SCAN_TO_P2P_LISTEN = 10,
	SCAN_P2P_LISTEN = 11,
	SCAN_COMPLETE = 12,
	SCAN_STATE_MAX = 13,
};

enum ss_backop_flag {
	SS_BACKOP_EN = 1,
	SS_BACKOP_EN_NL = 2,
	SS_BACKOP_PS_ANNC = 16,
	SS_BACKOP_TX_RESUME = 32,
};

enum {
	RTW_CHF_NO_IR = 1,
	RTW_CHF_DFS = 2,
	RTW_CHF_LONG_CAC = 4,
	RTW_CHF_NON_OCP = 8,
	RTW_CHF_NO_HT40U = 16,
	RTW_CHF_NO_HT40L = 32,
	RTW_CHF_NO_80MHZ = 64,
	RTW_CHF_NO_160MHZ = 128,
};

enum {
	BAND_24G = 1,
	BAND_5G = 2,
};

enum hw_mode {
	IEEE80211G = 0,
	IEEE80211A = 1,
};

struct p2p_oper_class_map {
	enum hw_mode mode;
	u8 op_class;
	u8 min_chan;
	u8 max_chan;
	u8 inc;
	enum {
		BW20 = 0,
		BW40PLUS = 1,
		BW40MINUS = 2,
	} bw;
};

enum rtw_event_id {
	EVT_SURVEY = 0,
	EVT_SURVEY_DONE = 1,
	EVT_JOINBSS = 2,
	EVT_ADD_STA = 3,
	EVT_DEL_STA = 4,
	EVT_WMM_UPDATE = 5,
	EVT_TIMEOUT_STA = 6,
	EVT_ID_MAX = 7,
};

enum {
	MI_LINKED = 0,
	MI_ASSOC = 1,
	MI_UNDER_WPS = 2,
	MI_AP_MODE = 3,
	MI_AP_ASSOC = 4,
	MI_ADHOC = 5,
	MI_ADHOC_ASSOC = 6,
	MI_MESH = 7,
	MI_MESH_ASSOC = 8,
	MI_STA_NOLINK = 9,
	MI_STA_LINKED = 10,
	MI_STA_LINKING = 11,
};

enum _HAL_PHYDM_OPS {
	HAL_PHYDM_DIS_ALL_FUNC = 0,
	HAL_PHYDM_FUNC_SET = 1,
	HAL_PHYDM_FUNC_CLR = 2,
	HAL_PHYDM_ABILITY_BK = 3,
	HAL_PHYDM_ABILITY_RESTORE = 4,
	HAL_PHYDM_ABILITY_SET = 5,
	HAL_PHYDM_ABILITY_GET = 6,
};

enum odm_ability {
	ODM_BB_DIG = 1,
	ODM_BB_RA_MASK = 2,
	ODM_BB_DYNAMIC_TXPWR = 4,
	ODM_BB_FA_CNT = 8,
	ODM_BB_RSSI_MONITOR = 16,
	ODM_BB_CCK_PD = 32,
	ODM_BB_ANT_DIV = 64,
	ODM_BB_SMT_ANT = 128,
	ODM_BB_PWR_TRAIN = 256,
	ODM_BB_RATE_ADAPTIVE = 512,
	ODM_BB_PATH_DIV = 1024,
	ODM_BB_DFS = 2048,
	ODM_BB_DYNAMIC_ARFR = 4096,
	ODM_BB_ADAPTIVITY = 8192,
	ODM_BB_CFO_TRACKING = 16384,
	ODM_BB_ENV_MONITOR = 32768,
	ODM_BB_PRIMARY_CCA = 65536,
	ODM_BB_ADAPTIVE_SOML = 131072,
	ODM_BB_LNA_SAT_CHK = 262144,
};

struct txpwr_lmt_ent {
	_list list;
	s8 lmt_2g[448];
	char name[0];
};

struct ieee802_1x_hdr {
	u8 version;
	u8 type;
	u16 length;
};

struct wpa_eapol_key {
	u8 type;
	u8 key_info[2];
	u8 key_length[2];
	u8 replay_counter[8];
	u8 key_nonce[32];
	u8 key_iv[16];
	u8 key_rsc[8];
	u8 key_id[8];
	u8 key_mic[16];
	u8 key_data_length[2];
};

enum eap_type {
	EAP_PACKET = 0,
	NON_EAPOL = 1,
	EAPOL_START = 2,
	EAPOL_LOGOFF = 3,
	EAPOL_KEY = 4,
	EAPOL_ENCAP_ASF_ALERT = 5,
	EAPOL_PACKET = 6,
	EAPOL_WPA_GROUP_KEY_1_2 = 7,
	EAPOL_WPA_GROUP_KEY_2_2 = 8,
	EAPOL_1_4 = 9,
	EAPOL_2_4 = 10,
	EAPOL_3_4 = 11,
	EAPOL_4_4 = 12,
};

typedef struct _ADAPTER ADAPTER;

enum _CAPABILITY {
	cESS = 1,
	cIBSS = 2,
	cPollable = 4,
	cPollReq = 8,
	cPrivacy = 16,
	cShortPreamble = 32,
	cPBCC = 64,
	cChannelAgility = 128,
	cSpectrumMgnt = 256,
	cQos = 512,
	cShortSlotTime = 1024,
	cAPSD = 2048,
	cRM = 4096,
	cDSSS_OFDM = 8192,
	cDelayedBA = 16384,
	cImmediateBA = 32768,
};

enum {
	ENCRYP_PROTOCOL_OPENSYS = 0,
	ENCRYP_PROTOCOL_WEP = 1,
	ENCRYP_PROTOCOL_WPA = 2,
	ENCRYP_PROTOCOL_WPA2 = 3,
	ENCRYP_PROTOCOL_WAPI = 4,
	ENCRYP_PROTOCOL_MAX = 5,
};

enum _RT_HT_INF0_CAP {
	RT_HT_CAP_USE_TURBO_AGGR = 1,
	RT_HT_CAP_USE_LONG_PREAMBLE = 2,
	RT_HT_CAP_USE_AMPDU = 4,
	RT_HT_CAP_USE_WOW = 8,
	RT_HT_CAP_USE_SOFTAP = 16,
	RT_HT_CAP_USE_92SE = 32,
	RT_HT_CAP_USE_88C_92C = 64,
	RT_HT_CAP_USE_AP_CLIENT_MODE = 128,
};

enum _RT_HT_INF1_CAP {
	RT_HT_CAP_USE_VIDEO_CLIENT = 1,
	RT_HT_CAP_USE_JAGUAR_BCUT = 2,
	RT_HT_CAP_USE_JAGUAR_CCUT = 4,
};

struct support_rate_handler {
	u8 rate;
	bool basic;
	bool existence;
};

struct reportpwrstate_parm {
	unsigned char mode;
	unsigned char state;
	short unsigned int rsvd;
};

typedef enum _PS_DENY_REASON PS_DENY_REASON;

enum _CHIP_TYPE {
	NULL_CHIP_TYPE = 0,
	RTL8188E = 1,
	RTL8192E = 2,
	RTL8812 = 3,
	RTL8821 = 4,
	RTL8723B = 5,
	RTL8814A = 6,
	RTL8703B = 7,
	RTL8188F = 8,
	RTL8188GTV = 9,
	RTL8822B = 10,
	RTL8723D = 11,
	RTL8821C = 12,
	RTL8710B = 13,
	RTL8192F = 14,
	RTL8822C = 15,
	RTL8814B = 16,
	RTL8723F = 17,
	MAX_CHIP_TYPE = 18,
};

struct center_chs_ent_t {
	u8 ch_num;
	u8 *chs;
};

struct op_chs_ent_t {
	u8 ch_num;
	u8 *chs;
};

struct op_class_t {
	u8 class_id;
	BAND_TYPE band;
	enum opc_bw bw;
	u8 *len_ch_attr;
};

enum rtw_edcca_mode {
	RTW_EDCCA_NORMAL = 0,
	RTW_EDCCA_ADAPT = 1,
	RTW_EDCCA_CS = 2,
	RTW_EDCCA_MODE_NUM = 3,
	RTW_EDCCA_MODE_AUTO = 255,
};

struct ch_list_t {
	u8 *len_ch_attr;
};

enum rtw_chd_2g {
	RTW_CHD_2G_00 = 0,
	RTW_CHD_2G_01 = 1,
	RTW_CHD_2G_02 = 2,
	RTW_CHD_2G_03 = 3,
	RTW_CHD_2G_04 = 4,
	RTW_CHD_2G_05 = 5,
	RTW_CHD_2G_06 = 6,
	RTW_CHD_2G_MAX = 7,
	RTW_CHD_2G_NULL = 0,
};

struct chplan_ent_t {
	u8 regd_2g;
	u8 chd_2g;
};

struct phydm_perpkt_info_struct {
	u8 data_rate;
	u8 station_id;
	u8 is_cck_rate: 1;
	u8 rate_ss: 3;
	u8 is_packet_match_bssid: 1;
	u8 is_packet_to_self: 1;
	u8 is_packet_beacon: 1;
	u8 is_to_self: 1;
	u8 ppdu_cnt;
};

struct recv_buf {
	_list list;
	u32 ref_cnt;
	PADAPTER adapter;
	u8 *pbuf;
	u8 *pallocated_buf;
	u32 len;
	u8 *phead;
	u8 *pdata;
	u8 *ptail;
	u8 *pend;
	_pkt *pskb;
};

enum rtw_rx_llc_hdl {
	RTW_RX_LLC_KEEP = 0,
	RTW_RX_LLC_REMOVE = 1,
	RTW_RX_LLC_VLAN = 2,
};

enum {
	SIGNAL_STAT_CALC_PROFILE_0 = 0,
	SIGNAL_STAT_CALC_PROFILE_1 = 1,
	SIGNAL_STAT_CALC_PROFILE_2 = 2,
	SIGNAL_STAT_CALC_PROFILE_MAX = 3,
};

typedef unsigned char _buffer;

struct pkt_file {
	_pkt *pkt;
	SIZE_T pkt_len;
	_buffer *cur_buffer;
	u8 *buf_start;
	u8 *cur_addr;
	SIZE_T buf_len;
};

struct rtw_wds_path;

struct rtw_mesh_path;

struct ieee80211_radiotap_header {
	uint8_t it_version;
	uint8_t it_pad;
	__le16 it_len;
	__le32 it_present;
};

enum VRTL_CARRIER_SENSE {
	DISABLE_VCS = 0,
	ENABLE_VCS = 1,
	AUTO_VCS = 2,
};

enum VCS_TYPE {
	NONE_VCS = 0,
	RTS_CTS = 1,
	CTS_TO_SELF = 2,
};

struct ieee80211_snap_hdr {
	u8 dsap;
	u8 ssap;
	u8 ctrl;
	u8 oui[3];
};

enum {
	XMITBUF_DATA = 0,
	XMITBUF_MGNT = 1,
	XMITBUF_CMD = 2,
};

enum XMIT_BLOCK_REASON {
	XMIT_BLOCK_NONE = 0,
	XMIT_BLOCK_REDLMEM = 1,
	XMIT_BLOCK_SUSPEND = 2,
	XMIT_BLOCK_MAX = 255,
};

enum NAT25_METHOD {
	NAT25_MIN = 0,
	NAT25_CHECK = 1,
	NAT25_INSERT = 2,
	NAT25_LOOKUP = 3,
	NAT25_PARSE = 4,
	NAT25_MAX = 5,
};

enum P2P_PROTO_WK_ID {
	P2P_FIND_PHASE_WK = 0,
	P2P_RESTORE_STATE_WK = 1,
	P2P_PRE_TX_PROVDISC_PROCESS_WK = 2,
	P2P_PRE_TX_NEGOREQ_PROCESS_WK = 3,
	P2P_PRE_TX_INVITEREQ_PROCESS_WK = 4,
};

typedef u8 u_int8_t;

typedef u16 u_int16_t;

typedef u32 u_int32_t;

struct icmpv6_echo {
	__be16 identifier;
	__be16 sequence;
};

struct icmpv6_nd_advt {
	__u32 reserved: 5;
	__u32 override: 1;
	__u32 solicited: 1;
	__u32 router: 1;
	__u32 reserved2: 24;
};

struct icmpv6_nd_ra {
	__u8 hop_limit;
	__u8 reserved: 3;
	__u8 router_pref: 2;
	__u8 home_agent: 1;
	__u8 other: 1;
	__u8 managed: 1;
	__be16 rt_lifetime;
};

struct icmp6hdr {
	__u8 icmp6_type;
	__u8 icmp6_code;
	__sum16 icmp6_cksum;
	union {
		__be32 un_data32[1];
		__be16 un_data16[2];
		__u8 un_data8[4];
		struct icmpv6_echo u_echo;
		struct icmpv6_nd_advt u_nd_advt;
		struct icmpv6_nd_ra u_nd_ra;
	} icmp6_dataun;
};

struct arphdr {
	__be16 ar_hrd;
	__be16 ar_pro;
	unsigned char ar_hln;
	unsigned char ar_pln;
	__be16 ar_op;
};

struct ipv6hdr {
	__u8 priority: 4;
	__u8 version: 4;
	__u8 flow_lbl[3];
	__be16 payload_len;
	__u8 nexthdr;
	__u8 hop_limit;
	struct in6_addr saddr;
	struct in6_addr daddr;
};

struct udphdr {
	__be16 source;
	__be16 dest;
	__be16 len;
	__sum16 check;
};

struct ipx_address {
	__be32 net;
	__u8 node[6];
	__be16 sock;
};

struct ipxhdr {
	__be16 ipx_checksum;
	__be16 ipx_pktsize;
	__u8 ipx_tctrl;
	__u8 ipx_type;
	struct ipx_address ipx_dest;
	struct ipx_address ipx_source;
} __attribute__((packed));

struct ddpehdr {
	__be16 deh_len_hops;
	__be16 deh_sum;
	__be16 deh_dnet;
	__be16 deh_snet;
	__u8 deh_dnode;
	__u8 deh_snode;
	__u8 deh_dport;
	__u8 deh_sport;
};

struct elapaarp {
	__be16 hw_type;
	__be16 pa_type;
	__u8 hw_len;
	__u8 pa_len;
	__be16 function;
	__u8 hw_src[6];
	__u8 pa_src_zero;
	__be16 pa_src_net;
	__u8 pa_src_node;
	__u8 hw_dst[6];
	__u8 pa_dst_zero;
	__be16 pa_dst_net;
	__u8 pa_dst_node;
} __attribute__((packed));

struct pppoe_tag {
	__be16 tag_type;
	__be16 tag_len;
	char tag_data[0];
};

struct pppoe_hdr {
	__u8 type: 4;
	__u8 ver: 4;
	__u8 code;
	__be16 sid;
	__be16 length;
	struct pppoe_tag tag[0];
};

struct dhcpMessage {
	u_int8_t op;
	u_int8_t htype;
	u_int8_t hlen;
	u_int8_t hops;
	u_int32_t xid;
	u_int16_t secs;
	u_int16_t flags;
	u_int32_t ciaddr;
	u_int32_t yiaddr;
	u_int32_t siaddr;
	u_int32_t giaddr;
	u_int8_t chaddr[16];
	u_int8_t sname[64];
	u_int8_t file[128];
	u_int32_t cookie;
	u_int8_t options[308];
};

enum _BT_Ant_NUM {
	Ant_x2 = 0,
	Ant_x1 = 1,
};

enum _RT_MEDIA_STATUS {
	RT_MEDIA_DISCONNECT = 0,
	RT_MEDIA_CONNECT = 1,
};

enum rt_spinlock_type {
	RT_TX_SPINLOCK = 1,
	RT_RX_SPINLOCK = 2,
	RT_RM_SPINLOCK = 3,
	RT_CAM_SPINLOCK = 4,
	RT_SCAN_SPINLOCK = 5,
	RT_LOG_SPINLOCK = 7,
	RT_BW_SPINLOCK = 8,
	RT_CHNLOP_SPINLOCK = 9,
	RT_RF_OPERATE_SPINLOCK = 10,
	RT_INITIAL_SPINLOCK = 11,
	RT_RF_STATE_SPINLOCK = 12,
	RT_PORT_SPINLOCK = 16,
	RT_VNIC_SPINLOCK = 17,
	RT_HVL_SPINLOCK = 18,
	RT_H2C_SPINLOCK = 20,
	rt_bt_data_spinlock = 25,
	RT_WAPI_OPTION_SPINLOCK = 26,
	RT_WAPI_RX_SPINLOCK = 27,
	RT_CCK_PAGEA_SPINLOCK = 28,
	RT_BUFFER_SPINLOCK = 29,
	RT_CHANNEL_AND_BANDWIDTH_SPINLOCK = 30,
	RT_GEN_TEMP_BUF_SPINLOCK = 31,
	RT_AWB_SPINLOCK = 32,
	RT_FW_PS_SPINLOCK = 33,
	RT_HW_TIMER_SPIN_LOCK = 34,
	RT_MPT_WI_SPINLOCK = 35,
	RT_P2P_SPIN_LOCK = 36,
	RT_DBG_SPIN_LOCK = 37,
	RT_IQK_SPINLOCK = 38,
	RT_PENDED_OID_SPINLOCK = 39,
	RT_CHNLLIST_SPINLOCK = 40,
	RT_INDIC_SPINLOCK = 41,
	RT_RFD_SPINLOCK = 42,
	RT_SYNC_IO_CNT_SPINLOCK = 43,
	RT_LAST_SPINLOCK = 44,
};

typedef enum _HAL_PHYDM_OPS HAL_PHYDM_OPS;

enum phydm_ic {
	ODM_RTL8188E = 1,
	ODM_RTL8812 = 2,
	ODM_RTL8821 = 4,
	ODM_RTL8192E = 8,
	ODM_RTL8723B = 16,
	ODM_RTL8814A = 32,
	ODM_RTL8881A = 64,
	ODM_RTL8822B = 128,
	ODM_RTL8703B = 256,
	ODM_RTL8195A = 512,
	ODM_RTL8188F = 1024,
	ODM_RTL8723D = 2048,
	ODM_RTL8197F = 4096,
	ODM_RTL8821C = 8192,
	ODM_RTL8814B = 16384,
	ODM_RTL8198F = 32768,
	ODM_RTL8710B = 65536,
	ODM_RTL8192F = 131072,
	ODM_RTL8822C = 262144,
	ODM_RTL8195B = 524288,
	ODM_RTL8812F = 1048576,
	ODM_RTL8197G = 2097152,
	ODM_RTL8721D = 4194304,
	ODM_RTL8710C = 8388608,
	ODM_RTL8723F = 16777216,
};

enum phydm_adapinfo {
	PHYDM_ADAPINFO_CARRIER_SENSE_ENABLE = 0,
	PHYDM_ADAPINFO_TH_L2H_INI = 1,
	PHYDM_ADAPINFO_TH_EDCCA_HL_DIFF = 2,
	PHYDM_ADAPINFO_AP_NUM_TH = 3,
	PHYDM_ADAPINFO_DOMAIN_CODE_2G = 4,
	PHYDM_ADAPINFO_DOMAIN_CODE_5G = 5,
	PHYDM_ADAPINFO_SWITCH_TH_L2H_INI_IN_BAND = 6,
};

enum halrf_cmninfo_init {
	HALRF_CMNINFO_ABILITY = 0,
	HALRF_CMNINFO_DPK_EN = 1,
	HALRF_CMNINFO_EEPROM_THERMAL_VALUE = 2,
	HALRF_CMNINFO_RFK_FORBIDDEN = 3,
	HALRF_CMNINFO_IQK_SEGMENT = 4,
	HALRF_CMNINFO_RATE_INDEX = 5,
	HALRF_CMNINFO_PWT_TYPE = 6,
	HALRF_CMNINFO_MP_PSD_POINT = 7,
	HALRF_CMNINFO_MP_PSD_START_POINT = 8,
	HALRF_CMNINFO_MP_PSD_STOP_POINT = 9,
	HALRF_CMNINFO_MP_PSD_AVERAGE = 10,
	HALRF_CMNINFO_IQK_TIMES = 11,
	HALRF_CMNINFO_MP_POWER_TRACKING_TYPE = 12,
	HALRF_CMNINFO_POWER_TRACK_CONTROL = 13,
};

enum odm_cmninfo {
	ODM_CMNINFO_PLATFORM = 0,
	ODM_CMNINFO_ABILITY = 1,
	ODM_CMNINFO_INTERFACE = 2,
	ODM_CMNINFO_MP_TEST_CHIP = 3,
	ODM_CMNINFO_IC_TYPE = 4,
	ODM_CMNINFO_CUT_VER = 5,
	ODM_CMNINFO_FAB_VER = 6,
	ODM_CMNINFO_FW_VER = 7,
	ODM_CMNINFO_FW_SUB_VER = 8,
	ODM_CMNINFO_RF_TYPE = 9,
	ODM_CMNINFO_RFE_TYPE = 10,
	ODM_CMNINFO_DPK_EN = 11,
	ODM_CMNINFO_BOARD_TYPE = 12,
	ODM_CMNINFO_PACKAGE_TYPE = 13,
	ODM_CMNINFO_EXT_LNA = 14,
	ODM_CMNINFO_5G_EXT_LNA = 15,
	ODM_CMNINFO_EXT_PA = 16,
	ODM_CMNINFO_5G_EXT_PA = 17,
	ODM_CMNINFO_GPA = 18,
	ODM_CMNINFO_APA = 19,
	ODM_CMNINFO_GLNA = 20,
	ODM_CMNINFO_ALNA = 21,
	ODM_CMNINFO_TDMA = 22,
	ODM_CMNINFO_EXT_TRSW = 23,
	ODM_CMNINFO_EXT_LNA_GAIN = 24,
	ODM_CMNINFO_PATCH_ID = 25,
	ODM_CMNINFO_BINHCT_TEST = 26,
	ODM_CMNINFO_BWIFI_TEST = 27,
	ODM_CMNINFO_SMART_CONCURRENT = 28,
	ODM_CMNINFO_CONFIG_BB_RF = 29,
	ODM_CMNINFO_IQKPAOFF = 30,
	ODM_CMNINFO_HUBUSBMODE = 31,
	ODM_CMNINFO_FWDWRSVDPAGEINPROGRESS = 32,
	ODM_CMNINFO_TX_TP = 33,
	ODM_CMNINFO_RX_TP = 34,
	ODM_CMNINFO_SOUNDING_SEQ = 35,
	ODM_CMNINFO_REGRFKFREEENABLE = 36,
	ODM_CMNINFO_RFKFREEENABLE = 37,
	ODM_CMNINFO_NORMAL_RX_PATH_CHANGE = 38,
	ODM_CMNINFO_VALID_PATH_SET = 39,
	ODM_CMNINFO_EFUSE0X3D8 = 40,
	ODM_CMNINFO_EFUSE0X3D7 = 41,
	ODM_CMNINFO_SOFT_AP_SPECIAL_SETTING = 42,
	ODM_CMNINFO_X_CAP_SETTING = 43,
	ODM_CMNINFO_ADVANCE_OTA = 44,
	ODM_CMNINFO_HP_HWID = 45,
	ODM_CMNINFO_TSSI_ENABLE = 46,
	ODM_CMNINFO_DIS_DPD = 47,
	ODM_CMNINFO_POWER_VOLTAGE = 48,
	ODM_CMNINFO_ANTDIV_GPIO = 49,
	ODM_CMNINFO_EN_AUTO_BW_TH = 50,
	ODM_CMNINFO_PEAK_DETECT_MODE = 51,
	ODM_CMNINFO_TX_UNI = 52,
	ODM_CMNINFO_RX_UNI = 53,
	ODM_CMNINFO_BAND = 54,
	ODM_CMNINFO_SEC_CHNL_OFFSET = 55,
	ODM_CMNINFO_SEC_MODE = 56,
	ODM_CMNINFO_BW = 57,
	ODM_CMNINFO_CHNL = 58,
	ODM_CMNINFO_FORCED_RATE = 59,
	ODM_CMNINFO_ANT_DIV = 60,
	ODM_CMNINFO_PATH_DIV = 61,
	ODM_CMNINFO_ADAPTIVE_SOML = 62,
	ODM_CMNINFO_ADAPTIVITY = 63,
	ODM_CMNINFO_SCAN = 64,
	ODM_CMNINFO_POWER_SAVING = 65,
	ODM_CMNINFO_ONE_PATH_CCA = 66,
	ODM_CMNINFO_DRV_STOP = 67,
	ODM_CMNINFO_PNP_IN = 68,
	ODM_CMNINFO_INIT_ON = 69,
	ODM_CMNINFO_ANT_TEST = 70,
	ODM_CMNINFO_NET_CLOSED = 71,
	ODM_CMNINFO_P2P_LINK = 72,
	ODM_CMNINFO_FCS_MODE = 73,
	ODM_CMNINFO_IS1ANTENNA = 74,
	ODM_CMNINFO_RFDEFAULTPATH = 75,
	ODM_CMNINFO_DFS_MASTER_ENABLE = 76,
	ODM_CMNINFO_FORCE_TX_ANT_BY_TXDESC = 77,
	ODM_CMNINFO_SET_S0S1_DEFAULT_ANTENNA = 78,
	ODM_CMNINFO_SOFT_AP_MODE = 79,
	ODM_CMNINFO_MP_MODE = 80,
	ODM_CMNINFO_INTERRUPT_MASK = 81,
	ODM_CMNINFO_BB_OPERATION_MODE = 82,
	ODM_CMNINFO_BF_ANTDIV_DECISION = 83,
	ODM_CMNINFO_MANUAL_SUPPORTABILITY = 84,
	ODM_CMNINFO_EN_DYM_BW_INDICATION = 85,
	ODM_CMNINFO_WIFI_DIRECT = 86,
	ODM_CMNINFO_WIFI_DISPLAY = 87,
	ODM_CMNINFO_LINK_IN_PROGRESS = 88,
	ODM_CMNINFO_LINK = 89,
	ODM_CMNINFO_CMW500LINK = 90,
	ODM_CMNINFO_STATION_STATE = 91,
	ODM_CMNINFO_RSSI_MIN = 92,
	ODM_CMNINFO_RSSI_MIN_BY_PATH = 93,
	ODM_CMNINFO_DBG_COMP = 94,
	ODM_CMNINFO_RA_THRESHOLD_HIGH = 95,
	ODM_CMNINFO_RA_THRESHOLD_LOW = 96,
	ODM_CMNINFO_RF_ANTENNA_TYPE = 97,
	ODM_CMNINFO_WITH_EXT_ANTENNA_SWITCH = 98,
	ODM_CMNINFO_BE_FIX_TX_ANT = 99,
	ODM_CMNINFO_BT_ENABLED = 100,
	ODM_CMNINFO_BT_HS_CONNECT_PROCESS = 101,
	ODM_CMNINFO_BT_HS_RSSI = 102,
	ODM_CMNINFO_BT_OPERATION = 103,
	ODM_CMNINFO_BT_LIMITED_DIG = 104,
	ODM_CMNINFO_AP_TOTAL_NUM = 105,
	ODM_CMNINFO_POWER_TRAINING = 106,
	ODM_CMNINFO_DFS_REGION_DOMAIN = 107,
	ODM_CMNINFO_BT_CONTINUOUS_TURN = 108,
	ODM_CMNINFO_IS_DOWNLOAD_FW = 109,
	ODM_CMNINFO_PHYDM_PATCH_ID = 110,
	ODM_CMNINFO_RRSR_VAL = 111,
	ODM_CMNINFO_LINKED_BF_SUPPORT = 112,
	ODM_CMNINFO_FLATNESS_TYPE = 113,
	ODM_CMNINFO_STA_STATUS = 114,
	ODM_CMNINFO_MAX = 115,
};

struct phy_sts_rpt_jgr2_type0 {
	u8 page_num;
	u8 pwdb;
	u8 gain: 6;
	u8 rsvd_0: 1;
	u8 trsw: 1;
	u8 rsvd_1;
	u8 rsvd_2;
	u8 rxsc: 4;
	u8 agc_table: 4;
	u8 channel;
	u8 band;
	u16 length;
	u8 antidx_a: 3;
	u8 antidx_b: 3;
	u8 rsvd_3: 2;
	u8 antidx_c: 3;
	u8 antidx_d: 3;
	u8 rsvd_4: 2;
	u8 signal_quality;
	u8 vga: 5;
	u8 lna_l: 3;
	u8 bb_power: 6;
	u8 rsvd_9: 1;
	u8 lna_h: 1;
	u8 rsvd_5;
	u32 rsvd_6;
	u32 rsvd_7;
	u32 rsvd_8;
};

struct phy_sts_rpt_jgr2_type1 {
	u8 page_num;
	u8 pwdb[4];
	u8 l_rxsc: 4;
	u8 ht_rxsc: 4;
	u8 channel;
	u8 band: 2;
	u8 rsvd_0: 1;
	u8 hw_antsw_occu: 1;
	u8 gnt_bt: 1;
	u8 ldpc: 1;
	u8 stbc: 1;
	u8 beamformed: 1;
	u16 lsig_length;
	u8 antidx_a: 3;
	u8 antidx_b: 3;
	u8 rsvd_1: 2;
	u8 antidx_c: 3;
	u8 antidx_d: 3;
	u8 rsvd_2: 2;
	u8 paid;
	u8 paid_msb: 1;
	u8 gid: 6;
	u8 rsvd_3: 1;
	u8 intf_pos;
	u8 intf_pos_msb: 1;
	u8 rsvd_4: 2;
	u8 nb_intf_flag: 1;
	u8 rf_mode: 2;
	u8 rsvd_5: 2;
	s8 rxevm[4];
	s8 cfo_tail[4];
	s8 rxsnr[4];
};

struct phy_sts_rpt_jgr2_type2 {
	u8 page_num;
	u8 pwdb[4];
	u8 l_rxsc: 4;
	u8 ht_rxsc: 4;
	u8 channel;
	u8 band: 2;
	u8 rsvd_0: 1;
	u8 hw_antsw_occu: 1;
	u8 gnt_bt: 1;
	u8 ldpc: 1;
	u8 stbc: 1;
	u8 beamformed: 1;
	u8 shift_l_map: 6;
	u8 rsvd_1: 2;
	u8 cnt_pw2cca;
	u8 agc_table_a: 4;
	u8 agc_table_b: 4;
	u8 agc_table_c: 4;
	u8 agc_table_d: 4;
	u8 cnt_cca2agc_rdy;
	u8 gain_a: 6;
	u8 rsvd_2: 1;
	u8 trsw_a: 1;
	u8 gain_b: 6;
	u8 rsvd_3: 1;
	u8 trsw_b: 1;
	u8 gain_c: 6;
	u8 rsvd_4: 1;
	u8 trsw_c: 1;
	u8 gain_d: 6;
	u8 rsvd_5: 1;
	u8 trsw_d: 1;
	u8 aagc_step_a: 2;
	u8 aagc_step_b: 2;
	u8 aagc_step_c: 2;
	u8 aagc_step_d: 2;
	u8 ht_aagc_gain[4];
	u8 dagc_gain[4];
	u8 counter: 6;
	u8 rsvd_6: 2;
	u8 syn_count: 5;
	u8 rsvd_7: 3;
};

enum {
	_MSG_EXCESSIVE_ = 0,
	_MSG_MSGDUMP_ = 1,
	_MSG_DEBUG_ = 2,
	_MSG_INFO_ = 3,
	_MSG_WARNING_ = 4,
	_MSG_ERROR_ = 5,
};

struct ieee80211_hdr {
	__le16 frame_control;
	__le16 duration_id;
	u8 addr1[6];
	u8 addr2[6];
	u8 addr3[6];
	__le16 seq_ctrl;
	u8 addr4[6];
};

struct _sha256_state {
	u64 length;
	u32 state[8];
	u32 curlen;
	u8 buf[64];
};

enum gro_result {
	GRO_MERGED = 0,
	GRO_MERGED_FREE = 1,
	GRO_HELD = 2,
	GRO_NORMAL = 3,
	GRO_DROP = 4,
	GRO_CONSUMED = 5,
};

typedef enum gro_result gro_result_t;

typedef struct completion _completion;

typedef struct hlist_head rtw_hlist_head;

typedef struct hlist_node rtw_hlist_node;

typedef ktime_t sysptime;

enum rtw_pwait_type {
	RTW_PWAIT_TYPE_MSLEEP = 0,
	RTW_PWAIT_TYPE_USLEEP = 1,
	RTW_PWAIT_TYPE_YIELD = 2,
	RTW_PWAIT_TYPE_MDELAY = 3,
	RTW_PWAIT_TYPE_UDELAY = 4,
	RTW_PWAIT_TYPE_NUM = 5,
};

struct rtw_pwait_conf {
	enum rtw_pwait_type type;
	s32 wait_time;
	s32 wait_cnt_lmt;
};

struct rtw_pwait_ctx {
	struct rtw_pwait_conf conf;
	s32 wait_cnt;
	void (*wait_hdl)(int);
};

struct rtw_cbuf {
	u32 write;
	u32 read;
	u32 size;
	void *bufs[0];
};

struct map_seg_t {
	u16 sa;
	u16 len;
	u8 *c;
};

struct map_t {
	u16 len;
	u16 seg_num;
	u8 init_value;
	struct map_seg_t *segs;
};

enum RFINTFS {
	SWSI = 0,
	HWSI = 1,
	HWPI = 2,
};

enum _BTCOEX_SUSPEND_STATE {
	BTCOEX_SUSPEND_STATE_RESUME = 0,
	BTCOEX_SUSPEND_STATE_SUSPEND = 1,
	BTCOEX_SUSPEND_STATE_SUSPEND_KEEP_ANT = 2,
	BTCOEX_SUSPEND_STATE_MAX = 3,
};

enum _DRIVER_STATE {
	DRIVER_NORMAL = 0,
	DRIVER_DISAPPEAR = 1,
	DRIVER_REPLACE_DONGLE = 2,
};

enum _NAPI_STATE {
	NAPI_DISABLE = 0,
	NAPI_ENABLE = 1,
};

struct sdio_device_id {
	__u8 class;
	__u16 vendor;
	__u16 device;
	kernel_ulong_t driver_data;
};

struct sdio_driver {
	char *name;
	const struct sdio_device_id *id_table;
	int (*probe)(struct sdio_func *, const struct sdio_device_id *);
	void (*remove)(struct sdio_func *);
	struct device_driver drv;
};

typedef struct sdio_data *PSDIO_DATA;

struct sdio_drv_priv {
	struct sdio_driver r871xs_drv;
	int drv_registered;
};

struct iw_param {
	__s32 value;
	__u8 fixed;
	__u8 disabled;
	__u16 flags;
};

struct iw_point {
	void *pointer;
	__u16 length;
	__u16 flags;
};

struct iw_freq {
	__s32 m;
	__s16 e;
	__u8 i;
	__u8 flags;
};

union iwreq_data {
	char name[16];
	struct iw_point essid;
	struct iw_param nwid;
	struct iw_freq freq;
	struct iw_param sens;
	struct iw_param bitrate;
	struct iw_param txpower;
	struct iw_param rts;
	struct iw_param frag;
	__u32 mode;
	struct iw_param retry;
	struct iw_point encoding;
	struct iw_param power;
	struct iw_quality qual;
	struct sockaddr ap_addr;
	struct sockaddr addr;
	struct iw_param param;
	struct iw_point data;
};

struct iwreq {
	union {
		char ifrn_name[16];
	} ifr_ifrn;
	union iwreq_data u;
};

struct iw_priv_args {
	__u32 cmd;
	__u16 set_args;
	__u16 get_args;
	char name[16];
};

struct iw_request_info {
	__u16 cmd;
	__u16 flags;
};

typedef int (*iw_handler)(struct net_device *, struct iw_request_info *, union iwreq_data *, char *);

enum {
	RTL871X_HOSTAPD_FLUSH = 1,
	RTL871X_HOSTAPD_ADD_STA = 2,
	RTL871X_HOSTAPD_REMOVE_STA = 3,
	RTL871X_HOSTAPD_GET_INFO_STA = 4,
	RTL871X_HOSTAPD_GET_WPAIE_STA = 5,
	RTL871X_SET_ENCRYPTION = 6,
	RTL871X_GET_ENCRYPTION = 7,
	RTL871X_HOSTAPD_SET_FLAGS_STA = 8,
	RTL871X_HOSTAPD_GET_RID = 9,
	RTL871X_HOSTAPD_SET_RID = 10,
	RTL871X_HOSTAPD_SET_ASSOC_AP_ADDR = 11,
	RTL871X_HOSTAPD_SET_GENERIC_ELEMENT = 12,
	RTL871X_HOSTAPD_MLME = 13,
	RTL871X_HOSTAPD_SCAN_REQ = 14,
	RTL871X_HOSTAPD_STA_CLEAR_STATS = 15,
	RTL871X_HOSTAPD_SET_BEACON = 16,
	RTL871X_HOSTAPD_SET_WPS_BEACON = 17,
	RTL871X_HOSTAPD_SET_WPS_PROBE_RESP = 18,
	RTL871X_HOSTAPD_SET_WPS_ASSOC_RESP = 19,
	RTL871X_HOSTAPD_SET_HIDDEN_SSID = 20,
	RTL871X_HOSTAPD_SET_MACADDR_ACL = 21,
	RTL871X_HOSTAPD_ACL_ADD_STA = 22,
	RTL871X_HOSTAPD_ACL_REMOVE_STA = 23,
};

struct ieee_param {
	u32 cmd;
	u8 sta_addr[6];
	union {
		struct {
			u8 name;
			u32 value;
		} wpa_param;
		struct {
			u32 len;
			u8 reserved[32];
			u8 data[0];
		} wpa_ie;
		struct {
			int command;
			int reason_code;
		} mlme;
		struct {
			u8 alg[16];
			u8 set_tx;
			u32 err;
			u8 idx;
			u8 seq[8];
			u16 key_len;
			u8 key[0];
		} crypt;
		struct {
			u16 aid;
			u16 capability;
			int flags;
			u8 tx_supp_rates[16];
			struct rtw_ieee80211_ht_cap ht_cap;
		} add_sta;
		struct {
			u8 reserved[2];
			u8 buf[0];
		} bcn_ie;
	} u;
};

struct ieee_param_ex {
	u32 cmd;
	u8 sta_addr[6];
	u8 data[0];
};

struct sta_data {
	u16 aid;
	u16 capability;
	int flags;
	u32 sta_set;
	u8 tx_supp_rates[16];
	u32 tx_supp_rates_len;
	struct rtw_ieee80211_ht_cap ht_cap;
	u64 rx_pkts;
	u64 rx_bytes;
	u64 rx_drops;
	u64 tx_pkts;
	u64 tx_bytes;
	u64 tx_drops;
};

enum txpwr_pg_mode {
	TXPWR_PG_WITH_PWR_IDX = 0,
	TXPWR_PG_WITH_TSSI_OFFSET = 1,
	TXPWR_PG_UNKNOWN = 2,
};

enum _BTCOEX_POLICY_CONTROL {
	BTCOEX_POLICY_CONTROL_AUTO = 0,
	BTCOEX_POLICY_CONTROL_FORCE_FREERUN = 1,
	BTCOEX_POLICY_CONTROL_FORCE_TDMA = 2,
};

struct iw_michaelmicfailure {
	__u32 flags;
	struct sockaddr src_addr;
	__u8 tsc[8];
};

enum nl80211_key_type {
	NL80211_KEYTYPE_GROUP = 0,
	NL80211_KEYTYPE_PAIRWISE = 1,
	NL80211_KEYTYPE_PEERKEY = 2,
	NUM_NL80211_KEYTYPES = 3,
};

struct ieee80211_msrment_ie {
	u8 token;
	u8 mode;
	u8 type;
	u8 request[0];
};

struct ieee80211_ext_chansw_ie {
	u8 mode;
	u8 new_operating_class;
	u8 new_ch_num;
	u8 count;
};

struct ieee80211_tpc_report_ie {
	u8 tx_power;
	u8 link_margin;
};

struct ieee80211_s1g_cap {
	u8 capab_info[10];
	u8 supp_mcs_nss[5];
};

struct ieee80211_mgmt {
	__le16 frame_control;
	__le16 duration;
	u8 da[6];
	u8 sa[6];
	u8 bssid[6];
	__le16 seq_ctrl;
	union {
		struct {
			__le16 auth_alg;
			__le16 auth_transaction;
			__le16 status_code;
			u8 variable[0];
		} auth;
		struct {
			__le16 reason_code;
		} deauth;
		struct {
			__le16 capab_info;
			__le16 listen_interval;
			u8 variable[0];
		} assoc_req;
		struct {
			__le16 capab_info;
			__le16 status_code;
			__le16 aid;
			u8 variable[0];
		} assoc_resp;
		struct {
			__le16 capab_info;
			__le16 status_code;
			__le16 aid;
			u8 variable[0];
		} reassoc_resp;
		struct {
			__le16 capab_info;
			__le16 status_code;
			u8 variable[0];
		} s1g_assoc_resp;
		struct {
			__le16 capab_info;
			__le16 status_code;
			u8 variable[0];
		} s1g_reassoc_resp;
		struct {
			__le16 capab_info;
			__le16 listen_interval;
			u8 current_ap[6];
			u8 variable[0];
		} reassoc_req;
		struct {
			__le16 reason_code;
		} disassoc;
		struct {
			__le64 timestamp;
			__le16 beacon_int;
			__le16 capab_info;
			u8 variable[0];
		} __attribute__((packed)) beacon;
		struct {
			u8 variable[0];
		} probe_req;
		struct {
			__le64 timestamp;
			__le16 beacon_int;
			__le16 capab_info;
			u8 variable[0];
		} __attribute__((packed)) probe_resp;
		struct {
			u8 category;
			union {
				struct {
					u8 action_code;
					u8 dialog_token;
					u8 status_code;
					u8 variable[0];
				} wme_action;
				struct {
					u8 action_code;
					u8 variable[0];
				} chan_switch;
				struct {
					u8 action_code;
					struct ieee80211_ext_chansw_ie data;
					u8 variable[0];
				} ext_chan_switch;
				struct {
					u8 action_code;
					u8 dialog_token;
					u8 element_id;
					u8 length;
					struct ieee80211_msrment_ie msr_elem;
				} measurement;
				struct {
					u8 action_code;
					u8 dialog_token;
					__le16 capab;
					__le16 timeout;
					__le16 start_seq_num;
					u8 variable[0];
				} addba_req;
				struct {
					u8 action_code;
					u8 dialog_token;
					__le16 status;
					__le16 capab;
					__le16 timeout;
				} addba_resp;
				struct {
					u8 action_code;
					__le16 params;
					__le16 reason_code;
				} __attribute__((packed)) delba;
				struct {
					u8 action_code;
					u8 variable[0];
				} self_prot;
				struct {
					u8 action_code;
					u8 variable[0];
				} mesh_action;
				struct {
					u8 action;
					u8 trans_id[2];
				} sa_query;
				struct {
					u8 action;
					u8 smps_control;
				} ht_smps;
				struct {
					u8 action_code;
					u8 chanwidth;
				} ht_notify_cw;
				struct {
					u8 action_code;
					u8 dialog_token;
					__le16 capability;
					u8 variable[0];
				} tdls_discover_resp;
				struct {
					u8 action_code;
					u8 operating_mode;
				} vht_opmode_notif;
				struct {
					u8 action_code;
					u8 membership[8];
					u8 position[16];
				} vht_group_notif;
				struct {
					u8 action_code;
					u8 dialog_token;
					u8 tpc_elem_id;
					u8 tpc_elem_length;
					struct ieee80211_tpc_report_ie tpc;
				} tpc_report;
				struct {
					u8 action_code;
					u8 dialog_token;
					u8 follow_up;
					u8 tod[6];
					u8 toa[6];
					__le16 tod_error;
					__le16 toa_error;
					u8 variable[0];
				} __attribute__((packed)) ftm;
			} u;
		} __attribute__((packed)) action;
	} u;
} __attribute__((packed));

enum ieee80211_max_ampdu_length_exp {
	IEEE80211_HT_MAX_AMPDU_8K = 0,
	IEEE80211_HT_MAX_AMPDU_16K = 1,
	IEEE80211_HT_MAX_AMPDU_32K = 2,
	IEEE80211_HT_MAX_AMPDU_64K = 3,
};

enum ieee80211_min_mpdu_spacing {
	IEEE80211_HT_MPDU_DENSITY_NONE = 0,
	IEEE80211_HT_MPDU_DENSITY_0_25 = 1,
	IEEE80211_HT_MPDU_DENSITY_0_5 = 2,
	IEEE80211_HT_MPDU_DENSITY_1 = 3,
	IEEE80211_HT_MPDU_DENSITY_2 = 4,
	IEEE80211_HT_MPDU_DENSITY_4 = 5,
	IEEE80211_HT_MPDU_DENSITY_8 = 6,
	IEEE80211_HT_MPDU_DENSITY_16 = 7,
};

struct ieee80211_he_operation {
	__le32 he_oper_params;
	__le16 he_mcs_nss_set;
	u8 optional[0];
} __attribute__((packed));

struct nl80211_sta_flag_update {
	__u32 mask;
	__u32 set;
};

enum nl80211_he_gi {
	NL80211_RATE_INFO_HE_GI_0_8 = 0,
	NL80211_RATE_INFO_HE_GI_1_6 = 1,
	NL80211_RATE_INFO_HE_GI_3_2 = 2,
};

enum nl80211_he_ltf {
	NL80211_RATE_INFO_HE_1XLTF = 0,
	NL80211_RATE_INFO_HE_2XLTF = 1,
	NL80211_RATE_INFO_HE_4XLTF = 2,
};

enum nl80211_sta_info {
	__NL80211_STA_INFO_INVALID = 0,
	NL80211_STA_INFO_INACTIVE_TIME = 1,
	NL80211_STA_INFO_RX_BYTES = 2,
	NL80211_STA_INFO_TX_BYTES = 3,
	NL80211_STA_INFO_LLID = 4,
	NL80211_STA_INFO_PLID = 5,
	NL80211_STA_INFO_PLINK_STATE = 6,
	NL80211_STA_INFO_SIGNAL = 7,
	NL80211_STA_INFO_TX_BITRATE = 8,
	NL80211_STA_INFO_RX_PACKETS = 9,
	NL80211_STA_INFO_TX_PACKETS = 10,
	NL80211_STA_INFO_TX_RETRIES = 11,
	NL80211_STA_INFO_TX_FAILED = 12,
	NL80211_STA_INFO_SIGNAL_AVG = 13,
	NL80211_STA_INFO_RX_BITRATE = 14,
	NL80211_STA_INFO_BSS_PARAM = 15,
	NL80211_STA_INFO_CONNECTED_TIME = 16,
	NL80211_STA_INFO_STA_FLAGS = 17,
	NL80211_STA_INFO_BEACON_LOSS = 18,
	NL80211_STA_INFO_T_OFFSET = 19,
	NL80211_STA_INFO_LOCAL_PM = 20,
	NL80211_STA_INFO_PEER_PM = 21,
	NL80211_STA_INFO_NONPEER_PM = 22,
	NL80211_STA_INFO_RX_BYTES64 = 23,
	NL80211_STA_INFO_TX_BYTES64 = 24,
	NL80211_STA_INFO_CHAIN_SIGNAL = 25,
	NL80211_STA_INFO_CHAIN_SIGNAL_AVG = 26,
	NL80211_STA_INFO_EXPECTED_THROUGHPUT = 27,
	NL80211_STA_INFO_RX_DROP_MISC = 28,
	NL80211_STA_INFO_BEACON_RX = 29,
	NL80211_STA_INFO_BEACON_SIGNAL_AVG = 30,
	NL80211_STA_INFO_TID_STATS = 31,
	NL80211_STA_INFO_RX_DURATION = 32,
	NL80211_STA_INFO_PAD = 33,
	NL80211_STA_INFO_ACK_SIGNAL = 34,
	NL80211_STA_INFO_ACK_SIGNAL_AVG = 35,
	NL80211_STA_INFO_RX_MPDUS = 36,
	NL80211_STA_INFO_FCS_ERROR_COUNT = 37,
	NL80211_STA_INFO_CONNECTED_TO_GATE = 38,
	NL80211_STA_INFO_TX_DURATION = 39,
	NL80211_STA_INFO_AIRTIME_WEIGHT = 40,
	NL80211_STA_INFO_AIRTIME_LINK_METRIC = 41,
	NL80211_STA_INFO_ASSOC_AT_BOOTTIME = 42,
	NL80211_STA_INFO_CONNECTED_TO_AS = 43,
	__NL80211_STA_INFO_AFTER_LAST = 44,
	NL80211_STA_INFO_MAX = 43,
};

enum nl80211_mesh_power_mode {
	NL80211_MESH_POWER_UNKNOWN = 0,
	NL80211_MESH_POWER_ACTIVE = 1,
	NL80211_MESH_POWER_LIGHT_SLEEP = 2,
	NL80211_MESH_POWER_DEEP_SLEEP = 3,
	__NL80211_MESH_POWER_AFTER_LAST = 4,
	NL80211_MESH_POWER_MAX = 3,
};

enum nl80211_ac {
	NL80211_AC_VO = 0,
	NL80211_AC_VI = 1,
	NL80211_AC_BE = 2,
	NL80211_AC_BK = 3,
	NL80211_NUM_ACS = 4,
};

enum nl80211_wpa_versions {
	NL80211_WPA_VERSION_1 = 1,
	NL80211_WPA_VERSION_2 = 2,
	NL80211_WPA_VERSION_3 = 4,
};

enum nl80211_txrate_gi {
	NL80211_TXRATE_DEFAULT_GI = 0,
	NL80211_TXRATE_FORCE_SGI = 1,
	NL80211_TXRATE_FORCE_LGI = 2,
};

enum nl80211_tx_power_setting {
	NL80211_TX_POWER_AUTOMATIC = 0,
	NL80211_TX_POWER_LIMITED = 1,
	NL80211_TX_POWER_FIXED = 2,
};

enum nl80211_tid_config {
	NL80211_TID_CONFIG_ENABLE = 0,
	NL80211_TID_CONFIG_DISABLE = 1,
};

enum nl80211_tx_rate_setting {
	NL80211_TX_RATE_AUTOMATIC = 0,
	NL80211_TX_RATE_LIMITED = 1,
	NL80211_TX_RATE_FIXED = 2,
};

enum nl80211_coalesce_condition {
	NL80211_COALESCE_CONDITION_MATCH = 0,
	NL80211_COALESCE_CONDITION_NO_MATCH = 1,
};

enum nl80211_hidden_ssid {
	NL80211_HIDDEN_SSID_NOT_IN_USE = 0,
	NL80211_HIDDEN_SSID_ZERO_LEN = 1,
	NL80211_HIDDEN_SSID_ZERO_CONTENTS = 2,
};

enum nl80211_tdls_operation {
	NL80211_TDLS_DISCOVERY_REQ = 0,
	NL80211_TDLS_SETUP = 1,
	NL80211_TDLS_TEARDOWN = 2,
	NL80211_TDLS_ENABLE_LINK = 3,
	NL80211_TDLS_DISABLE_LINK = 4,
};

enum nl80211_feature_flags {
	NL80211_FEATURE_SK_TX_STATUS = 1,
	NL80211_FEATURE_HT_IBSS = 2,
	NL80211_FEATURE_INACTIVITY_TIMER = 4,
	NL80211_FEATURE_CELL_BASE_REG_HINTS = 8,
	NL80211_FEATURE_P2P_DEVICE_NEEDS_CHANNEL = 16,
	NL80211_FEATURE_SAE = 32,
	NL80211_FEATURE_LOW_PRIORITY_SCAN = 64,
	NL80211_FEATURE_SCAN_FLUSH = 128,
	NL80211_FEATURE_AP_SCAN = 256,
	NL80211_FEATURE_VIF_TXPOWER = 512,
	NL80211_FEATURE_NEED_OBSS_SCAN = 1024,
	NL80211_FEATURE_P2P_GO_CTWIN = 2048,
	NL80211_FEATURE_P2P_GO_OPPPS = 4096,
	NL80211_FEATURE_ADVERTISE_CHAN_LIMITS = 16384,
	NL80211_FEATURE_FULL_AP_CLIENT_STATE = 32768,
	NL80211_FEATURE_USERSPACE_MPM = 65536,
	NL80211_FEATURE_ACTIVE_MONITOR = 131072,
	NL80211_FEATURE_AP_MODE_CHAN_WIDTH_CHANGE = 262144,
	NL80211_FEATURE_DS_PARAM_SET_IE_IN_PROBES = 524288,
	NL80211_FEATURE_WFA_TPC_IE_IN_PROBES = 1048576,
	NL80211_FEATURE_QUIET = 2097152,
	NL80211_FEATURE_TX_POWER_INSERTION = 4194304,
	NL80211_FEATURE_ACKTO_ESTIMATION = 8388608,
	NL80211_FEATURE_STATIC_SMPS = 16777216,
	NL80211_FEATURE_DYNAMIC_SMPS = 33554432,
	NL80211_FEATURE_SUPPORTS_WMM_ADMISSION = 67108864,
	NL80211_FEATURE_MAC_ON_CREATE = 134217728,
	NL80211_FEATURE_TDLS_CHANNEL_SWITCH = 268435456,
	NL80211_FEATURE_SCAN_RANDOM_MAC_ADDR = 536870912,
	NL80211_FEATURE_SCHED_SCAN_RANDOM_MAC_ADDR = 1073741824,
	NL80211_FEATURE_ND_RANDOM_MAC_ADDR = 2147483648,
};

enum nl80211_timeout_reason {
	NL80211_TIMEOUT_UNSPECIFIED = 0,
	NL80211_TIMEOUT_SCAN = 1,
	NL80211_TIMEOUT_AUTH = 2,
	NL80211_TIMEOUT_ASSOC = 3,
};

enum nl80211_acl_policy {
	NL80211_ACL_POLICY_ACCEPT_UNLESS_LISTED = 0,
	NL80211_ACL_POLICY_DENY_UNLESS_LISTED = 1,
};

enum nl80211_smps_mode {
	NL80211_SMPS_OFF = 0,
	NL80211_SMPS_STATIC = 1,
	NL80211_SMPS_DYNAMIC = 2,
	__NL80211_SMPS_AFTER_LAST = 3,
	NL80211_SMPS_MAX = 2,
};

enum nl80211_crit_proto_id {
	NL80211_CRIT_PROTO_UNSPEC = 0,
	NL80211_CRIT_PROTO_DHCP = 1,
	NL80211_CRIT_PROTO_EAPOL = 2,
	NL80211_CRIT_PROTO_APIPA = 3,
	NUM_NL80211_CRIT_PROTO = 4,
};

enum nl80211_nan_function_type {
	NL80211_NAN_FUNC_PUBLISH = 0,
	NL80211_NAN_FUNC_SUBSCRIBE = 1,
	NL80211_NAN_FUNC_FOLLOW_UP = 2,
	__NL80211_NAN_FUNC_TYPE_AFTER_LAST = 3,
	NL80211_NAN_FUNC_MAX_TYPE = 2,
};

enum nl80211_external_auth_action {
	NL80211_EXTERNAL_AUTH_START = 0,
	NL80211_EXTERNAL_AUTH_ABORT = 1,
};

enum nl80211_preamble {
	NL80211_PREAMBLE_LEGACY = 0,
	NL80211_PREAMBLE_HT = 1,
	NL80211_PREAMBLE_VHT = 2,
	NL80211_PREAMBLE_DMG = 3,
	NL80211_PREAMBLE_HE = 4,
};

enum ieee80211_privacy {
	IEEE80211_PRIVACY_ON = 0,
	IEEE80211_PRIVACY_OFF = 1,
	IEEE80211_PRIVACY_ANY = 2,
};

struct ieee80211_he_obss_pd {
	bool enable;
	u8 sr_ctrl;
	u8 non_srg_max_offset;
	u8 min_offset;
	u8 max_offset;
	u8 bss_color_bitmap[8];
	u8 partial_bssid_bitmap[8];
};

struct cfg80211_he_bss_color {
	u8 color;
	bool enabled;
	bool partial;
};

struct vif_params {
	u32 flags;
	int use_4addr;
	u8 macaddr[6];
	const u8 *vht_mumimo_groups;
	const u8 *vht_mumimo_follow_addr;
};

struct cfg80211_bitrate_mask {
	struct {
		u32 legacy;
		u8 ht_mcs[10];
		u16 vht_mcs[8];
		u16 he_mcs[8];
		enum nl80211_txrate_gi gi;
		enum nl80211_he_gi he_gi;
		enum nl80211_he_ltf he_ltf;
	} control[5];
};

struct cfg80211_tid_cfg {
	bool config_override;
	u8 tids;
	u64 mask;
	enum nl80211_tid_config noack;
	u8 retry_long;
	u8 retry_short;
	enum nl80211_tid_config ampdu;
	enum nl80211_tid_config rtscts;
	enum nl80211_tid_config amsdu;
	enum nl80211_tx_rate_setting txrate_type;
	struct cfg80211_bitrate_mask txrate_mask;
};

struct cfg80211_tid_config {
	const u8 *peer;
	u32 n_tid_conf;
	struct cfg80211_tid_cfg tid_conf[0];
};

struct survey_info {
	struct ieee80211_channel *channel;
	u64 time;
	u64 time_busy;
	u64 time_ext_busy;
	u64 time_rx;
	u64 time_tx;
	u64 time_scan;
	u64 time_bss_rx;
	u32 filled;
	s8 noise;
};

struct cfg80211_beacon_data {
	const u8 *head;
	const u8 *tail;
	const u8 *beacon_ies;
	const u8 *proberesp_ies;
	const u8 *assocresp_ies;
	const u8 *probe_resp;
	const u8 *lci;
	const u8 *civicloc;
	s8 ftm_responder;
	size_t head_len;
	size_t tail_len;
	size_t beacon_ies_len;
	size_t proberesp_ies_len;
	size_t assocresp_ies_len;
	size_t probe_resp_len;
	size_t lci_len;
	size_t civicloc_len;
};

struct cfg80211_acl_data {
	enum nl80211_acl_policy acl_policy;
	int n_acl_entries;
	struct mac_address mac_addrs[0];
};

struct cfg80211_fils_discovery {
	u32 min_interval;
	u32 max_interval;
	size_t tmpl_len;
	const u8 *tmpl;
};

struct cfg80211_unsol_bcast_probe_resp {
	u32 interval;
	size_t tmpl_len;
	const u8 *tmpl;
};

struct cfg80211_ap_settings {
	struct cfg80211_chan_def chandef;
	struct cfg80211_beacon_data beacon;
	int beacon_interval;
	int dtim_period;
	const u8 *ssid;
	size_t ssid_len;
	enum nl80211_hidden_ssid hidden_ssid;
	struct cfg80211_crypto_settings crypto;
	bool privacy;
	enum nl80211_auth_type auth_type;
	enum nl80211_smps_mode smps_mode;
	int inactivity_timeout;
	u8 p2p_ctwindow;
	bool p2p_opp_ps;
	const struct cfg80211_acl_data *acl;
	bool pbss;
	struct cfg80211_bitrate_mask beacon_rate;
	const struct ieee80211_ht_cap *ht_cap;
	const struct ieee80211_vht_cap *vht_cap;
	const struct ieee80211_he_cap_elem *he_cap;
	const struct ieee80211_he_operation *he_oper;
	bool ht_required;
	bool vht_required;
	bool he_required;
	bool twt_responder;
	u32 flags;
	struct ieee80211_he_obss_pd he_obss_pd;
	struct cfg80211_he_bss_color he_bss_color;
	struct cfg80211_fils_discovery fils_discovery;
	struct cfg80211_unsol_bcast_probe_resp unsol_bcast_probe_resp;
};

struct cfg80211_csa_settings {
	struct cfg80211_chan_def chandef;
	struct cfg80211_beacon_data beacon_csa;
	const u16 *counter_offsets_beacon;
	const u16 *counter_offsets_presp;
	unsigned int n_counter_offsets_beacon;
	unsigned int n_counter_offsets_presp;
	struct cfg80211_beacon_data beacon_after;
	bool radar_required;
	bool block_tx;
	u8 count;
};

struct sta_txpwr {
	s16 power;
	enum nl80211_tx_power_setting type;
};

struct station_parameters {
	const u8 *supported_rates;
	struct net_device *vlan;
	u32 sta_flags_mask;
	u32 sta_flags_set;
	u32 sta_modify_mask;
	int listen_interval;
	u16 aid;
	u16 vlan_id;
	u16 peer_aid;
	u8 supported_rates_len;
	u8 plink_action;
	u8 plink_state;
	const struct ieee80211_ht_cap *ht_capa;
	const struct ieee80211_vht_cap *vht_capa;
	u8 uapsd_queues;
	u8 max_sp;
	enum nl80211_mesh_power_mode local_pm;
	u16 capability;
	const u8 *ext_capab;
	u8 ext_capab_len;
	const u8 *supported_channels;
	u8 supported_channels_len;
	const u8 *supported_oper_classes;
	u8 supported_oper_classes_len;
	u8 opmode_notif;
	bool opmode_notif_used;
	int support_p2p_ps;
	const struct ieee80211_he_cap_elem *he_capa;
	u8 he_capa_len;
	u16 airtime_weight;
	struct sta_txpwr txpwr;
	const struct ieee80211_he_6ghz_capa *he_6ghz_capa;
};

struct station_del_parameters {
	const u8 *mac;
	u8 subtype;
	u16 reason_code;
};

struct rate_info {
	u8 flags;
	u8 mcs;
	u16 legacy;
	u8 nss;
	u8 bw;
	u8 he_gi;
	u8 he_dcm;
	u8 he_ru_alloc;
	u8 n_bonded_ch;
};

struct sta_bss_parameters {
	u8 flags;
	u8 dtim_period;
	u16 beacon_interval;
};

struct cfg80211_txq_stats {
	u32 filled;
	u32 backlog_bytes;
	u32 backlog_packets;
	u32 flows;
	u32 drops;
	u32 ecn_marks;
	u32 overlimit;
	u32 overmemory;
	u32 collisions;
	u32 tx_bytes;
	u32 tx_packets;
	u32 max_flows;
};

struct cfg80211_tid_stats {
	u32 filled;
	u64 rx_msdu;
	u64 tx_msdu;
	u64 tx_msdu_retries;
	u64 tx_msdu_failed;
	struct cfg80211_txq_stats txq_stats;
};

struct station_info {
	u64 filled;
	u32 connected_time;
	u32 inactive_time;
	u64 assoc_at;
	u64 rx_bytes;
	u64 tx_bytes;
	u16 llid;
	u16 plid;
	u8 plink_state;
	s8 signal;
	s8 signal_avg;
	u8 chains;
	s8 chain_signal[4];
	s8 chain_signal_avg[4];
	struct rate_info txrate;
	struct rate_info rxrate;
	u32 rx_packets;
	u32 tx_packets;
	u32 tx_retries;
	u32 tx_failed;
	u32 rx_dropped_misc;
	struct sta_bss_parameters bss_param;
	struct nl80211_sta_flag_update sta_flags;
	int generation;
	const u8 *assoc_req_ies;
	size_t assoc_req_ies_len;
	u32 beacon_loss_count;
	s64 t_offset;
	enum nl80211_mesh_power_mode local_pm;
	enum nl80211_mesh_power_mode peer_pm;
	enum nl80211_mesh_power_mode nonpeer_pm;
	u32 expected_throughput;
	u64 tx_duration;
	u64 rx_duration;
	u64 rx_beacon;
	u8 rx_beacon_signal_avg;
	u8 connected_to_gate;
	struct cfg80211_tid_stats *pertid;
	s8 ack_signal;
	s8 avg_ack_signal;
	u16 airtime_weight;
	u32 rx_mpdu_count;
	u32 fcs_err_count;
	u32 airtime_link_metric;
	u8 connected_to_as;
};

struct mpath_info {
	u32 filled;
	u32 frame_qlen;
	u32 sn;
	u32 metric;
	u32 exptime;
	u32 discovery_timeout;
	u8 discovery_retries;
	u8 flags;
	u8 hop_count;
	u32 path_change_count;
	int generation;
};

struct bss_parameters {
	int use_cts_prot;
	int use_short_preamble;
	int use_short_slot_time;
	const u8 *basic_rates;
	u8 basic_rates_len;
	int ap_isolate;
	int ht_opmode;
	s8 p2p_ctwindow;
	s8 p2p_opp_ps;
};

struct mesh_config {
	u16 dot11MeshRetryTimeout;
	u16 dot11MeshConfirmTimeout;
	u16 dot11MeshHoldingTimeout;
	u16 dot11MeshMaxPeerLinks;
	u8 dot11MeshMaxRetries;
	u8 dot11MeshTTL;
	u8 element_ttl;
	bool auto_open_plinks;
	u32 dot11MeshNbrOffsetMaxNeighbor;
	u8 dot11MeshHWMPmaxPREQretries;
	u32 path_refresh_time;
	u16 min_discovery_timeout;
	u32 dot11MeshHWMPactivePathTimeout;
	u16 dot11MeshHWMPpreqMinInterval;
	u16 dot11MeshHWMPperrMinInterval;
	u16 dot11MeshHWMPnetDiameterTraversalTime;
	u8 dot11MeshHWMPRootMode;
	bool dot11MeshConnectedToMeshGate;
	bool dot11MeshConnectedToAuthServer;
	u16 dot11MeshHWMPRannInterval;
	bool dot11MeshGateAnnouncementProtocol;
	bool dot11MeshForwarding;
	s32 rssi_threshold;
	u16 ht_opmode;
	u32 dot11MeshHWMPactivePathToRootTimeout;
	u16 dot11MeshHWMProotInterval;
	u16 dot11MeshHWMPconfirmationInterval;
	enum nl80211_mesh_power_mode power_mode;
	u16 dot11MeshAwakeWindowDuration;
	u32 plink_timeout;
	bool dot11MeshNolearn;
};

struct mesh_setup {
	struct cfg80211_chan_def chandef;
	const u8 *mesh_id;
	u8 mesh_id_len;
	u8 sync_method;
	u8 path_sel_proto;
	u8 path_metric;
	u8 auth_id;
	const u8 *ie;
	u8 ie_len;
	bool is_authenticated;
	bool is_secure;
	bool user_mpm;
	u8 dtim_period;
	u16 beacon_interval;
	int mcast_rate[5];
	u32 basic_rates;
	struct cfg80211_bitrate_mask beacon_rate;
	bool userspace_handles_dfs;
	bool control_port_over_nl80211;
};

struct ocb_setup {
	struct cfg80211_chan_def chandef;
};

struct ieee80211_txq_params {
	enum nl80211_ac ac;
	u16 txop;
	u16 cwmin;
	u16 cwmax;
	u8 aifs;
};

struct cfg80211_inform_bss {
	struct ieee80211_channel *chan;
	enum nl80211_bss_scan_width scan_width;
	s32 signal;
	u64 boottime_ns;
	u64 parent_tsf;
	u8 parent_bssid[6];
	u8 chains;
	s8 chain_signal[4];
};

struct cfg80211_bss_ies {
	u64 tsf;
	struct callback_head callback_head;
	int len;
	bool from_beacon;
	u8 data[0];
};

struct cfg80211_bss {
	struct ieee80211_channel *channel;
	enum nl80211_bss_scan_width scan_width;
	const struct cfg80211_bss_ies *ies;
	const struct cfg80211_bss_ies *beacon_ies;
	const struct cfg80211_bss_ies *proberesp_ies;
	struct cfg80211_bss *hidden_beacon_bss;
	struct cfg80211_bss *transmitted_bss;
	struct list_head nontrans_list;
	s32 signal;
	u16 beacon_interval;
	u16 capability;
	u8 bssid[6];
	u8 chains;
	s8 chain_signal[4];
	u8 bssid_index;
	u8 max_bssid_indicator;
	int: 24;
	u8 priv[0];
};

struct cfg80211_auth_request {
	struct cfg80211_bss *bss;
	const u8 *ie;
	size_t ie_len;
	enum nl80211_auth_type auth_type;
	const u8 *key;
	u8 key_len;
	u8 key_idx;
	const u8 *auth_data;
	size_t auth_data_len;
};

struct cfg80211_assoc_request {
	struct cfg80211_bss *bss;
	const u8 *ie;
	const u8 *prev_bssid;
	size_t ie_len;
	struct cfg80211_crypto_settings crypto;
	bool use_mfp;
	int: 24;
	u32 flags;
	struct ieee80211_ht_cap ht_capa;
	struct ieee80211_ht_cap ht_capa_mask;
	struct ieee80211_vht_cap vht_capa;
	struct ieee80211_vht_cap vht_capa_mask;
	int: 32;
	const u8 *fils_kek;
	size_t fils_kek_len;
	const u8 *fils_nonces;
	struct ieee80211_s1g_cap s1g_capa;
	struct ieee80211_s1g_cap s1g_capa_mask;
	short: 16;
} __attribute__((packed));

struct cfg80211_deauth_request {
	const u8 *bssid;
	const u8 *ie;
	size_t ie_len;
	u16 reason_code;
	bool local_state_change;
};

struct cfg80211_disassoc_request {
	struct cfg80211_bss *bss;
	const u8 *ie;
	size_t ie_len;
	u16 reason_code;
	bool local_state_change;
};

struct cfg80211_ibss_params {
	const u8 *ssid;
	const u8 *bssid;
	struct cfg80211_chan_def chandef;
	const u8 *ie;
	u8 ssid_len;
	u8 ie_len;
	u16 beacon_interval;
	u32 basic_rates;
	bool channel_fixed;
	bool privacy;
	bool control_port;
	bool control_port_over_nl80211;
	bool userspace_handles_dfs;
	int: 24;
	int mcast_rate[5];
	struct ieee80211_ht_cap ht_capa;
	struct ieee80211_ht_cap ht_capa_mask;
	struct key_params *wep_keys;
	int wep_tx_key;
	int: 32;
} __attribute__((packed));

struct cfg80211_pmksa {
	const u8 *bssid;
	const u8 *pmkid;
	const u8 *pmk;
	size_t pmk_len;
	const u8 *ssid;
	size_t ssid_len;
	const u8 *cache_id;
	u32 pmk_lifetime;
	u8 pmk_reauth_threshold;
};

struct cfg80211_coalesce_rules {
	int delay;
	enum nl80211_coalesce_condition condition;
	struct cfg80211_pkt_pattern *patterns;
	int n_patterns;
};

struct cfg80211_coalesce {
	struct cfg80211_coalesce_rules *rules;
	int n_rules;
};

struct cfg80211_gtk_rekey_data {
	const u8 *kek;
	const u8 *kck;
	const u8 *replay_ctr;
	u32 akm;
	u8 kek_len;
	u8 kck_len;
};

struct cfg80211_update_ft_ies_params {
	u16 md;
	const u8 *ie;
	size_t ie_len;
};

struct cfg80211_mgmt_tx_params {
	struct ieee80211_channel *chan;
	bool offchan;
	unsigned int wait;
	const u8 *buf;
	size_t len;
	bool no_cck;
	bool dont_wait_for_ack;
	int n_csa_offsets;
	const u16 *csa_offsets;
};

struct cfg80211_dscp_exception {
	u8 dscp;
	u8 up;
};

struct cfg80211_dscp_range {
	u8 low;
	u8 high;
};

struct cfg80211_qos_map {
	u8 num_des;
	struct cfg80211_dscp_exception dscp_exception[21];
	struct cfg80211_dscp_range up[8];
};

struct cfg80211_nan_conf {
	u8 master_pref;
	u8 bands;
};

struct cfg80211_nan_func_filter {
	const u8 *filter;
	u8 len;
};

struct cfg80211_nan_func {
	enum nl80211_nan_function_type type;
	u8 service_id[6];
	u8 publish_type;
	bool close_range;
	bool publish_bcast;
	bool subscribe_active;
	u8 followup_id;
	u8 followup_reqid;
	struct mac_address followup_dest;
	u32 ttl;
	const u8 *serv_spec_info;
	u8 serv_spec_info_len;
	bool srf_include;
	const u8 *srf_bf;
	u8 srf_bf_len;
	u8 srf_bf_idx;
	struct mac_address *srf_macs;
	int srf_num_macs;
	struct cfg80211_nan_func_filter *rx_filters;
	struct cfg80211_nan_func_filter *tx_filters;
	u8 num_tx_filters;
	u8 num_rx_filters;
	u8 instance_id;
	u64 cookie;
};

struct cfg80211_pmk_conf {
	const u8 *aa;
	u8 pmk_len;
	const u8 *pmk;
	const u8 *pmk_r0_name;
};

struct cfg80211_external_auth_params {
	enum nl80211_external_auth_action action;
	u8 bssid[6];
	struct cfg80211_ssid ssid;
	unsigned int key_mgmt_suite;
	u16 status;
	const u8 *pmkid;
};

struct cfg80211_ftm_responder_stats {
	u32 filled;
	u32 success_num;
	u32 partial_num;
	u32 failed_num;
	u32 asap_num;
	u32 non_asap_num;
	u64 total_duration_ms;
	u32 unknown_triggers_num;
	u32 reschedule_requests_num;
	u32 out_of_window_triggers_num;
};

struct cfg80211_pmsr_ftm_request_peer {
	enum nl80211_preamble preamble;
	u16 burst_period;
	u8 requested: 1;
	u8 asap: 1;
	u8 request_lci: 1;
	u8 request_civicloc: 1;
	u8 trigger_based: 1;
	u8 non_trigger_based: 1;
	u8 num_bursts_exp;
	u8 burst_duration;
	u8 ftms_per_burst;
	u8 ftmr_retries;
};

struct cfg80211_pmsr_request_peer {
	u8 addr[6];
	struct cfg80211_chan_def chandef;
	u8 report_ap_tsf: 1;
	struct cfg80211_pmsr_ftm_request_peer ftm;
};

struct cfg80211_pmsr_request {
	u64 cookie;
	void *drv_data;
	u32 n_peers;
	u32 nl_portid;
	u32 timeout;
	u8 mac_addr[6];
	u8 mac_addr_mask[6];
	struct list_head list;
	struct cfg80211_pmsr_request_peer peers[0];
};

struct cfg80211_update_owe_info {
	u8 peer[6];
	u16 status;
	const u8 *ie;
	size_t ie_len;
};

struct mgmt_frame_regs {
	u32 global_stypes;
	u32 interface_stypes;
	u32 global_mcast_stypes;
	u32 interface_mcast_stypes;
};

struct cfg80211_ops {
	int (*suspend)(struct wiphy *, struct cfg80211_wowlan *);
	int (*resume)(struct wiphy *);
	void (*set_wakeup)(struct wiphy *, bool);
	struct wireless_dev * (*add_virtual_intf)(struct wiphy *, const char *, unsigned char, enum nl80211_iftype, struct vif_params *);
	int (*del_virtual_intf)(struct wiphy *, struct wireless_dev *);
	int (*change_virtual_intf)(struct wiphy *, struct net_device *, enum nl80211_iftype, struct vif_params *);
	int (*add_key)(struct wiphy *, struct net_device *, u8, bool, const u8 *, struct key_params *);
	int (*get_key)(struct wiphy *, struct net_device *, u8, bool, const u8 *, void *, void (*)(void *, struct key_params *));
	int (*del_key)(struct wiphy *, struct net_device *, u8, bool, const u8 *);
	int (*set_default_key)(struct wiphy *, struct net_device *, u8, bool, bool);
	int (*set_default_mgmt_key)(struct wiphy *, struct net_device *, u8);
	int (*set_default_beacon_key)(struct wiphy *, struct net_device *, u8);
	int (*start_ap)(struct wiphy *, struct net_device *, struct cfg80211_ap_settings *);
	int (*change_beacon)(struct wiphy *, struct net_device *, struct cfg80211_beacon_data *);
	int (*stop_ap)(struct wiphy *, struct net_device *);
	int (*add_station)(struct wiphy *, struct net_device *, const u8 *, struct station_parameters *);
	int (*del_station)(struct wiphy *, struct net_device *, struct station_del_parameters *);
	int (*change_station)(struct wiphy *, struct net_device *, const u8 *, struct station_parameters *);
	int (*get_station)(struct wiphy *, struct net_device *, const u8 *, struct station_info *);
	int (*dump_station)(struct wiphy *, struct net_device *, int, u8 *, struct station_info *);
	int (*add_mpath)(struct wiphy *, struct net_device *, const u8 *, const u8 *);
	int (*del_mpath)(struct wiphy *, struct net_device *, const u8 *);
	int (*change_mpath)(struct wiphy *, struct net_device *, const u8 *, const u8 *);
	int (*get_mpath)(struct wiphy *, struct net_device *, u8 *, u8 *, struct mpath_info *);
	int (*dump_mpath)(struct wiphy *, struct net_device *, int, u8 *, u8 *, struct mpath_info *);
	int (*get_mpp)(struct wiphy *, struct net_device *, u8 *, u8 *, struct mpath_info *);
	int (*dump_mpp)(struct wiphy *, struct net_device *, int, u8 *, u8 *, struct mpath_info *);
	int (*get_mesh_config)(struct wiphy *, struct net_device *, struct mesh_config *);
	int (*update_mesh_config)(struct wiphy *, struct net_device *, u32, const struct mesh_config *);
	int (*join_mesh)(struct wiphy *, struct net_device *, const struct mesh_config *, const struct mesh_setup *);
	int (*leave_mesh)(struct wiphy *, struct net_device *);
	int (*join_ocb)(struct wiphy *, struct net_device *, struct ocb_setup *);
	int (*leave_ocb)(struct wiphy *, struct net_device *);
	int (*change_bss)(struct wiphy *, struct net_device *, struct bss_parameters *);
	int (*set_txq_params)(struct wiphy *, struct net_device *, struct ieee80211_txq_params *);
	int (*libertas_set_mesh_channel)(struct wiphy *, struct net_device *, struct ieee80211_channel *);
	int (*set_monitor_channel)(struct wiphy *, struct cfg80211_chan_def *);
	int (*scan)(struct wiphy *, struct cfg80211_scan_request *);
	void (*abort_scan)(struct wiphy *, struct wireless_dev *);
	int (*auth)(struct wiphy *, struct net_device *, struct cfg80211_auth_request *);
	int (*assoc)(struct wiphy *, struct net_device *, struct cfg80211_assoc_request *);
	int (*deauth)(struct wiphy *, struct net_device *, struct cfg80211_deauth_request *);
	int (*disassoc)(struct wiphy *, struct net_device *, struct cfg80211_disassoc_request *);
	int (*connect)(struct wiphy *, struct net_device *, struct cfg80211_connect_params *);
	int (*update_connect_params)(struct wiphy *, struct net_device *, struct cfg80211_connect_params *, u32);
	int (*disconnect)(struct wiphy *, struct net_device *, u16);
	int (*join_ibss)(struct wiphy *, struct net_device *, struct cfg80211_ibss_params *);
	int (*leave_ibss)(struct wiphy *, struct net_device *);
	int (*set_mcast_rate)(struct wiphy *, struct net_device *, int *);
	int (*set_wiphy_params)(struct wiphy *, u32);
	int (*set_tx_power)(struct wiphy *, struct wireless_dev *, enum nl80211_tx_power_setting, int);
	int (*get_tx_power)(struct wiphy *, struct wireless_dev *, int *);
	int (*set_wds_peer)(struct wiphy *, struct net_device *, const u8 *);
	void (*rfkill_poll)(struct wiphy *);
	int (*set_bitrate_mask)(struct wiphy *, struct net_device *, const u8 *, const struct cfg80211_bitrate_mask *);
	int (*dump_survey)(struct wiphy *, struct net_device *, int, struct survey_info *);
	int (*set_pmksa)(struct wiphy *, struct net_device *, struct cfg80211_pmksa *);
	int (*del_pmksa)(struct wiphy *, struct net_device *, struct cfg80211_pmksa *);
	int (*flush_pmksa)(struct wiphy *, struct net_device *);
	int (*remain_on_channel)(struct wiphy *, struct wireless_dev *, struct ieee80211_channel *, unsigned int, u64 *);
	int (*cancel_remain_on_channel)(struct wiphy *, struct wireless_dev *, u64);
	int (*mgmt_tx)(struct wiphy *, struct wireless_dev *, struct cfg80211_mgmt_tx_params *, u64 *);
	int (*mgmt_tx_cancel_wait)(struct wiphy *, struct wireless_dev *, u64);
	int (*set_power_mgmt)(struct wiphy *, struct net_device *, bool, int);
	int (*set_cqm_rssi_config)(struct wiphy *, struct net_device *, s32, u32);
	int (*set_cqm_rssi_range_config)(struct wiphy *, struct net_device *, s32, s32);
	int (*set_cqm_txe_config)(struct wiphy *, struct net_device *, u32, u32, u32);
	void (*update_mgmt_frame_registrations)(struct wiphy *, struct wireless_dev *, struct mgmt_frame_regs *);
	int (*set_antenna)(struct wiphy *, u32, u32);
	int (*get_antenna)(struct wiphy *, u32 *, u32 *);
	int (*sched_scan_start)(struct wiphy *, struct net_device *, struct cfg80211_sched_scan_request *);
	int (*sched_scan_stop)(struct wiphy *, struct net_device *, u64);
	int (*set_rekey_data)(struct wiphy *, struct net_device *, struct cfg80211_gtk_rekey_data *);
	int (*tdls_mgmt)(struct wiphy *, struct net_device *, const u8 *, u8, u8, u16, u32, bool, const u8 *, size_t);
	int (*tdls_oper)(struct wiphy *, struct net_device *, const u8 *, enum nl80211_tdls_operation);
	int (*probe_client)(struct wiphy *, struct net_device *, const u8 *, u64 *);
	int (*set_noack_map)(struct wiphy *, struct net_device *, u16);
	int (*get_channel)(struct wiphy *, struct wireless_dev *, struct cfg80211_chan_def *);
	int (*start_p2p_device)(struct wiphy *, struct wireless_dev *);
	void (*stop_p2p_device)(struct wiphy *, struct wireless_dev *);
	int (*set_mac_acl)(struct wiphy *, struct net_device *, const struct cfg80211_acl_data *);
	int (*start_radar_detection)(struct wiphy *, struct net_device *, struct cfg80211_chan_def *, u32);
	void (*end_cac)(struct wiphy *, struct net_device *);
	int (*update_ft_ies)(struct wiphy *, struct net_device *, struct cfg80211_update_ft_ies_params *);
	int (*crit_proto_start)(struct wiphy *, struct wireless_dev *, enum nl80211_crit_proto_id, u16);
	void (*crit_proto_stop)(struct wiphy *, struct wireless_dev *);
	int (*set_coalesce)(struct wiphy *, struct cfg80211_coalesce *);
	int (*channel_switch)(struct wiphy *, struct net_device *, struct cfg80211_csa_settings *);
	int (*set_qos_map)(struct wiphy *, struct net_device *, struct cfg80211_qos_map *);
	int (*set_ap_chanwidth)(struct wiphy *, struct net_device *, struct cfg80211_chan_def *);
	int (*add_tx_ts)(struct wiphy *, struct net_device *, u8, const u8 *, u8, u16);
	int (*del_tx_ts)(struct wiphy *, struct net_device *, u8, const u8 *);
	int (*tdls_channel_switch)(struct wiphy *, struct net_device *, const u8 *, u8, struct cfg80211_chan_def *);
	void (*tdls_cancel_channel_switch)(struct wiphy *, struct net_device *, const u8 *);
	int (*start_nan)(struct wiphy *, struct wireless_dev *, struct cfg80211_nan_conf *);
	void (*stop_nan)(struct wiphy *, struct wireless_dev *);
	int (*add_nan_func)(struct wiphy *, struct wireless_dev *, struct cfg80211_nan_func *);
	void (*del_nan_func)(struct wiphy *, struct wireless_dev *, u64);
	int (*nan_change_conf)(struct wiphy *, struct wireless_dev *, struct cfg80211_nan_conf *, u32);
	int (*set_multicast_to_unicast)(struct wiphy *, struct net_device *, const bool);
	int (*get_txq_stats)(struct wiphy *, struct wireless_dev *, struct cfg80211_txq_stats *);
	int (*set_pmk)(struct wiphy *, struct net_device *, const struct cfg80211_pmk_conf *);
	int (*del_pmk)(struct wiphy *, struct net_device *, const u8 *);
	int (*external_auth)(struct wiphy *, struct net_device *, struct cfg80211_external_auth_params *);
	int (*tx_control_port)(struct wiphy *, struct net_device *, const u8 *, size_t, const u8 *, const __be16, const bool, u64 *);
	int (*get_ftm_responder_stats)(struct wiphy *, struct net_device *, struct cfg80211_ftm_responder_stats *);
	int (*start_pmsr)(struct wiphy *, struct wireless_dev *, struct cfg80211_pmsr_request *);
	void (*abort_pmsr)(struct wiphy *, struct wireless_dev *, struct cfg80211_pmsr_request *);
	int (*update_owe_info)(struct wiphy *, struct net_device *, struct cfg80211_update_owe_info *);
	int (*probe_mesh_link)(struct wiphy *, struct net_device *, const u8 *, size_t);
	int (*set_tid_config)(struct wiphy *, struct net_device *, struct cfg80211_tid_config *);
	int (*reset_tid_config)(struct wiphy *, struct net_device *, const u8 *, u8);
};

enum wiphy_flags {
	WIPHY_FLAG_SUPPORTS_EXT_KEK_KCK = 1,
	WIPHY_FLAG_SPLIT_SCAN_6GHZ = 4,
	WIPHY_FLAG_NETNS_OK = 8,
	WIPHY_FLAG_PS_ON_BY_DEFAULT = 16,
	WIPHY_FLAG_4ADDR_AP = 32,
	WIPHY_FLAG_4ADDR_STATION = 64,
	WIPHY_FLAG_CONTROL_PORT_PROTOCOL = 128,
	WIPHY_FLAG_IBSS_RSN = 256,
	WIPHY_FLAG_MESH_AUTH = 1024,
	WIPHY_FLAG_SUPPORTS_FW_ROAM = 8192,
	WIPHY_FLAG_AP_UAPSD = 16384,
	WIPHY_FLAG_SUPPORTS_TDLS = 32768,
	WIPHY_FLAG_TDLS_EXTERNAL_SETUP = 65536,
	WIPHY_FLAG_HAVE_AP_SME = 131072,
	WIPHY_FLAG_REPORTS_OBSS = 262144,
	WIPHY_FLAG_AP_PROBE_RESP_OFFLOAD = 524288,
	WIPHY_FLAG_OFFCHAN_TX = 1048576,
	WIPHY_FLAG_HAS_REMAIN_ON_CHANNEL = 2097152,
	WIPHY_FLAG_SUPPORTS_5_10_MHZ = 4194304,
	WIPHY_FLAG_HAS_CHANNEL_SWITCH = 8388608,
	WIPHY_FLAG_HAS_STATIC_WEP = 16777216,
};

enum wiphy_wowlan_support_flags {
	WIPHY_WOWLAN_ANY = 1,
	WIPHY_WOWLAN_MAGIC_PKT = 2,
	WIPHY_WOWLAN_DISCONNECT = 4,
	WIPHY_WOWLAN_SUPPORTS_GTK_REKEY = 8,
	WIPHY_WOWLAN_GTK_REKEY_FAILURE = 16,
	WIPHY_WOWLAN_EAP_IDENTITY_REQ = 32,
	WIPHY_WOWLAN_4WAY_HANDSHAKE = 64,
	WIPHY_WOWLAN_RFKILL_RELEASE = 128,
	WIPHY_WOWLAN_NET_DETECT = 256,
};

struct cfg80211_fils_resp_params {
	const u8 *kek;
	size_t kek_len;
	bool update_erp_next_seq_num;
	u16 erp_next_seq_num;
	const u8 *pmk;
	size_t pmk_len;
	const u8 *pmkid;
};

struct cfg80211_connect_resp_params {
	int status;
	const u8 *bssid;
	struct cfg80211_bss *bss;
	const u8 *req_ie;
	size_t req_ie_len;
	const u8 *resp_ie;
	size_t resp_ie_len;
	struct cfg80211_fils_resp_params fils;
	enum nl80211_timeout_reason timeout_reason;
};

struct cfg80211_roam_info {
	struct ieee80211_channel *channel;
	struct cfg80211_bss *bss;
	const u8 *bssid;
	const u8 *req_ie;
	size_t req_ie_len;
	const u8 *resp_ie;
	size_t resp_ie_len;
	struct cfg80211_fils_resp_params fils;
};

struct rtw_wiphy_data {
	struct dvobj_priv *dvobj;
	s16 txpwr_total_lmt_mbm;
	s16 txpwr_total_target_mbm;
};

enum nl80211_commands {
	NL80211_CMD_UNSPEC = 0,
	NL80211_CMD_GET_WIPHY = 1,
	NL80211_CMD_SET_WIPHY = 2,
	NL80211_CMD_NEW_WIPHY = 3,
	NL80211_CMD_DEL_WIPHY = 4,
	NL80211_CMD_GET_INTERFACE = 5,
	NL80211_CMD_SET_INTERFACE = 6,
	NL80211_CMD_NEW_INTERFACE = 7,
	NL80211_CMD_DEL_INTERFACE = 8,
	NL80211_CMD_GET_KEY = 9,
	NL80211_CMD_SET_KEY = 10,
	NL80211_CMD_NEW_KEY = 11,
	NL80211_CMD_DEL_KEY = 12,
	NL80211_CMD_GET_BEACON = 13,
	NL80211_CMD_SET_BEACON = 14,
	NL80211_CMD_START_AP = 15,
	NL80211_CMD_NEW_BEACON = 15,
	NL80211_CMD_STOP_AP = 16,
	NL80211_CMD_DEL_BEACON = 16,
	NL80211_CMD_GET_STATION = 17,
	NL80211_CMD_SET_STATION = 18,
	NL80211_CMD_NEW_STATION = 19,
	NL80211_CMD_DEL_STATION = 20,
	NL80211_CMD_GET_MPATH = 21,
	NL80211_CMD_SET_MPATH = 22,
	NL80211_CMD_NEW_MPATH = 23,
	NL80211_CMD_DEL_MPATH = 24,
	NL80211_CMD_SET_BSS = 25,
	NL80211_CMD_SET_REG = 26,
	NL80211_CMD_REQ_SET_REG = 27,
	NL80211_CMD_GET_MESH_CONFIG = 28,
	NL80211_CMD_SET_MESH_CONFIG = 29,
	NL80211_CMD_SET_MGMT_EXTRA_IE = 30,
	NL80211_CMD_GET_REG = 31,
	NL80211_CMD_GET_SCAN = 32,
	NL80211_CMD_TRIGGER_SCAN = 33,
	NL80211_CMD_NEW_SCAN_RESULTS = 34,
	NL80211_CMD_SCAN_ABORTED = 35,
	NL80211_CMD_REG_CHANGE = 36,
	NL80211_CMD_AUTHENTICATE = 37,
	NL80211_CMD_ASSOCIATE = 38,
	NL80211_CMD_DEAUTHENTICATE = 39,
	NL80211_CMD_DISASSOCIATE = 40,
	NL80211_CMD_MICHAEL_MIC_FAILURE = 41,
	NL80211_CMD_REG_BEACON_HINT = 42,
	NL80211_CMD_JOIN_IBSS = 43,
	NL80211_CMD_LEAVE_IBSS = 44,
	NL80211_CMD_TESTMODE = 45,
	NL80211_CMD_CONNECT = 46,
	NL80211_CMD_ROAM = 47,
	NL80211_CMD_DISCONNECT = 48,
	NL80211_CMD_SET_WIPHY_NETNS = 49,
	NL80211_CMD_GET_SURVEY = 50,
	NL80211_CMD_NEW_SURVEY_RESULTS = 51,
	NL80211_CMD_SET_PMKSA = 52,
	NL80211_CMD_DEL_PMKSA = 53,
	NL80211_CMD_FLUSH_PMKSA = 54,
	NL80211_CMD_REMAIN_ON_CHANNEL = 55,
	NL80211_CMD_CANCEL_REMAIN_ON_CHANNEL = 56,
	NL80211_CMD_SET_TX_BITRATE_MASK = 57,
	NL80211_CMD_REGISTER_FRAME = 58,
	NL80211_CMD_REGISTER_ACTION = 58,
	NL80211_CMD_FRAME = 59,
	NL80211_CMD_ACTION = 59,
	NL80211_CMD_FRAME_TX_STATUS = 60,
	NL80211_CMD_ACTION_TX_STATUS = 60,
	NL80211_CMD_SET_POWER_SAVE = 61,
	NL80211_CMD_GET_POWER_SAVE = 62,
	NL80211_CMD_SET_CQM = 63,
	NL80211_CMD_NOTIFY_CQM = 64,
	NL80211_CMD_SET_CHANNEL = 65,
	NL80211_CMD_SET_WDS_PEER = 66,
	NL80211_CMD_FRAME_WAIT_CANCEL = 67,
	NL80211_CMD_JOIN_MESH = 68,
	NL80211_CMD_LEAVE_MESH = 69,
	NL80211_CMD_UNPROT_DEAUTHENTICATE = 70,
	NL80211_CMD_UNPROT_DISASSOCIATE = 71,
	NL80211_CMD_NEW_PEER_CANDIDATE = 72,
	NL80211_CMD_GET_WOWLAN = 73,
	NL80211_CMD_SET_WOWLAN = 74,
	NL80211_CMD_START_SCHED_SCAN = 75,
	NL80211_CMD_STOP_SCHED_SCAN = 76,
	NL80211_CMD_SCHED_SCAN_RESULTS = 77,
	NL80211_CMD_SCHED_SCAN_STOPPED = 78,
	NL80211_CMD_SET_REKEY_OFFLOAD = 79,
	NL80211_CMD_PMKSA_CANDIDATE = 80,
	NL80211_CMD_TDLS_OPER = 81,
	NL80211_CMD_TDLS_MGMT = 82,
	NL80211_CMD_UNEXPECTED_FRAME = 83,
	NL80211_CMD_PROBE_CLIENT = 84,
	NL80211_CMD_REGISTER_BEACONS = 85,
	NL80211_CMD_UNEXPECTED_4ADDR_FRAME = 86,
	NL80211_CMD_SET_NOACK_MAP = 87,
	NL80211_CMD_CH_SWITCH_NOTIFY = 88,
	NL80211_CMD_START_P2P_DEVICE = 89,
	NL80211_CMD_STOP_P2P_DEVICE = 90,
	NL80211_CMD_CONN_FAILED = 91,
	NL80211_CMD_SET_MCAST_RATE = 92,
	NL80211_CMD_SET_MAC_ACL = 93,
	NL80211_CMD_RADAR_DETECT = 94,
	NL80211_CMD_GET_PROTOCOL_FEATURES = 95,
	NL80211_CMD_UPDATE_FT_IES = 96,
	NL80211_CMD_FT_EVENT = 97,
	NL80211_CMD_CRIT_PROTOCOL_START = 98,
	NL80211_CMD_CRIT_PROTOCOL_STOP = 99,
	NL80211_CMD_GET_COALESCE = 100,
	NL80211_CMD_SET_COALESCE = 101,
	NL80211_CMD_CHANNEL_SWITCH = 102,
	NL80211_CMD_VENDOR = 103,
	NL80211_CMD_SET_QOS_MAP = 104,
	NL80211_CMD_ADD_TX_TS = 105,
	NL80211_CMD_DEL_TX_TS = 106,
	NL80211_CMD_GET_MPP = 107,
	NL80211_CMD_JOIN_OCB = 108,
	NL80211_CMD_LEAVE_OCB = 109,
	NL80211_CMD_CH_SWITCH_STARTED_NOTIFY = 110,
	NL80211_CMD_TDLS_CHANNEL_SWITCH = 111,
	NL80211_CMD_TDLS_CANCEL_CHANNEL_SWITCH = 112,
	NL80211_CMD_WIPHY_REG_CHANGE = 113,
	NL80211_CMD_ABORT_SCAN = 114,
	NL80211_CMD_START_NAN = 115,
	NL80211_CMD_STOP_NAN = 116,
	NL80211_CMD_ADD_NAN_FUNCTION = 117,
	NL80211_CMD_DEL_NAN_FUNCTION = 118,
	NL80211_CMD_CHANGE_NAN_CONFIG = 119,
	NL80211_CMD_NAN_MATCH = 120,
	NL80211_CMD_SET_MULTICAST_TO_UNICAST = 121,
	NL80211_CMD_UPDATE_CONNECT_PARAMS = 122,
	NL80211_CMD_SET_PMK = 123,
	NL80211_CMD_DEL_PMK = 124,
	NL80211_CMD_PORT_AUTHORIZED = 125,
	NL80211_CMD_RELOAD_REGDB = 126,
	NL80211_CMD_EXTERNAL_AUTH = 127,
	NL80211_CMD_STA_OPMODE_CHANGED = 128,
	NL80211_CMD_CONTROL_PORT_FRAME = 129,
	NL80211_CMD_GET_FTM_RESPONDER_STATS = 130,
	NL80211_CMD_PEER_MEASUREMENT_START = 131,
	NL80211_CMD_PEER_MEASUREMENT_RESULT = 132,
	NL80211_CMD_PEER_MEASUREMENT_COMPLETE = 133,
	NL80211_CMD_NOTIFY_RADAR = 134,
	NL80211_CMD_UPDATE_OWE_INFO = 135,
	NL80211_CMD_PROBE_MESH_LINK = 136,
	NL80211_CMD_SET_TID_CONFIG = 137,
	NL80211_CMD_UNPROT_BEACON = 138,
	NL80211_CMD_CONTROL_PORT_FRAME_TX_STATUS = 139,
	__NL80211_CMD_AFTER_LAST = 140,
	NL80211_CMD_MAX = 139,
};

enum nl80211_attrs {
	NL80211_ATTR_UNSPEC = 0,
	NL80211_ATTR_WIPHY = 1,
	NL80211_ATTR_WIPHY_NAME = 2,
	NL80211_ATTR_IFINDEX = 3,
	NL80211_ATTR_IFNAME = 4,
	NL80211_ATTR_IFTYPE = 5,
	NL80211_ATTR_MAC = 6,
	NL80211_ATTR_KEY_DATA = 7,
	NL80211_ATTR_KEY_IDX = 8,
	NL80211_ATTR_KEY_CIPHER = 9,
	NL80211_ATTR_KEY_SEQ = 10,
	NL80211_ATTR_KEY_DEFAULT = 11,
	NL80211_ATTR_BEACON_INTERVAL = 12,
	NL80211_ATTR_DTIM_PERIOD = 13,
	NL80211_ATTR_BEACON_HEAD = 14,
	NL80211_ATTR_BEACON_TAIL = 15,
	NL80211_ATTR_STA_AID = 16,
	NL80211_ATTR_STA_FLAGS = 17,
	NL80211_ATTR_STA_LISTEN_INTERVAL = 18,
	NL80211_ATTR_STA_SUPPORTED_RATES = 19,
	NL80211_ATTR_STA_VLAN = 20,
	NL80211_ATTR_STA_INFO = 21,
	NL80211_ATTR_WIPHY_BANDS = 22,
	NL80211_ATTR_MNTR_FLAGS = 23,
	NL80211_ATTR_MESH_ID = 24,
	NL80211_ATTR_STA_PLINK_ACTION = 25,
	NL80211_ATTR_MPATH_NEXT_HOP = 26,
	NL80211_ATTR_MPATH_INFO = 27,
	NL80211_ATTR_BSS_CTS_PROT = 28,
	NL80211_ATTR_BSS_SHORT_PREAMBLE = 29,
	NL80211_ATTR_BSS_SHORT_SLOT_TIME = 30,
	NL80211_ATTR_HT_CAPABILITY = 31,
	NL80211_ATTR_SUPPORTED_IFTYPES = 32,
	NL80211_ATTR_REG_ALPHA2 = 33,
	NL80211_ATTR_REG_RULES = 34,
	NL80211_ATTR_MESH_CONFIG = 35,
	NL80211_ATTR_BSS_BASIC_RATES = 36,
	NL80211_ATTR_WIPHY_TXQ_PARAMS = 37,
	NL80211_ATTR_WIPHY_FREQ = 38,
	NL80211_ATTR_WIPHY_CHANNEL_TYPE = 39,
	NL80211_ATTR_KEY_DEFAULT_MGMT = 40,
	NL80211_ATTR_MGMT_SUBTYPE = 41,
	NL80211_ATTR_IE = 42,
	NL80211_ATTR_MAX_NUM_SCAN_SSIDS = 43,
	NL80211_ATTR_SCAN_FREQUENCIES = 44,
	NL80211_ATTR_SCAN_SSIDS = 45,
	NL80211_ATTR_GENERATION = 46,
	NL80211_ATTR_BSS = 47,
	NL80211_ATTR_REG_INITIATOR = 48,
	NL80211_ATTR_REG_TYPE = 49,
	NL80211_ATTR_SUPPORTED_COMMANDS = 50,
	NL80211_ATTR_FRAME = 51,
	NL80211_ATTR_SSID = 52,
	NL80211_ATTR_AUTH_TYPE = 53,
	NL80211_ATTR_REASON_CODE = 54,
	NL80211_ATTR_KEY_TYPE = 55,
	NL80211_ATTR_MAX_SCAN_IE_LEN = 56,
	NL80211_ATTR_CIPHER_SUITES = 57,
	NL80211_ATTR_FREQ_BEFORE = 58,
	NL80211_ATTR_FREQ_AFTER = 59,
	NL80211_ATTR_FREQ_FIXED = 60,
	NL80211_ATTR_WIPHY_RETRY_SHORT = 61,
	NL80211_ATTR_WIPHY_RETRY_LONG = 62,
	NL80211_ATTR_WIPHY_FRAG_THRESHOLD = 63,
	NL80211_ATTR_WIPHY_RTS_THRESHOLD = 64,
	NL80211_ATTR_TIMED_OUT = 65,
	NL80211_ATTR_USE_MFP = 66,
	NL80211_ATTR_STA_FLAGS2 = 67,
	NL80211_ATTR_CONTROL_PORT = 68,
	NL80211_ATTR_TESTDATA = 69,
	NL80211_ATTR_PRIVACY = 70,
	NL80211_ATTR_DISCONNECTED_BY_AP = 71,
	NL80211_ATTR_STATUS_CODE = 72,
	NL80211_ATTR_CIPHER_SUITES_PAIRWISE = 73,
	NL80211_ATTR_CIPHER_SUITE_GROUP = 74,
	NL80211_ATTR_WPA_VERSIONS = 75,
	NL80211_ATTR_AKM_SUITES = 76,
	NL80211_ATTR_REQ_IE = 77,
	NL80211_ATTR_RESP_IE = 78,
	NL80211_ATTR_PREV_BSSID = 79,
	NL80211_ATTR_KEY = 80,
	NL80211_ATTR_KEYS = 81,
	NL80211_ATTR_PID = 82,
	NL80211_ATTR_4ADDR = 83,
	NL80211_ATTR_SURVEY_INFO = 84,
	NL80211_ATTR_PMKID = 85,
	NL80211_ATTR_MAX_NUM_PMKIDS = 86,
	NL80211_ATTR_DURATION = 87,
	NL80211_ATTR_COOKIE = 88,
	NL80211_ATTR_WIPHY_COVERAGE_CLASS = 89,
	NL80211_ATTR_TX_RATES = 90,
	NL80211_ATTR_FRAME_MATCH = 91,
	NL80211_ATTR_ACK = 92,
	NL80211_ATTR_PS_STATE = 93,
	NL80211_ATTR_CQM = 94,
	NL80211_ATTR_LOCAL_STATE_CHANGE = 95,
	NL80211_ATTR_AP_ISOLATE = 96,
	NL80211_ATTR_WIPHY_TX_POWER_SETTING = 97,
	NL80211_ATTR_WIPHY_TX_POWER_LEVEL = 98,
	NL80211_ATTR_TX_FRAME_TYPES = 99,
	NL80211_ATTR_RX_FRAME_TYPES = 100,
	NL80211_ATTR_FRAME_TYPE = 101,
	NL80211_ATTR_CONTROL_PORT_ETHERTYPE = 102,
	NL80211_ATTR_CONTROL_PORT_NO_ENCRYPT = 103,
	NL80211_ATTR_SUPPORT_IBSS_RSN = 104,
	NL80211_ATTR_WIPHY_ANTENNA_TX = 105,
	NL80211_ATTR_WIPHY_ANTENNA_RX = 106,
	NL80211_ATTR_MCAST_RATE = 107,
	NL80211_ATTR_OFFCHANNEL_TX_OK = 108,
	NL80211_ATTR_BSS_HT_OPMODE = 109,
	NL80211_ATTR_KEY_DEFAULT_TYPES = 110,
	NL80211_ATTR_MAX_REMAIN_ON_CHANNEL_DURATION = 111,
	NL80211_ATTR_MESH_SETUP = 112,
	NL80211_ATTR_WIPHY_ANTENNA_AVAIL_TX = 113,
	NL80211_ATTR_WIPHY_ANTENNA_AVAIL_RX = 114,
	NL80211_ATTR_SUPPORT_MESH_AUTH = 115,
	NL80211_ATTR_STA_PLINK_STATE = 116,
	NL80211_ATTR_WOWLAN_TRIGGERS = 117,
	NL80211_ATTR_WOWLAN_TRIGGERS_SUPPORTED = 118,
	NL80211_ATTR_SCHED_SCAN_INTERVAL = 119,
	NL80211_ATTR_INTERFACE_COMBINATIONS = 120,
	NL80211_ATTR_SOFTWARE_IFTYPES = 121,
	NL80211_ATTR_REKEY_DATA = 122,
	NL80211_ATTR_MAX_NUM_SCHED_SCAN_SSIDS = 123,
	NL80211_ATTR_MAX_SCHED_SCAN_IE_LEN = 124,
	NL80211_ATTR_SCAN_SUPP_RATES = 125,
	NL80211_ATTR_HIDDEN_SSID = 126,
	NL80211_ATTR_IE_PROBE_RESP = 127,
	NL80211_ATTR_IE_ASSOC_RESP = 128,
	NL80211_ATTR_STA_WME = 129,
	NL80211_ATTR_SUPPORT_AP_UAPSD = 130,
	NL80211_ATTR_ROAM_SUPPORT = 131,
	NL80211_ATTR_SCHED_SCAN_MATCH = 132,
	NL80211_ATTR_MAX_MATCH_SETS = 133,
	NL80211_ATTR_PMKSA_CANDIDATE = 134,
	NL80211_ATTR_TX_NO_CCK_RATE = 135,
	NL80211_ATTR_TDLS_ACTION = 136,
	NL80211_ATTR_TDLS_DIALOG_TOKEN = 137,
	NL80211_ATTR_TDLS_OPERATION = 138,
	NL80211_ATTR_TDLS_SUPPORT = 139,
	NL80211_ATTR_TDLS_EXTERNAL_SETUP = 140,
	NL80211_ATTR_DEVICE_AP_SME = 141,
	NL80211_ATTR_DONT_WAIT_FOR_ACK = 142,
	NL80211_ATTR_FEATURE_FLAGS = 143,
	NL80211_ATTR_PROBE_RESP_OFFLOAD = 144,
	NL80211_ATTR_PROBE_RESP = 145,
	NL80211_ATTR_DFS_REGION = 146,
	NL80211_ATTR_DISABLE_HT = 147,
	NL80211_ATTR_HT_CAPABILITY_MASK = 148,
	NL80211_ATTR_NOACK_MAP = 149,
	NL80211_ATTR_INACTIVITY_TIMEOUT = 150,
	NL80211_ATTR_RX_SIGNAL_DBM = 151,
	NL80211_ATTR_BG_SCAN_PERIOD = 152,
	NL80211_ATTR_WDEV = 153,
	NL80211_ATTR_USER_REG_HINT_TYPE = 154,
	NL80211_ATTR_CONN_FAILED_REASON = 155,
	NL80211_ATTR_AUTH_DATA = 156,
	NL80211_ATTR_VHT_CAPABILITY = 157,
	NL80211_ATTR_SCAN_FLAGS = 158,
	NL80211_ATTR_CHANNEL_WIDTH = 159,
	NL80211_ATTR_CENTER_FREQ1 = 160,
	NL80211_ATTR_CENTER_FREQ2 = 161,
	NL80211_ATTR_P2P_CTWINDOW = 162,
	NL80211_ATTR_P2P_OPPPS = 163,
	NL80211_ATTR_LOCAL_MESH_POWER_MODE = 164,
	NL80211_ATTR_ACL_POLICY = 165,
	NL80211_ATTR_MAC_ADDRS = 166,
	NL80211_ATTR_MAC_ACL_MAX = 167,
	NL80211_ATTR_RADAR_EVENT = 168,
	NL80211_ATTR_EXT_CAPA = 169,
	NL80211_ATTR_EXT_CAPA_MASK = 170,
	NL80211_ATTR_STA_CAPABILITY = 171,
	NL80211_ATTR_STA_EXT_CAPABILITY = 172,
	NL80211_ATTR_PROTOCOL_FEATURES = 173,
	NL80211_ATTR_SPLIT_WIPHY_DUMP = 174,
	NL80211_ATTR_DISABLE_VHT = 175,
	NL80211_ATTR_VHT_CAPABILITY_MASK = 176,
	NL80211_ATTR_MDID = 177,
	NL80211_ATTR_IE_RIC = 178,
	NL80211_ATTR_CRIT_PROT_ID = 179,
	NL80211_ATTR_MAX_CRIT_PROT_DURATION = 180,
	NL80211_ATTR_PEER_AID = 181,
	NL80211_ATTR_COALESCE_RULE = 182,
	NL80211_ATTR_CH_SWITCH_COUNT = 183,
	NL80211_ATTR_CH_SWITCH_BLOCK_TX = 184,
	NL80211_ATTR_CSA_IES = 185,
	NL80211_ATTR_CNTDWN_OFFS_BEACON = 186,
	NL80211_ATTR_CNTDWN_OFFS_PRESP = 187,
	NL80211_ATTR_RXMGMT_FLAGS = 188,
	NL80211_ATTR_STA_SUPPORTED_CHANNELS = 189,
	NL80211_ATTR_STA_SUPPORTED_OPER_CLASSES = 190,
	NL80211_ATTR_HANDLE_DFS = 191,
	NL80211_ATTR_SUPPORT_5_MHZ = 192,
	NL80211_ATTR_SUPPORT_10_MHZ = 193,
	NL80211_ATTR_OPMODE_NOTIF = 194,
	NL80211_ATTR_VENDOR_ID = 195,
	NL80211_ATTR_VENDOR_SUBCMD = 196,
	NL80211_ATTR_VENDOR_DATA = 197,
	NL80211_ATTR_VENDOR_EVENTS = 198,
	NL80211_ATTR_QOS_MAP = 199,
	NL80211_ATTR_MAC_HINT = 200,
	NL80211_ATTR_WIPHY_FREQ_HINT = 201,
	NL80211_ATTR_MAX_AP_ASSOC_STA = 202,
	NL80211_ATTR_TDLS_PEER_CAPABILITY = 203,
	NL80211_ATTR_SOCKET_OWNER = 204,
	NL80211_ATTR_CSA_C_OFFSETS_TX = 205,
	NL80211_ATTR_MAX_CSA_COUNTERS = 206,
	NL80211_ATTR_TDLS_INITIATOR = 207,
	NL80211_ATTR_USE_RRM = 208,
	NL80211_ATTR_WIPHY_DYN_ACK = 209,
	NL80211_ATTR_TSID = 210,
	NL80211_ATTR_USER_PRIO = 211,
	NL80211_ATTR_ADMITTED_TIME = 212,
	NL80211_ATTR_SMPS_MODE = 213,
	NL80211_ATTR_OPER_CLASS = 214,
	NL80211_ATTR_MAC_MASK = 215,
	NL80211_ATTR_WIPHY_SELF_MANAGED_REG = 216,
	NL80211_ATTR_EXT_FEATURES = 217,
	NL80211_ATTR_SURVEY_RADIO_STATS = 218,
	NL80211_ATTR_NETNS_FD = 219,
	NL80211_ATTR_SCHED_SCAN_DELAY = 220,
	NL80211_ATTR_REG_INDOOR = 221,
	NL80211_ATTR_MAX_NUM_SCHED_SCAN_PLANS = 222,
	NL80211_ATTR_MAX_SCAN_PLAN_INTERVAL = 223,
	NL80211_ATTR_MAX_SCAN_PLAN_ITERATIONS = 224,
	NL80211_ATTR_SCHED_SCAN_PLANS = 225,
	NL80211_ATTR_PBSS = 226,
	NL80211_ATTR_BSS_SELECT = 227,
	NL80211_ATTR_STA_SUPPORT_P2P_PS = 228,
	NL80211_ATTR_PAD = 229,
	NL80211_ATTR_IFTYPE_EXT_CAPA = 230,
	NL80211_ATTR_MU_MIMO_GROUP_DATA = 231,
	NL80211_ATTR_MU_MIMO_FOLLOW_MAC_ADDR = 232,
	NL80211_ATTR_SCAN_START_TIME_TSF = 233,
	NL80211_ATTR_SCAN_START_TIME_TSF_BSSID = 234,
	NL80211_ATTR_MEASUREMENT_DURATION = 235,
	NL80211_ATTR_MEASUREMENT_DURATION_MANDATORY = 236,
	NL80211_ATTR_MESH_PEER_AID = 237,
	NL80211_ATTR_NAN_MASTER_PREF = 238,
	NL80211_ATTR_BANDS = 239,
	NL80211_ATTR_NAN_FUNC = 240,
	NL80211_ATTR_NAN_MATCH = 241,
	NL80211_ATTR_FILS_KEK = 242,
	NL80211_ATTR_FILS_NONCES = 243,
	NL80211_ATTR_MULTICAST_TO_UNICAST_ENABLED = 244,
	NL80211_ATTR_BSSID = 245,
	NL80211_ATTR_SCHED_SCAN_RELATIVE_RSSI = 246,
	NL80211_ATTR_SCHED_SCAN_RSSI_ADJUST = 247,
	NL80211_ATTR_TIMEOUT_REASON = 248,
	NL80211_ATTR_FILS_ERP_USERNAME = 249,
	NL80211_ATTR_FILS_ERP_REALM = 250,
	NL80211_ATTR_FILS_ERP_NEXT_SEQ_NUM = 251,
	NL80211_ATTR_FILS_ERP_RRK = 252,
	NL80211_ATTR_FILS_CACHE_ID = 253,
	NL80211_ATTR_PMK = 254,
	NL80211_ATTR_SCHED_SCAN_MULTI = 255,
	NL80211_ATTR_SCHED_SCAN_MAX_REQS = 256,
	NL80211_ATTR_WANT_1X_4WAY_HS = 257,
	NL80211_ATTR_PMKR0_NAME = 258,
	NL80211_ATTR_PORT_AUTHORIZED = 259,
	NL80211_ATTR_EXTERNAL_AUTH_ACTION = 260,
	NL80211_ATTR_EXTERNAL_AUTH_SUPPORT = 261,
	NL80211_ATTR_NSS = 262,
	NL80211_ATTR_ACK_SIGNAL = 263,
	NL80211_ATTR_CONTROL_PORT_OVER_NL80211 = 264,
	NL80211_ATTR_TXQ_STATS = 265,
	NL80211_ATTR_TXQ_LIMIT = 266,
	NL80211_ATTR_TXQ_MEMORY_LIMIT = 267,
	NL80211_ATTR_TXQ_QUANTUM = 268,
	NL80211_ATTR_HE_CAPABILITY = 269,
	NL80211_ATTR_FTM_RESPONDER = 270,
	NL80211_ATTR_FTM_RESPONDER_STATS = 271,
	NL80211_ATTR_TIMEOUT = 272,
	NL80211_ATTR_PEER_MEASUREMENTS = 273,
	NL80211_ATTR_AIRTIME_WEIGHT = 274,
	NL80211_ATTR_STA_TX_POWER_SETTING = 275,
	NL80211_ATTR_STA_TX_POWER = 276,
	NL80211_ATTR_SAE_PASSWORD = 277,
	NL80211_ATTR_TWT_RESPONDER = 278,
	NL80211_ATTR_HE_OBSS_PD = 279,
	NL80211_ATTR_WIPHY_EDMG_CHANNELS = 280,
	NL80211_ATTR_WIPHY_EDMG_BW_CONFIG = 281,
	NL80211_ATTR_VLAN_ID = 282,
	NL80211_ATTR_HE_BSS_COLOR = 283,
	NL80211_ATTR_IFTYPE_AKM_SUITES = 284,
	NL80211_ATTR_TID_CONFIG = 285,
	NL80211_ATTR_CONTROL_PORT_NO_PREAUTH = 286,
	NL80211_ATTR_PMK_LIFETIME = 287,
	NL80211_ATTR_PMK_REAUTH_THRESHOLD = 288,
	NL80211_ATTR_RECEIVE_MULTICAST = 289,
	NL80211_ATTR_WIPHY_FREQ_OFFSET = 290,
	NL80211_ATTR_CENTER_FREQ1_OFFSET = 291,
	NL80211_ATTR_SCAN_FREQ_KHZ = 292,
	NL80211_ATTR_HE_6GHZ_CAPABILITY = 293,
	NL80211_ATTR_FILS_DISCOVERY = 294,
	NL80211_ATTR_UNSOL_BCAST_PROBE_RESP = 295,
	NL80211_ATTR_S1G_CAPABILITY = 296,
	NL80211_ATTR_S1G_CAPABILITY_MASK = 297,
	NL80211_ATTR_SAE_PWE = 298,
	__NL80211_ATTR_AFTER_LAST = 299,
	NUM_NL80211_ATTR = 299,
	NL80211_ATTR_MAX = 298,
};

enum wiphy_vendor_command_flags {
	WIPHY_VENDOR_CMD_NEED_WDEV = 1,
	WIPHY_VENDOR_CMD_NEED_NETDEV = 2,
	WIPHY_VENDOR_CMD_NEED_RUNNING = 4,
};

enum rtw_vendor_subcmd {
	GSCAN_SUBCMD_GET_CAPABILITIES = 4096,
	GSCAN_SUBCMD_SET_CONFIG = 4097,
	GSCAN_SUBCMD_SET_SCAN_CONFIG = 4098,
	GSCAN_SUBCMD_ENABLE_GSCAN = 4099,
	GSCAN_SUBCMD_GET_SCAN_RESULTS = 4100,
	GSCAN_SUBCMD_SCAN_RESULTS = 4101,
	GSCAN_SUBCMD_SET_HOTLIST = 4102,
	GSCAN_SUBCMD_SET_SIGNIFICANT_CHANGE_CONFIG = 4103,
	GSCAN_SUBCMD_ENABLE_FULL_SCAN_RESULTS = 4104,
	GSCAN_SUBCMD_GET_CHANNEL_LIST = 4105,
	WIFI_SUBCMD_GET_FEATURE_SET = 4106,
	WIFI_SUBCMD_GET_FEATURE_SET_MATRIX = 4107,
	WIFI_SUBCMD_SET_PNO_RANDOM_MAC_OUI = 4108,
	WIFI_SUBCMD_NODFS_SET = 4109,
	WIFI_SUBCMD_SET_COUNTRY_CODE = 4110,
	GSCAN_SUBCMD_SET_EPNO_SSID = 4111,
	WIFI_SUBCMD_SET_SSID_WHITE_LIST = 4112,
	WIFI_SUBCMD_SET_ROAM_PARAMS = 4113,
	WIFI_SUBCMD_ENABLE_LAZY_ROAM = 4114,
	WIFI_SUBCMD_SET_BSSID_PREF = 4115,
	WIFI_SUBCMD_SET_BSSID_BLACKLIST = 4116,
	GSCAN_SUBCMD_ANQPO_CONFIG = 4117,
	WIFI_SUBCMD_SET_RSSI_MONITOR = 4118,
	WIFI_SUBCMD_CONFIG_ND_OFFLOAD = 4119,
	GSCAN_SUBCMD_MAX = 4120,
	RTT_SUBCMD_SET_CONFIG = 4352,
	RTT_SUBCMD_CANCEL_CONFIG = 4353,
	RTT_SUBCMD_GETCAPABILITY = 4354,
	APF_SUBCMD_GET_CAPABILITIES = 6144,
	APF_SUBCMD_SET_FILTER = 6145,
	LOGGER_START_LOGGING = 5120,
	LOGGER_TRIGGER_MEM_DUMP = 5121,
	LOGGER_GET_MEM_DUMP = 5122,
	LOGGER_GET_VER = 5123,
	LOGGER_GET_RING_STATUS = 5124,
	LOGGER_GET_RING_DATA = 5125,
	LOGGER_GET_FEATURE = 5126,
	LOGGER_RESET_LOGGING = 5127,
	LOGGER_TRIGGER_DRIVER_MEM_DUMP = 5128,
	LOGGER_GET_DRIVER_MEM_DUMP = 5129,
	LOGGER_START_PKT_FATE_MONITORING = 5130,
	LOGGER_GET_TX_PKT_FATES = 5131,
	LOGGER_GET_RX_PKT_FATES = 5132,
	WIFI_OFFLOAD_SUBCMD_START_MKEEP_ALIVE = 5632,
	WIFI_OFFLOAD_SUBCMD_STOP_MKEEP_ALIVE = 5633,
	VENDOR_SUBCMD_MAX = 5634,
};

enum andr_wifi_feature_set_attr {
	ANDR_WIFI_ATTRIBUTE_NUM_FEATURE_SET = 0,
	ANDR_WIFI_ATTRIBUTE_FEATURE_SET = 1,
	ANDR_WIFI_ATTRIBUTE_RANDOM_MAC_OUI = 2,
	ANDR_WIFI_ATTRIBUTE_NODFS_SET = 3,
	ANDR_WIFI_ATTRIBUTE_COUNTRY = 4,
	ANDR_WIFI_ATTRIBUTE_ND_OFFLOAD_VALUE = 5,
};

enum ieee80211_regulatory_flags {
	REGULATORY_CUSTOM_REG = 1,
	REGULATORY_STRICT_REG = 2,
	REGULATORY_DISABLE_BEACON_HINTS = 4,
	REGULATORY_COUNTRY_IE_FOLLOW_POWER = 8,
	REGULATORY_COUNTRY_IE_IGNORE = 16,
	REGULATORY_ENABLE_RELAX_NO_IR = 32,
	REGULATORY_IGNORE_STALE_KICKOFF = 64,
	REGULATORY_WIPHY_SELF_MANAGED = 128,
};

enum ieee80211_channel_flags {
	IEEE80211_CHAN_DISABLED = 1,
	IEEE80211_CHAN_NO_IR = 2,
	IEEE80211_CHAN_RADAR = 8,
	IEEE80211_CHAN_NO_HT40PLUS = 16,
	IEEE80211_CHAN_NO_HT40MINUS = 32,
	IEEE80211_CHAN_NO_OFDM = 64,
	IEEE80211_CHAN_NO_80MHZ = 128,
	IEEE80211_CHAN_NO_160MHZ = 256,
	IEEE80211_CHAN_INDOOR_ONLY = 512,
	IEEE80211_CHAN_IR_CONCURRENT = 1024,
	IEEE80211_CHAN_NO_20MHZ = 2048,
	IEEE80211_CHAN_NO_10MHZ = 4096,
	IEEE80211_CHAN_NO_HE = 8192,
	IEEE80211_CHAN_1MHZ = 16384,
	IEEE80211_CHAN_2MHZ = 32768,
	IEEE80211_CHAN_4MHZ = 65536,
	IEEE80211_CHAN_8MHZ = 131072,
	IEEE80211_CHAN_16MHZ = 262144,
};

enum ANDROID_WIFI_CMD {
	ANDROID_WIFI_CMD_START = 0,
	ANDROID_WIFI_CMD_STOP = 1,
	ANDROID_WIFI_CMD_SCAN_ACTIVE = 2,
	ANDROID_WIFI_CMD_SCAN_PASSIVE = 3,
	ANDROID_WIFI_CMD_RSSI = 4,
	ANDROID_WIFI_CMD_LINKSPEED = 5,
	ANDROID_WIFI_CMD_RXFILTER_START = 6,
	ANDROID_WIFI_CMD_RXFILTER_STOP = 7,
	ANDROID_WIFI_CMD_RXFILTER_ADD = 8,
	ANDROID_WIFI_CMD_RXFILTER_REMOVE = 9,
	ANDROID_WIFI_CMD_BTCOEXSCAN_START = 10,
	ANDROID_WIFI_CMD_BTCOEXSCAN_STOP = 11,
	ANDROID_WIFI_CMD_BTCOEXMODE = 12,
	ANDROID_WIFI_CMD_SETSUSPENDMODE = 13,
	ANDROID_WIFI_CMD_SETSUSPENDOPT = 14,
	ANDROID_WIFI_CMD_P2P_DEV_ADDR = 15,
	ANDROID_WIFI_CMD_SETFWPATH = 16,
	ANDROID_WIFI_CMD_SETBAND = 17,
	ANDROID_WIFI_CMD_GETBAND = 18,
	ANDROID_WIFI_CMD_COUNTRY = 19,
	ANDROID_WIFI_CMD_P2P_SET_NOA = 20,
	ANDROID_WIFI_CMD_P2P_GET_NOA = 21,
	ANDROID_WIFI_CMD_P2P_SET_PS = 22,
	ANDROID_WIFI_CMD_SET_AP_WPS_P2P_IE = 23,
	ANDROID_WIFI_CMD_MIRACAST = 24,
	ANDROID_WIFI_CMD_MACADDR = 25,
	ANDROID_WIFI_CMD_BLOCK_SCAN = 26,
	ANDROID_WIFI_CMD_BLOCK = 27,
	ANDROID_WIFI_CMD_WFD_ENABLE = 28,
	ANDROID_WIFI_CMD_WFD_DISABLE = 29,
	ANDROID_WIFI_CMD_WFD_SET_TCPPORT = 30,
	ANDROID_WIFI_CMD_WFD_SET_MAX_TPUT = 31,
	ANDROID_WIFI_CMD_WFD_SET_DEVTYPE = 32,
	ANDROID_WIFI_CMD_CHANGE_DTIM = 33,
	ANDROID_WIFI_CMD_HOSTAPD_SET_MACADDR_ACL = 34,
	ANDROID_WIFI_CMD_HOSTAPD_ACL_ADD_STA = 35,
	ANDROID_WIFI_CMD_HOSTAPD_ACL_REMOVE_STA = 36,
	ANDROID_WIFI_CMD_P2P_DISABLE = 37,
	ANDROID_WIFI_CMD_SET_AEK = 38,
	ANDROID_WIFI_CMD_EXT_AUTH_STATUS = 39,
	ANDROID_WIFI_CMD_DRIVERVERSION = 40,
	ANDROID_WIFI_CMD_MAX = 41,
};

struct android_wifi_priv_cmd {
	char *buf;
	int used_len;
	int total_len;
};

typedef struct android_wifi_priv_cmd android_wifi_priv_cmd;

struct rtw_proc_hdl {
	char *name;
	u8 type;
	union {
		int (*show)(struct seq_file *, void *);
		struct seq_operations *seq_op;
		struct {
			int (*show)(struct seq_file *, void *);
			size_t size;
		} sz;
	} u;
	ssize_t (*write)(struct file *, const char *, size_t, loff_t *, void *);
};

enum _BT_CTRL_STATUS {
	BT_STATUS_SUCCESS = 0,
	BT_STATUS_BT_OP_SUCCESS = 1,
	BT_STATUS_H2C_SUCCESS = 2,
	BT_STATUS_H2C_FAIL = 3,
	BT_STATUS_H2C_LENGTH_EXCEEDED = 4,
	BT_STATUS_H2C_TIMTOUT = 5,
	BT_STATUS_H2C_BT_NO_RSP = 6,
	BT_STATUS_C2H_SUCCESS = 7,
	BT_STATUS_C2H_REQNUM_MISMATCH = 8,
	BT_STATUS_OPCODE_U_VERSION_MISMATCH = 8,
	BT_STATUS_OPCODE_L_VERSION_MISMATCH = 10,
	BT_STATUS_UNKNOWN_OPCODE_U = 11,
	BT_STATUS_UNKNOWN_OPCODE_L = 12,
	BT_STATUS_PARAMETER_FORMAT_ERROR_U = 13,
	BT_STATUS_PARAMETER_FORMAT_ERROR_L = 14,
	BT_STATUS_PARAMETER_OUT_OF_RANGE_U = 15,
	BT_STATUS_PARAMETER_OUT_OF_RANGE_L = 16,
	BT_STATUS_UNKNOWN_STATUS_L = 17,
	BT_STATUS_UNKNOWN_STATUS_H = 18,
	BT_STATUS_WRONG_LEVEL = 19,
	BT_STATUS_NOT_IMPLEMENT = 20,
	BT_STATUS_BT_STACK_OP_SUCCESS = 21,
	BT_STATUS_BT_STACK_NOT_SUPPORT = 22,
	BT_STATUS_BT_STACK_SEND_HCI_EVENT_FAIL = 23,
	BT_STATUS_BT_STACK_NOT_BIND = 24,
	BT_STATUS_BT_STACK_NO_RSP = 25,
	BT_STATUS_MAX = 26,
};

struct dbg_rx_counter {
	u32 rx_pkt_ok;
	u32 rx_pkt_crc_error;
	u32 rx_pkt_drop;
	u32 rx_ofdm_fa;
	u32 rx_cck_fa;
	u32 rx_ht_fa;
};

typedef struct _MPT_CONTEXT *PMPT_CONTEXT;

enum _MPT_RATE_INDEX {
	MPT_RATE_1M = 1,
	MPT_RATE_2M = 2,
	MPT_RATE_55M = 3,
	MPT_RATE_11M = 4,
	MPT_RATE_6M = 5,
	MPT_RATE_9M = 6,
	MPT_RATE_12M = 7,
	MPT_RATE_18M = 8,
	MPT_RATE_24M = 9,
	MPT_RATE_36M = 10,
	MPT_RATE_48M = 11,
	MPT_RATE_54M = 12,
	MPT_RATE_MCS0 = 13,
	MPT_RATE_MCS1 = 14,
	MPT_RATE_MCS2 = 15,
	MPT_RATE_MCS3 = 16,
	MPT_RATE_MCS4 = 17,
	MPT_RATE_MCS5 = 18,
	MPT_RATE_MCS6 = 19,
	MPT_RATE_MCS7 = 20,
	MPT_RATE_MCS8 = 21,
	MPT_RATE_MCS9 = 22,
	MPT_RATE_MCS10 = 23,
	MPT_RATE_MCS11 = 24,
	MPT_RATE_MCS12 = 25,
	MPT_RATE_MCS13 = 26,
	MPT_RATE_MCS14 = 27,
	MPT_RATE_MCS15 = 28,
	MPT_RATE_MCS16 = 29,
	MPT_RATE_MCS17 = 30,
	MPT_RATE_MCS18 = 31,
	MPT_RATE_MCS19 = 32,
	MPT_RATE_MCS20 = 33,
	MPT_RATE_MCS21 = 34,
	MPT_RATE_MCS22 = 35,
	MPT_RATE_MCS23 = 36,
	MPT_RATE_MCS24 = 37,
	MPT_RATE_MCS25 = 38,
	MPT_RATE_MCS26 = 39,
	MPT_RATE_MCS27 = 40,
	MPT_RATE_MCS28 = 41,
	MPT_RATE_MCS29 = 42,
	MPT_RATE_MCS30 = 43,
	MPT_RATE_MCS31 = 44,
	MPT_RATE_VHT1SS_MCS0 = 100,
	MPT_RATE_VHT1SS_MCS1 = 101,
	MPT_RATE_VHT1SS_MCS2 = 102,
	MPT_RATE_VHT1SS_MCS3 = 103,
	MPT_RATE_VHT1SS_MCS4 = 104,
	MPT_RATE_VHT1SS_MCS5 = 105,
	MPT_RATE_VHT1SS_MCS6 = 106,
	MPT_RATE_VHT1SS_MCS7 = 107,
	MPT_RATE_VHT1SS_MCS8 = 108,
	MPT_RATE_VHT1SS_MCS9 = 109,
	MPT_RATE_VHT2SS_MCS0 = 110,
	MPT_RATE_VHT2SS_MCS1 = 111,
	MPT_RATE_VHT2SS_MCS2 = 112,
	MPT_RATE_VHT2SS_MCS3 = 113,
	MPT_RATE_VHT2SS_MCS4 = 114,
	MPT_RATE_VHT2SS_MCS5 = 115,
	MPT_RATE_VHT2SS_MCS6 = 116,
	MPT_RATE_VHT2SS_MCS7 = 117,
	MPT_RATE_VHT2SS_MCS8 = 118,
	MPT_RATE_VHT2SS_MCS9 = 119,
	MPT_RATE_VHT3SS_MCS0 = 120,
	MPT_RATE_VHT3SS_MCS1 = 121,
	MPT_RATE_VHT3SS_MCS2 = 122,
	MPT_RATE_VHT3SS_MCS3 = 123,
	MPT_RATE_VHT3SS_MCS4 = 124,
	MPT_RATE_VHT3SS_MCS5 = 125,
	MPT_RATE_VHT3SS_MCS6 = 126,
	MPT_RATE_VHT3SS_MCS7 = 127,
	MPT_RATE_VHT3SS_MCS8 = 128,
	MPT_RATE_VHT3SS_MCS9 = 129,
	MPT_RATE_VHT4SS_MCS0 = 130,
	MPT_RATE_VHT4SS_MCS1 = 131,
	MPT_RATE_VHT4SS_MCS2 = 132,
	MPT_RATE_VHT4SS_MCS3 = 133,
	MPT_RATE_VHT4SS_MCS4 = 134,
	MPT_RATE_VHT4SS_MCS5 = 135,
	MPT_RATE_VHT4SS_MCS6 = 136,
	MPT_RATE_VHT4SS_MCS7 = 137,
	MPT_RATE_VHT4SS_MCS8 = 138,
	MPT_RATE_VHT4SS_MCS9 = 139,
	MPT_RATE_LAST = 140,
};

enum _mp_tx_pkt_payload {
	MP_TX_Payload_00 = 0,
	MP_TX_Payload_a5 = 1,
	MP_TX_Payload_5a = 2,
	MP_TX_Payload_ff = 3,
	MP_TX_Payload_prbs9 = 4,
	MP_TX_Payload_default_random = 5,
};

enum _C2H_EVT {
	C2H_DBG = 0,
	C2H_LB = 1,
	C2H_TXBF = 2,
	C2H_CCX_TX_RPT = 3,
	C2H_AP_REQ_TXRPT = 4,
	C2H_FW_SCAN_COMPLETE = 7,
	C2H_BT_INFO = 9,
	C2H_BT_MP_INFO = 11,
	C2H_RA_RPT = 12,
	C2H_SPC_STAT = 13,
	C2H_RA_PARA_RPT = 14,
	C2H_FW_CHNL_SWITCH_COMPLETE = 16,
	C2H_IQK_FINISH = 17,
	C2H_MAILBOX_STATUS = 21,
	C2H_P2P_RPORT = 22,
	C2H_MCC = 23,
	C2H_MAC_HIDDEN_RPT = 25,
	C2H_MAC_HIDDEN_RPT_2 = 26,
	C2H_BCN_EARLY_RPT = 30,
	C2H_DEFEATURE_DBG = 34,
	C2H_CUSTOMER_STR_RPT = 36,
	C2H_CUSTOMER_STR_RPT_2 = 37,
	C2H_WLAN_INFO = 39,
	C2H_LPS_STATUS_RPT = 50,
	C2H_SET_TXPWR_FINISH = 112,
	C2H_DEFEATURE_RSVD = 253,
	C2H_EXTEND = 255,
};

enum _RATEID_IDX_ {
	RATEID_IDX_BGN_40M_2SS = 0,
	RATEID_IDX_BGN_40M_1SS = 1,
	RATEID_IDX_BGN_20M_2SS_BN = 2,
	RATEID_IDX_BGN_20M_1SS_BN = 3,
	RATEID_IDX_GN_N2SS = 4,
	RATEID_IDX_GN_N1SS = 5,
	RATEID_IDX_BG = 6,
	RATEID_IDX_G = 7,
	RATEID_IDX_B = 8,
	RATEID_IDX_VHT_2SS = 9,
	RATEID_IDX_VHT_1SS = 10,
	RATEID_IDX_MIX1 = 11,
	RATEID_IDX_MIX2 = 12,
	RATEID_IDX_VHT_3SS = 13,
	RATEID_IDX_BGN_3SS = 14,
	RATEID_IDX_BGN_4SS = 15,
	RATEID_IDX_VHT_4SS = 16,
};

enum _RATR_TABLE_MODE {
	RATR_INX_WIRELESS_NGB = 0,
	RATR_INX_WIRELESS_NG = 1,
	RATR_INX_WIRELESS_NB = 2,
	RATR_INX_WIRELESS_N = 3,
	RATR_INX_WIRELESS_GB = 4,
	RATR_INX_WIRELESS_G = 5,
	RATR_INX_WIRELESS_B = 6,
	RATR_INX_WIRELESS_MC = 7,
	RATR_INX_WIRELESS_AC_N = 8,
};

struct rtw_ieee80211_hdr_3addr_qos {
	u16 frame_ctl;
	u16 duration_id;
	u8 addr1[6];
	u8 addr2[6];
	u8 addr3[6];
	u16 seq_ctl;
	u16 qc;
};

enum h2c_cmd {
	H2C_RSVD_PAGE = 0,
	H2C_MEDIA_STATUS_RPT = 1,
	H2C_SCAN_ENABLE = 2,
	H2C_KEEP_ALIVE = 3,
	H2C_DISCON_DECISION = 4,
	H2C_PSD_OFFLOAD = 5,
	H2C_CUSTOMER_STR_REQ = 6,
	H2C_TXPWR_IDX_OFFLOAD = 7,
	H2C_AP_OFFLOAD = 8,
	H2C_BCN_RSVDPAGE = 9,
	H2C_PROBERSP_RSVDPAGE = 10,
	H2C_FCS_RSVDPAGE = 16,
	H2C_FCS_INFO = 17,
	H2C_AP_WOW_GPIO_CTRL = 19,
	H2C_CHNL_SWITCH_OPER_OFFLOAD = 28,
	H2C_SINGLE_CHANNELSWITCH_V2 = 29,
	H2C_SET_PWR_MODE = 32,
	H2C_PS_TUNING_PARA = 33,
	H2C_PS_TUNING_PARA2 = 34,
	H2C_P2P_LPS_PARAM = 35,
	H2C_P2P_PS_OFFLOAD = 36,
	H2C_PS_SCAN_ENABLE = 37,
	H2C_SAP_PS_ = 38,
	H2C_INACTIVE_PS_ = 39,
	H2C_FWLPS_IN_IPS_ = 40,
	H2C_MACID_CFG = 64,
	H2C_TXBF = 65,
	H2C_RSSI_SETTING = 66,
	H2C_AP_REQ_TXRPT = 67,
	H2C_INIT_RATE_COLLECT = 68,
	H2C_IQ_CALIBRATION = 69,
	H2C_RA_MASK_3SS = 70,
	H2C_RA_PARA_ADJUST = 71,
	H2C_DYNAMIC_TX_PATH = 72,
	H2C_FW_TRACE_EN = 73,
	H2C_B_TYPE_TDMA = 96,
	H2C_BT_INFO = 97,
	H2C_FORCE_BT_TXPWR = 98,
	H2C_BT_IGNORE_WLANACT = 99,
	H2C_DAC_SWING_VALUE = 100,
	H2C_ANT_SEL_RSV = 101,
	H2C_WL_OPMODE = 102,
	H2C_BT_MP_OPER = 103,
	H2C_BT_CONTROL = 104,
	H2C_BT_WIFI_CTRL = 105,
	H2C_BT_FW_PATCH = 106,
	H2C_WOWLAN = 128,
	H2C_REMOTE_WAKE_CTRL = 129,
	H2C_AOAC_GLOBAL_INFO = 130,
	H2C_AOAC_RSVD_PAGE = 131,
	H2C_AOAC_RSVD_PAGE2 = 132,
	H2C_D0_SCAN_OFFLOAD_CTRL = 133,
	H2C_D0_SCAN_OFFLOAD_INFO = 134,
	H2C_CHNL_SWITCH_OFFLOAD = 135,
	H2C_AOAC_RSVDPAGE3 = 136,
	H2C_GPIO_CUSTOM = 137,
	H2C_P2P_OFFLOAD_RSVD_PAGE = 138,
	H2C_P2P_OFFLOAD = 139,
	H2C_WAR_OFFLOAD = 141,
	H2C_WAROFLD_RSVDPAGE1 = 142,
	H2C_RESET_TSF = 192,
	H2C_CUSTOMER_STR_W1 = 198,
	H2C_CUSTOMER_STR_W2 = 199,
	H2C_CUSTOMER_STR_W3 = 200,
	H2C_BT_UNKNOWN_DEVICE_WA = 209,
	H2C_MAXID = 210,
};

struct _RSVDPAGE_LOC {
	u8 LocProbeRsp;
	u8 LocPsPoll;
	u8 LocNullData;
	u8 LocQosNull;
	u8 LocBTQosNull;
	u8 LocApOffloadBCN;
};

typedef struct _RSVDPAGE_LOC RSVDPAGE_LOC;

typedef struct _RSVDPAGE_LOC *PRSVDPAGE_LOC;

struct rsvd_page_cache_t {
	char *name;
	u8 loc;
	u8 page_num;
	u8 *data;
	u32 size;
};

enum _RT_CUSTOMER_ID {
	RT_CID_DEFAULT = 0,
	RT_CID_8187_ALPHA0 = 1,
	RT_CID_8187_SERCOMM_PS = 2,
	RT_CID_8187_HW_LED = 3,
	RT_CID_8187_NETGEAR = 4,
	RT_CID_WHQL = 5,
	RT_CID_819x_CAMEO = 6,
	RT_CID_819x_RUNTOP = 7,
	RT_CID_819x_Senao = 8,
	RT_CID_TOSHIBA = 9,
	RT_CID_819x_Netcore = 10,
	RT_CID_Nettronix = 11,
	RT_CID_DLINK = 12,
	RT_CID_PRONET = 13,
	RT_CID_COREGA = 14,
	RT_CID_CHINA_MOBILE = 15,
	RT_CID_819x_ALPHA = 16,
	RT_CID_819x_Sitecom = 17,
	RT_CID_CCX = 18,
	RT_CID_819X_LENOVO = 19,
	RT_CID_819x_QMI = 20,
	RT_CID_819x_Edimax_Belkin = 21,
	RT_CID_819x_Sercomm_Belkin = 22,
	RT_CID_819x_CAMEO1 = 23,
	RT_CID_819x_MSI = 24,
	RT_CID_819X_ACER = 25,
	RT_CID_819x_AzWave_ASUS = 26,
	RT_CID_819x_AzWave = 27,
	RT_CID_819x_HP = 28,
	RT_CID_819x_WNC_COREGA = 29,
	RT_CID_819x_Arcadyan_Belkin = 30,
	RT_CID_819x_SAMSUNG = 31,
	RT_CID_819x_CLEVO = 32,
	RT_CID_819x_DELL = 33,
	RT_CID_819x_PRONETS = 34,
	RT_CID_819x_Edimax_ASUS = 35,
	RT_CID_NETGEAR = 36,
	RT_CID_PLANEX = 37,
	RT_CID_CC_C = 38,
	RT_CID_819x_Xavi = 39,
	RT_CID_LENOVO_CHINA = 40,
	RT_CID_INTEL_CHINA = 41,
	RT_CID_TPLINK_HPWR = 42,
	RT_CID_819x_Sercomm_Netgear = 43,
	RT_CID_819x_ALPHA_Dlink = 44,
	RT_CID_WNC_NEC = 45,
	RT_CID_DNI_BUFFALO = 46,
};

enum hal_status {
	HAL_STATUS_SUCCESS = 0,
	HAL_STATUS_FAILURE = 1,
};

enum odm_pw_lmt_regulation_type {
	PW_LMT_REGU_FCC = 0,
	PW_LMT_REGU_ETSI = 1,
	PW_LMT_REGU_MKK = 2,
	PW_LMT_REGU_WW13 = 3,
	PW_LMT_REGU_IC = 4,
	PW_LMT_REGU_KCC = 5,
	PW_LMT_REGU_ACMA = 6,
	PW_LMT_REGU_CHILE = 7,
	PW_LMT_REGU_UKRAINE = 8,
	PW_LMT_REGU_MEXICO = 9,
	PW_LMT_REGU_CN = 10,
};

enum odm_pw_lmt_band_type {
	PW_LMT_BAND_2_4G = 0,
	PW_LMT_BAND_5G = 1,
};

enum odm_pw_lmt_bandwidth_type {
	PW_LMT_BW_20M = 0,
	PW_LMT_BW_40M = 1,
	PW_LMT_BW_80M = 2,
	PW_LMT_BW_160M = 3,
};

enum odm_pw_lmt_ratesection_type {
	PW_LMT_RS_CCK = 0,
	PW_LMT_RS_OFDM = 1,
	PW_LMT_RS_HT = 2,
	PW_LMT_RS_VHT = 3,
};

enum odm_pw_lmt_rfpath_type {
	PW_LMT_PH_1T = 0,
	PW_LMT_PH_2T = 1,
	PW_LMT_PH_3T = 2,
	PW_LMT_PH_4T = 3,
};

enum odm_bb_config_type {
	CONFIG_BB_PHY_REG = 0,
	CONFIG_BB_AGC_TAB = 1,
	CONFIG_BB_AGC_TAB_2G = 2,
	CONFIG_BB_AGC_TAB_5G = 3,
	CONFIG_BB_PHY_REG_PG = 4,
	CONFIG_BB_PHY_REG_MP = 5,
	CONFIG_BB_AGC_TAB_DIFF = 6,
	CONFIG_BB_RF_CAL_INIT = 7,
};

enum odm_rf_config_type {
	CONFIG_RF_RADIO = 0,
	CONFIG_RF_TXPWR_LMT = 1,
	CONFIG_RF_SYN_RADIO = 2,
};

struct _TxPowerInfo24G {
	u8 IndexCCK_Base[24];
	u8 IndexBW40_Base[24];
	s8 CCK_Diff[16];
	s8 OFDM_Diff[16];
	s8 BW20_Diff[16];
	s8 BW40_Diff[16];
};

typedef struct _TxPowerInfo24G TxPowerInfo24G;

struct _TxPowerInfo5G {
	u8 IndexBW40_Base[56];
	s8 OFDM_Diff[16];
	s8 BW20_Diff[16];
	s8 BW40_Diff[16];
	s8 BW80_Diff[16];
	s8 BW160_Diff[16];
};

typedef struct _TxPowerInfo5G TxPowerInfo5G;

enum {
	UP_LINK = 0,
	DOWN_LINK = 1,
};

enum phy_cnt {
	FA_OFDM = 0,
	FA_CCK = 1,
	FA_TOTAL = 2,
	CCA_OFDM = 3,
	CCA_CCK = 4,
	CCA_ALL = 5,
	CRC32_OK_VHT = 6,
	CRC32_OK_HT = 7,
	CRC32_OK_LEGACY = 8,
	CRC32_OK_CCK = 9,
	CRC32_ERROR_VHT = 10,
	CRC32_ERROR_HT = 11,
	CRC32_ERROR_LEGACY = 12,
	CRC32_ERROR_CCK = 13,
};

enum odm_interface {
	ODM_ITRF_PCIE = 1,
	ODM_ITRF_USB = 2,
	ODM_ITRF_SDIO = 4,
	ODM_ITRF_ALL = 7,
};

enum odm_wireless_mode {
	ODM_WM_UNKNOW = 0,
	ODM_WM_B = 1,
	ODM_WM_G = 2,
	ODM_WM_A = 4,
	ODM_WM_N24G = 8,
	ODM_WM_N5G = 16,
	ODM_WM_AUTO = 32,
	ODM_WM_AC = 64,
};

enum odm_board_type {
	ODM_BOARD_DEFAULT = 0,
	ODM_BOARD_MINICARD = 1,
	ODM_BOARD_SLIM = 2,
	ODM_BOARD_BT = 4,
	ODM_BOARD_EXT_PA = 8,
	ODM_BOARD_EXT_LNA = 16,
	ODM_BOARD_EXT_TRSW = 32,
	ODM_BOARD_EXT_PA_5G = 64,
	ODM_BOARD_EXT_LNA_5G = 128,
};

enum phydm_pause_type {
	PHYDM_PAUSE = 1,
	PHYDM_PAUSE_NO_SET = 2,
	PHYDM_RESUME = 3,
};

enum phydm_pause_level {
	PHYDM_PAUSE_RELEASE = 4294967295,
	PHYDM_PAUSE_LEVEL_0 = 0,
	PHYDM_PAUSE_LEVEL_1 = 1,
	PHYDM_PAUSE_LEVEL_2 = 2,
	PHYDM_PAUSE_LEVEL_3 = 3,
	PHYDM_PAUSE_MAX_NUM = 4,
};

enum halrf_cmninfo_hook {
	HALRF_CMNINFO_CON_TX = 0,
	HALRF_CMNINFO_SINGLE_TONE = 1,
	HALRF_CMNINFO_CARRIER_SUPPRESSION = 2,
	HALRF_CMNINFO_MP_RATE_INDEX = 3,
	HALRF_CMNINFO_MANUAL_RF_SUPPORTABILITY = 4,
};

enum phydm_info_query {
	PHYDM_INFO_FA_OFDM = 0,
	PHYDM_INFO_FA_CCK = 1,
	PHYDM_INFO_FA_TOTAL = 2,
	PHYDM_INFO_CCA_OFDM = 3,
	PHYDM_INFO_CCA_CCK = 4,
	PHYDM_INFO_CCA_ALL = 5,
	PHYDM_INFO_CRC32_OK_VHT = 6,
	PHYDM_INFO_CRC32_OK_HT = 7,
	PHYDM_INFO_CRC32_OK_LEGACY = 8,
	PHYDM_INFO_CRC32_OK_CCK = 9,
	PHYDM_INFO_CRC32_ERROR_VHT = 10,
	PHYDM_INFO_CRC32_ERROR_HT = 11,
	PHYDM_INFO_CRC32_ERROR_LEGACY = 12,
	PHYDM_INFO_CRC32_ERROR_CCK = 13,
	PHYDM_INFO_EDCCA_FLAG = 14,
	PHYDM_INFO_OFDM_ENABLE = 15,
	PHYDM_INFO_CCK_ENABLE = 16,
	PHYDM_INFO_CRC32_OK_HT_AGG = 17,
	PHYDM_INFO_CRC32_ERROR_HT_AGG = 18,
	PHYDM_INFO_DBG_PORT_0 = 19,
	PHYDM_INFO_CURR_IGI = 20,
	PHYDM_INFO_RSSI_MIN = 21,
	PHYDM_INFO_RSSI_MAX = 22,
	PHYDM_INFO_CLM_RATIO = 23,
	PHYDM_INFO_NHM_RATIO = 24,
	PHYDM_INFO_NHM_NOISE_PWR = 25,
	PHYDM_INFO_NHM_PWR = 26,
	PHYDM_INFO_NHM_ENV_RATIO = 27,
	PHYDM_INFO_TXEN_CCK = 28,
	PHYDM_INFO_TXEN_OFDM = 29,
};

enum phydm_offload_ability {
	PHYDM_PHY_PARAM_OFFLOAD = 1,
	PHYDM_RF_IQK_OFFLOAD = 2,
	PHYDM_RF_DPK_OFFLOAD = 4,
};

enum phydm_bb_op_mode {
	PHYDM_PERFORMANCE_MODE = 0,
	PHYDM_BALANCE_MODE = 1,
};

enum phydm_halmac_param {
	PHYDM_HALMAC_CMD_MAC_W8 = 0,
	PHYDM_HALMAC_CMD_MAC_W16 = 1,
	PHYDM_HALMAC_CMD_MAC_W32 = 2,
	PHYDM_HALMAC_CMD_BB_W8 = 3,
	PHYDM_HALMAC_CMD_BB_W16 = 4,
	PHYDM_HALMAC_CMD_BB_W32 = 5,
	PHYDM_HALMAC_CMD_RF_W = 6,
	PHYDM_HALMAC_CMD_DELAY_US = 7,
	PHYDM_HALMAC_CMD_DELAY_MS = 8,
	PHYDM_HALMAC_CMD_END = 255,
};

struct turbo_edca_setting {
	u32 edca_ul;
	u32 edca_dl;
};

enum _BT_CoType {
	BT_2WIRE = 0,
	BT_ISSC_3WIRE = 1,
	BT_ACCEL = 2,
	BT_CSR_BC4 = 3,
	BT_CSR_BC8 = 4,
	BT_RTL8756 = 5,
	BT_RTL8723A = 6,
	BT_RTL8821 = 7,
	BT_RTL8723B = 8,
	BT_RTL8192E = 9,
	BT_RTL8814A = 10,
	BT_RTL8812A = 11,
	BT_RTL8703B = 12,
	BT_RTL8822B = 13,
	BT_RTL8723D = 14,
	BT_RTL8821C = 15,
	BT_RTL8192F = 16,
	BT_RTL8822C = 17,
	BT_RTL8814B = 18,
	BT_RTL8723F = 19,
};

typedef enum _RT_MEDIA_STATUS RT_MEDIA_STATUS;

typedef struct _RT_LINK_DETECT_T *PRT_LINK_DETECT_T;

typedef void *PVOID;

enum _BTC_MSG_COMP_TYPE {
	COMP_COEX = 0,
	COMP_MAX = 1,
};

struct coex_dm_8723d_1ant {
	u8 pre_ant_pos_type;
	u8 cur_ant_pos_type;
	bool cur_ignore_wlan_act;
	bool pre_ignore_wlan_act;
	u8 cur_ps_tdma;
	u8 ps_tdma_para[5];
	u8 ps_tdma_du_adj_type;
	bool cur_ps_tdma_on;
	bool pre_bt_auto_report;
	bool cur_bt_auto_report;
	u8 pre_lps;
	u8 cur_lps;
	u8 pre_rpwm;
	u8 cur_rpwm;
	bool pre_low_penalty_ra;
	bool cur_low_penalty_ra;
	u32 cur_val0x6c0;
	u32 cur_val0x6c4;
	u32 cur_val0x6c8;
	u8 cur_val0x6cc;
	bool limited_dig;
	u32 backup_arfr_cnt1;
	u32 backup_arfr_cnt2;
	u16 backup_retry_limit;
	u8 backup_ampdu_max_time;
	u8 pre_algorithm;
	u8 cur_algorithm;
	u8 bt_status;
	u8 wifi_chnl_info[3];
	u32 pre_ra_mask;
	u32 cur_ra_mask;
	u8 pre_arfr_type;
	u8 cur_arfr_type;
	u8 pre_retry_limit_type;
	u8 cur_retry_limit_type;
	u8 pre_ampdu_time_type;
	u8 cur_ampdu_time_type;
	u32 arp_cnt;
	u8 error_condition;
	u32 setting_tdma;
};

struct coex_sta_8723d_1ant {
	bool bt_disabled;
	bool bt_link_exist;
	bool sco_exist;
	bool a2dp_exist;
	bool hid_exist;
	bool pan_exist;
	bool bt_hi_pri_link_exist;
	u8 num_of_profile;
	bool under_lps;
	bool under_ips;
	u32 specific_pkt_period_cnt;
	u8 connect_ap_period_cnt;
	u8 pnp_awake_period_cnt;
	u32 high_priority_tx;
	u32 high_priority_rx;
	u32 low_priority_tx;
	u32 low_priority_rx;
	bool bt_ctr_ok;
	bool is_hipri_rx_overhead;
	s8 bt_rssi;
	bool bt_tx_rx_mask;
	bool bt_mesh_on;
	u8 pre_bt_rssi_state;
	u8 pre_wifi_rssi_state[4];
	u8 bt_info_c2h[30];
	u32 bt_info_c2h_cnt[3];
	bool bt_whck_test;
	bool c2h_bt_inquiry_page;
	bool bt_inq_page_pre;
	bool bt_inq_page_remain;
	bool c2h_bt_remote_name_req;
	bool c2h_bt_page;
	bool wifi_is_high_pri_task;
	bool wifi_in_scan_task;
	u8 bt_retry_cnt;
	u8 bt_info_ext;
	u8 bt_info_ext2;
	u32 pop_event_cnt;
	u8 scan_ap_num;
	u32 crc_ok_cck;
	u32 crc_ok_11g;
	u32 crc_ok_11n;
	u32 crc_ok_11n_vht;
	u32 crc_err_cck;
	u32 crc_err_11g;
	u32 crc_err_11n;
	u32 crc_err_11n_vht;
	bool cck_lock;
	bool cck_lock_ever;
	bool cck_lock_warn;
	u8 coex_table_type;
	bool force_lps_ctrl;
	bool concurrent_rx_mode_on;
	u16 score_board;
	u8 isolation_btween_wb;
	u8 a2dp_bit_pool;
	u8 kt_ver;
	bool acl_busy;
	bool bt_create_connection;
	u32 bt_coex_supported_feature;
	u32 bt_coex_supported_version;
	u8 bt_ble_scan_type;
	u32 bt_ble_scan_para[3];
	bool run_time_state;
	bool freeze_coexrun_by_btinfo;
	bool is_A2DP_3M;
	bool voice_over_HOGP;
	bool bt_a2dp_active;
	u8 bt_info;
	u8 forbidden_slot;
	u8 hid_busy_num;
	u8 hid_pair_cnt;
	u32 cnt_remotenamereq;
	u32 cnt_setuplink;
	u32 cnt_reinit;
	u32 cnt_ignwlanact;
	u32 cnt_page;
	u32 cnt_roleswitch;
	u16 bt_reg_vendor_ac;
	u16 bt_reg_vendor_ae;
	bool is_setup_link;
	u8 wl_noisy_level;
	u32 gnt_error_cnt;
	u8 bt_afh_map[10];
	u8 bt_relink_downcount;
	u8 bt_inq_page_downcount;
	bool is_tdma_btautoslot;
	bool is_tdma_btautoslot_hang;
	bool is_rf_state_off;
	bool is_hid_low_pri_tx_overhead;
	bool is_bt_multi_link;
	bool is_bt_a2dp_sink;
	bool is_bt_mesh_ver;
	u8 wl_fw_dbg_info[10];
	u8 wl_rx_rate;
	u8 wl_rts_rx_rate;
	u16 score_board_WB;
	bool is_hid_rcu;
	bool is_ble_scan_en;
	u16 legacy_forbidden_slot;
	u16 le_forbidden_slot;
	u8 bt_a2dp_vendor_id;
	u32 bt_a2dp_device_name;
	bool is_bt_opp_exist;
	bool is_no_wl_5ms_extend;
	u16 wl_0x42a_backup;
	u32 wl_0x430_backup;
	u32 wl_0x434_backup;
	u8 wl_0x456_backup;
	bool wl_tx_limit_en;
	bool wl_ampdu_limit_en;
	bool wl_rxagg_limit_en;
	u8 wl_rxagg_size;
	u8 tdma_timer_base;
	u8 wl_iot_peer;
};

struct coex_dm_8723d_2ant {
	u8 pre_bt_dec_pwr_lvl;
	u8 cur_bt_dec_pwr_lvl;
	u8 pre_fw_dac_swing_lvl;
	u8 cur_fw_dac_swing_lvl;
	bool cur_ignore_wlan_act;
	bool pre_ignore_wlan_act;
	u8 cur_ps_tdma;
	u8 ps_tdma_para[5];
	u8 ps_tdma_du_adj_type;
	bool reset_tdma_adjust;
	bool cur_ps_tdma_on;
	bool pre_bt_auto_report;
	bool cur_bt_auto_report;
	bool pre_rf_rx_lpf_shrink;
	bool cur_rf_rx_lpf_shrink;
	u32 bt_rf_0x1e_backup;
	bool pre_low_penalty_ra;
	bool cur_low_penalty_ra;
	bool pre_dac_swing_on;
	u32 pre_dac_swing_lvl;
	bool cur_dac_swing_on;
	u32 cur_dac_swing_lvl;
	bool pre_adc_back_off;
	bool cur_adc_back_off;
	bool pre_agc_table_en;
	bool cur_agc_table_en;
	u32 cur_val0x6c0;
	u32 cur_val0x6c4;
	u32 cur_val0x6c8;
	u8 cur_val0x6cc;
	bool limited_dig;
	u8 pre_algorithm;
	u8 cur_algorithm;
	u8 bt_status;
	u8 wifi_chnl_info[3];
	bool need_recover0x948;
	u32 backup0x948;
	u8 pre_lps;
	u8 cur_lps;
	u8 pre_rpwm;
	u8 cur_rpwm;
	bool is_switch_to_1dot5_ant;
	u8 switch_thres_offset;
	u32 arp_cnt;
	u8 pre_ant_pos_type;
	u8 cur_ant_pos_type;
	u32 setting_tdma;
};

struct coex_sta_8723d_2ant {
	bool bt_disabled;
	bool bt_link_exist;
	bool sco_exist;
	bool a2dp_exist;
	bool hid_exist;
	bool pan_exist;
	bool under_lps;
	bool under_ips;
	u8 connect_ap_period_cnt;
	u8 pnp_awake_period_cnt;
	u32 high_priority_tx;
	u32 high_priority_rx;
	u32 low_priority_tx;
	u32 low_priority_rx;
	bool bt_ctr_ok;
	bool is_hipri_rx_overhead;
	u8 bt_rssi;
	bool bt_tx_rx_mask;
	u8 pre_bt_rssi_state;
	u8 pre_wifi_rssi_state[4];
	u8 bt_info_c2h[30];
	u32 bt_info_c2h_cnt[3];
	bool bt_whck_test;
	bool c2h_bt_inquiry_page;
	bool bt_inq_page_pre;
	bool bt_inq_page_remain;
	bool c2h_bt_remote_name_req;
	u8 bt_retry_cnt;
	u8 bt_info_ext;
	u8 bt_info_ext2;
	u32 pop_event_cnt;
	u8 scan_ap_num;
	u32 crc_ok_cck;
	u32 crc_ok_11g;
	u32 crc_ok_11n;
	u32 crc_ok_11n_vht;
	u32 crc_err_cck;
	u32 crc_err_11g;
	u32 crc_err_11n;
	u32 crc_err_11n_vht;
	u32 acc_crc_ratio;
	u32 now_crc_ratio;
	u32 cnt_crcok_max_in_10s;
	bool cck_lock;
	bool cck_lock_ever;
	bool cck_lock_warn;
	u8 coex_table_type;
	bool force_lps_ctrl;
	u8 dis_ver_info_cnt;
	u8 a2dp_bit_pool;
	u8 kt_ver;
	bool concurrent_rx_mode_on;
	u16 score_board;
	u8 isolation_btween_wb;
	u8 wifi_coex_thres;
	u8 bt_coex_thres;
	u8 wifi_coex_thres2;
	u8 bt_coex_thres2;
	u8 num_of_profile;
	bool acl_busy;
	bool bt_create_connection;
	bool wifi_is_high_pri_task;
	u32 specific_pkt_period_cnt;
	u32 bt_coex_supported_feature;
	u32 bt_coex_supported_version;
	u8 bt_ble_scan_type;
	u32 bt_ble_scan_para[3];
	bool run_time_state;
	bool freeze_coexrun_by_btinfo;
	bool is_A2DP_3M;
	bool voice_over_HOGP;
	bool bt_a2dp_active;
	u8 bt_info;
	u8 forbidden_slot;
	u8 hid_busy_num;
	u8 hid_pair_cnt;
	u32 cnt_remotenamereq;
	u32 cnt_setuplink;
	u32 cnt_reinit;
	u32 cnt_ignwlanact;
	u32 cnt_page;
	u32 cnt_roleswitch;
	u16 bt_reg_vendor_ac;
	u16 bt_reg_vendor_ae;
	bool is_setup_link;
	bool wl_noisy_level;
	u32 gnt_error_cnt;
	u8 bt_afh_map[10];
	u8 bt_relink_downcount;
	u8 bt_inq_page_downcount;
	bool is_tdma_btautoslot;
	bool is_tdma_btautoslot_hang;
	bool is_esco_mode;
	bool is_rf_state_off;
	bool is_hid_low_pri_tx_overhead;
	bool is_bt_multi_link;
	bool is_bt_a2dp_sink;
	u8 wl_fw_dbg_info[10];
	u8 wl_rx_rate;
	u8 wl_rts_rx_rate;
	u16 score_board_WB;
	bool is_2g_freerun;
	bool is_hid_rcu;
	bool is_ble_scan_en;
	u16 legacy_forbidden_slot;
	u16 le_forbidden_slot;
	u8 bt_a2dp_vendor_id;
	u32 bt_a2dp_device_name;
	bool is_bt_opp_exist;
	bool is_no_wl_5ms_extend;
	u16 wl_0x42a_backup;
	u32 wl_0x430_backup;
	u32 wl_0x434_backup;
	u8 wl_0x456_backup;
	bool wl_tx_limit_en;
	bool wl_ampdu_limit_en;
	bool wl_rxagg_limit_en;
	u8 wl_rxagg_size;
	u8 tdma_timer_base;
	u8 wl_iot_peer;
};

enum {
	BTC_CCK_1 = 0,
	BTC_CCK_2 = 1,
	BTC_CCK_5_5 = 2,
	BTC_CCK_11 = 3,
	BTC_OFDM_6 = 4,
	BTC_OFDM_9 = 5,
	BTC_OFDM_12 = 6,
	BTC_OFDM_18 = 7,
	BTC_OFDM_24 = 8,
	BTC_OFDM_36 = 9,
	BTC_OFDM_48 = 10,
	BTC_OFDM_54 = 11,
	BTC_MCS_0 = 12,
	BTC_MCS_1 = 13,
	BTC_MCS_2 = 14,
	BTC_MCS_3 = 15,
	BTC_MCS_4 = 16,
	BTC_MCS_5 = 17,
	BTC_MCS_6 = 18,
	BTC_MCS_7 = 19,
	BTC_MCS_8 = 20,
	BTC_MCS_9 = 21,
	BTC_MCS_10 = 22,
	BTC_MCS_11 = 23,
	BTC_MCS_12 = 24,
	BTC_MCS_13 = 25,
	BTC_MCS_14 = 26,
	BTC_MCS_15 = 27,
	BTC_MCS_16 = 28,
	BTC_MCS_17 = 29,
	BTC_MCS_18 = 30,
	BTC_MCS_19 = 31,
	BTC_MCS_20 = 32,
	BTC_MCS_21 = 33,
	BTC_MCS_22 = 34,
	BTC_MCS_23 = 35,
	BTC_MCS_24 = 36,
	BTC_MCS_25 = 37,
	BTC_MCS_26 = 38,
	BTC_MCS_27 = 39,
	BTC_MCS_28 = 40,
	BTC_MCS_29 = 41,
	BTC_MCS_30 = 42,
	BTC_MCS_31 = 43,
	BTC_VHT_1SS_MCS_0 = 44,
	BTC_VHT_1SS_MCS_1 = 45,
	BTC_VHT_1SS_MCS_2 = 46,
	BTC_VHT_1SS_MCS_3 = 47,
	BTC_VHT_1SS_MCS_4 = 48,
	BTC_VHT_1SS_MCS_5 = 49,
	BTC_VHT_1SS_MCS_6 = 50,
	BTC_VHT_1SS_MCS_7 = 51,
	BTC_VHT_1SS_MCS_8 = 52,
	BTC_VHT_1SS_MCS_9 = 53,
	BTC_VHT_2SS_MCS_0 = 54,
	BTC_VHT_2SS_MCS_1 = 55,
	BTC_VHT_2SS_MCS_2 = 56,
	BTC_VHT_2SS_MCS_3 = 57,
	BTC_VHT_2SS_MCS_4 = 58,
	BTC_VHT_2SS_MCS_5 = 59,
	BTC_VHT_2SS_MCS_6 = 60,
	BTC_VHT_2SS_MCS_7 = 61,
	BTC_VHT_2SS_MCS_8 = 62,
	BTC_VHT_2SS_MCS_9 = 63,
	BTC_VHT_3SS_MCS_0 = 64,
	BTC_VHT_3SS_MCS_1 = 65,
	BTC_VHT_3SS_MCS_2 = 66,
	BTC_VHT_3SS_MCS_3 = 67,
	BTC_VHT_3SS_MCS_4 = 68,
	BTC_VHT_3SS_MCS_5 = 69,
	BTC_VHT_3SS_MCS_6 = 70,
	BTC_VHT_3SS_MCS_7 = 71,
	BTC_VHT_3SS_MCS_8 = 72,
	BTC_VHT_3SS_MCS_9 = 73,
	BTC_VHT_4SS_MCS_0 = 74,
	BTC_VHT_4SS_MCS_1 = 75,
	BTC_VHT_4SS_MCS_2 = 76,
	BTC_VHT_4SS_MCS_3 = 77,
	BTC_VHT_4SS_MCS_4 = 78,
	BTC_VHT_4SS_MCS_5 = 79,
	BTC_VHT_4SS_MCS_6 = 80,
	BTC_VHT_4SS_MCS_7 = 81,
	BTC_VHT_4SS_MCS_8 = 82,
	BTC_VHT_4SS_MCS_9 = 83,
	BTC_MCS_32 = 84,
	BTC_UNKNOWN = 85,
	BTC_PKT_MGNT = 86,
	BTC_PKT_CTRL = 87,
	BTC_PKT_UNKNOWN = 88,
	BTC_PKT_NOT_FOR_ME = 89,
	BTC_RATE_MAX = 90,
};

enum {
	BTC_MULTIPORT_SCC = 0,
	BTC_MULTIPORT_MCC_DUAL_CHANNEL = 1,
	BTC_MULTIPORT_MCC_DUAL_BAND = 2,
	BTC_MULTIPORT_MAX = 3,
};

enum _BTC_CHIP_INTERFACE {
	BTC_INTF_UNKNOWN = 0,
	BTC_INTF_PCI = 1,
	BTC_INTF_USB = 2,
	BTC_INTF_SDIO = 3,
	BTC_INTF_MAX = 4,
};

typedef enum _BTC_CHIP_INTERFACE BTC_CHIP_INTERFACE;

enum _BTC_CHIP_TYPE {
	BTC_CHIP_UNDEF = 0,
	BTC_CHIP_CSR_BC4 = 1,
	BTC_CHIP_CSR_BC8 = 2,
	BTC_CHIP_RTL8723A = 3,
	BTC_CHIP_RTL8821 = 4,
	BTC_CHIP_RTL8723B = 5,
	BTC_CHIP_RTL8822B = 6,
	BTC_CHIP_RTL8822C = 7,
	BTC_CHIP_RTL8821C = 8,
	BTC_CHIP_RTL8821A = 9,
	BTC_CHIP_RTL8723D = 10,
	BTC_CHIP_RTL8703B = 11,
	BTC_CHIP_RTL8725A = 12,
	BTC_CHIP_RTL8723F = 13,
	BTC_CHIP_MAX = 14,
};

enum btc_btinfo_src {
	BTC_BTINFO_SRC_WL_FW = 0,
	BTC_BTINFO_SRC_BT_RSP = 1,
	BTC_BTINFO_SRC_BT_ACT = 2,
	BTC_BTINFO_SRC_BT_IQK = 3,
	BTC_BTINFO_SRC_BT_SCBD = 4,
	BTC_BTINFO_SRC_H2C60 = 5,
	BTC_BTINFO_SRC_MAX = 6,
};

enum btc_wl2bt_scoreboard {
	BTC_SCBD_ACTIVE = 1,
	BTC_SCBD_ON = 2,
	BTC_SCBD_SCAN = 4,
	BTC_SCBD_UNDERTEST = 8,
	BTC_SCBD_RXGAIN = 16,
	BTC_SCBD_WLBUSY = 128,
	BTC_SCBD_EXTFEM = 256,
	BTC_SCBD_TDMA = 512,
	BTC_SCBD_FIX2M = 1024,
	BTC_SCBD_MAILBOX_DBG = 16384,
	BTC_SCBD_ALL = 65535,
	BTC_SCBD_ALL_32BIT = 4294967295,
};

enum btc_bt_state_cnt {
	BTC_CNT_BT_RETRY = 0,
	BTC_CNT_BT_REINIT = 1,
	BTC_CNT_BT_POPEVENT = 2,
	BTC_CNT_BT_SETUPLINK = 3,
	BTC_CNT_BT_IGNWLANACT = 4,
	BTC_CNT_BT_INQ = 5,
	BTC_CNT_BT_PAGE = 6,
	BTC_CNT_BT_ROLESWITCH = 7,
	BTC_CNT_BT_AFHUPDATE = 8,
	BTC_CNT_BT_DISABLE = 9,
	BTC_CNT_BT_INFOUPDATE = 10,
	BTC_CNT_BT_IQK = 11,
	BTC_CNT_BT_IQKFAIL = 12,
	BTC_CNT_BT_TRX = 13,
	BTC_CNT_BT_MAX = 14,
};

enum btc_wl_state_cnt {
	BTC_CNT_WL_SCANAP = 0,
	BTC_CNT_WL_ARP = 1,
	BTC_CNT_WL_GNTERR = 2,
	BTC_CNT_WL_PSFAIL = 3,
	BTC_CNT_WL_COEXRUN = 4,
	BTC_CNT_WL_COEXINFO1 = 5,
	BTC_CNT_WL_COEXINFO2 = 6,
	BTC_CNT_WL_AUTOSLOT_HANG = 7,
	BTC_CNT_WL_NOISY0 = 8,
	BTC_CNT_WL_NOISY1 = 9,
	BTC_CNT_WL_NOISY2 = 10,
	BTC_CNT_WL_ACTIVEPORT = 11,
	BTC_CNT_WL_LEAKAP_NORX = 12,
	BTC_CNT_WL_FW_NOTIFY = 13,
	BTC_CNT_WL_2G_TDDTRY = 14,
	BTC_CNT_WL_2G_FDDSTAY = 15,
	BTC_CNT_WL_MAX = 16,
};

enum btc_timer_cnt {
	BTC_TIMER_WL_STAYBUSY = 0,
	BTC_TIMER_WL_COEXFREEZE = 1,
	BTC_TIMER_WL_SPECPKT = 2,
	BTC_TIMER_WL_CONNPKT = 3,
	BTC_TIMER_WL_PNPWAKEUP = 4,
	BTC_TIMER_WL_CCKLOCK = 5,
	BTC_TIMER_WL_FWDBG = 6,
	BTC_TIMER_BT_RELINK = 7,
	BTC_TIMER_BT_REENABLE = 8,
	BTC_TIMER_BT_MULTILINK = 9,
	BTC_TIMER_BT_INQPAGE = 10,
	BTC_TIMER_BT_A2DP_ACT = 11,
	BTC_TIMER_MAX = 12,
};

enum btc_indirect_reg_type {
	BTC_INDIRECT_1700 = 0,
	BTC_INDIRECT_7C0 = 1,
	BTC_INDIRECT_MAX = 2,
};

struct btc_board_info {
	u8 bt_chip_type;
	u8 pg_ant_num;
	u8 btdm_ant_num;
	u8 btdm_ant_num_by_ant_det;
	u8 btdm_ant_pos;
	u8 single_ant_path;
	bool tfbga_package;
	bool btdm_ant_det_finish;
	bool btdm_ant_det_already_init_phydm;
	u8 ant_type;
	u8 rfe_type;
	u8 ant_div_cfg;
	bool btdm_ant_det_complete_fail;
	u8 ant_det_result;
	bool ant_det_result_five_complete;
	u32 antdetval;
	u8 customerID;
	u8 customer_id;
	u8 ant_distance;
	u8 ext_chip_id;
};

struct btc_coex_dm {
	bool cur_ignore_wlan_act;
	bool cur_ps_tdma_on;
	bool cur_low_penalty_ra;
	bool cur_wl_rx_low_gain_en;
	u8 bt_rssi_state[4];
	u8 wl_rssi_state[4];
	u8 cur_ps_tdma;
	u8 ps_tdma_para[5];
	u8 fw_tdma_para[5];
	u8 cur_lps;
	u8 cur_rpwm;
	u8 cur_bt_pwr_lvl;
	u8 cur_bt_lna_lvl;
	u8 cur_wl_pwr_lvl;
	u8 cur_algorithm;
	u8 bt_status;
	u8 wl_chnl_info[3];
	u8 cur_toggle_para[6];
	u32 cur_ant_pos_type;
	u32 cur_switch_status;
	u32 setting_tdma;
};

struct btc_coex_sta {
	bool coex_freeze;
	bool coex_freerun;
	bool rf4ce_en;
	bool force_freerun;
	bool force_tdd;
	bool bt_disabled;
	bool bt_disabled_pre;
	bool bt_link_exist;
	bool bt_whck_test;
	bool bt_inq_page;
	bool bt_inq_page_pre;
	bool bt_inq_page_remain;
	bool bt_inq;
	bool bt_page;
	bool bt_ble_voice;
	bool bt_ble_exist;
	bool bt_hfp_exist;
	bool bt_a2dp_exist;
	bool bt_hid_exist;
	bool bt_pan_exist;
	bool bt_opp_exist;
	bool bt_msft_mr_exist;
	bool bt_acl_busy;
	bool bt_fix_2M;
	bool bt_setup_link;
	bool bt_multi_link;
	bool bt_multi_link_pre;
	bool bt_multi_link_remain;
	bool bt_a2dp_sink;
	bool bt_reenable;
	bool bt_ble_scan_en;
	bool bt_slave;
	bool bt_a2dp_active;
	bool bt_a2dp_active_pre;
	bool bt_a2dp_active_remain;
	bool bt_slave_latency;
	bool bt_init_scan;
	bool bt_418_hid_exist;
	bool bt_ble_hid_exist;
	bool bt_mesh;
	bool bt_ctr_ok;
	bool wl_under_lps;
	bool wl_under_ips;
	bool wl_under_4way;
	bool wl_hi_pri_task1;
	bool wl_hi_pri_task2;
	bool wl_cck_lock;
	bool wl_cck_lock_pre;
	bool wl_cck_lock_ever;
	bool wl_force_lps_ctrl;
	bool wl_busy_pre;
	bool wl_gl_busy;
	bool wl_gl_busy_pre;
	bool wl_linkscan_proc;
	bool wl_mimo_ps;
	bool wl_cck_dead_lock_ap;
	bool wl_tx_limit_en;
	bool wl_ampdu_limit_en;
	bool wl_rxagg_limit_en;
	bool wl_connecting;
	bool wl_pnp_wakeup;
	bool wl_slot_toggle;
	bool wl_slot_toggle_change;
	bool wl_leak_ap;
	bool wl_blacklist_ap;
	bool wl_rfk;
	u8 coex_table_type;
	u8 coex_run_reason;
	u8 tdma_byte4_modify_pre;
	u8 kt_ver;
	u8 gnt_workaround_state;
	u8 tdma_timer_base;
	u8 bt_rssi;
	u8 bt_profile_num;
	u8 bt_profile_num_pre;
	u8 bt_info_c2h[60];
	u8 bt_info_lb2;
	u8 bt_info_lb3;
	u8 bt_info_hb0;
	u8 bt_info_hb1;
	u8 bt_info_hb2;
	u8 bt_info_hb3;
	u8 bt_ble_scan_type;
	u8 bt_afh_map[10];
	u8 bt_a2dp_vendor_id;
	u8 bt_hid_pair_num;
	u8 bt_hid_slot;
	u8 bt_a2dp_bitpool;
	u8 bt_iqk_state;
	u8 bt_sut_pwr_lvl[4];
	u8 bt_golden_rx_shift[4];
	u8 bt_ext_autoslot_thres;
	u8 ext_chip_mode;
	u8 wl_pnp_state_pre;
	u8 wl_noisy_level;
	u8 wl_fw_dbg_info[10];
	u8 wl_fw_dbg_info_pre[10];
	u8 wl_rx_rate;
	u8 wl_tx_rate;
	u8 wl_rts_rx_rate;
	u8 wl_center_ch;
	u8 wl_tx_macid;
	u8 wl_tx_retry_ratio;
	u8 wl_coex_mode;
	u8 wl_iot_peer;
	u8 wl_ra_thres;
	u8 wl_ampdulen;
	u8 wl_rxagg_size;
	u8 wl_toggle_para[6];
	u8 wl_toggle_interval;
	u16 score_board_BW;
	u32 score_board_WB;
	u16 bt_reg_vendor_ac;
	u16 bt_reg_vendor_ae;
	u32 bt_reg_vendor_dac;
	u16 bt_reg_modem_a;
	u16 bt_reg_rf_2;
	u16 bt_reg_rf_9;
	u16 wl_txlimit;
	u32 score_board_BW_32bit;
	u32 score_board_WB_32bit;
	u32 hi_pri_tx;
	u32 hi_pri_rx;
	u32 lo_pri_tx;
	u32 lo_pri_rx;
	u32 bt_supported_feature;
	u32 bt_supported_version;
	u32 bt_ble_scan_para[3];
	u32 bt_a2dp_device_name;
	u32 bt_a2dp_flush_time;
	u32 wl_arfb1;
	u32 wl_arfb2;
	u32 wl_traffic_dir;
	u32 wl_bw;
	u32 cnt_bt_info_c2h[6];
	u32 cnt_bt[14];
	u32 cnt_wl[16];
	u32 cnt_timer[12];
};

struct btc_rfe_type {
	bool ant_switch_exist;
	bool ant_switch_diversity;
	bool ant_switch_with_bt;
	u8 rfe_module_type;
	u8 ant_switch_type;
	u8 ant_switch_polarity;
	bool band_switch_exist;
	u8 band_switch_type;
	u8 band_switch_polarity;
	bool wlg_at_btg;
};

struct btc_wifi_link_info_ext {
	bool is_all_under_5g;
	bool is_mcc_25g;
	bool is_p2p_connected;
	bool is_ap_mode;
	bool is_scan;
	bool is_link;
	bool is_roam;
	bool is_4way;
	bool is_32k;
	bool is_connected;
	u8 num_of_active_port;
	u32 port_connect_status;
	u32 traffic_dir;
	u32 wifi_bw;
};

struct btc_coex_table_para {
	u32 bt;
	u32 wl;
};

struct btc_tdma_para {
	u8 para[5];
};

struct btc_5g_afh_map {
	u32 wl_5g_ch;
	u8 bt_skip_ch;
	u8 bt_skip_span;
};

struct btc_rf_para {
	u8 wl_pwr_dec_lvl;
	u8 bt_pwr_dec_lvl;
	bool wl_low_gain_en;
	u8 bt_lna_lvl;
};

enum _BTC_WIRELESS_FREQ {
	BTC_FREQ_2_4G = 0,
	BTC_FREQ_5G = 1,
	BTC_FREQ_25G = 2,
	BTC_FREQ_MAX = 3,
};

enum _BTC_WIFI_BW_MODE {
	BTC_WIFI_BW_LEGACY = 0,
	BTC_WIFI_BW_HT20 = 1,
	BTC_WIFI_BW_HT40 = 2,
	BTC_WIFI_BW_HT80 = 3,
	BTC_WIFI_BW_HT160 = 4,
	BTC_WIFI_BW_MAX = 5,
};

enum _BTC_WIFI_TRAFFIC_DIR {
	BTC_WIFI_TRAFFIC_TX = 0,
	BTC_WIFI_TRAFFIC_RX = 1,
	BTC_WIFI_TRAFFIC_MAX = 2,
};

enum _BTC_WIFI_PNP {
	BTC_WIFI_PNP_WAKE_UP = 0,
	BTC_WIFI_PNP_SLEEP = 1,
	BTC_WIFI_PNP_SLEEP_KEEP_ANT = 2,
	BTC_WIFI_PNP_WOWLAN = 3,
	BTC_WIFI_PNP_MAX = 4,
};

enum _BTC_ANT_TYPE {
	BTC_ANT_TYPE_0 = 0,
	BTC_ANT_TYPE_1 = 1,
	BTC_ANT_TYPE_2 = 2,
	BTC_ANT_TYPE_3 = 3,
	BTC_ANT_TYPE_4 = 4,
	BTC_ANT_TYPE_MAX = 5,
};

enum _BTC_VENDOR {
	BTC_VENDOR_LENOVO = 0,
	BTC_VENDOR_ASUS = 1,
	BTC_VENDOR_OTHER = 2,
};

enum _BTC_GET_TYPE {
	BTC_GET_BL_HS_OPERATION = 0,
	BTC_GET_BL_HS_CONNECTING = 1,
	BTC_GET_BL_WIFI_FW_READY = 2,
	BTC_GET_BL_WIFI_CONNECTED = 3,
	BTC_GET_BL_WIFI_DUAL_BAND_CONNECTED = 4,
	BTC_GET_BL_WIFI_LINK_INFO = 5,
	BTC_GET_BL_WIFI_BUSY = 6,
	BTC_GET_BL_WIFI_SCAN = 7,
	BTC_GET_BL_WIFI_LINK = 8,
	BTC_GET_BL_WIFI_ROAM = 9,
	BTC_GET_BL_WIFI_4_WAY_PROGRESS = 10,
	BTC_GET_BL_WIFI_UNDER_5G = 11,
	BTC_GET_BL_WIFI_AP_MODE_ENABLE = 12,
	BTC_GET_BL_WIFI_ENABLE_ENCRYPTION = 13,
	BTC_GET_BL_WIFI_UNDER_B_MODE = 14,
	BTC_GET_BL_EXT_SWITCH = 15,
	BTC_GET_BL_WIFI_IS_IN_MP_MODE = 16,
	BTC_GET_BL_IS_ASUS_8723B = 17,
	BTC_GET_BL_RF4CE_CONNECTED = 18,
	BTC_GET_BL_WIFI_LW_PWR_STATE = 19,
	BTC_GET_S4_WIFI_RSSI = 20,
	BTC_GET_S4_HS_RSSI = 21,
	BTC_GET_U4_WIFI_BW = 22,
	BTC_GET_U4_WIFI_TRAFFIC_DIRECTION = 23,
	BTC_GET_U4_WIFI_TRAFFIC_DIR = 24,
	BTC_GET_U4_WIFI_FW_VER = 25,
	BTC_GET_U4_WIFI_PHY_VER = 26,
	BTC_GET_U4_WIFI_LINK_STATUS = 27,
	BTC_GET_U4_BT_PATCH_VER = 28,
	BTC_GET_U4_VENDOR = 29,
	BTC_GET_U4_SUPPORTED_VERSION = 30,
	BTC_GET_U4_SUPPORTED_FEATURE = 31,
	BTC_GET_U4_BT_DEVICE_INFO = 32,
	BTC_GET_U4_BT_FORBIDDEN_SLOT_VAL = 33,
	BTC_GET_U4_BT_A2DP_FLUSH_VAL = 34,
	BTC_GET_U4_WIFI_IQK_TOTAL = 35,
	BTC_GET_U4_WIFI_IQK_OK = 36,
	BTC_GET_U4_WIFI_IQK_FAIL = 37,
	BTC_GET_U1_WIFI_DOT11_CHNL = 38,
	BTC_GET_U1_WIFI_CENTRAL_CHNL = 39,
	BTC_GET_U1_WIFI_HS_CHNL = 40,
	BTC_GET_U1_WIFI_P2P_CHNL = 41,
	BTC_GET_U1_MAC_PHY_MODE = 42,
	BTC_GET_U1_AP_NUM = 43,
	BTC_GET_U1_ANT_TYPE = 44,
	BTC_GET_U1_IOT_PEER = 45,
	BTC_GET_BL_WIFI_BSSID = 46,
	BTC_GET_U2_BEACON_PERIOD = 47,
	BTC_GET_U1_LPS_MODE = 48,
	BTC_GET_MAX = 49,
};

enum _BTC_SET_TYPE {
	BTC_SET_BL_BT_DISABLE = 0,
	BTC_SET_BL_BT_ENABLE_DISABLE_CHANGE = 1,
	BTC_SET_BL_BT_TRAFFIC_BUSY = 2,
	BTC_SET_BL_BT_LIMITED_DIG = 3,
	BTC_SET_BL_FORCE_TO_ROAM = 4,
	BTC_SET_BL_TO_REJ_AP_AGG_PKT = 5,
	BTC_SET_BL_BT_CTRL_AGG_SIZE = 6,
	BTC_SET_BL_INC_SCAN_DEV_NUM = 7,
	BTC_SET_BL_BT_TX_RX_MASK = 8,
	BTC_SET_BL_MIRACAST_PLUS_BT = 9,
	BTC_SET_BL_BT_LNA_CONSTRAIN_LEVEL = 10,
	BTC_SET_BL_BT_GOLDEN_RX_RANGE = 11,
	BTC_SET_U1_RSSI_ADJ_VAL_FOR_AGC_TABLE_ON = 12,
	BTC_SET_U1_AGG_BUF_SIZE = 13,
	BTC_SET_ACT_GET_BT_RSSI = 14,
	BTC_SET_ACT_AGGREGATE_CTRL = 15,
	BTC_SET_ACT_ANTPOSREGRISTRY_CTRL = 16,
	BTC_SET_MIMO_PS_MODE = 17,
	BTC_SET_U1_RSSI_ADJ_VAL_FOR_1ANT_COEX_TYPE = 18,
	BTC_SET_U1_LPS_VAL = 19,
	BTC_SET_U1_RPWM_VAL = 20,
	BTC_SET_ACT_LEAVE_LPS = 21,
	BTC_SET_ACT_ENTER_LPS = 22,
	BTC_SET_ACT_NORMAL_LPS = 23,
	BTC_SET_ACT_PRE_NORMAL_LPS = 24,
	BTC_SET_ACT_POST_NORMAL_LPS = 25,
	BTC_SET_ACT_DISABLE_LOW_POWER = 26,
	BTC_SET_ACT_UPDATE_RAMASK = 27,
	BTC_SET_ACT_SEND_MIMO_PS = 28,
	BTC_SET_ACT_CTRL_BT_INFO = 29,
	BTC_SET_ACT_CTRL_BT_COEX = 30,
	BTC_SET_ACT_CTRL_8723B_ANT = 31,
	BTC_SET_RESET_COEX_VAR = 32,
	BTC_SET_MAX = 33,
};

enum _BTC_DBG_DISP_TYPE {
	BTC_DBG_DISP_COEX_STATISTICS = 0,
	BTC_DBG_DISP_BT_LINK_INFO = 1,
	BTC_DBG_DISP_WIFI_STATUS = 2,
	BTC_DBG_DISP_MAX = 3,
};

enum _BTC_NOTIFY_TYPE_IPS {
	BTC_IPS_LEAVE = 0,
	BTC_IPS_ENTER = 1,
	BTC_IPS_MAX = 2,
};

enum _BTC_NOTIFY_TYPE_LPS {
	BTC_LPS_DISABLE = 0,
	BTC_LPS_ENABLE = 1,
	BTC_LPS_MAX = 2,
};

enum _BTC_NOTIFY_TYPE_SCAN {
	BTC_SCAN_FINISH = 0,
	BTC_SCAN_START = 1,
	BTC_SCAN_START_2G = 2,
	BTC_SCAN_START_5G = 3,
	BTC_SCAN_MAX = 4,
};

enum _BTC_NOTIFY_TYPE_SWITCHBAND {
	BTC_NOT_SWITCH = 0,
	BTC_SWITCH_TO_24G = 1,
	BTC_SWITCH_TO_5G = 2,
	BTC_SWITCH_TO_24G_NOFORSCAN = 3,
	BTC_SWITCH_MAX = 4,
};

enum _BTC_NOTIFY_TYPE_ASSOCIATE {
	BTC_ASSOCIATE_FINISH = 0,
	BTC_ASSOCIATE_START = 1,
	BTC_ASSOCIATE_5G_FINISH = 2,
	BTC_ASSOCIATE_5G_START = 3,
	BTC_ASSOCIATE_MAX = 4,
};

enum _BTC_NOTIFY_TYPE_MEDIA_STATUS {
	BTC_MEDIA_DISCONNECT = 0,
	BTC_MEDIA_CONNECT = 1,
	BTC_MEDIA_CONNECT_5G = 2,
	BTC_MEDIA_MAX = 3,
};

enum _BTC_NOTIFY_TYPE_SPECIFIC_PACKET {
	BTC_PACKET_UNKNOWN = 0,
	BTC_PACKET_DHCP = 1,
	BTC_PACKET_ARP = 2,
	BTC_PACKET_EAPOL = 3,
	BTC_PACKET_MAX = 4,
};

enum _BTC_ANTENNA_POS {
	BTC_ANTENNA_AT_MAIN_PORT = 1,
	BTC_ANTENNA_AT_AUX_PORT = 2,
};

struct _COL_H2C {
	u8 opcode;
	u8 opcode_ver: 4;
	u8 req_num: 4;
	u8 buf[1];
};

typedef struct _COL_H2C *PCOL_H2C;

struct _COL_C2H_ACK {
	u8 status;
	u8 opcode_ver: 4;
	u8 req_num: 4;
	u8 ret_len;
	u8 buf[1];
};

typedef struct _COL_C2H_ACK *PCOL_C2H_ACK;

enum _COL_H2C_STATUS {
	COL_STATUS_C2H_OK = 0,
	COL_STATUS_C2H_UNKNOWN = 1,
	COL_STATUS_C2H_UNKNOWN_OPCODE = 2,
	COL_STATUS_C2H_OPCODE_VER_MISMATCH = 3,
	COL_STATUS_C2H_PARAMETER_ERROR = 4,
	COL_STATUS_C2H_PARAMETER_OUT_OF_RANGE = 5,
	COL_STATUS_C2H_REQ_NUM_MISMATCH = 6,
	COL_STATUS_H2C_HALMAC_FAIL = 7,
	COL_STATUS_H2C_TIMTOUT = 8,
	COL_STATUS_INVALID_C2H_LEN = 9,
	COL_STATUS_COEX_DATA_OVERFLOW = 10,
	COL_STATUS_MAX = 11,
};

typedef enum _COL_H2C_STATUS COL_H2C_STATUS;

enum _COL_OPCODE {
	COL_OP_WIFI_STATUS_NOTIFY = 0,
	COL_OP_WIFI_PROGRESS_NOTIFY = 1,
	COL_OP_WIFI_INFO_NOTIFY = 2,
	COL_OP_WIFI_POWER_STATE_NOTIFY = 3,
	COL_OP_SET_CONTROL = 4,
	COL_OP_GET_CONTROL = 5,
	COL_OP_WIFI_OPCODE_MAX = 6,
};

enum _COL_IND_TYPE {
	COL_IND_BT_INFO = 0,
	COL_IND_PSTDMA = 1,
	COL_IND_LIMITED_TX_RX = 2,
	COL_IND_COEX_TABLE = 3,
	COL_IND_REQ = 4,
	COL_IND_MAX = 5,
};

struct _COL_SINGLE_H2C_RECORD {
	u8 h2c_buf[20];
	u32 h2c_len;
	u8 c2h_ack_buf[20];
	u32 c2h_ack_len;
	u32 count;
	u32 status[11];
};

typedef struct _COL_SINGLE_H2C_RECORD COL_SINGLE_H2C_RECORD;

typedef struct _COL_SINGLE_H2C_RECORD *PCOL_SINGLE_H2C_RECORD;

struct _COL_SINGLE_C2H_IND_RECORD {
	u8 ind_buf[20];
	u32 ind_len;
	u32 count;
	u32 status[11];
};

typedef struct _COL_SINGLE_C2H_IND_RECORD COL_SINGLE_C2H_IND_RECORD;

struct _BTC_OFFLOAD {
	u8 h2c_req_num;
	u32 cnt_h2c_sent;
	COL_SINGLE_H2C_RECORD h2c_record[6];
	u32 cnt_c2h_ack;
	u32 status[11];
	struct completion c2h_event[16];
	u8 c2h_ack_buf[320];
	u8 c2h_ack_len[16];
	u32 cnt_c2h_ind;
	COL_SINGLE_C2H_IND_RECORD c2h_ind_record[5];
	u32 c2h_ind_status[11];
	u8 c2h_ind_buf[20];
	u8 c2h_ind_len;
};

typedef struct _BTC_OFFLOAD BTC_OFFLOAD;

enum _BTC_LINK_MODE {
	BTC_LINK_NONE = 0,
	BTC_LINK_ONLY_GO = 1,
	BTC_LINK_ONLY_GC = 2,
	BTC_LINK_ONLY_STA = 3,
	BTC_LINK_ONLY_AP = 4,
	BTC_LINK_2G_MCC_GO_STA = 5,
	BTC_LINK_5G_MCC_GO_STA = 6,
	BTC_LINK_25G_MCC_GO_STA = 7,
	BTC_LINK_2G_MCC_GC_STA = 8,
	BTC_LINK_5G_MCC_GC_STA = 9,
	BTC_LINK_25G_MCC_GC_STA = 10,
	BTC_LINK_2G_SCC_GO_STA = 11,
	BTC_LINK_5G_SCC_GO_STA = 12,
	BTC_LINK_2G_SCC_GC_STA = 13,
	BTC_LINK_5G_SCC_GC_STA = 14,
	BTC_LINK_MAX = 30,
};

typedef enum _BTC_LINK_MODE BTC_LINK_MODE;

struct btc_wifi_link_info {
	BTC_LINK_MODE link_mode;
	u8 sta_center_channel;
	u8 p2p_center_channel;
	BOOLEAN bany_client_join_go;
	BOOLEAN benable_noa;
	BOOLEAN bhotspot;
};

typedef u8 (*BFP_BTC_R1)(PVOID, u32);

typedef u16 (*BFP_BTC_R2)(PVOID, u32);

typedef u32 (*BFP_BTC_R4)(PVOID, u32);

typedef void (*BFP_BTC_W1)(PVOID, u32, u8);

typedef void (*BFP_BTC_W1_BIT_MASK)(PVOID, u32, u8, u8);

typedef void (*BFP_BTC_W2)(PVOID, u32, u16);

typedef void (*BFP_BTC_W4)(PVOID, u32, u32);

typedef void (*BFP_BTC_LOCAL_REG_W1)(PVOID, u32, u8);

typedef u32 (*BFP_BTC_R_LINDIRECT)(PVOID, u16);

typedef u16 (*BFP_BTC_R_SCBD)(PVOID, u16 *);

typedef u32 (*BFP_BTC_R_SCBD_32BIT)(PVOID, u32 *);

typedef void (*BFP_BTC_W_SCBD)(PVOID, u16, BOOLEAN);

typedef void (*BFP_BTC_W_SCBD_32BIT)(PVOID, u32, BOOLEAN);

typedef void (*BFP_BTC_W_LINDIRECT)(PVOID, u16, u32, u32);

typedef void (*BFP_BTC_SET_BB_REG)(PVOID, u32, u32, u32);

typedef u32 (*BFP_BTC_GET_BB_REG)(PVOID, u32, u32);

typedef void (*BFP_BTC_SET_RF_REG)(PVOID, enum rf_path, u32, u32, u32);

typedef u32 (*BFP_BTC_GET_RF_REG)(PVOID, enum rf_path, u32, u32);

typedef void (*BFP_BTC_FILL_H2C)(PVOID, u8, u32, u8 *);

typedef BOOLEAN (*BFP_BTC_GET)(PVOID, u8, PVOID);

typedef BOOLEAN (*BFP_BTC_SET)(PVOID, u8, PVOID);

typedef u16 (*BFP_BTC_SET_BT_REG)(PVOID, u8, u32, u32);

typedef BOOLEAN (*BFP_BTC_SET_BT_ANT_DETECTION)(PVOID, u8, u8);

typedef BOOLEAN (*BFP_BTC_SET_BT_TRX_MASK)(PVOID, u8);

typedef u32 (*BFP_BTC_GET_BT_REG)(PVOID, u8, u32);

typedef void (*BFP_BTC_DISP_DBG_MSG)(PVOID, u8);

typedef COL_H2C_STATUS (*BFP_BTC_COEX_H2C_PROCESS)(PVOID, u8, u8, u8 *, u8);

typedef u32 (*BFP_BTC_GET_BT_COEX_SUPPORTED_FEATURE)(PVOID);

typedef u32 (*BFP_BTC_GET_BT_COEX_SUPPORTED_VERSION)(PVOID);

typedef u32 (*BFP_BTC_GET_PHYDM_VERSION)(PVOID);

typedef u8 (*BFP_BTC_SET_TIMER)(PVOID, u32, u32);

typedef u32 (*BFP_BTC_SET_ATOMIC)(PVOID, u32 *, u32);

typedef void (*BTC_PHYDM_MODIFY_RA_PCR_THRESHLOD)(PVOID, u8, u8);

typedef u32 (*BTC_PHYDM_CMNINFOQUERY)(PVOID, u8);

typedef void (*BTC_REDUCE_WL_TX_POWER)(PVOID, s8);

typedef void (*BTC_PHYDM_MODIFY_ANTDIV_HWSW)(PVOID, u8);

typedef u8 (*BFP_BTC_GET_ANT_DET_VAL_FROM_BT)(PVOID);

typedef u8 (*BFP_BTC_GET_BLE_SCAN_TYPE_FROM_BT)(PVOID);

typedef u32 (*BFP_BTC_GET_BLE_SCAN_PARA_FROM_BT)(PVOID, u8);

typedef BOOLEAN (*BFP_BTC_GET_BT_AFH_MAP_FROM_BT)(PVOID, u8, u8 *);

struct btc_bt_info {
	bool bt_disabled;
	bool bt_enable_disable_change;
	u8 rssi_adjust_for_agc_table_on;
	u8 rssi_adjust_for_1ant_coex_type;
	bool pre_bt_ctrl_agg_buf_size;
	bool bt_ctrl_agg_buf_size;
	bool pre_reject_agg_pkt;
	bool reject_agg_pkt;
	bool increase_scan_dev_num;
	bool bt_tx_rx_mask;
	u8 pre_agg_buf_size;
	u8 agg_buf_size;
	bool bt_busy;
	bool limited_dig;
	u16 bt_hci_ver;
	u32 bt_real_fw_ver;
	u32 get_bt_fw_ver_cnt;
	u32 bt_get_fw_ver;
	bool miracast_plus_bt;
	bool bt_disable_low_pwr;
	bool bt_ctrl_lps;
	bool bt_lps_on;
	bool force_to_roam;
	u8 lps_val;
	u8 rpwm_val;
	u32 ra_mask;
};

struct btc_stack_info {
	bool profile_notified;
	u16 hci_version;
	u8 num_of_link;
	bool bt_link_exist;
	bool sco_exist;
	bool acl_exist;
	bool a2dp_exist;
	bool hid_exist;
	u8 num_of_hid;
	bool pan_exist;
	bool unknown_acl_exist;
	s8 min_bt_rssi;
};

struct btc_bt_link_info {
	bool bt_link_exist;
	bool bt_hi_pri_link_exist;
	bool sco_exist;
	bool sco_only;
	bool a2dp_exist;
	bool a2dp_only;
	bool hid_exist;
	bool hid_only;
	bool pan_exist;
	bool pan_only;
	bool slave_role;
	bool acl_busy;
};

struct btc_statistics {
	u32 cnt_bind;
	u32 cnt_power_on;
	u32 cnt_pre_load_firmware;
	u32 cnt_init_hw_config;
	u32 cnt_init_coex_dm;
	u32 cnt_ips_notify;
	u32 cnt_lps_notify;
	u32 cnt_scan_notify;
	u32 cnt_connect_notify;
	u32 cnt_media_status_notify;
	u32 cnt_specific_packet_notify;
	u32 cnt_bt_info_notify;
	u32 cnt_rf_status_notify;
	u32 cnt_periodical;
	u32 cnt_coex_dm_switch;
	u32 cnt_stack_operation_notify;
	u32 cnt_dbg_ctrl;
	u32 cnt_rate_id_notify;
	u32 cnt_halt_notify;
	u32 cnt_pnp_notify;
};

struct btc_chip_para;

struct btc_coexist {
	BOOLEAN bBinded;
	PVOID Adapter;
	struct btc_board_info board_info;
	struct btc_bt_info bt_info;
	struct btc_stack_info stack_info;
	struct btc_bt_link_info bt_link_info;
	struct btc_wifi_link_info wifi_link_info;
	struct btc_wifi_link_info_ext wifi_link_info_ext;
	struct btc_coex_dm coex_dm;
	struct btc_coex_sta coex_sta;
	struct btc_rfe_type rfe_type;
	const struct btc_chip_para *chip_para;
	u8 wifi_black_bssid[6];
	u8 wifi_bssid[6];
	BTC_CHIP_INTERFACE chip_interface;
	PVOID odm_priv;
	BOOLEAN initilized;
	BOOLEAN stop_coex_dm;
	BOOLEAN manual_control;
	BOOLEAN bdontenterLPS;
	u8 *cli_buf;
	struct btc_statistics statistics;
	u8 pwrModeVal[10];
	BOOLEAN dbg_mode;
	BOOLEAN auto_report;
	u8 chip_type;
	BOOLEAN wl_rf_state_off;
	BFP_BTC_R1 btc_read_1byte;
	BFP_BTC_W1 btc_write_1byte;
	BFP_BTC_W1_BIT_MASK btc_write_1byte_bitmask;
	BFP_BTC_R2 btc_read_2byte;
	BFP_BTC_W2 btc_write_2byte;
	BFP_BTC_R4 btc_read_4byte;
	BFP_BTC_W4 btc_write_4byte;
	BFP_BTC_LOCAL_REG_W1 btc_write_local_reg_1byte;
	BFP_BTC_R_LINDIRECT btc_read_linderct;
	BFP_BTC_W_LINDIRECT btc_write_linderct;
	BFP_BTC_R_SCBD btc_read_scbd;
	BFP_BTC_R_SCBD_32BIT btc_read_scbd_32bit;
	BFP_BTC_W_SCBD btc_write_scbd;
	BFP_BTC_W_SCBD_32BIT btc_write_scbd_32bit;
	BFP_BTC_SET_BB_REG btc_set_bb_reg;
	BFP_BTC_GET_BB_REG btc_get_bb_reg;
	BFP_BTC_SET_RF_REG btc_set_rf_reg;
	BFP_BTC_GET_RF_REG btc_get_rf_reg;
	BFP_BTC_FILL_H2C btc_fill_h2c;
	BFP_BTC_DISP_DBG_MSG btc_disp_dbg_msg;
	BFP_BTC_GET btc_get;
	BFP_BTC_SET btc_set;
	BFP_BTC_GET_BT_REG btc_get_bt_reg;
	BFP_BTC_SET_BT_REG btc_set_bt_reg;
	BFP_BTC_SET_BT_ANT_DETECTION btc_set_bt_ant_detection;
	BFP_BTC_COEX_H2C_PROCESS btc_coex_h2c_process;
	BFP_BTC_SET_BT_TRX_MASK btc_set_bt_trx_mask;
	BFP_BTC_GET_BT_COEX_SUPPORTED_FEATURE btc_get_bt_coex_supported_feature;
	BFP_BTC_GET_BT_COEX_SUPPORTED_VERSION btc_get_bt_coex_supported_version;
	BFP_BTC_GET_PHYDM_VERSION btc_get_bt_phydm_version;
	BFP_BTC_SET_TIMER btc_set_timer;
	BFP_BTC_SET_ATOMIC btc_set_atomic;
	BTC_PHYDM_MODIFY_RA_PCR_THRESHLOD btc_phydm_modify_RA_PCR_threshold;
	BTC_PHYDM_CMNINFOQUERY btc_phydm_query_PHY_counter;
	BTC_REDUCE_WL_TX_POWER btc_reduce_wl_tx_power;
	BTC_PHYDM_MODIFY_ANTDIV_HWSW btc_phydm_modify_antdiv_hwsw;
	BFP_BTC_GET_ANT_DET_VAL_FROM_BT btc_get_ant_det_val_from_bt;
	BFP_BTC_GET_BLE_SCAN_TYPE_FROM_BT btc_get_ble_scan_type_from_bt;
	BFP_BTC_GET_BLE_SCAN_PARA_FROM_BT btc_get_ble_scan_para_from_bt;
	BFP_BTC_GET_BT_AFH_MAP_FROM_BT btc_get_bt_afh_map_from_bt;
	union {
		struct coex_dm_8723d_1ant coex_dm_8723d_1ant;
		struct coex_dm_8723d_2ant coex_dm_8723d_2ant;
	};
	union {
		struct coex_sta_8723d_1ant coex_sta_8723d_1ant;
		struct coex_sta_8723d_2ant coex_sta_8723d_2ant;
	};
	union {	};
	union {	};
};

typedef struct btc_coexist *PBTC_COEXIST;

typedef void (*BFP_BTC_CHIP_SETUP)(PBTC_COEXIST, u8);

struct btc_chip_para {
	const char *chip_name;
	u32 para_ver_date;
	u32 para_ver;
	u32 bt_desired_ver;
	u32 wl_desired_ver;
	bool scbd_support;
	u32 scbd_reg;
	u8 scbd_bit_num;
	bool mailbox_support;
	bool lte_indirect_access;
	bool new_scbd10_def;
	u8 indirect_type;
	u8 pstdma_type;
	u8 bt_rssi_type;
	u8 ant_isolation;
	u8 rssi_tolerance;
	u8 rx_path_num;
	u8 wl_rssi_step_num;
	const u8 *wl_rssi_step;
	u8 bt_rssi_step_num;
	const u8 *bt_rssi_step;
	u8 table_sant_num;
	const struct btc_coex_table_para *table_sant;
	u8 table_nsant_num;
	const struct btc_coex_table_para *table_nsant;
	u8 tdma_sant_num;
	const struct btc_tdma_para *tdma_sant;
	u8 tdma_nsant_num;
	const struct btc_tdma_para *tdma_nsant;
	u8 wl_rf_para_tx_num;
	const struct btc_rf_para *wl_rf_para_tx;
	const struct btc_rf_para *wl_rf_para_rx;
	u8 bt_afh_span_bw20;
	u8 bt_afh_span_bw40;
	u8 afh_5g_num;
	const struct btc_5g_afh_map *afh_5g;
	BFP_BTC_CHIP_SETUP chip_setup;
};

enum _bt_ext_eid {
	C2H_WIFI_FW_ACTIVE_RSP = 0,
	C2H_TRIG_BY_BT_FW = 1,
};

enum _bt_c2h_status {
	BT_STATUS_OK = 0,
	BT_STATUS_VERSION_MISMATCH = 1,
	BT_STATUS_UNKNOWN_OPCODE = 2,
	BT_STATUS_ERROR_PARAMETER = 3,
};

enum _bt_op_code {
	BT_OP_GET_BT_VERSION = 0,
	BT_OP_WRITE_REG_ADDR = 12,
	BT_OP_WRITE_REG_VALUE = 13,
	BT_OP_READ_REG = 17,
	BT_LO_OP_GET_AFH_MAP_L = 30,
	BT_LO_OP_GET_AFH_MAP_M = 31,
	BT_LO_OP_GET_AFH_MAP_H = 32,
	BT_OP_SET_BT_TRX_MASK = 41,
	BT_OP_GET_BT_COEX_SUPPORTED_FEATURE = 42,
	BT_OP_GET_BT_COEX_SUPPORTED_VERSION = 43,
	BT_OP_GET_BT_ANT_DET_VAL = 44,
	BT_OP_GET_BT_BLE_SCAN_TYPE = 45,
	BT_OP_GET_BT_BLE_SCAN_PARA = 46,
	BT_OP_GET_BT_DEVICE_INFO = 48,
	BT_OP_GET_BT_FORBIDDEN_SLOT_VAL = 49,
	BT_OP_SET_BT_LANCONSTRAIN_LEVEL = 50,
	BT_OP_SET_BT_TEST_MODE_VAL = 51,
	BT_OP_MAX = 52,
};

struct _btcoexdbginfo {
	u8 *info;
	u32 size;
	u32 len;
};

typedef struct _btcoexdbginfo BTCDBGINFO;

typedef struct _btcoexdbginfo *PBTCDBGINFO;

struct ant_isolation {
	char *param_name;
	u8 *value;
};

typedef struct ant_isolation ANT_ISOLATION;

enum _RF_CHIP {
	RF_CHIP_MIN = 0,
	RF_8225 = 1,
	RF_8256 = 2,
	RF_8258 = 3,
	RF_6052 = 4,
	RF_PSEUDO_11N = 5,
	RF_CHIP_MAX = 6,
};

typedef enum _ANTENNA_PATH ANTENNA_PATH;

struct _R_ANTENNA_SELECT_OFDM {
	u32 r_tx_antenna: 4;
	u32 r_ant_l: 4;
	u32 r_ant_non_ht: 4;
	u32 r_ant_ht1: 4;
	u32 r_ant_ht2: 4;
	u32 r_ant_ht_s1: 4;
	u32 r_ant_non_ht_s1: 4;
	u32 OFDM_TXSC: 2;
	u32 Reserved: 2;
};

typedef struct _R_ANTENNA_SELECT_OFDM R_ANTENNA_SELECT_OFDM;

struct _R_ANTENNA_SELECT_CCK {
	u8 r_cckrx_enable_2: 2;
	u8 r_cckrx_enable: 2;
	u8 r_ccktx_enable: 4;
};

typedef struct _R_ANTENNA_SELECT_CCK R_ANTENNA_SELECT_CCK;

enum _MPT_BANDWIDTH {
	MPT_BW_20MHZ = 0,
	MPT_BW_40MHZ_DUPLICATE = 1,
	MPT_BW_40MHZ_ABOVE = 2,
	MPT_BW_40MHZ_BELOW = 3,
	MPT_BW_40MHZ = 4,
	MPT_BW_80MHZ = 5,
	MPT_BW_80MHZ_20_ABOVE = 6,
	MPT_BW_80MHZ_20_BELOW = 7,
	MPT_BW_80MHZ_20_BOTTOM = 8,
	MPT_BW_80MHZ_20_TOP = 9,
	MPT_BW_80MHZ_40_ABOVE = 10,
	MPT_BW_80MHZ_40_BELOW = 11,
};

enum _OFDM_TX_MODE {
	OFDM_ALL_OFF = 0,
	OFDM_ContinuousTx = 1,
	OFDM_SingleCarrier = 2,
	OFDM_SingleTone = 4,
};

enum _MPT_TXPWR_DEF {
	MPT_CCK = 0,
	MPT_OFDM = 1,
	MPT_OFDM_AND_HT = 2,
	MPT_HT = 3,
	MPT_VHT = 4,
};

typedef enum _MPT_TXPWR_DEF MPT_TXPWR_DEF;

enum _PWRSEQ_CMD_DELAY_UNIT_ {
	PWRSEQ_DELAY_US = 0,
	PWRSEQ_DELAY_MS = 1,
};

struct _WL_PWR_CFG_ {
	u16 offset;
	u8 cut_msk;
	u8 fab_msk: 4;
	u8 interface_msk: 4;
	u8 base: 4;
	u8 cmd: 4;
	u8 msk;
	u8 value;
};

typedef struct _WL_PWR_CFG_ WLAN_PWR_CFG;

enum _VHT_DATA_SC {
	VHT_DATA_SC_DONOT_CARE = 0,
	VHT_DATA_SC_20_UPPER_OF_80MHZ = 1,
	VHT_DATA_SC_20_LOWER_OF_80MHZ = 2,
	VHT_DATA_SC_20_UPPERST_OF_80MHZ = 3,
	VHT_DATA_SC_20_LOWEST_OF_80MHZ = 4,
	VHT_DATA_SC_20_RECV1 = 5,
	VHT_DATA_SC_20_RECV2 = 6,
	VHT_DATA_SC_20_RECV3 = 7,
	VHT_DATA_SC_20_RECV4 = 8,
	VHT_DATA_SC_40_UPPER_OF_80MHZ = 9,
	VHT_DATA_SC_40_LOWER_OF_80MHZ = 10,
};

enum AGGRE_SIZE {
	HT_AGG_SIZE_8K = 0,
	HT_AGG_SIZE_16K = 1,
	HT_AGG_SIZE_32K = 2,
	HT_AGG_SIZE_64K = 3,
	VHT_AGG_SIZE_128K = 4,
	VHT_AGG_SIZE_256K = 5,
	VHT_AGG_SIZE_512K = 6,
	VHT_AGG_SIZE_1024K = 7,
};

struct PG_PKT_STRUCT_A {
	u8 offset;
	u8 word_en;
	u8 data[8];
	u8 word_cnts;
};

typedef struct PG_PKT_STRUCT_A PGPKT_STRUCT;

typedef struct PG_PKT_STRUCT_A *PPGPKT_STRUCT;

enum _FIRMWARE_SOURCE {
	FW_SOURCE_IMG_FILE = 0,
	FW_SOURCE_HEADER_FILE = 1,
};

typedef enum _FIRMWARE_SOURCE FIRMWARE_SOURCE;

struct _MP_FIRMWARE {
	FIRMWARE_SOURCE eFWSource;
	u8 *szFwBuffer;
	u32 ulFwLength;
};

typedef struct _MP_FIRMWARE *PRT_MP_FIRMWARE;

enum h2c_cmd_8723D {
	H2C_8723D_RSVD_PAGE = 0,
	H2C_8723D_MEDIA_STATUS_RPT = 1,
	H2C_8723D_SCAN_ENABLE = 2,
	H2C_8723D_KEEP_ALIVE = 3,
	H2C_8723D_DISCON_DECISION = 4,
	H2C_8723D_PSD_OFFLOAD = 5,
	H2C_8723D_AP_OFFLOAD = 8,
	H2C_8723D_BCN_RSVDPAGE = 9,
	H2C_8723D_PROBERSP_RSVDPAGE = 10,
	H2C_8723D_FCS_RSVDPAGE = 16,
	H2C_8723D_FCS_INFO = 17,
	H2C_8723D_AP_WOW_GPIO_CTRL = 19,
	H2C_8723D_SET_PWR_MODE = 32,
	H2C_8723D_PS_TUNING_PARA = 33,
	H2C_8723D_PS_TUNING_PARA2 = 34,
	H2C_8723D_P2P_LPS_PARAM = 35,
	H2C_8723D_P2P_PS_OFFLOAD = 36,
	H2C_8723D_PS_SCAN_ENABLE = 37,
	H2C_8723D_SAP_PS_ = 38,
	H2C_8723D_INACTIVE_PS_ = 39,
	H2C_8723D_FWLPS_IN_IPS_ = 40,
	H2C_8723D_MACID_CFG = 64,
	H2C_8723D_TXBF = 65,
	H2C_8723D_RSSI_SETTING = 66,
	H2C_8723D_AP_REQ_TXRPT = 67,
	H2C_8723D_INIT_RATE_COLLECT = 68,
	H2C_8723D_RA_PARA_ADJUST = 70,
	H2C_8723D_B_TYPE_TDMA = 96,
	H2C_8723D_BT_INFO = 97,
	H2C_8723D_FORCE_BT_TXPWR = 98,
	H2C_8723D_BT_IGNORE_WLANACT = 99,
	H2C_8723D_DAC_SWING_VALUE = 100,
	H2C_8723D_ANT_SEL_RSV = 101,
	H2C_8723D_WL_OPMODE = 102,
	H2C_8723D_BT_MP_OPER = 103,
	H2C_8723D_BT_CONTROL = 104,
	H2C_8723D_BT_WIFI_CTRL = 105,
	H2C_8723D_BT_FW_PATCH = 106,
	H2C_8723D_BT_WLAN_CALIBRATION = 109,
	H2C_8723D_WOWLAN = 128,
	H2C_8723D_REMOTE_WAKE_CTRL = 129,
	H2C_8723D_AOAC_GLOBAL_INFO = 130,
	H2C_8723D_AOAC_RSVD_PAGE = 131,
	H2C_8723D_AOAC_RSVD_PAGE2 = 132,
	H2C_8723D_D0_SCAN_OFFLOAD_CTRL = 133,
	H2C_8723D_D0_SCAN_OFFLOAD_INFO = 134,
	H2C_8723D_CHNL_SWITCH_OFFLOAD = 135,
	H2C_8723D_P2P_OFFLOAD_RSVD_PAGE = 138,
	H2C_8723D_P2P_OFFLOAD = 139,
	H2C_8723D_RESET_TSF = 192,
	H2C_8723D_MAXID = 193,
};

struct _RT_FIRMWARE {
	FIRMWARE_SOURCE eFWSource;
	u8 *szFwBuffer;
	u32 ulFwLength;
};

typedef struct _RT_FIRMWARE *PRT_FIRMWARE_8723D;

struct _RT_8723D_FIRMWARE_HDR {
	u16 Signature;
	u8 Category;
	u8 Function;
	u16 Version;
	u16 Subversion;
	u8 Month;
	u8 Date;
	u8 Hour;
	u8 Minute;
	u16 RamCodeSize;
	u16 Rsvd2;
	u32 SvnIdx;
	u32 Rsvd3;
	u32 Rsvd4;
	u32 Rsvd5;
};

typedef struct _RT_8723D_FIRMWARE_HDR *PRT_8723D_FIRMWARE_HDR;

struct qinfo_8723d {
	u32 head: 8;
	u32 pkt_num: 7;
	u32 tail: 8;
	u32 ac: 2;
	u32 macid: 7;
};

struct bcn_qinfo_8723d {
	u16 head: 8;
	u16 pkt_num: 8;
};

typedef enum _EXTCHNL_OFFSET EXTCHNL_OFFSET;

enum odm_fab {
	ODM_TSMC = 0,
	ODM_UMC = 1,
};

enum _RX_PACKET_TYPE {
	NORMAL_RX = 0,
	TX_REPORT1 = 1,
	TX_REPORT2 = 2,
	HIS_REPORT = 3,
	C2H_PACKET = 4,
};

struct P2P_PS_Offload_t {
	u8 Offload_En: 1;
	u8 role: 1;
	u8 CTWindow_En: 1;
	u8 NoA0_En: 1;
	u8 NoA1_En: 1;
	u8 AllStaSleep: 1;
	u8 discovery: 1;
	u8 rsvd: 1;
};

enum PDM_RATE_TYPE {
	PDM_1SS = 1,
	PDM_2SS = 2,
	PDM_3SS = 3,
	PDM_4SS = 4,
	PDM_CCK = 11,
	PDM_OFDM = 12,
};

enum phydm_ctrl_info_rate {
	ODM_RATE1M = 0,
	ODM_RATE2M = 1,
	ODM_RATE5_5M = 2,
	ODM_RATE11M = 3,
	ODM_RATE6M = 4,
	ODM_RATE9M = 5,
	ODM_RATE12M = 6,
	ODM_RATE18M = 7,
	ODM_RATE24M = 8,
	ODM_RATE36M = 9,
	ODM_RATE48M = 10,
	ODM_RATE54M = 11,
	ODM_RATEMCS0 = 12,
	ODM_RATEMCS1 = 13,
	ODM_RATEMCS2 = 14,
	ODM_RATEMCS3 = 15,
	ODM_RATEMCS4 = 16,
	ODM_RATEMCS5 = 17,
	ODM_RATEMCS6 = 18,
	ODM_RATEMCS7 = 19,
	ODM_RATEMCS8 = 20,
	ODM_RATEMCS9 = 21,
	ODM_RATEMCS10 = 22,
	ODM_RATEMCS11 = 23,
	ODM_RATEMCS12 = 24,
	ODM_RATEMCS13 = 25,
	ODM_RATEMCS14 = 26,
	ODM_RATEMCS15 = 27,
	ODM_RATEMCS16 = 28,
	ODM_RATEMCS17 = 29,
	ODM_RATEMCS18 = 30,
	ODM_RATEMCS19 = 31,
	ODM_RATEMCS20 = 32,
	ODM_RATEMCS21 = 33,
	ODM_RATEMCS22 = 34,
	ODM_RATEMCS23 = 35,
	ODM_RATEMCS24 = 36,
	ODM_RATEMCS25 = 37,
	ODM_RATEMCS26 = 38,
	ODM_RATEMCS27 = 39,
	ODM_RATEMCS28 = 40,
	ODM_RATEMCS29 = 41,
	ODM_RATEMCS30 = 42,
	ODM_RATEMCS31 = 43,
	ODM_RATEVHTSS1MCS0 = 44,
	ODM_RATEVHTSS1MCS1 = 45,
	ODM_RATEVHTSS1MCS2 = 46,
	ODM_RATEVHTSS1MCS3 = 47,
	ODM_RATEVHTSS1MCS4 = 48,
	ODM_RATEVHTSS1MCS5 = 49,
	ODM_RATEVHTSS1MCS6 = 50,
	ODM_RATEVHTSS1MCS7 = 51,
	ODM_RATEVHTSS1MCS8 = 52,
	ODM_RATEVHTSS1MCS9 = 53,
	ODM_RATEVHTSS2MCS0 = 54,
	ODM_RATEVHTSS2MCS1 = 55,
	ODM_RATEVHTSS2MCS2 = 56,
	ODM_RATEVHTSS2MCS3 = 57,
	ODM_RATEVHTSS2MCS4 = 58,
	ODM_RATEVHTSS2MCS5 = 59,
	ODM_RATEVHTSS2MCS6 = 60,
	ODM_RATEVHTSS2MCS7 = 61,
	ODM_RATEVHTSS2MCS8 = 62,
	ODM_RATEVHTSS2MCS9 = 63,
	ODM_RATEVHTSS3MCS0 = 64,
	ODM_RATEVHTSS3MCS1 = 65,
	ODM_RATEVHTSS3MCS2 = 66,
	ODM_RATEVHTSS3MCS3 = 67,
	ODM_RATEVHTSS3MCS4 = 68,
	ODM_RATEVHTSS3MCS5 = 69,
	ODM_RATEVHTSS3MCS6 = 70,
	ODM_RATEVHTSS3MCS7 = 71,
	ODM_RATEVHTSS3MCS8 = 72,
	ODM_RATEVHTSS3MCS9 = 73,
	ODM_RATEVHTSS4MCS0 = 74,
	ODM_RATEVHTSS4MCS1 = 75,
	ODM_RATEVHTSS4MCS2 = 76,
	ODM_RATEVHTSS4MCS3 = 77,
	ODM_RATEVHTSS4MCS4 = 78,
	ODM_RATEVHTSS4MCS5 = 79,
	ODM_RATEVHTSS4MCS6 = 80,
	ODM_RATEVHTSS4MCS7 = 81,
	ODM_RATEVHTSS4MCS8 = 82,
	ODM_RATEVHTSS4MCS9 = 83,
};

enum phydm_ic_ip {
	PHYDM_IC_N = 0,
	PHYDM_IC_AC = 1,
	PHYDM_IC_JGR3 = 2,
};

enum odm_cut_version {
	ODM_CUT_A = 0,
	ODM_CUT_B = 1,
	ODM_CUT_C = 2,
	ODM_CUT_D = 3,
	ODM_CUT_E = 4,
	ODM_CUT_F = 5,
	ODM_CUT_G = 6,
	ODM_CUT_H = 7,
	ODM_CUT_I = 8,
	ODM_CUT_J = 9,
	ODM_CUT_K = 10,
	ODM_CUT_L = 11,
	ODM_CUT_M = 12,
	ODM_CUT_N = 13,
	ODM_CUT_O = 14,
	ODM_CUT_TEST = 15,
};

struct phydm_cfo_rpt {
	s32 cfo_rpt_s[4];
	s32 cfo_rpt_l[4];
	s32 cfo_rpt_acq[4];
	s32 cfo_rpt_sec[4];
	s32 cfo_rpt_end[4];
};

enum phydm_dbg_comp {
	DBG_DIG = 1,
	DBG_RA_MASK = 2,
	DBG_DYN_TXPWR = 4,
	DBG_FA_CNT = 8,
	DBG_RSSI_MNTR = 16,
	DBG_CCKPD = 32,
	DBG_ANT_DIV = 64,
	DBG_SMT_ANT = 128,
	DBG_PWR_TRAIN = 256,
	DBG_RA = 512,
	DBG_PATH_DIV = 1024,
	DBG_DFS = 2048,
	DBG_DYN_ARFR = 4096,
	DBG_ADPTVTY = 8192,
	DBG_CFO_TRK = 16384,
	DBG_ENV_MNTR = 32768,
	DBG_PRI_CCA = 65536,
	DBG_ADPTV_SOML = 131072,
	DBG_LNA_SAT_CHK = 262144,
	DBG_PHY_STATUS = 1048576,
	DBG_TMP = 2097152,
	DBG_FW_TRACE = 4194304,
	DBG_TXBF = 8388608,
	DBG_COMMON_FLOW = 16777216,
	DBG_COMP_MCC = 33554432,
	DBG_FW_DM = 67108864,
	DBG_DM_SUMMARY = 134217728,
	ODM_PHY_CONFIG = 268435456,
	ODM_COMP_INIT = 536870912,
	DBG_CMN = 1073741824,
	ODM_COMP_API = 2147483648,
};

enum phydm_h2c_cmd {
	PHYDM_H2C_RA_MASK = 64,
	PHYDM_H2C_TXBF = 65,
	ODM_H2C_RSSI_REPORT = 66,
	ODM_H2C_IQ_CALIBRATION = 69,
	PHYDM_RA_MASK_ABOVE_3SS = 70,
	ODM_H2C_RA_PARA_ADJUST = 71,
	PHYDM_H2C_DYNAMIC_TX_PATH = 72,
	PHYDM_H2C_FW_TRACE_EN = 73,
	ODM_H2C_WIFI_CALIBRATION = 109,
	PHYDM_H2C_MU = 74,
	PHYDM_H2C_FW_GENERAL_INIT = 76,
	PHYDM_H2C_FW_CLM_MNTR = 77,
	PHYDM_H2C_MCC = 79,
	PHYDM_H2C_RESP_TX_PATH_CTRL = 80,
	PHYDM_H2C_RESP_TX_ANT_CTRL = 81,
	PHYDM_H2C_FW_DM_CTRL = 85,
	ODM_MAX_H2CCMD = 86,
};

struct phydm_command {
	char name[16];
	u8 id;
};

enum PHYDM_CMD_ID {
	PHYDM_HELP = 0,
	PHYDM_DEMO = 1,
	PHYDM_RF_CMD = 2,
	PHYDM_DIG = 3,
	PHYDM_RA = 4,
	PHYDM_PROFILE = 5,
	PHYDM_ANTDIV = 6,
	PHYDM_PATHDIV = 7,
	PHYDM_DEBUG = 8,
	PHYDM_MP_DEBUG = 9,
	PHYDM_FW_DEBUG = 10,
	PHYDM_SUPPORT_ABILITY = 11,
	PHYDM_GET_TXAGC = 12,
	PHYDM_SET_TXAGC = 13,
	PHYDM_SMART_ANT = 14,
	PHYDM_CH_BW = 15,
	PHYDM_TRX_PATH = 16,
	PHYDM_LA_MODE = 17,
	PHYDM_DUMP_REG = 18,
	PHYDM_AUTO_DBG = 19,
	PHYDM_DD_DBG = 20,
	PHYDM_BIG_JUMP = 21,
	PHYDM_SHOW_RXRATE = 22,
	PHYDM_NBI_EN = 23,
	PHYDM_CSI_MASK_EN = 24,
	PHYDM_DFS_DEBUG = 25,
	PHYDM_DFS_HIST = 26,
	PHYDM_NHM = 27,
	PHYDM_CLM = 28,
	PHYDM_FAHM = 29,
	PHYDM_ENV_MNTR = 30,
	PHYDM_BB_INFO = 31,
	PHYDM_H2C = 32,
	PHYDM_EXT_RF_E_CTRL = 33,
	PHYDM_ADAPTIVE_SOML = 34,
	PHYDM_PSD = 35,
	PHYDM_DEBUG_PORT = 36,
	PHYDM_DIS_HTSTF_CONTROL = 37,
	PHYDM_CFO_TRK = 38,
	PHYDM_ADAPTIVITY_DEBUG = 39,
	PHYDM_DIS_DYM_ANT_WEIGHTING = 40,
	PHYDM_FORECE_PT_STATE = 41,
	PHYDM_STA_INFO = 42,
	PHYDM_PAUSE_FUNC = 43,
	PHYDM_PER_TONE_EVM = 44,
	PHYDM_DYN_TXPWR = 45,
	PHYDM_LNA_SAT = 46,
	PHYDM_ANAPAR = 47,
	PHYDM_CCK_RX_PATHDIV = 48,
	PHYDM_BEAM_FORMING = 49,
	PHYDM_REG_MONITOR = 50,
	PHYDM_PHY_STATUS = 51,
	PHYDM_CRC32_CNT = 52,
	PHYDM_DCC = 53,
	PHYDM_PMAC_TX = 54,
	PHYDM_GET_RXAGC = 55,
	PHYDM_SHIFT_RXAGC = 56,
	PHYDM_IFS_CLM = 57,
	PHYDM_ENHANCE_MNTR = 58,
	PHYDM_CSI_DBG = 59,
};

enum phydm_c2h_evt {
	PHYDM_C2H_DBG = 0,
	PHYDM_C2H_LB = 1,
	PHYDM_C2H_XBF = 2,
	PHYDM_C2H_TX_REPORT = 3,
	PHYDM_C2H_INFO = 9,
	PHYDM_C2H_BT_MP = 11,
	PHYDM_C2H_RA_RPT = 12,
	PHYDM_C2H_RA_PARA_RPT = 14,
	PHYDM_C2H_DYNAMIC_TX_PATH_RPT = 15,
	PHYDM_C2H_IQK_FINISH = 17,
	PHYDM_C2H_CLM_MONITOR = 42,
	PHYDM_C2H_DBG_CODE = 254,
	PHYDM_C2H_EXTEND = 255,
};

enum phydm_extend_c2h_evt {
	PHYDM_EXTEND_C2H_DBG_PRINT = 0,
};

struct phy_rx_agc_info {
	u8 gain: 7;
	u8 trsw: 1;
};

struct phy_status_rpt_8192cd {
	struct phy_rx_agc_info path_agc[2];
	u8 ch_corr[2];
	u8 cck_sig_qual_ofdm_pwdb_all;
	u8 cck_agc_rpt_ofdm_cfosho_a;
	u8 cck_rpt_b_ofdm_cfosho_b;
	u8 rsvd_1;
	u8 noise_power_db_msb;
	s8 path_cfotail[2];
	u8 pcts_mask[2];
	s8 stream_rxevm[2];
	u8 path_rxsnr[2];
	u8 noise_power_db_lsb;
	u8 rsvd_2[3];
	u8 stream_csi[2];
	u8 stream_target_csi[2];
	s8 sig_evm;
	u8 rsvd_3;
	u8 antsel_rx_keep_2: 1;
	u8 sgi_en: 1;
	u8 rxsc: 2;
	u8 idle_long: 1;
	u8 r_ant_train_en: 1;
	u8 ant_sel_b: 1;
	u8 ant_sel: 1;
};

enum phydm_init_result {
	PHYDM_INIT_SUCCESS = 0,
	PHYDM_INIT_FAIL_BBRF_REG_INVALID = 1,
};

enum phydm_structure_type {
	PHYDM_FALSEALMCNT = 0,
	PHYDM_CFOTRACK = 1,
	PHYDM_ADAPTIVITY = 2,
	PHYDM_DFS = 3,
	PHYDM_ROMINFO = 4,
};

enum phydm_dig_trend {
	DIG_STABLE = 0,
	DIG_INCREASING = 1,
	DIG_DECREASING = 2,
};

enum phydm_fw_dig_mode_e {
	DIG_PERFORMANCE_MODE = 0,
	DIG_COVERAGE_MODE = 1,
	DIG_LPS_MODE = 2,
};

enum phydm_edcca_mode {
	PHYDM_EDCCA_NORMAL_MODE = 0,
	PHYDM_EDCCA_ADAPT_MODE = 1,
};

enum phydm_legacy_spec_rate {
	PHYDM_SPEC_RATE_6M = 11,
	PHYDM_SPEC_RATE_9M = 15,
	PHYDM_SPEC_RATE_12M = 10,
	PHYDM_SPEC_RATE_18M = 14,
	PHYDM_SPEC_RATE_24M = 9,
	PHYDM_SPEC_RATE_36M = 13,
	PHYDM_SPEC_RATE_48M = 8,
	PHYDM_SPEC_RATE_54M = 12,
};

enum odm_band_type {
	ODM_BAND_2_4G = 0,
	ODM_BAND_5G = 1,
	ODM_BAND_ON_BOTH = 2,
	ODM_BANDMAX = 3,
};

enum phydm_ra_dbg_para {
	RADBG_PCR_TH_OFFSET = 0,
	RADBG_RTY_PENALTY = 1,
	RADBG_N_HIGH = 2,
	RADBG_N_LOW = 3,
	RADBG_TRATE_UP_TABLE = 4,
	RADBG_TRATE_DOWN_TABLE = 5,
	RADBG_TRYING_NECESSARY = 6,
	RADBG_TDROPING_NECESSARY = 7,
	RADBG_RATE_UP_RTY_RATIO = 8,
	RADBG_RATE_DOWN_RTY_RATIO = 9,
	RADBG_DEBUG_MONITOR1 = 12,
	RADBG_DEBUG_MONITOR2 = 13,
	RADBG_DEBUG_MONITOR3 = 14,
	RADBG_DEBUG_MONITOR4 = 15,
	RADBG_DEBUG_MONITOR5 = 16,
	NUM_RA_PARA = 17,
};

enum phydm_wireless_mode {
	PHYDM_WIRELESS_MODE_UNKNOWN = 0,
	PHYDM_WIRELESS_MODE_A = 1,
	PHYDM_WIRELESS_MODE_B = 2,
	PHYDM_WIRELESS_MODE_G = 4,
	PHYDM_WIRELESS_MODE_AUTO = 8,
	PHYDM_WIRELESS_MODE_N_24G = 16,
	PHYDM_WIRELESS_MODE_N_5G = 32,
	PHYDM_WIRELESS_MODE_AC_5G = 64,
	PHYDM_WIRELESS_MODE_AC_24G = 128,
	PHYDM_WIRELESS_MODE_AC_ONLY = 256,
	PHYDM_WIRELESS_MODE_MAX = 2048,
	PHYDM_WIRELESS_MODE_ALL = 65535,
};

enum phydm_rateid_idx {
	PHYDM_BGN_40M_2SS = 0,
	PHYDM_BGN_40M_1SS = 1,
	PHYDM_BGN_20M_2SS = 2,
	PHYDM_BGN_20M_1SS = 3,
	PHYDM_GN_N2SS = 4,
	PHYDM_GN_N1SS = 5,
	PHYDM_BG = 6,
	PHYDM_G = 7,
	PHYDM_B_20M = 8,
	PHYDM_ARFR0_AC_2SS = 9,
	PHYDM_ARFR1_AC_1SS = 10,
	PHYDM_ARFR2_AC_2G_1SS = 11,
	PHYDM_ARFR3_AC_2G_2SS = 12,
	PHYDM_ARFR4_AC_3SS = 13,
	PHYDM_ARFR5_N_3SS = 14,
	PHYDM_ARFR7_N_4SS = 15,
	PHYDM_ARFR6_AC_4SS = 16,
};

enum phydm_rateid_idx_type_2 {
	PHYDM_TYPE2_AC_2SS = 9,
	PHYDM_TYPE2_AC_1SS = 10,
	PHYDM_TYPE2_MIX_1SS = 11,
	PHYDM_TYPE2_MIX_2SS = 12,
	PHYDM_TYPE2_ARFR3_AC_2G_2SS = 16,
	PHYDM_TYPE2_ARFR5_AC_2G_1SS = 18,
};

enum phydm_qam_order {
	PHYDM_QAM_CCK = 0,
	PHYDM_QAM_BPSK = 1,
	PHYDM_QAM_QPSK = 2,
	PHYDM_QAM_16QAM = 3,
	PHYDM_QAM_64QAM = 4,
	PHYDM_QAM_256QAM = 5,
};

struct ra_mask_rpt_trig {
	u8 ra_mask_rpt_stamp;
	u8 macid;
};

struct ra_mask_rpt {
	u8 ra_mask_rpt_stamp;
	u8 ra_mask_buf[8];
};

enum phydm_mac_edcca_type {
	PHYDM_IGNORE_EDCCA = 0,
	PHYDM_DONT_IGNORE_EDCCA = 1,
};

enum phydm_adaptivity_debug_mode {
	PHYDM_ADAPT_MSG = 0,
	PHYDM_ADAPT_DEBUG = 1,
	PHYDM_ADAPT_RESUME = 2,
};

enum halrf_lna_set {
	HALRF_LNA_DISABLE = 0,
	HALRF_LNA_ENABLE = 1,
};

struct noise_level {
	u8 value[4];
	s8 sval[4];
	s32 sum[4];
	u8 valid[4];
	u8 valid_cnt[4];
};

enum ODM_MGN_RATE {
	ODM_MGN_1M = 2,
	ODM_MGN_2M = 4,
	ODM_MGN_5_5M = 11,
	ODM_MGN_6M = 12,
	ODM_MGN_9M = 18,
	ODM_MGN_11M = 22,
	ODM_MGN_12M = 24,
	ODM_MGN_18M = 36,
	ODM_MGN_24M = 48,
	ODM_MGN_36M = 72,
	ODM_MGN_48M = 96,
	ODM_MGN_54M = 108,
	ODM_MGN_MCS32 = 127,
	ODM_MGN_MCS0 = 128,
	ODM_MGN_MCS1 = 129,
	ODM_MGN_MCS2 = 130,
	ODM_MGN_MCS3 = 131,
	ODM_MGN_MCS4 = 132,
	ODM_MGN_MCS5 = 133,
	ODM_MGN_MCS6 = 134,
	ODM_MGN_MCS7 = 135,
	ODM_MGN_MCS8 = 136,
	ODM_MGN_MCS9 = 137,
	ODM_MGN_MCS10 = 138,
	ODM_MGN_MCS11 = 139,
	ODM_MGN_MCS12 = 140,
	ODM_MGN_MCS13 = 141,
	ODM_MGN_MCS14 = 142,
	ODM_MGN_MCS15 = 143,
	ODM_MGN_MCS16 = 144,
	ODM_MGN_MCS17 = 145,
	ODM_MGN_MCS18 = 146,
	ODM_MGN_MCS19 = 147,
	ODM_MGN_MCS20 = 148,
	ODM_MGN_MCS21 = 149,
	ODM_MGN_MCS22 = 150,
	ODM_MGN_MCS23 = 151,
	ODM_MGN_MCS24 = 152,
	ODM_MGN_MCS25 = 153,
	ODM_MGN_MCS26 = 154,
	ODM_MGN_MCS27 = 155,
	ODM_MGN_MCS28 = 156,
	ODM_MGN_MCS29 = 157,
	ODM_MGN_MCS30 = 158,
	ODM_MGN_MCS31 = 159,
	ODM_MGN_VHT1SS_MCS0 = 160,
	ODM_MGN_VHT1SS_MCS1 = 161,
	ODM_MGN_VHT1SS_MCS2 = 162,
	ODM_MGN_VHT1SS_MCS3 = 163,
	ODM_MGN_VHT1SS_MCS4 = 164,
	ODM_MGN_VHT1SS_MCS5 = 165,
	ODM_MGN_VHT1SS_MCS6 = 166,
	ODM_MGN_VHT1SS_MCS7 = 167,
	ODM_MGN_VHT1SS_MCS8 = 168,
	ODM_MGN_VHT1SS_MCS9 = 169,
	ODM_MGN_VHT2SS_MCS0 = 170,
	ODM_MGN_VHT2SS_MCS1 = 171,
	ODM_MGN_VHT2SS_MCS2 = 172,
	ODM_MGN_VHT2SS_MCS3 = 173,
	ODM_MGN_VHT2SS_MCS4 = 174,
	ODM_MGN_VHT2SS_MCS5 = 175,
	ODM_MGN_VHT2SS_MCS6 = 176,
	ODM_MGN_VHT2SS_MCS7 = 177,
	ODM_MGN_VHT2SS_MCS8 = 178,
	ODM_MGN_VHT2SS_MCS9 = 179,
	ODM_MGN_VHT3SS_MCS0 = 180,
	ODM_MGN_VHT3SS_MCS1 = 181,
	ODM_MGN_VHT3SS_MCS2 = 182,
	ODM_MGN_VHT3SS_MCS3 = 183,
	ODM_MGN_VHT3SS_MCS4 = 184,
	ODM_MGN_VHT3SS_MCS5 = 185,
	ODM_MGN_VHT3SS_MCS6 = 186,
	ODM_MGN_VHT3SS_MCS7 = 187,
	ODM_MGN_VHT3SS_MCS8 = 188,
	ODM_MGN_VHT3SS_MCS9 = 189,
	ODM_MGN_VHT4SS_MCS0 = 190,
	ODM_MGN_VHT4SS_MCS1 = 191,
	ODM_MGN_VHT4SS_MCS2 = 192,
	ODM_MGN_VHT4SS_MCS3 = 193,
	ODM_MGN_VHT4SS_MCS4 = 194,
	ODM_MGN_VHT4SS_MCS5 = 195,
	ODM_MGN_VHT4SS_MCS6 = 196,
	ODM_MGN_VHT4SS_MCS7 = 197,
	ODM_MGN_VHT4SS_MCS8 = 198,
	ODM_MGN_VHT4SS_MCS9 = 199,
	ODM_MGN_UNKNOWN = 200,
};

enum phydm_clm_level {
	CLM_RELEASE = 0,
	CLM_LV_1 = 1,
	CLM_LV_2 = 2,
	CLM_LV_3 = 3,
	CLM_LV_4 = 4,
	CLM_MAX_NUM = 5,
};

enum phydm_nhm_level {
	NHM_RELEASE = 0,
	NHM_LV_1 = 1,
	NHM_LV_2 = 2,
	NHM_LV_3 = 3,
	NHM_LV_4 = 4,
	NHM_MAX_NUM = 5,
};

enum phydm_fahm_level {
	FAHM_RELEASE = 0,
	FAHM_LV_1 = 1,
	FAHM_LV_2 = 2,
	FAHM_LV_3 = 3,
	FAHM_LV_4 = 4,
	FAHM_MAX_NUM = 5,
};

enum phydm_ifs_clm_level {
	IFS_CLM_RELEASE = 0,
	IFS_CLM_LV_1 = 1,
	IFS_CLM_LV_2 = 2,
	IFS_CLM_LV_3 = 3,
	IFS_CLM_LV_4 = 4,
	IFS_CLM_MAX_NUM = 5,
};

enum fahm_application {
	FAHM_BACKGROUND = 0,
	FAHM_ACS = 1,
	FAHM_DBG = 2,
};

enum ifs_clm_application {
	IFS_CLM_BACKGROUND = 0,
	IFS_CLM_ACS = 1,
	IFS_CLM_HP_TAS = 2,
	IFS_CLM_DBG = 3,
};

enum phydm_ifs_clm_unit {
	IFS_CLM_4 = 0,
	IFS_CLM_8 = 1,
	IFS_CLM_12 = 2,
	IFS_CLM_16 = 3,
	IFS_CLM_INIT = 4,
};

struct env_trig_rpt {
	u8 nhm_rpt_stamp;
	u8 clm_rpt_stamp;
};

struct env_mntr_rpt {
	u8 nhm_ratio;
	u8 nhm_env_ratio;
	u8 nhm_result[12];
	u8 clm_ratio;
	u8 nhm_rpt_stamp;
	u8 clm_rpt_stamp;
	u8 nhm_noise_pwr;
	u8 nhm_pwr;
};

struct enhance_mntr_trig_rpt {
	u8 nhm_rpt_stamp;
	u8 clm_rpt_stamp;
	u8 fahm_rpt_stamp;
	u8 ifs_clm_rpt_stamp;
};

struct enhance_mntr_rpt {
	u8 nhm_ratio;
	u8 nhm_env_ratio;
	u8 nhm_result[12];
	u8 clm_ratio;
	u8 nhm_rpt_stamp;
	u8 clm_rpt_stamp;
	u8 nhm_noise_pwr;
	u8 nhm_pwr;
	u16 fahm_result[12];
	u8 fahm_rpt_stamp;
	u8 fahm_pwr;
	u8 fahm_ratio;
	u8 fahm_denom_ratio;
	u8 fahm_inclu_cck;
	u8 ifs_clm_rpt_stamp;
	u8 ifs_clm_tx_ratio;
	u8 ifs_clm_edcca_excl_cca_ratio;
	u8 ifs_clm_cck_fa_ratio;
	u8 ifs_clm_cck_cca_excl_fa_ratio;
	u8 ifs_clm_ofdm_fa_ratio;
	u8 ifs_clm_ofdm_cca_excl_fa_ratio;
};

struct nhm_para_info {
	enum nhm_option_txon_all incld_txon;
	enum nhm_option_cca_all incld_cca;
	enum nhm_divider_opt_all div_opt;
	enum nhm_application nhm_app;
	enum phydm_nhm_level nhm_lv;
	u16 mntr_time;
	bool en_1db_mode;
	u8 nhm_th0_manual;
};

struct clm_para_info {
	enum clm_application clm_app;
	enum phydm_clm_level clm_lv;
	u16 mntr_time;
};

struct fahm_para_info {
	enum fahm_application app;
	enum phydm_fahm_level lv;
	u16 mntr_time;
	u8 numer_opt;
	u8 denom_opt;
	bool en_1db_mode;
	u8 th0_manual;
};

struct ifs_clm_para_info {
	enum ifs_clm_application ifs_clm_app;
	enum phydm_ifs_clm_level ifs_clm_lv;
	enum phydm_ifs_clm_unit ifs_clm_ctrl_unit;
	u16 mntr_time;
	bool ifs_clm_th_en[4];
	u16 ifs_clm_th_low[4];
	u16 ifs_clm_th_high[4];
	s16 th_shift;
};

struct n_dbgport_803 {
	u8 bb_rst_b: 1;
	u8 glb_rst_b: 1;
	u8 zero_1bit_1: 1;
	u8 ofdm_rst_b: 1;
	u8 cck_txpe: 1;
	u8 ofdm_txpe: 1;
	u8 phy_tx_on: 1;
	u8 tdrdy: 1;
	u8 txd: 8;
	u8 cck_cca_pp: 1;
	u8 ofdm_cca_pp: 1;
	u8 rx_rst: 1;
	u8 rdrdy: 1;
	u8 rxd_7_4: 4;
	u8 rxd_3_0: 4;
	u8 ofdm_tx_en: 1;
	u8 cck_tx_en: 1;
	u8 zero_1bit_2: 1;
	u8 clk_80m: 1;
};

enum odm_rf_band {
	ODM_RF_BAND_2G = 0,
	ODM_RF_BAND_5G_LOW = 1,
	ODM_RF_BAND_5G_MID = 2,
	ODM_RF_BAND_5G_HIGH = 3,
};

enum phydm_sec_chnl_offset {
	PHYDM_DONT_CARE = 0,
	PHYDM_BELOW = 1,
	PHYDM_ABOVE = 2,
};

enum pow_train_state {
	DYNAMIC_POW_TRAIN = 0,
	ENABLE_POW_TRAIN = 1,
	DISABLE_POW_TRAIN = 2,
};

enum power_training_score {
	DISABLE_PT_SCORE = 0,
	KEEP_PRE_PT_SCORE = 1,
	ENABLE_PT_SCORE = 2,
};

enum halrf_ability {
	HAL_RF_TX_PWR_TRACK = 1,
	HAL_RF_IQK = 2,
	HAL_RF_LCK = 4,
	HAL_RF_DPK = 8,
	HAL_RF_TXGAPK = 16,
	HAL_RF_DACK = 32,
	HAL_RF_DPK_TRACK = 64,
	HAL_2GBAND_SHIFT = 128,
	HAL_RF_RXDCK = 256,
};

enum halrf_dbg_comp {
	DBG_RF_TX_PWR_TRACK = 1,
	DBG_RF_IQK = 2,
	DBG_RF_LCK = 4,
	DBG_RF_DPK = 8,
	DBG_RF_TXGAPK = 16,
	DBG_RF_DACK = 32,
	DBG_RF_DPK_TRACK = 64,
	DBG_RF_RFK = 512,
	DBG_RF_MP = 536870912,
	DBG_RF_TMP = 1073741824,
	DBG_RF_INIT = 2147483648,
};

enum halrf_k_segment_time {
	SEGMENT_FREE = 0,
	SEGMENT_10MS = 10,
	SEGMENT_30MS = 30,
	SEGMENT_50MS = 50,
};

struct halrf_command {
	char name[16];
	u8 id;
};

enum halrf_CMD_ID {
	HALRF_HELP = 0,
	HALRF_SUPPORTABILITY = 1,
	HALRF_DBG_COMP = 2,
	HALRF_PROFILE = 3,
	HALRF_IQK_INFO = 4,
	HALRF_IQK = 5,
	HALRF_IQK_DEBUG = 6,
	HALRF_DPK = 7,
	HALRF_DACK = 8,
	HALRF_DACK_DEBUG = 9,
	HALRF_DUMP_RFK_REG = 10,
};

enum pwrtrack_method {
	BBSWING = 0,
	TXAGC = 1,
	MIX_MODE = 2,
	TSSI_MODE = 3,
	MIX_2G_TSSI_5G_MODE = 4,
	MIX_5G_TSSI_2G_MODE = 5,
	CLEAN_MODE = 6,
};

typedef void (*func_set_pwr)(void *, enum pwrtrack_method, u8, u8);

typedef void (*func_iqk)(void *, u8, u8, u8);

typedef void (*func_lck)(void *);

typedef void (*func_tssi_dck)(void *, u8);

typedef void (*func_swing)(void *, u8 **, u8 **, u8 **, u8 **);

typedef void (*func_swing8814only)(void *, u8 **, u8 **, u8 **, u8 **);

typedef void (*func_swing_xtal)(void *, s8 **, s8 **);

typedef void (*func_set_xtal)(void *);

struct txpwrtrack_cfg {
	u8 swing_table_size_cck;
	u8 swing_table_size_ofdm;
	u8 threshold_iqk;
	u8 threshold_dpk;
	u8 average_thermal_num;
	u8 rf_path_count;
	u32 thermal_reg_addr;
	func_set_pwr odm_tx_pwr_track_set_pwr;
	func_iqk do_iqk;
	func_lck phy_lc_calibrate;
	func_tssi_dck do_tssi_dck;
	func_swing get_delta_swing_table;
	func_swing8814only get_delta_swing_table8814only;
	func_swing_xtal get_delta_swing_xtal_table;
	func_set_xtal odm_txxtaltrack_set_xtal;
};

enum phydm_kfree_channeltosw {
	PHYDM_2G = 0,
	PHYDM_5GLB1 = 1,
	PHYDM_5GLB2 = 2,
	PHYDM_5GMB1 = 3,
	PHYDM_5GMB2 = 4,
	PHYDM_5GHB = 5,
};

enum rt_status {
	RT_STATUS_SUCCESS = 0,
	RT_STATUS_FAILURE = 1,
	RT_STATUS_PENDING = 2,
	RT_STATUS_RESOURCE = 3,
	RT_STATUS_INVALID_CONTEXT = 4,
	RT_STATUS_INVALID_PARAMETER = 5,
	RT_STATUS_NOT_SUPPORT = 6,
	RT_STATUS_OS_API_FAILED = 7,
};

enum bt_8723d_1ant_signal_state {
	BT_8723D_1ANT_SIG_STA_SET_TO_LOW = 0,
	BT_8723D_1ANT_SIG_STA_SET_BY_HW = 0,
	BT_8723D_1ANT_SIG_STA_SET_TO_HIGH = 1,
	BT_8723D_1ANT_SIG_STA_MAX = 2,
};

enum bt_8723d_1ant_path_ctrl_owner {
	BT_8723D_1ANT_PCO_BTSIDE = 0,
	BT_8723D_1ANT_PCO_WLSIDE = 1,
	BT_8723D_1ANT_PCO_MAX = 2,
};

enum bt_8723d_1ant_gnt_ctrl_type {
	BT_8723D_1ANT_GNT_TYPE_CTRL_BY_PTA = 0,
	BT_8723D_1ANT_GNT_TYPE_CTRL_BY_SW = 1,
	BT_8723D_1ANT_GNT_TYPE_MAX = 2,
};

enum bt_8723d_1ant_gnt_ctrl_block {
	BT_8723D_1ANT_GNT_BLOCK_RFC_BB = 0,
	BT_8723D_1ANT_GNT_BLOCK_RFC = 1,
	BT_8723D_1ANT_GNT_BLOCK_BB = 2,
	BT_8723D_1ANT_GNT_BLOCK_MAX = 3,
};

enum bt_8723d_1ant_lte_coex_table_type {
	BT_8723D_1ANT_CTT_WL_VS_LTE = 0,
	BT_8723D_1ANT_CTT_BT_VS_LTE = 1,
	BT_8723D_1ANT_CTT_MAX = 2,
};

enum bt_info_src_8723d_1ant {
	BT_INFO_SRC_8723D_1ANT_WIFI_FW = 0,
	BT_INFO_SRC_8723D_1ANT_BT_RSP = 1,
	BT_INFO_SRC_8723D_1ANT_BT_ACTIVE_SEND = 2,
	BT_INFO_SRC_8723D_1ANT_MAX = 3,
};

enum bt_8723d_1ant_bt_status {
	BT_8723D_1ANT_BT_STATUS_NON_CONNECTED_IDLE = 0,
	BT_8723D_1ANT_BT_STATUS_CONNECTED_IDLE = 1,
	BT_8723D_1ANT_BT_STATUS_INQ_PAGE = 2,
	BT_8723D_1ANT_BT_STATUS_ACL_BUSY = 3,
	BT_8723D_1ANT_BT_STATUS_SCO_BUSY = 4,
	BT_8723D_1ANT_BT_STATUS_ACL_SCO_BUSY = 5,
	BT_8723D_1ANT_BT_STATUS_MAX = 6,
};

enum bt_8723d_1ant_coex_algo {
	BT_8723D_1ANT_COEX_ALGO_UNDEFINED = 0,
	BT_8723D_1ANT_COEX_ALGO_SCO = 1,
	BT_8723D_1ANT_COEX_ALGO_HID = 2,
	BT_8723D_1ANT_COEX_ALGO_A2DP = 3,
	BT_8723D_1ANT_COEX_ALGO_A2DP_PANHS = 4,
	BT_8723D_1ANT_COEX_ALGO_PANEDR = 5,
	BT_8723D_1ANT_COEX_ALGO_PANHS = 6,
	BT_8723D_1ANT_COEX_ALGO_PANEDR_A2DP = 7,
	BT_8723D_1ANT_COEX_ALGO_PANEDR_HID = 8,
	BT_8723D_1ANT_COEX_ALGO_HID_A2DP_PANEDR = 9,
	BT_8723D_1ANT_COEX_ALGO_HID_A2DP = 10,
	BT_8723D_1ANT_COEX_ALGO_MAX = 11,
};

enum bt_8723d_1ant_phase {
	BT_8723D_1ANT_PHASE_COEX_INIT = 0,
	BT_8723D_1ANT_PHASE_WLANONLY_INIT = 1,
	BT_8723D_1ANT_PHASE_WLAN_OFF = 2,
	BT_8723D_1ANT_PHASE_2G_RUNTIME = 3,
	BT_8723D_1ANT_PHASE_5G_RUNTIME = 4,
	BT_8723D_1ANT_PHASE_BTMPMODE = 5,
	BT_8723D_1ANT_PHASE_ANTENNA_DET = 6,
	BT_8723D_1ANT_PHASE_COEX_POWERON = 7,
	BT_8723D_1ANT_PHASE_MAX = 8,
};

enum bt_8723d_1ant_Scoreboard {
	BT_8723D_1ANT_SCOREBOARD_ACTIVE = 1,
	BT_8723D_1ANT_SCOREBOARD_ONOFF = 2,
	BT_8723D_1ANT_SCOREBOARD_SCAN = 4,
	BT_8723D_1ANT_SCOREBOARD_UNDERTEST = 8,
	BT_8723D_1ANT_SCOREBOARD_RXGAIN = 16,
	BT_8723D_1ANT_SCOREBOARD_DKTOPP2M = 32,
	BT_8723D_1ANT_SCOREBOARD_WLBUSY = 64,
	BT_8723D_1ANT_SCOREBOARD_TDMA = 512,
};

struct psdscan_sta_8723d_1ant {
	u32 ant_det_bt_le_channel;
	u32 ant_det_bt_tx_time;
	u32 ant_det_pre_psdscan_peak_val;
	bool ant_det_is_ant_det_available;
	u32 ant_det_psd_scan_peak_val;
	bool ant_det_is_btreply_available;
	u32 ant_det_psd_scan_peak_freq;
	u8 ant_det_result;
	u8 ant_det_peak_val[16];
	u8 ant_det_peak_freq[16];
	u32 ant_det_try_count;
	u32 ant_det_fail_count;
	u32 ant_det_inteval_count;
	u32 ant_det_thres_offset;
	u32 real_cent_freq;
	s32 real_offset;
	u32 real_span;
	u32 psd_band_width;
	u32 psd_point;
	u32 psd_report[1024];
	u32 psd_report_max_hold[1024];
	u32 psd_start_point;
	u32 psd_stop_point;
	u32 psd_max_value_point;
	u32 psd_max_value;
	u32 psd_max_value2;
	u32 psd_avg_value;
	u32 psd_loop_max_value[50];
	u32 psd_start_base;
	u32 psd_avg_num;
	u32 psd_gen_count;
	bool is_antdet_running;
	bool is_psd_show_max_only;
};

enum _BTC_POWERSAVE_TYPE {
	BTC_PS_WIFI_NATIVE = 0,
	BTC_PS_LPS_ON = 1,
	BTC_PS_LPS_OFF = 2,
	BTC_PS_MAX = 3,
};

enum _BTC_RSSI_STATE {
	BTC_RSSI_STATE_HIGH = 0,
	BTC_RSSI_STATE_MEDIUM = 1,
	BTC_RSSI_STATE_LOW = 2,
	BTC_RSSI_STATE_STAY_HIGH = 3,
	BTC_RSSI_STATE_STAY_MEDIUM = 4,
	BTC_RSSI_STATE_STAY_LOW = 5,
	BTC_RSSI_MAX = 6,
};

enum _BTC_IOT_PEER {
	BTC_IOT_PEER_UNKNOWN = 0,
	BTC_IOT_PEER_REALTEK = 1,
	BTC_IOT_PEER_REALTEK_92SE = 2,
	BTC_IOT_PEER_BROADCOM = 3,
	BTC_IOT_PEER_RALINK = 4,
	BTC_IOT_PEER_ATHEROS = 5,
	BTC_IOT_PEER_CISCO = 6,
	BTC_IOT_PEER_MERU = 7,
	BTC_IOT_PEER_MARVELL = 8,
	BTC_IOT_PEER_REALTEK_SOFTAP = 9,
	BTC_IOT_PEER_SELF_SOFTAP = 10,
	BTC_IOT_PEER_AIRGO = 11,
	BTC_IOT_PEER_INTEL = 12,
	BTC_IOT_PEER_RTK_APCLIENT = 13,
	BTC_IOT_PEER_REALTEK_81XX = 14,
	BTC_IOT_PEER_REALTEK_WOW = 15,
	BTC_IOT_PEER_REALTEK_JAGUAR_BCUTAP = 16,
	BTC_IOT_PEER_REALTEK_JAGUAR_CCUTAP = 17,
	BTC_IOT_PEER_MAX = 18,
};

enum bt_8723d_2ant_signal_state {
	BT_8723D_2ANT_SIG_STA_SET_TO_LOW = 0,
	BT_8723D_2ANT_SIG_STA_SET_BY_HW = 0,
	BT_8723D_2ANT_SIG_STA_SET_TO_HIGH = 1,
	BT_8723D_2ANT_SIG_STA_MAX = 2,
};

enum bt_8723d_2ant_path_ctrl_owner {
	BT_8723D_2ANT_PCO_BTSIDE = 0,
	BT_8723D_2ANT_PCO_WLSIDE = 1,
	BT_8723D_2ANT_PCO_MAX = 2,
};

enum bt_8723d_2ant_gnt_ctrl_type {
	BT_8723D_2ANT_GNT_TYPE_CTRL_BY_PTA = 0,
	BT_8723D_2ANT_GNT_TYPE_CTRL_BY_SW = 1,
	BT_8723D_2ANT_GNT_TYPE_MAX = 2,
};

enum bt_8723d_2ant_gnt_ctrl_block {
	BT_8723D_2ANT_GNT_BLOCK_RFC_BB = 0,
	BT_8723D_2ANT_GNT_BLOCK_RFC = 1,
	BT_8723D_2ANT_GNT_BLOCK_BB = 2,
	BT_8723D_2ANT_GNT_BLOCK_MAX = 3,
};

enum bt_8723d_2ant_lte_coex_table_type {
	BT_8723D_2ANT_CTT_WL_VS_LTE = 0,
	BT_8723D_2ANT_CTT_BT_VS_LTE = 1,
	BT_8723D_2ANT_CTT_MAX = 2,
};

enum bt_info_src_8723d_2ant {
	BT_INFO_SRC_8723D_2ANT_WIFI_FW = 0,
	BT_INFO_SRC_8723D_2ANT_BT_RSP = 1,
	BT_INFO_SRC_8723D_2ANT_BT_ACTIVE_SEND = 2,
	BT_INFO_SRC_8723D_2ANT_MAX = 3,
};

enum bt_8723d_2ant_bt_status {
	BT_8723D_2ANT_BT_STATUS_NON_CONNECTED_IDLE = 0,
	BT_8723D_2ANT_BT_STATUS_CONNECTED_IDLE = 1,
	BT_8723D_2ANT_BT_STATUS_INQ_PAGE = 2,
	BT_8723D_2ANT_BT_STATUS_ACL_BUSY = 3,
	BT_8723D_2ANT_BT_STATUS_SCO_BUSY = 4,
	BT_8723D_2ANT_BT_STATUS_ACL_SCO_BUSY = 5,
	BT_8723D_2ANT_BT_STATUS_MAX = 6,
};

enum bt_8723d_2ant_coex_algo {
	BT_8723D_2ANT_COEX_ALGO_UNDEFINED = 0,
	BT_8723D_2ANT_COEX_ALGO_SCO = 1,
	BT_8723D_2ANT_COEX_ALGO_HID = 2,
	BT_8723D_2ANT_COEX_ALGO_A2DP = 3,
	BT_8723D_2ANT_COEX_ALGO_A2DP_PANHS = 4,
	BT_8723D_2ANT_COEX_ALGO_PANEDR = 5,
	BT_8723D_2ANT_COEX_ALGO_PANHS = 6,
	BT_8723D_2ANT_COEX_ALGO_PANEDR_A2DP = 7,
	BT_8723D_2ANT_COEX_ALGO_PANEDR_HID = 8,
	BT_8723D_2ANT_COEX_ALGO_HID_A2DP_PANEDR = 9,
	BT_8723D_2ANT_COEX_ALGO_HID_A2DP = 10,
	BT_8723D_2ANT_COEX_ALGO_NOPROFILEBUSY = 11,
	BT_8723D_2ANT_COEX_ALGO_A2DPSINK = 12,
	BT_8723D_2ANT_COEX_ALGO_MAX = 13,
};

enum bt_8723d_2ant_phase {
	BT_8723D_2ANT_PHASE_COEX_INIT = 0,
	BT_8723D_2ANT_PHASE_WLANONLY_INIT = 1,
	BT_8723D_2ANT_PHASE_WLAN_OFF = 2,
	BT_8723D_2ANT_PHASE_2G_RUNTIME = 3,
	BT_8723D_2ANT_PHASE_5G_RUNTIME = 4,
	BT_8723D_2ANT_PHASE_BTMPMODE = 5,
	BT_8723D_2ANT_PHASE_ANTENNA_DET = 6,
	BT_8723D_2ANT_PHASE_COEX_POWERON = 7,
	BT_8723D_2ANT_PHASE_2G_FREERUN = 8,
	BT_8723D_2ANT_PHASE_MAX = 9,
};

enum bt_8723d_2ant_Scoreboard {
	BT_8723D_2ANT_SCOREBOARD_ACTIVE = 1,
	BT_8723D_2ANT_SCOREBOARD_ONOFF = 2,
	BT_8723D_2ANT_SCOREBOARD_SCAN = 4,
	BT_8723D_2ANT_SCOREBOARD_UNDERTEST = 8,
	BT_8723D_2ANT_SCOREBOARD_RXGAIN = 16,
	BT_8723D_2ANT_SCOREBOARD_WLBUSY = 64,
	BT_8723D_2ANT_SCOREBOARD_TDMA = 512,
};

struct psdscan_sta_8723d_2ant {
	u32 ant_det_bt_le_channel;
	u32 ant_det_bt_tx_time;
	u32 ant_det_pre_psdscan_peak_val;
	bool ant_det_is_ant_det_available;
	u32 ant_det_psd_scan_peak_val;
	bool ant_det_is_btreply_available;
	u32 ant_det_psd_scan_peak_freq;
	u8 ant_det_result;
	u8 ant_det_peak_val[16];
	u8 ant_det_peak_freq[16];
	u32 ant_det_try_count;
	u32 ant_det_fail_count;
	u32 ant_det_inteval_count;
	u32 ant_det_thres_offset;
	u32 real_cent_freq;
	s32 real_offset;
	u32 real_span;
	u32 psd_band_width;
	u32 psd_point;
	u32 psd_report[1024];
	u32 psd_report_max_hold[1024];
	u32 psd_start_point;
	u32 psd_stop_point;
	u32 psd_max_value_point;
	u32 psd_max_value;
	u32 psd_max_value2;
	u32 psd_avg_value;
	u32 psd_loop_max_value[50];
	u32 psd_start_base;
	u32 psd_avg_num;
	u32 psd_gen_count;
	bool is_antdet_running;
	bool is_psd_show_max_only;
};

enum _TEST_MODE {
	TEST_NONE = 0,
	PACKETS_TX = 1,
	PACKETS_RX = 2,
	CONTINUOUS_TX = 3,
	OFDM_Single_Tone_TX = 4,
	CCK_Carrier_Suppression_TX = 5,
};

struct psd_init_regs {
	int reg_88c;
	int reg_c00;
	int reg_e00;
	int reg_1800;
	int reg_1a00;
	int reg_800;
	int reg_808;
};

struct netdev_lag_lower_state_info {
	u8 link_up: 1;
	u8 tx_enabled: 1;
};

struct net_failover_info {
	struct net_device *primary_dev;
	struct net_device *standby_dev;
	struct rtnl_link_stats64 primary_stats;
	struct rtnl_link_stats64 standby_stats;
	struct rtnl_link_stats64 failover_stats;
	spinlock_t stats_lock;
};

struct usb_endpoint_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bEndpointAddress;
	__u8 bmAttributes;
	__le16 wMaxPacketSize;
	__u8 bInterval;
	__u8 bRefresh;
	__u8 bSynchAddress;
} __attribute__((packed));

enum usb_device_speed {
	USB_SPEED_UNKNOWN = 0,
	USB_SPEED_LOW = 1,
	USB_SPEED_FULL = 2,
	USB_SPEED_HIGH = 3,
	USB_SPEED_WIRELESS = 4,
	USB_SPEED_SUPER = 5,
	USB_SPEED_SUPER_PLUS = 6,
};

enum usb_device_state {
	USB_STATE_NOTATTACHED = 0,
	USB_STATE_ATTACHED = 1,
	USB_STATE_POWERED = 2,
	USB_STATE_RECONNECTING = 3,
	USB_STATE_UNAUTHENTICATED = 4,
	USB_STATE_DEFAULT = 5,
	USB_STATE_ADDRESS = 6,
	USB_STATE_CONFIGURED = 7,
	USB_STATE_SUSPENDED = 8,
};

enum usb_ssp_rate {
	USB_SSP_GEN_UNKNOWN = 0,
	USB_SSP_GEN_2x1 = 1,
	USB_SSP_GEN_1x2 = 2,
	USB_SSP_GEN_2x2 = 3,
};

enum usb_otg_state {
	OTG_STATE_UNDEFINED = 0,
	OTG_STATE_B_IDLE = 1,
	OTG_STATE_B_SRP_INIT = 2,
	OTG_STATE_B_PERIPHERAL = 3,
	OTG_STATE_B_WAIT_ACON = 4,
	OTG_STATE_B_HOST = 5,
	OTG_STATE_A_IDLE = 6,
	OTG_STATE_A_WAIT_VRISE = 7,
	OTG_STATE_A_WAIT_BCON = 8,
	OTG_STATE_A_HOST = 9,
	OTG_STATE_A_SUSPEND = 10,
	OTG_STATE_A_PERIPHERAL = 11,
	OTG_STATE_A_WAIT_VFALL = 12,
	OTG_STATE_A_VBUS_ERR = 13,
};

struct usb_otg_caps {
	u16 otg_rev;
	bool hnp_support;
	bool srp_support;
	bool adp_support;
};

enum usb_dr_mode {
	USB_DR_MODE_UNKNOWN = 0,
	USB_DR_MODE_HOST = 1,
	USB_DR_MODE_PERIPHERAL = 2,
	USB_DR_MODE_OTG = 3,
};

struct usb_device_id {
	__u16 match_flags;
	__u16 idVendor;
	__u16 idProduct;
	__u16 bcdDevice_lo;
	__u16 bcdDevice_hi;
	__u8 bDeviceClass;
	__u8 bDeviceSubClass;
	__u8 bDeviceProtocol;
	__u8 bInterfaceClass;
	__u8 bInterfaceSubClass;
	__u8 bInterfaceProtocol;
	__u8 bInterfaceNumber;
	kernel_ulong_t driver_info;
};

struct usb_descriptor_header {
	__u8 bLength;
	__u8 bDescriptorType;
};

struct usb_device_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__le16 bcdUSB;
	__u8 bDeviceClass;
	__u8 bDeviceSubClass;
	__u8 bDeviceProtocol;
	__u8 bMaxPacketSize0;
	__le16 idVendor;
	__le16 idProduct;
	__le16 bcdDevice;
	__u8 iManufacturer;
	__u8 iProduct;
	__u8 iSerialNumber;
	__u8 bNumConfigurations;
};

struct usb_config_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__le16 wTotalLength;
	__u8 bNumInterfaces;
	__u8 bConfigurationValue;
	__u8 iConfiguration;
	__u8 bmAttributes;
	__u8 bMaxPower;
} __attribute__((packed));

struct usb_interface_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bInterfaceNumber;
	__u8 bAlternateSetting;
	__u8 bNumEndpoints;
	__u8 bInterfaceClass;
	__u8 bInterfaceSubClass;
	__u8 bInterfaceProtocol;
	__u8 iInterface;
};

struct usb_ssp_isoc_ep_comp_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__le16 wReseved;
	__le32 dwBytesPerInterval;
};

struct usb_ss_ep_comp_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bMaxBurst;
	__u8 bmAttributes;
	__le16 wBytesPerInterval;
};

struct usb_interface_assoc_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bFirstInterface;
	__u8 bInterfaceCount;
	__u8 bFunctionClass;
	__u8 bFunctionSubClass;
	__u8 bFunctionProtocol;
	__u8 iFunction;
};

struct usb_bos_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__le16 wTotalLength;
	__u8 bNumDeviceCaps;
} __attribute__((packed));

struct usb_ext_cap_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDevCapabilityType;
	__le32 bmAttributes;
} __attribute__((packed));

struct usb_ss_cap_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDevCapabilityType;
	__u8 bmAttributes;
	__le16 wSpeedSupported;
	__u8 bFunctionalitySupport;
	__u8 bU1devExitLat;
	__le16 bU2DevExitLat;
};

struct usb_ss_container_id_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDevCapabilityType;
	__u8 bReserved;
	__u8 ContainerID[16];
};

struct usb_ssp_cap_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDevCapabilityType;
	__u8 bReserved;
	__le32 bmAttributes;
	__le16 wFunctionalitySupport;
	__le16 wReserved;
	__le32 bmSublinkSpeedAttr[1];
};

struct usb_ptm_cap_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDevCapabilityType;
};

enum usb3_link_state {
	USB3_LPM_U0 = 0,
	USB3_LPM_U1 = 1,
	USB3_LPM_U2 = 2,
	USB3_LPM_U3 = 3,
};

struct ep_device;

struct usb_host_endpoint {
	struct usb_endpoint_descriptor desc;
	struct usb_ss_ep_comp_descriptor ss_ep_comp;
	struct usb_ssp_isoc_ep_comp_descriptor ssp_isoc_ep_comp;
	char: 8;
	struct list_head urb_list;
	void *hcpriv;
	struct ep_device *ep_dev;
	unsigned char *extra;
	int extralen;
	int enabled;
	int streams;
	int: 32;
} __attribute__((packed));

struct usb_host_interface {
	struct usb_interface_descriptor desc;
	int extralen;
	unsigned char *extra;
	struct usb_host_endpoint *endpoint;
	char *string;
};

enum usb_interface_condition {
	USB_INTERFACE_UNBOUND = 0,
	USB_INTERFACE_BINDING = 1,
	USB_INTERFACE_BOUND = 2,
	USB_INTERFACE_UNBINDING = 3,
};

struct usb_interface {
	struct usb_host_interface *altsetting;
	struct usb_host_interface *cur_altsetting;
	unsigned int num_altsetting;
	struct usb_interface_assoc_descriptor *intf_assoc;
	int minor;
	enum usb_interface_condition condition;
	unsigned int sysfs_files_created: 1;
	unsigned int ep_devs_created: 1;
	unsigned int unregistering: 1;
	unsigned int needs_remote_wakeup: 1;
	unsigned int needs_altsetting0: 1;
	unsigned int needs_binding: 1;
	unsigned int resetting_device: 1;
	unsigned int authorized: 1;
	struct device dev;
	struct device *usb_dev;
	struct work_struct reset_ws;
};

struct usb_interface_cache {
	unsigned int num_altsetting;
	struct kref ref;
	struct usb_host_interface altsetting[0];
};

struct usb_host_config {
	struct usb_config_descriptor desc;
	char *string;
	struct usb_interface_assoc_descriptor *intf_assoc[16];
	struct usb_interface *interface[32];
	struct usb_interface_cache *intf_cache[32];
	unsigned char *extra;
	int extralen;
};

struct usb_host_bos {
	struct usb_bos_descriptor *desc;
	struct usb_ext_cap_descriptor *ext_cap;
	struct usb_ss_cap_descriptor *ss_cap;
	struct usb_ssp_cap_descriptor *ssp_cap;
	struct usb_ss_container_id_descriptor *ss_id;
	struct usb_ptm_cap_descriptor *ptm_cap;
};

struct usb_devmap {
	long unsigned int devicemap[2];
};

struct usb_device;

struct usb_bus {
	struct device *controller;
	struct device *sysdev;
	int busnum;
	const char *bus_name;
	u8 uses_pio_for_control;
	u8 otg_port;
	unsigned int is_b_host: 1;
	unsigned int b_hnp_enable: 1;
	unsigned int no_stop_on_short: 1;
	unsigned int no_sg_constraint: 1;
	unsigned int sg_tablesize;
	int devnum_next;
	struct mutex devnum_next_mutex;
	struct usb_devmap devmap;
	struct usb_device *root_hub;
	struct usb_bus *hs_companion;
	int bandwidth_allocated;
	int bandwidth_int_reqs;
	int bandwidth_isoc_reqs;
	unsigned int resuming_ports;
};

struct wusb_dev;

enum usb_device_removable {
	USB_DEVICE_REMOVABLE_UNKNOWN = 0,
	USB_DEVICE_REMOVABLE = 1,
	USB_DEVICE_FIXED = 2,
};

struct usb2_lpm_parameters {
	unsigned int besl;
	int timeout;
};

struct usb3_lpm_parameters {
	unsigned int mel;
	unsigned int pel;
	unsigned int sel;
	int timeout;
};

struct usb_tt;

struct usb_device {
	int devnum;
	char devpath[16];
	u32 route;
	enum usb_device_state state;
	enum usb_device_speed speed;
	unsigned int rx_lanes;
	unsigned int tx_lanes;
	struct usb_tt *tt;
	int ttport;
	unsigned int toggle[2];
	struct usb_device *parent;
	struct usb_bus *bus;
	struct usb_host_endpoint ep0;
	struct device dev;
	struct usb_device_descriptor descriptor;
	struct usb_host_bos *bos;
	struct usb_host_config *config;
	struct usb_host_config *actconfig;
	struct usb_host_endpoint *ep_in[16];
	struct usb_host_endpoint *ep_out[16];
	char **rawdescriptors;
	short unsigned int bus_mA;
	u8 portnum;
	u8 level;
	u8 devaddr;
	unsigned int can_submit: 1;
	unsigned int persist_enabled: 1;
	unsigned int have_langid: 1;
	unsigned int authorized: 1;
	unsigned int authenticated: 1;
	unsigned int wusb: 1;
	unsigned int lpm_capable: 1;
	unsigned int usb2_hw_lpm_capable: 1;
	unsigned int usb2_hw_lpm_besl_capable: 1;
	unsigned int usb2_hw_lpm_enabled: 1;
	unsigned int usb2_hw_lpm_allowed: 1;
	unsigned int usb3_lpm_u1_enabled: 1;
	unsigned int usb3_lpm_u2_enabled: 1;
	int string_langid;
	char *product;
	char *manufacturer;
	char *serial;
	struct list_head filelist;
	int maxchild;
	u32 quirks;
	atomic_t urbnum;
	long unsigned int active_duration;
	long unsigned int connect_time;
	unsigned int do_remote_wakeup: 1;
	unsigned int reset_resume: 1;
	unsigned int port_is_suspended: 1;
	struct wusb_dev *wusb_dev;
	int slot_id;
	enum usb_device_removable removable;
	struct usb2_lpm_parameters l1_params;
	struct usb3_lpm_parameters u1_params;
	struct usb3_lpm_parameters u2_params;
	unsigned int lpm_disable_count;
	u16 hub_delay;
	unsigned int use_generic_driver: 1;
};

enum usb_port_connect_type {
	USB_PORT_CONNECT_TYPE_UNKNOWN = 0,
	USB_PORT_CONNECT_TYPE_HOT_PLUG = 1,
	USB_PORT_CONNECT_TYPE_HARD_WIRED = 2,
	USB_PORT_NOT_USED = 3,
};

struct usb_tt {
	struct usb_device *hub;
	int multi;
	unsigned int think_time;
	void *hcpriv;
	spinlock_t lock;
	struct list_head clear_list;
	struct work_struct clear_work;
};

struct usb_dynids {
	spinlock_t lock;
	struct list_head list;
};

struct usbdrv_wrap {
	struct device_driver driver;
	int for_devices;
};

struct usb_driver {
	const char *name;
	int (*probe)(struct usb_interface *, const struct usb_device_id *);
	void (*disconnect)(struct usb_interface *);
	int (*unlocked_ioctl)(struct usb_interface *, unsigned int, void *);
	int (*suspend)(struct usb_interface *, pm_message_t);
	int (*resume)(struct usb_interface *);
	int (*reset_resume)(struct usb_interface *);
	int (*pre_reset)(struct usb_interface *);
	int (*post_reset)(struct usb_interface *);
	const struct usb_device_id *id_table;
	const struct attribute_group **dev_groups;
	struct usb_dynids dynids;
	struct usbdrv_wrap drvwrap;
	unsigned int no_dynamic_id: 1;
	unsigned int supports_autosuspend: 1;
	unsigned int disable_hub_initiated_lpm: 1;
	unsigned int soft_unbind: 1;
};

struct usb_device_driver {
	const char *name;
	bool (*match)(struct usb_device *);
	int (*probe)(struct usb_device *);
	void (*disconnect)(struct usb_device *);
	int (*suspend)(struct usb_device *, pm_message_t);
	int (*resume)(struct usb_device *, pm_message_t);
	const struct attribute_group **dev_groups;
	struct usbdrv_wrap drvwrap;
	const struct usb_device_id *id_table;
	unsigned int supports_autosuspend: 1;
	unsigned int generic_subclass: 1;
};

struct usb_iso_packet_descriptor {
	unsigned int offset;
	unsigned int length;
	unsigned int actual_length;
	int status;
};

struct usb_anchor {
	struct list_head urb_list;
	wait_queue_head_t wait;
	spinlock_t lock;
	atomic_t suspend_wakeups;
	unsigned int poisoned: 1;
};

struct urb;

typedef void (*usb_complete_t)(struct urb *);

struct urb {
	struct kref kref;
	int unlinked;
	void *hcpriv;
	atomic_t use_count;
	atomic_t reject;
	struct list_head urb_list;
	struct list_head anchor_list;
	struct usb_anchor *anchor;
	struct usb_device *dev;
	struct usb_host_endpoint *ep;
	unsigned int pipe;
	unsigned int stream_id;
	int status;
	unsigned int transfer_flags;
	void *transfer_buffer;
	dma_addr_t transfer_dma;
	struct scatterlist *sg;
	int num_mapped_sgs;
	int num_sgs;
	u32 transfer_buffer_length;
	u32 actual_length;
	unsigned char *setup_packet;
	dma_addr_t setup_dma;
	int start_frame;
	int number_of_packets;
	int interval;
	int error_count;
	void *context;
	usb_complete_t complete;
	struct usb_iso_packet_descriptor iso_frame_desc[0];
};

struct giveback_urb_bh {
	bool running;
	spinlock_t lock;
	struct list_head head;
	struct tasklet_struct bh;
	struct usb_host_endpoint *completing_ep;
};

enum usb_dev_authorize_policy {
	USB_DEVICE_AUTHORIZE_NONE = 0,
	USB_DEVICE_AUTHORIZE_ALL = 1,
	USB_DEVICE_AUTHORIZE_INTERNAL = 2,
};

struct usb_phy_roothub;

struct hc_driver;

struct usb_phy;

struct usb_hcd {
	struct usb_bus self;
	struct kref kref;
	const char *product_desc;
	int speed;
	char irq_descr[24];
	struct timer_list rh_timer;
	struct urb *status_urb;
	struct work_struct wakeup_work;
	struct work_struct died_work;
	const struct hc_driver *driver;
	struct usb_phy *usb_phy;
	struct usb_phy_roothub *phy_roothub;
	long unsigned int flags;
	enum usb_dev_authorize_policy dev_policy;
	unsigned int rh_registered: 1;
	unsigned int rh_pollable: 1;
	unsigned int msix_enabled: 1;
	unsigned int msi_enabled: 1;
	unsigned int skip_phy_initialization: 1;
	unsigned int uses_new_polling: 1;
	unsigned int wireless: 1;
	unsigned int has_tt: 1;
	unsigned int amd_resume_bug: 1;
	unsigned int can_do_streams: 1;
	unsigned int tpl_support: 1;
	unsigned int cant_recv_wakeups: 1;
	unsigned int irq;
	void *regs;
	resource_size_t rsrc_start;
	resource_size_t rsrc_len;
	unsigned int power_budget;
	struct giveback_urb_bh high_prio_bh;
	struct giveback_urb_bh low_prio_bh;
	struct mutex *address0_mutex;
	struct mutex *bandwidth_mutex;
	struct usb_hcd *shared_hcd;
	struct usb_hcd *primary_hcd;
	struct dma_pool *pool[4];
	int state;
	struct gen_pool *localmem_pool;
	long unsigned int hcd_priv[0];
};

struct hc_driver {
	const char *description;
	const char *product_desc;
	size_t hcd_priv_size;
	irqreturn_t (*irq)(struct usb_hcd *);
	int flags;
	int (*reset)(struct usb_hcd *);
	int (*start)(struct usb_hcd *);
	int (*pci_suspend)(struct usb_hcd *, bool);
	int (*pci_resume)(struct usb_hcd *, bool);
	void (*stop)(struct usb_hcd *);
	void (*shutdown)(struct usb_hcd *);
	int (*get_frame_number)(struct usb_hcd *);
	int (*urb_enqueue)(struct usb_hcd *, struct urb *, gfp_t);
	int (*urb_dequeue)(struct usb_hcd *, struct urb *, int);
	int (*map_urb_for_dma)(struct usb_hcd *, struct urb *, gfp_t);
	void (*unmap_urb_for_dma)(struct usb_hcd *, struct urb *);
	void (*endpoint_disable)(struct usb_hcd *, struct usb_host_endpoint *);
	void (*endpoint_reset)(struct usb_hcd *, struct usb_host_endpoint *);
	int (*hub_status_data)(struct usb_hcd *, char *);
	int (*hub_control)(struct usb_hcd *, u16, u16, u16, char *, u16);
	int (*bus_suspend)(struct usb_hcd *);
	int (*bus_resume)(struct usb_hcd *);
	int (*start_port_reset)(struct usb_hcd *, unsigned int);
	long unsigned int (*get_resuming_ports)(struct usb_hcd *);
	void (*relinquish_port)(struct usb_hcd *, int);
	int (*port_handed_over)(struct usb_hcd *, int);
	void (*clear_tt_buffer_complete)(struct usb_hcd *, struct usb_host_endpoint *);
	int (*alloc_dev)(struct usb_hcd *, struct usb_device *);
	void (*free_dev)(struct usb_hcd *, struct usb_device *);
	int (*alloc_streams)(struct usb_hcd *, struct usb_device *, struct usb_host_endpoint **, unsigned int, unsigned int, gfp_t);
	int (*free_streams)(struct usb_hcd *, struct usb_device *, struct usb_host_endpoint **, unsigned int, gfp_t);
	int (*add_endpoint)(struct usb_hcd *, struct usb_device *, struct usb_host_endpoint *);
	int (*drop_endpoint)(struct usb_hcd *, struct usb_device *, struct usb_host_endpoint *);
	int (*check_bandwidth)(struct usb_hcd *, struct usb_device *);
	void (*reset_bandwidth)(struct usb_hcd *, struct usb_device *);
	int (*address_device)(struct usb_hcd *, struct usb_device *);
	int (*enable_device)(struct usb_hcd *, struct usb_device *);
	int (*update_hub_device)(struct usb_hcd *, struct usb_device *, struct usb_tt *, gfp_t);
	int (*reset_device)(struct usb_hcd *, struct usb_device *);
	int (*update_device)(struct usb_hcd *, struct usb_device *);
	int (*set_usb2_hw_lpm)(struct usb_hcd *, struct usb_device *, int);
	int (*enable_usb3_lpm_timeout)(struct usb_hcd *, struct usb_device *, enum usb3_link_state);
	int (*disable_usb3_lpm_timeout)(struct usb_hcd *, struct usb_device *, enum usb3_link_state);
	int (*find_raw_port_number)(struct usb_hcd *, int);
	int (*port_power)(struct usb_hcd *, int, bool);
};

enum usb_phy_type {
	USB_PHY_TYPE_UNDEFINED = 0,
	USB_PHY_TYPE_USB2 = 1,
	USB_PHY_TYPE_USB3 = 2,
};

enum usb_phy_events {
	USB_EVENT_NONE = 0,
	USB_EVENT_VBUS = 1,
	USB_EVENT_ID = 2,
	USB_EVENT_CHARGER = 3,
	USB_EVENT_ENUMERATED = 4,
};

enum usb_charger_type {
	UNKNOWN_TYPE = 0,
	SDP_TYPE = 1,
	DCP_TYPE = 2,
	CDP_TYPE = 3,
	ACA_TYPE = 4,
};

enum usb_charger_state {
	USB_CHARGER_DEFAULT = 0,
	USB_CHARGER_PRESENT = 1,
	USB_CHARGER_ABSENT = 2,
};

struct usb_charger_current {
	unsigned int sdp_min;
	unsigned int sdp_max;
	unsigned int dcp_min;
	unsigned int dcp_max;
	unsigned int cdp_min;
	unsigned int cdp_max;
	unsigned int aca_min;
	unsigned int aca_max;
};

struct usb_otg;

struct usb_phy_io_ops;

struct usb_phy {
	struct device *dev;
	const char *label;
	unsigned int flags;
	enum usb_phy_type type;
	enum usb_phy_events last_event;
	struct usb_otg *otg;
	struct device *io_dev;
	struct usb_phy_io_ops *io_ops;
	void *io_priv;
	struct extcon_dev *edev;
	struct extcon_dev *id_edev;
	struct notifier_block vbus_nb;
	struct notifier_block id_nb;
	struct notifier_block type_nb;
	enum usb_charger_type chg_type;
	enum usb_charger_state chg_state;
	struct usb_charger_current chg_cur;
	struct work_struct chg_work;
	struct atomic_notifier_head notifier;
	u16 port_status;
	u16 port_change;
	struct list_head head;
	int (*init)(struct usb_phy *);
	void (*shutdown)(struct usb_phy *);
	int (*set_vbus)(struct usb_phy *, int);
	int (*set_power)(struct usb_phy *, unsigned int);
	int (*set_suspend)(struct usb_phy *, int);
	int (*set_wakeup)(struct usb_phy *, bool);
	int (*notify_connect)(struct usb_phy *, enum usb_device_speed);
	int (*notify_disconnect)(struct usb_phy *, enum usb_device_speed);
	enum usb_charger_type (*charger_detect)(struct usb_phy *);
};

struct usb_port_status {
	__le16 wPortStatus;
	__le16 wPortChange;
	__le32 dwExtPortStatus;
};

struct usb_hub_status {
	__le16 wHubStatus;
	__le16 wHubChange;
};

struct usb_hub_descriptor {
	__u8 bDescLength;
	__u8 bDescriptorType;
	__u8 bNbrPorts;
	__le16 wHubCharacteristics;
	__u8 bPwrOn2PwrGood;
	__u8 bHubContrCurrent;
	union {
		struct {
			__u8 DeviceRemovable[4];
			__u8 PortPwrCtrlMask[4];
		} hs;
		struct {
			__u8 bHubHdrDecLat;
			__le16 wHubDelay;
			__le16 DeviceRemovable;
		} __attribute__((packed)) ss;
	} u;
} __attribute__((packed));

struct usb_phy_io_ops {
	int (*read)(struct usb_phy *, u32);
	int (*write)(struct usb_phy *, u32, u32);
};

struct usb_gadget;

struct usb_otg {
	u8 default_a;
	struct phy *phy;
	struct usb_phy *usb_phy;
	struct usb_bus *host;
	struct usb_gadget *gadget;
	enum usb_otg_state state;
	int (*set_host)(struct usb_otg *, struct usb_bus *);
	int (*set_peripheral)(struct usb_otg *, struct usb_gadget *);
	int (*set_vbus)(struct usb_otg *, bool);
	int (*start_srp)(struct usb_otg *);
	int (*start_hnp)(struct usb_otg *);
};

typedef u32 usb_port_location_t;

struct usb_port;

struct usb_hub {
	struct device *intfdev;
	struct usb_device *hdev;
	struct kref kref;
	struct urb *urb;
	u8 (*buffer)[8];
	union {
		struct usb_hub_status hub;
		struct usb_port_status port;
	} *status;
	struct mutex status_mutex;
	int error;
	int nerrors;
	long unsigned int event_bits[1];
	long unsigned int change_bits[1];
	long unsigned int removed_bits[1];
	long unsigned int wakeup_bits[1];
	long unsigned int power_bits[1];
	long unsigned int child_usage_bits[1];
	long unsigned int warm_reset_bits[1];
	struct usb_hub_descriptor *descriptor;
	struct usb_tt tt;
	unsigned int mA_per_port;
	unsigned int wakeup_enabled_descendants;
	unsigned int limited_power: 1;
	unsigned int quiescing: 1;
	unsigned int disconnected: 1;
	unsigned int in_reset: 1;
	unsigned int quirk_disable_autosuspend: 1;
	unsigned int quirk_check_port_auto_suspend: 1;
	unsigned int has_indicators: 1;
	u8 indicator[31];
	struct delayed_work leds;
	struct delayed_work init_work;
	struct work_struct events;
	spinlock_t irq_urb_lock;
	struct timer_list irq_urb_retry;
	struct usb_port **ports;
};

struct usb_dev_state;

struct usb_port {
	struct usb_device *child;
	struct device dev;
	struct usb_dev_state *port_owner;
	struct usb_port *peer;
	struct dev_pm_qos_request *req;
	enum usb_port_connect_type connect_type;
	usb_port_location_t location;
	struct mutex status_lock;
	u32 over_current_count;
	u8 portnum;
	u32 quirks;
	unsigned int is_superspeed: 1;
	unsigned int usb3_lpm_u1_permit: 1;
	unsigned int usb3_lpm_u2_permit: 1;
};

struct find_interface_arg {
	int minor;
	struct device_driver *drv;
};

struct each_dev_arg {
	void *data;
	int (*fn)(struct usb_device *, void *);
};

struct usb_qualifier_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__le16 bcdUSB;
	__u8 bDeviceClass;
	__u8 bDeviceSubClass;
	__u8 bDeviceProtocol;
	__u8 bMaxPacketSize0;
	__u8 bNumConfigurations;
	__u8 bRESERVED;
};

struct usb_set_sel_req {
	__u8 u1_sel;
	__u8 u1_pel;
	__le16 u2_sel;
	__le16 u2_pel;
};

struct usbdevfs_hub_portinfo {
	char nports;
	char port[127];
};

enum hub_led_mode {
	INDICATOR_AUTO = 0,
	INDICATOR_CYCLE = 1,
	INDICATOR_GREEN_BLINK = 2,
	INDICATOR_GREEN_BLINK_OFF = 3,
	INDICATOR_AMBER_BLINK = 4,
	INDICATOR_AMBER_BLINK_OFF = 5,
	INDICATOR_ALT_BLINK = 6,
	INDICATOR_ALT_BLINK_OFF = 7,
};

struct usb_tt_clear {
	struct list_head clear_list;
	unsigned int tt;
	u16 devinfo;
	struct usb_hcd *hcd;
	struct usb_host_endpoint *ep;
};

enum hub_activation_type {
	HUB_INIT = 0,
	HUB_INIT2 = 1,
	HUB_INIT3 = 2,
	HUB_POST_RESET = 3,
	HUB_RESUME = 4,
	HUB_RESET_RESUME = 5,
};

enum hub_quiescing_type {
	HUB_DISCONNECT = 0,
	HUB_PRE_RESET = 1,
	HUB_SUSPEND = 2,
};

struct usb_ctrlrequest {
	__u8 bRequestType;
	__u8 bRequest;
	__le16 wValue;
	__le16 wIndex;
	__le16 wLength;
};

enum usb_led_event {
	USB_LED_EVENT_HOST = 0,
	USB_LED_EVENT_GADGET = 1,
};

struct usb_sg_request {
	int status;
	size_t bytes;
	spinlock_t lock;
	struct usb_device *dev;
	int pipe;
	int entries;
	struct urb **urbs;
	int count;
	struct completion complete;
};

struct usb_cdc_header_desc {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
	__le16 bcdCDC;
} __attribute__((packed));

struct usb_cdc_call_mgmt_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
	__u8 bmCapabilities;
	__u8 bDataInterface;
};

struct usb_cdc_acm_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
	__u8 bmCapabilities;
};

struct usb_cdc_union_desc {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
	__u8 bMasterInterface0;
	__u8 bSlaveInterface0;
};

struct usb_cdc_country_functional_desc {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
	__u8 iCountryCodeRelDate;
	__le16 wCountyCode0;
};

struct usb_cdc_network_terminal_desc {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
	__u8 bEntityId;
	__u8 iName;
	__u8 bChannelIndex;
	__u8 bPhysicalInterface;
};

struct usb_cdc_ether_desc {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
	__u8 iMACAddress;
	__le32 bmEthernetStatistics;
	__le16 wMaxSegmentSize;
	__le16 wNumberMCFilters;
	__u8 bNumberPowerFilters;
} __attribute__((packed));

struct usb_cdc_dmm_desc {
	__u8 bFunctionLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubtype;
	__u16 bcdVersion;
	__le16 wMaxCommand;
} __attribute__((packed));

struct usb_cdc_mdlm_desc {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
	__le16 bcdVersion;
	__u8 bGUID[16];
} __attribute__((packed));

struct usb_cdc_mdlm_detail_desc {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
	__u8 bGuidDescriptorType;
	__u8 bDetailData[0];
};

struct usb_cdc_obex_desc {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
	__le16 bcdVersion;
} __attribute__((packed));

struct usb_cdc_ncm_desc {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
	__le16 bcdNcmVersion;
	__u8 bmNetworkCapabilities;
} __attribute__((packed));

struct usb_cdc_mbim_desc {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
	__le16 bcdMBIMVersion;
	__le16 wMaxControlMessage;
	__u8 bNumberFilters;
	__u8 bMaxFilterSize;
	__le16 wMaxSegmentSize;
	__u8 bmNetworkCapabilities;
} __attribute__((packed));

struct usb_cdc_mbim_extended_desc {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
	__le16 bcdMBIMExtendedVersion;
	__u8 bMaxOutstandingCommandMessages;
	__le16 wMTU;
} __attribute__((packed));

struct usb_cdc_parsed_header {
	struct usb_cdc_union_desc *usb_cdc_union_desc;
	struct usb_cdc_header_desc *usb_cdc_header_desc;
	struct usb_cdc_call_mgmt_descriptor *usb_cdc_call_mgmt_descriptor;
	struct usb_cdc_acm_descriptor *usb_cdc_acm_descriptor;
	struct usb_cdc_country_functional_desc *usb_cdc_country_functional_desc;
	struct usb_cdc_network_terminal_desc *usb_cdc_network_terminal_desc;
	struct usb_cdc_ether_desc *usb_cdc_ether_desc;
	struct usb_cdc_dmm_desc *usb_cdc_dmm_desc;
	struct usb_cdc_mdlm_desc *usb_cdc_mdlm_desc;
	struct usb_cdc_mdlm_detail_desc *usb_cdc_mdlm_detail_desc;
	struct usb_cdc_obex_desc *usb_cdc_obex_desc;
	struct usb_cdc_ncm_desc *usb_cdc_ncm_desc;
	struct usb_cdc_mbim_desc *usb_cdc_mbim_desc;
	struct usb_cdc_mbim_extended_desc *usb_cdc_mbim_extended_desc;
	bool phonet_magic_present;
};

struct api_context {
	struct completion done;
	int status;
};

struct set_config_request {
	struct usb_device *udev;
	int config;
	struct work_struct work;
	struct list_head node;
};

struct usb_dynid {
	struct list_head node;
	struct usb_device_id id;
};

struct usb_dev_cap_header {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDevCapabilityType;
};

struct usb_class_driver {
	char *name;
	char * (*devnode)(struct device *, umode_t *);
	const struct file_operations *fops;
	int minor_base;
};

struct usb_class {
	struct kref kref;
	struct class *class;
};

struct ep_device {
	struct usb_endpoint_descriptor *desc;
	struct usb_device *udev;
	struct device dev;
};

struct usbdevfs_ctrltransfer {
	__u8 bRequestType;
	__u8 bRequest;
	__u16 wValue;
	__u16 wIndex;
	__u16 wLength;
	__u32 timeout;
	void *data;
};

struct usbdevfs_bulktransfer {
	unsigned int ep;
	unsigned int len;
	unsigned int timeout;
	void *data;
};

struct usbdevfs_setinterface {
	unsigned int interface;
	unsigned int altsetting;
};

struct usbdevfs_disconnectsignal {
	unsigned int signr;
	void *context;
};

struct usbdevfs_getdriver {
	unsigned int interface;
	char driver[256];
};

struct usbdevfs_connectinfo {
	unsigned int devnum;
	unsigned char slow;
};

struct usbdevfs_conninfo_ex {
	__u32 size;
	__u32 busnum;
	__u32 devnum;
	__u32 speed;
	__u8 num_ports;
	__u8 ports[7];
};

struct usbdevfs_iso_packet_desc {
	unsigned int length;
	unsigned int actual_length;
	unsigned int status;
};

struct usbdevfs_urb {
	unsigned char type;
	unsigned char endpoint;
	int status;
	unsigned int flags;
	void *buffer;
	int buffer_length;
	int actual_length;
	int start_frame;
	union {
		int number_of_packets;
		unsigned int stream_id;
	};
	int error_count;
	unsigned int signr;
	void *usercontext;
	struct usbdevfs_iso_packet_desc iso_frame_desc[0];
};

struct usbdevfs_ioctl {
	int ifno;
	int ioctl_code;
	void *data;
};

struct usbdevfs_disconnect_claim {
	unsigned int interface;
	unsigned int flags;
	char driver[256];
};

struct usbdevfs_streams {
	unsigned int num_streams;
	unsigned int num_eps;
	unsigned char eps[0];
};

struct usb_dev_state {
	struct list_head list;
	struct usb_device *dev;
	struct file *file;
	spinlock_t lock;
	struct list_head async_pending;
	struct list_head async_completed;
	struct list_head memory_list;
	wait_queue_head_t wait;
	wait_queue_head_t wait_for_resume;
	unsigned int discsignr;
	struct pid *disc_pid;
	const struct cred *cred;
	sigval_t disccontext;
	long unsigned int ifclaimed;
	u32 disabled_bulk_eps;
	long unsigned int interface_allowed_mask;
	int not_yet_resumed;
	bool suspend_allowed;
	bool privileges_dropped;
};

struct usb_memory {
	struct list_head memlist;
	int vma_use_count;
	int urb_use_count;
	u32 size;
	void *mem;
	dma_addr_t dma_handle;
	long unsigned int vm_start;
	struct usb_dev_state *ps;
};

struct async {
	struct list_head asynclist;
	struct usb_dev_state *ps;
	struct pid *pid;
	const struct cred *cred;
	unsigned int signr;
	unsigned int ifnum;
	void *userbuffer;
	void *userurb;
	sigval_t userurb_sigval;
	struct urb *urb;
	struct usb_memory *usbm;
	unsigned int mem_usage;
	int status;
	u8 bulk_addr;
	u8 bulk_status;
};

enum snoop_when {
	SUBMIT = 0,
	COMPLETE = 1,
};

struct quirk_entry {
	u16 vid;
	u16 pid;
	u32 flags;
};

struct class_info {
	int class;
	char *class_name;
};

struct usb_phy_roothub {
	struct phy *phy;
	struct list_head list;
};

enum usb_phy_interface {
	USBPHY_INTERFACE_MODE_UNKNOWN = 0,
	USBPHY_INTERFACE_MODE_UTMI = 1,
	USBPHY_INTERFACE_MODE_UTMIW = 2,
	USBPHY_INTERFACE_MODE_ULPI = 3,
	USBPHY_INTERFACE_MODE_SERIAL = 4,
	USBPHY_INTERFACE_MODE_HSIC = 5,
};

typedef __u32 __hc32;

typedef __u16 __hc16;

struct td;

struct ed {
	__hc32 hwINFO;
	__hc32 hwTailP;
	__hc32 hwHeadP;
	__hc32 hwNextED;
	dma_addr_t dma;
	struct td *dummy;
	struct ed *ed_next;
	struct ed *ed_prev;
	struct list_head td_list;
	struct list_head in_use_list;
	u8 state;
	u8 type;
	u8 branch;
	u16 interval;
	u16 load;
	u16 last_iso;
	u16 tick;
	unsigned int takeback_wdh_cnt;
	struct td *pending_td;
	long: 64;
};

struct td {
	__hc32 hwINFO;
	__hc32 hwCBP;
	__hc32 hwNextTD;
	__hc32 hwBE;
	__hc16 hwPSW[2];
	__u8 index;
	struct ed *ed;
	struct td *td_hash;
	struct td *next_dl_td;
	struct urb *urb;
	dma_addr_t td_dma;
	dma_addr_t data_dma;
	struct list_head td_list;
	long: 64;
};

struct ohci_hcca {
	__hc32 int_table[32];
	__hc32 frame_no;
	__hc32 done_head;
	u8 reserved_for_hc[116];
	u8 what[4];
};

struct ohci_roothub_regs {
	__hc32 a;
	__hc32 b;
	__hc32 status;
	__hc32 portstatus[15];
};

struct ohci_regs {
	__hc32 revision;
	__hc32 control;
	__hc32 cmdstatus;
	__hc32 intrstatus;
	__hc32 intrenable;
	__hc32 intrdisable;
	__hc32 hcca;
	__hc32 ed_periodcurrent;
	__hc32 ed_controlhead;
	__hc32 ed_controlcurrent;
	__hc32 ed_bulkhead;
	__hc32 ed_bulkcurrent;
	__hc32 donehead;
	__hc32 fminterval;
	__hc32 fmremaining;
	__hc32 fmnumber;
	__hc32 periodicstart;
	__hc32 lsthresh;
	struct ohci_roothub_regs roothub;
	long: 64;
	long: 64;
};

struct urb_priv {
	struct ed *ed;
	u16 length;
	u16 td_cnt;
	struct list_head pending;
	struct td *td[0];
};

typedef struct urb_priv urb_priv_t;

enum ohci_rh_state {
	OHCI_RH_HALTED = 0,
	OHCI_RH_SUSPENDED = 1,
	OHCI_RH_RUNNING = 2,
};

struct ohci_hcd {
	spinlock_t lock;
	struct ohci_regs *regs;
	struct ohci_hcca *hcca;
	dma_addr_t hcca_dma;
	struct ed *ed_rm_list;
	struct ed *ed_bulktail;
	struct ed *ed_controltail;
	struct ed *periodic[32];
	void (*start_hnp)(struct ohci_hcd *);
	struct dma_pool *td_cache;
	struct dma_pool *ed_cache;
	struct td *td_hash[64];
	struct td *dl_start;
	struct td *dl_end;
	struct list_head pending;
	struct list_head eds_in_use;
	enum ohci_rh_state rh_state;
	int num_ports;
	int load[32];
	u32 hc_control;
	long unsigned int next_statechange;
	u32 fminterval;
	unsigned int autostop: 1;
	unsigned int working: 1;
	unsigned int restart_work: 1;
	long unsigned int flags;
	unsigned int prev_frame_no;
	unsigned int wdh_cnt;
	unsigned int prev_wdh_cnt;
	u32 prev_donehead;
	struct timer_list io_watchdog;
	struct work_struct nec_work;
	struct dentry *debug_dir;
	long unsigned int priv[0];
};

struct ohci_driver_overrides {
	const char *product_desc;
	size_t extra_priv_size;
	int (*reset)(struct usb_hcd *);
};

struct debug_buffer {
	ssize_t (*fill_func)(struct debug_buffer *);
	struct ohci_hcd *ohci;
	struct mutex mutex;
	size_t count;
	char *page;
};

struct xhci_cap_regs {
	__le32 hc_capbase;
	__le32 hcs_params1;
	__le32 hcs_params2;
	__le32 hcs_params3;
	__le32 hcc_params;
	__le32 db_off;
	__le32 run_regs_off;
	__le32 hcc_params2;
};

struct xhci_op_regs {
	__le32 command;
	__le32 status;
	__le32 page_size;
	__le32 reserved1;
	__le32 reserved2;
	__le32 dev_notification;
	__le64 cmd_ring;
	__le32 reserved3[4];
	__le64 dcbaa_ptr;
	__le32 config_reg;
	__le32 reserved4[241];
	__le32 port_status_base;
	__le32 port_power_base;
	__le32 port_link_base;
	__le32 reserved5;
	__le32 reserved6[1016];
};

struct xhci_intr_reg {
	__le32 irq_pending;
	__le32 irq_control;
	__le32 erst_size;
	__le32 rsvd;
	__le64 erst_base;
	__le64 erst_dequeue;
};

struct xhci_run_regs {
	__le32 microframe_index;
	__le32 rsvd[7];
	struct xhci_intr_reg ir_set[128];
};

struct xhci_doorbell_array {
	__le32 doorbell[256];
};

struct xhci_container_ctx {
	unsigned int type;
	int size;
	u8 *bytes;
	dma_addr_t dma;
};

struct xhci_slot_ctx {
	__le32 dev_info;
	__le32 dev_info2;
	__le32 tt_info;
	__le32 dev_state;
	__le32 reserved[4];
};

struct xhci_ep_ctx {
	__le32 ep_info;
	__le32 ep_info2;
	__le64 deq;
	__le32 tx_info;
	__le32 reserved[3];
};

struct xhci_input_control_ctx {
	__le32 drop_flags;
	__le32 add_flags;
	__le32 rsvd2[6];
};

union xhci_trb;

struct xhci_command {
	struct xhci_container_ctx *in_ctx;
	u32 status;
	int slot_id;
	struct completion *completion;
	union xhci_trb *command_trb;
	struct list_head cmd_list;
};

struct xhci_link_trb {
	__le64 segment_ptr;
	__le32 intr_target;
	__le32 control;
};

struct xhci_transfer_event {
	__le64 buffer;
	__le32 transfer_len;
	__le32 flags;
};

struct xhci_event_cmd {
	__le64 cmd_trb;
	__le32 status;
	__le32 flags;
};

struct xhci_generic_trb {
	__le32 field[4];
};

union xhci_trb {
	struct xhci_link_trb link;
	struct xhci_transfer_event trans_event;
	struct xhci_event_cmd event_cmd;
	struct xhci_generic_trb generic;
};

struct xhci_stream_ctx {
	__le64 stream_ring;
	__le32 reserved[2];
};

struct xhci_ring;

struct xhci_stream_info {
	struct xhci_ring **stream_rings;
	unsigned int num_streams;
	struct xhci_stream_ctx *stream_ctx_array;
	unsigned int num_stream_ctxs;
	dma_addr_t ctx_array_dma;
	struct xarray trb_address_map;
	struct xhci_command *free_streams_command;
};

enum xhci_ring_type {
	TYPE_CTRL = 0,
	TYPE_ISOC = 1,
	TYPE_BULK = 2,
	TYPE_INTR = 3,
	TYPE_STREAM = 4,
	TYPE_COMMAND = 5,
	TYPE_EVENT = 6,
};

struct xhci_segment;

struct xhci_ring {
	struct xhci_segment *first_seg;
	struct xhci_segment *last_seg;
	union xhci_trb *enqueue;
	struct xhci_segment *enq_seg;
	union xhci_trb *dequeue;
	struct xhci_segment *deq_seg;
	struct list_head td_list;
	u32 cycle_state;
	unsigned int err_count;
	unsigned int stream_id;
	unsigned int num_segs;
	unsigned int num_trbs_free;
	unsigned int num_trbs_free_temp;
	unsigned int bounce_buf_len;
	enum xhci_ring_type type;
	bool last_td_was_short;
	struct xarray *trb_address_map;
};

struct xhci_bw_info {
	unsigned int ep_interval;
	unsigned int mult;
	unsigned int num_packets;
	unsigned int max_packet_size;
	unsigned int max_esit_payload;
	unsigned int type;
};

struct xhci_virt_device;

struct xhci_hcd;

struct xhci_virt_ep {
	struct xhci_virt_device *vdev;
	unsigned int ep_index;
	struct xhci_ring *ring;
	struct xhci_stream_info *stream_info;
	struct xhci_ring *new_ring;
	unsigned int ep_state;
	struct list_head cancelled_td_list;
	struct timer_list stop_cmd_timer;
	struct xhci_hcd *xhci;
	struct xhci_segment *queued_deq_seg;
	union xhci_trb *queued_deq_ptr;
	bool skip;
	struct xhci_bw_info bw_info;
	struct list_head bw_endpoint_list;
	int next_frame_id;
	bool use_extended_tbc;
};

struct xhci_interval_bw_table;

struct xhci_tt_bw_info;

struct xhci_virt_device {
	int slot_id;
	struct usb_device *udev;
	struct xhci_container_ctx *out_ctx;
	struct xhci_container_ctx *in_ctx;
	struct xhci_virt_ep eps[31];
	u8 fake_port;
	u8 real_port;
	struct xhci_interval_bw_table *bw_table;
	struct xhci_tt_bw_info *tt_info;
	long unsigned int flags;
	u16 current_mel;
	void *debugfs_private;
};

struct xhci_erst_entry;

struct xhci_erst {
	struct xhci_erst_entry *entries;
	unsigned int num_entries;
	dma_addr_t erst_dma_addr;
	unsigned int erst_size;
};

struct s3_save {
	u32 command;
	u32 dev_nt;
	u64 dcbaa_ptr;
	u32 config_reg;
	u32 irq_pending;
	u32 irq_control;
	u32 erst_size;
	u64 erst_base;
	u64 erst_dequeue;
};

struct xhci_bus_state {
	long unsigned int bus_suspended;
	long unsigned int next_statechange;
	u32 port_c_suspend;
	u32 suspended_ports;
	u32 port_remote_wakeup;
	long unsigned int resume_done[31];
	long unsigned int resuming_ports;
	long unsigned int rexit_ports;
	struct completion rexit_done[31];
	struct completion u3exit_done[31];
};

struct xhci_port;

struct xhci_hub {
	struct xhci_port **ports;
	unsigned int num_ports;
	struct usb_hcd *hcd;
	struct xhci_bus_state bus_state;
	u8 maj_rev;
	u8 min_rev;
};

struct xhci_device_context_array;

struct xhci_scratchpad;

struct xhci_root_port_bw_info;

struct xhci_port_cap;

struct xhci_vendor_ops;

struct xhci_hcd {
	struct usb_hcd *main_hcd;
	struct usb_hcd *shared_hcd;
	struct xhci_cap_regs *cap_regs;
	struct xhci_op_regs *op_regs;
	struct xhci_run_regs *run_regs;
	struct xhci_doorbell_array *dba;
	struct xhci_intr_reg *ir_set;
	__u32 hcs_params1;
	__u32 hcs_params2;
	__u32 hcs_params3;
	__u32 hcc_params;
	__u32 hcc_params2;
	spinlock_t lock;
	u8 sbrn;
	u16 hci_version;
	u8 max_slots;
	u8 max_interrupters;
	u8 max_ports;
	u8 isoc_threshold;
	u32 imod_interval;
	int event_ring_max;
	int page_size;
	int page_shift;
	int msix_count;
	struct clk *clk;
	struct clk *reg_clk;
	struct reset_control *reset;
	struct xhci_device_context_array *dcbaa;
	struct xhci_ring *cmd_ring;
	unsigned int cmd_ring_state;
	struct list_head cmd_list;
	unsigned int cmd_ring_reserved_trbs;
	struct delayed_work cmd_timer;
	struct completion cmd_ring_stop_completion;
	struct xhci_command *current_cmd;
	struct xhci_ring *event_ring;
	struct xhci_erst erst;
	struct xhci_scratchpad *scratchpad;
	struct list_head lpm_failed_devs;
	struct mutex mutex;
	struct xhci_command *lpm_command;
	struct xhci_virt_device *devs[256];
	struct xhci_root_port_bw_info *rh_bw;
	struct dma_pool *device_pool;
	struct dma_pool *segment_pool;
	struct dma_pool *small_streams_pool;
	struct dma_pool *medium_streams_pool;
	unsigned int xhc_state;
	u32 command;
	struct s3_save s3;
	long long unsigned int quirks;
	unsigned int num_active_eps;
	unsigned int limit_active_eps;
	struct xhci_port *hw_ports;
	struct xhci_hub usb2_rhub;
	struct xhci_hub usb3_rhub;
	unsigned int hw_lpm_support: 1;
	unsigned int broken_suspend: 1;
	u32 *ext_caps;
	unsigned int num_ext_caps;
	struct xhci_port_cap *port_caps;
	unsigned int num_port_caps;
	struct timer_list comp_mode_recovery_timer;
	u32 port_status_u0;
	u16 test_mode;
	struct dentry *debugfs_root;
	struct dentry *debugfs_slots;
	struct list_head regset_list;
	void *dbc;
	union {
		struct xhci_vendor_ops *vendor_ops;
		struct {
			u64 android_kabi_reserved1;
		};
		union {		};
	};
	long unsigned int priv[0];
};

struct xhci_segment {
	union xhci_trb *trbs;
	struct xhci_segment *next;
	dma_addr_t dma;
	dma_addr_t bounce_dma;
	void *bounce_buf;
	unsigned int bounce_offs;
	unsigned int bounce_len;
};

enum xhci_overhead_type {
	LS_OVERHEAD_TYPE = 0,
	FS_OVERHEAD_TYPE = 1,
	HS_OVERHEAD_TYPE = 2,
};

struct xhci_interval_bw {
	unsigned int num_packets;
	struct list_head endpoints;
	unsigned int overhead[3];
};

struct xhci_interval_bw_table {
	unsigned int interval0_esit_payload;
	struct xhci_interval_bw interval_bw[16];
	unsigned int bw_used;
	unsigned int ss_bw_in;
	unsigned int ss_bw_out;
};

struct xhci_tt_bw_info {
	struct list_head tt_list;
	int slot_id;
	int ttport;
	struct xhci_interval_bw_table bw_table;
	int active_eps;
};

struct xhci_root_port_bw_info {
	struct list_head tts;
	unsigned int num_active_tts;
	struct xhci_interval_bw_table bw_table;
};

struct xhci_device_context_array {
	__le64 dev_context_ptrs[256];
	dma_addr_t dma;
};

enum xhci_setup_dev {
	SETUP_CONTEXT_ONLY = 0,
	SETUP_CONTEXT_ADDRESS = 1,
};

enum xhci_cancelled_td_status {
	TD_DIRTY = 0,
	TD_HALTED = 1,
	TD_CLEARING_CACHE = 2,
	TD_CLEARED = 3,
};

struct xhci_td {
	struct list_head td_list;
	struct list_head cancelled_td_list;
	int status;
	enum xhci_cancelled_td_status cancel_status;
	struct urb *urb;
	struct xhci_segment *start_seg;
	union xhci_trb *first_trb;
	union xhci_trb *last_trb;
	struct xhci_segment *last_trb_seg;
	struct xhci_segment *bounce_seg;
	bool urb_length_set;
	unsigned int num_trbs;
};

struct xhci_erst_entry {
	__le64 seg_addr;
	__le32 seg_size;
	__le32 rsvd;
};

struct xhci_scratchpad {
	u64 *sp_array;
	dma_addr_t sp_dma;
	void **sp_buffers;
};

struct urb_priv___2 {
	int num_tds;
	int num_tds_done;
	struct xhci_td td[0];
};

struct xhci_port_cap {
	u32 *psi;
	u8 psi_count;
	u8 psi_uid_count;
	u8 maj_rev;
	u8 min_rev;
};

struct xhci_port {
	__le32 *addr;
	int hw_portnum;
	int hcd_portnum;
	struct xhci_hub *rhub;
	struct xhci_port_cap *port_cap;
};

struct xhci_vendor_ops {
	int (*vendor_init)(struct xhci_hcd *);
	void (*vendor_cleanup)(struct xhci_hcd *);
	bool (*is_usb_offload_enabled)(struct xhci_hcd *, struct xhci_virt_device *, unsigned int);
	irqreturn_t (*queue_irq_work)(struct xhci_hcd *);
	struct xhci_device_context_array * (*alloc_dcbaa)(struct xhci_hcd *, gfp_t);
	void (*free_dcbaa)(struct xhci_hcd *);
	struct xhci_ring * (*alloc_transfer_ring)(struct xhci_hcd *, u32, enum xhci_ring_type, unsigned int, gfp_t);
	void (*free_transfer_ring)(struct xhci_hcd *, struct xhci_virt_device *, unsigned int);
	int (*sync_dev_ctx)(struct xhci_hcd *, unsigned int);
	bool (*usb_offload_skip_urb)(struct xhci_hcd *, struct urb *);
	void (*alloc_container_ctx)(struct xhci_hcd *, struct xhci_container_ctx *, int, gfp_t);
	void (*free_container_ctx)(struct xhci_hcd *, struct xhci_container_ctx *);
};

struct xhci_driver_overrides {
	size_t extra_priv_size;
	int (*reset)(struct usb_hcd *);
	int (*start)(struct usb_hcd *);
	int (*add_endpoint)(struct usb_hcd *, struct usb_device *, struct usb_host_endpoint *);
	int (*drop_endpoint)(struct usb_hcd *, struct usb_device *, struct usb_host_endpoint *);
	int (*check_bandwidth)(struct usb_hcd *, struct usb_device *);
	void (*reset_bandwidth)(struct usb_hcd *, struct usb_device *);
	int (*address_device)(struct usb_hcd *, struct usb_device *);
	int (*bus_suspend)(struct usb_hcd *);
	int (*bus_resume)(struct usb_hcd *);
};

typedef void (*xhci_get_quirks_t)(struct device *, struct xhci_hcd *);

enum xhci_ep_reset_type {
	EP_HARD_RESET = 0,
	EP_SOFT_RESET = 1,
};

struct dbc_regs {
	__le32 capability;
	__le32 doorbell;
	__le32 ersts;
	__le32 __reserved_0;
	__le64 erstba;
	__le64 erdp;
	__le32 control;
	__le32 status;
	__le32 portsc;
	__le32 __reserved_1;
	__le64 dccp;
	__le32 devinfo1;
	__le32 devinfo2;
};

struct dbc_str_descs {
	char string0[64];
	char manufacturer[64];
	char product[64];
	char serial[64];
};

enum dbc_state {
	DS_DISABLED = 0,
	DS_INITIALIZED = 1,
	DS_ENABLED = 2,
	DS_CONNECTED = 3,
	DS_CONFIGURED = 4,
	DS_STALLED = 5,
};

struct xhci_dbc;

struct dbc_ep {
	struct xhci_dbc *dbc;
	struct list_head list_pending;
	struct xhci_ring *ring;
	unsigned int direction: 1;
};

struct dbc_driver;

struct xhci_dbc {
	spinlock_t lock;
	struct device *dev;
	struct xhci_hcd *xhci;
	struct dbc_regs *regs;
	struct xhci_ring *ring_evt;
	struct xhci_ring *ring_in;
	struct xhci_ring *ring_out;
	struct xhci_erst erst;
	struct xhci_container_ctx *ctx;
	struct dbc_str_descs *string;
	dma_addr_t string_dma;
	size_t string_size;
	enum dbc_state state;
	struct delayed_work event_work;
	unsigned int resume_required: 1;
	struct dbc_ep eps[2];
	const struct dbc_driver *driver;
	void *priv;
};

struct dbc_driver {
	int (*configure)(struct xhci_dbc *);
	void (*disconnect)(struct xhci_dbc *);
};

struct dbc_request {
	void *buf;
	unsigned int length;
	dma_addr_t dma;
	void (*complete)(struct xhci_dbc *, struct dbc_request *);
	struct list_head list_pool;
	int status;
	unsigned int actual;
	struct xhci_dbc *dbc;
	struct list_head list_pending;
	dma_addr_t trb_dma;
	union xhci_trb *trb;
	unsigned int direction: 1;
};

struct trace_event_raw_xhci_log_msg {
	struct trace_entry ent;
	u32 __data_loc_msg;
	char __data[0];
};

struct trace_event_raw_xhci_log_ctx {
	struct trace_entry ent;
	int ctx_64;
	unsigned int ctx_type;
	dma_addr_t ctx_dma;
	u8 *ctx_va;
	unsigned int ctx_ep_num;
	int slot_id;
	u32 __data_loc_ctx_data;
	char __data[0];
};

struct trace_event_raw_xhci_log_trb {
	struct trace_entry ent;
	u32 type;
	u32 field0;
	u32 field1;
	u32 field2;
	u32 field3;
	u32 __data_loc_str;
	char __data[0];
};

struct trace_event_raw_xhci_log_free_virt_dev {
	struct trace_entry ent;
	void *vdev;
	long long unsigned int out_ctx;
	long long unsigned int in_ctx;
	u8 fake_port;
	u8 real_port;
	u16 current_mel;
	char __data[0];
};

struct trace_event_raw_xhci_log_virt_dev {
	struct trace_entry ent;
	void *vdev;
	long long unsigned int out_ctx;
	long long unsigned int in_ctx;
	int devnum;
	int state;
	int speed;
	u8 portnum;
	u8 level;
	int slot_id;
	char __data[0];
};

struct trace_event_raw_xhci_log_urb {
	struct trace_entry ent;
	void *urb;
	unsigned int pipe;
	unsigned int stream;
	int status;
	unsigned int flags;
	int num_mapped_sgs;
	int num_sgs;
	int length;
	int actual;
	int epnum;
	int dir_in;
	int type;
	int slot_id;
	char __data[0];
};

struct trace_event_raw_xhci_log_ep_ctx {
	struct trace_entry ent;
	u32 info;
	u32 info2;
	u64 deq;
	u32 tx_info;
	u32 __data_loc_str;
	char __data[0];
};

struct trace_event_raw_xhci_log_slot_ctx {
	struct trace_entry ent;
	u32 info;
	u32 info2;
	u32 tt_info;
	u32 state;
	u32 __data_loc_str;
	char __data[0];
};

struct trace_event_raw_xhci_log_ctrl_ctx {
	struct trace_entry ent;
	u32 drop;
	u32 add;
	u32 __data_loc_str;
	char __data[0];
};

struct trace_event_raw_xhci_log_ring {
	struct trace_entry ent;
	u32 type;
	void *ring;
	dma_addr_t enq;
	dma_addr_t deq;
	dma_addr_t enq_seg;
	dma_addr_t deq_seg;
	unsigned int num_segs;
	unsigned int stream_id;
	unsigned int cycle_state;
	unsigned int num_trbs_free;
	unsigned int bounce_buf_len;
	char __data[0];
};

struct trace_event_raw_xhci_log_portsc {
	struct trace_entry ent;
	u32 portnum;
	u32 portsc;
	u32 __data_loc_str;
	char __data[0];
};

struct trace_event_raw_xhci_log_doorbell {
	struct trace_entry ent;
	u32 slot;
	u32 doorbell;
	u32 __data_loc_str;
	char __data[0];
};

struct trace_event_raw_xhci_dbc_log_request {
	struct trace_entry ent;
	struct dbc_request *req;
	bool dir;
	unsigned int actual;
	unsigned int length;
	int status;
	char __data[0];
};

struct trace_event_data_offsets_xhci_log_msg {
	u32 msg;
};

struct trace_event_data_offsets_xhci_log_ctx {
	u32 ctx_data;
};

struct trace_event_data_offsets_xhci_log_trb {
	u32 str;
};

struct trace_event_data_offsets_xhci_log_free_virt_dev {};

struct trace_event_data_offsets_xhci_log_virt_dev {};

struct trace_event_data_offsets_xhci_log_urb {};

struct trace_event_data_offsets_xhci_log_ep_ctx {
	u32 str;
};

struct trace_event_data_offsets_xhci_log_slot_ctx {
	u32 str;
};

struct trace_event_data_offsets_xhci_log_ctrl_ctx {
	u32 str;
};

struct trace_event_data_offsets_xhci_log_ring {};

struct trace_event_data_offsets_xhci_log_portsc {
	u32 str;
};

struct trace_event_data_offsets_xhci_log_doorbell {
	u32 str;
};

struct trace_event_data_offsets_xhci_dbc_log_request {};

typedef void (*btf_trace_xhci_dbg_address)(void *, struct va_format *);

typedef void (*btf_trace_xhci_dbg_context_change)(void *, struct va_format *);

typedef void (*btf_trace_xhci_dbg_quirks)(void *, struct va_format *);

typedef void (*btf_trace_xhci_dbg_reset_ep)(void *, struct va_format *);

typedef void (*btf_trace_xhci_dbg_cancel_urb)(void *, struct va_format *);

typedef void (*btf_trace_xhci_dbg_init)(void *, struct va_format *);

typedef void (*btf_trace_xhci_dbg_ring_expansion)(void *, struct va_format *);

typedef void (*btf_trace_xhci_address_ctx)(void *, struct xhci_hcd *, struct xhci_container_ctx *, unsigned int);

typedef void (*btf_trace_xhci_handle_event)(void *, struct xhci_ring *, struct xhci_generic_trb *);

typedef void (*btf_trace_xhci_handle_command)(void *, struct xhci_ring *, struct xhci_generic_trb *);

typedef void (*btf_trace_xhci_handle_transfer)(void *, struct xhci_ring *, struct xhci_generic_trb *);

typedef void (*btf_trace_xhci_queue_trb)(void *, struct xhci_ring *, struct xhci_generic_trb *);

typedef void (*btf_trace_xhci_dbc_handle_event)(void *, struct xhci_ring *, struct xhci_generic_trb *);

typedef void (*btf_trace_xhci_dbc_handle_transfer)(void *, struct xhci_ring *, struct xhci_generic_trb *);

typedef void (*btf_trace_xhci_dbc_gadget_ep_queue)(void *, struct xhci_ring *, struct xhci_generic_trb *);

typedef void (*btf_trace_xhci_free_virt_device)(void *, struct xhci_virt_device *);

typedef void (*btf_trace_xhci_alloc_virt_device)(void *, struct xhci_virt_device *);

typedef void (*btf_trace_xhci_setup_device)(void *, struct xhci_virt_device *);

typedef void (*btf_trace_xhci_setup_addressable_virt_device)(void *, struct xhci_virt_device *);

typedef void (*btf_trace_xhci_stop_device)(void *, struct xhci_virt_device *);

typedef void (*btf_trace_xhci_urb_enqueue)(void *, struct urb *);

typedef void (*btf_trace_xhci_urb_giveback)(void *, struct urb *);

typedef void (*btf_trace_xhci_urb_dequeue)(void *, struct urb *);

typedef void (*btf_trace_xhci_handle_cmd_stop_ep)(void *, struct xhci_ep_ctx *);

typedef void (*btf_trace_xhci_handle_cmd_set_deq_ep)(void *, struct xhci_ep_ctx *);

typedef void (*btf_trace_xhci_handle_cmd_reset_ep)(void *, struct xhci_ep_ctx *);

typedef void (*btf_trace_xhci_handle_cmd_config_ep)(void *, struct xhci_ep_ctx *);

typedef void (*btf_trace_xhci_add_endpoint)(void *, struct xhci_ep_ctx *);

typedef void (*btf_trace_xhci_alloc_dev)(void *, struct xhci_slot_ctx *);

typedef void (*btf_trace_xhci_free_dev)(void *, struct xhci_slot_ctx *);

typedef void (*btf_trace_xhci_handle_cmd_disable_slot)(void *, struct xhci_slot_ctx *);

typedef void (*btf_trace_xhci_discover_or_reset_device)(void *, struct xhci_slot_ctx *);

typedef void (*btf_trace_xhci_setup_device_slot)(void *, struct xhci_slot_ctx *);

typedef void (*btf_trace_xhci_handle_cmd_addr_dev)(void *, struct xhci_slot_ctx *);

typedef void (*btf_trace_xhci_handle_cmd_reset_dev)(void *, struct xhci_slot_ctx *);

typedef void (*btf_trace_xhci_handle_cmd_set_deq)(void *, struct xhci_slot_ctx *);

typedef void (*btf_trace_xhci_configure_endpoint)(void *, struct xhci_slot_ctx *);

typedef void (*btf_trace_xhci_address_ctrl_ctx)(void *, struct xhci_input_control_ctx *);

typedef void (*btf_trace_xhci_configure_endpoint_ctrl_ctx)(void *, struct xhci_input_control_ctx *);

typedef void (*btf_trace_xhci_ring_alloc)(void *, struct xhci_ring *);

typedef void (*btf_trace_xhci_ring_free)(void *, struct xhci_ring *);

typedef void (*btf_trace_xhci_ring_expansion)(void *, struct xhci_ring *);

typedef void (*btf_trace_xhci_inc_enq)(void *, struct xhci_ring *);

typedef void (*btf_trace_xhci_inc_deq)(void *, struct xhci_ring *);

typedef void (*btf_trace_xhci_handle_port_status)(void *, u32, u32);

typedef void (*btf_trace_xhci_get_port_status)(void *, u32, u32);

typedef void (*btf_trace_xhci_hub_status_data)(void *, u32, u32);

typedef void (*btf_trace_xhci_ring_ep_doorbell)(void *, u32, u32);

typedef void (*btf_trace_xhci_ring_host_doorbell)(void *, u32, u32);

typedef void (*btf_trace_xhci_dbc_alloc_request)(void *, struct dbc_request *);

typedef void (*btf_trace_xhci_dbc_free_request)(void *, struct dbc_request *);

typedef void (*btf_trace_xhci_dbc_queue_request)(void *, struct dbc_request *);

typedef void (*btf_trace_xhci_dbc_giveback_request)(void *, struct dbc_request *);

struct xhci_regset {
	char name[32];
	struct debugfs_regset32 regset;
	size_t nregs;
	struct list_head list;
};

struct xhci_file_map {
	const char *name;
	int (*show)(struct seq_file *, void *);
};

struct xhci_ep_priv {
	char name[32];
	struct dentry *root;
	struct xhci_stream_info *stream_info;
	struct xhci_ring *show_ring;
	unsigned int stream_id;
};

struct xhci_slot_priv {
	char name[32];
	struct dentry *root;
	struct xhci_ep_priv *eps[31];
	struct xhci_virt_device *dev;
};

struct xhci_vendor_data;

struct xhci_plat_priv {
	const char *firmware_name;
	long long unsigned int quirks;
	struct xhci_vendor_data *vendor_data;
	int (*plat_setup)(struct usb_hcd *);
	void (*plat_start)(struct usb_hcd *);
	int (*init_quirk)(struct usb_hcd *);
	int (*suspend_quirk)(struct usb_hcd *);
	int (*resume_quirk)(struct usb_hcd *);
};

struct xhci_plat_priv_overwrite {
	struct xhci_vendor_ops *vendor_ops;
};

enum {
	US_FL_SINGLE_LUN = 1,
	US_FL_NEED_OVERRIDE = 2,
	US_FL_SCM_MULT_TARG = 4,
	US_FL_FIX_INQUIRY = 8,
	US_FL_FIX_CAPACITY = 16,
	US_FL_IGNORE_RESIDUE = 32,
	US_FL_BULK32 = 64,
	US_FL_NOT_LOCKABLE = 128,
	US_FL_GO_SLOW = 256,
	US_FL_NO_WP_DETECT = 512,
	US_FL_MAX_SECTORS_64 = 1024,
	US_FL_IGNORE_DEVICE = 2048,
	US_FL_CAPACITY_HEURISTICS = 4096,
	US_FL_MAX_SECTORS_MIN = 8192,
	US_FL_BULK_IGNORE_TAG = 16384,
	US_FL_SANE_SENSE = 32768,
	US_FL_CAPACITY_OK = 65536,
	US_FL_BAD_SENSE = 131072,
	US_FL_NO_READ_DISC_INFO = 262144,
	US_FL_NO_READ_CAPACITY_16 = 524288,
	US_FL_INITIAL_READ10 = 1048576,
	US_FL_WRITE_CACHE = 2097152,
	US_FL_NEEDS_CAP16 = 4194304,
	US_FL_IGNORE_UAS = 8388608,
	US_FL_BROKEN_FUA = 16777216,
	US_FL_NO_ATA_1X = 33554432,
	US_FL_NO_REPORT_OPCODES = 67108864,
	US_FL_MAX_SECTORS_240 = 134217728,
	US_FL_NO_REPORT_LUNS = 268435456,
	US_FL_ALWAYS_SYNC = 536870912,
	US_FL_NO_SAME = 1073741824,
	US_FL_SENSE_AFTER_SYNC = 2147483648,
};

struct us_data;

struct us_unusual_dev {
	const char *vendorName;
	const char *productName;
	__u8 useProtocol;
	__u8 useTransport;
	int (*initFunction)(struct us_data *);
};

typedef int (*trans_cmnd)(struct scsi_cmnd *, struct us_data *);

typedef int (*trans_reset)(struct us_data *);

typedef void (*proto_cmnd)(struct scsi_cmnd *, struct us_data *);

typedef void (*extra_data_destructor)(void *);

typedef void (*pm_hook)(struct us_data *, int);

struct us_data {
	struct mutex dev_mutex;
	struct usb_device *pusb_dev;
	struct usb_interface *pusb_intf;
	const struct us_unusual_dev *unusual_dev;
	long unsigned int fflags;
	long unsigned int dflags;
	unsigned int send_bulk_pipe;
	unsigned int recv_bulk_pipe;
	unsigned int send_ctrl_pipe;
	unsigned int recv_ctrl_pipe;
	unsigned int recv_intr_pipe;
	char *transport_name;
	char *protocol_name;
	__le32 bcs_signature;
	u8 subclass;
	u8 protocol;
	u8 max_lun;
	u8 ifnum;
	u8 ep_bInterval;
	trans_cmnd transport;
	trans_reset transport_reset;
	proto_cmnd proto_handler;
	struct scsi_cmnd *srb;
	unsigned int tag;
	char scsi_name[32];
	struct urb *current_urb;
	struct usb_ctrlrequest *cr;
	struct usb_sg_request current_sg;
	unsigned char *iobuf;
	dma_addr_t iobuf_dma;
	struct task_struct *ctl_thread;
	struct completion cmnd_ready;
	struct completion notify;
	wait_queue_head_t delay_wait;
	struct delayed_work scan_dwork;
	void *extra;
	extra_data_destructor extra_destructor;
	pm_hook suspend_resume_hook;
	int use_last_sector_hacks;
	int last_sector_retries;
};

enum xfer_buf_dir {
	TO_XFER_BUF = 0,
	FROM_XFER_BUF = 1,
};

struct bulk_cb_wrap {
	__le32 Signature;
	__u32 Tag;
	__le32 DataTransferLength;
	__u8 Flags;
	__u8 Lun;
	__u8 Length;
	__u8 CDB[16];
};

struct bulk_cs_wrap {
	__le32 Signature;
	__u32 Tag;
	__le32 Residue;
	__u8 Status;
};

struct swoc_info {
	__u8 rev;
	__u8 reserved[8];
	__u16 LinuxSKU;
	__u16 LinuxVer;
	__u8 reserved2[47];
} __attribute__((packed));

struct ignore_entry {
	u16 vid;
	u16 pid;
	u16 bcdmin;
	u16 bcdmax;
};

struct nand_flash_dev {
	int model_id;
	int chipshift;
	char pageshift;
	char blockshift;
	char zoneshift;
	char pageadrlen;
};

struct sddr09_card_info {
	long unsigned int capacity;
	int pagesize;
	int pageshift;
	int blocksize;
	int blockshift;
	int blockmask;
	int *lba_to_pba;
	int *pba_to_lba;
	int lbact;
	int flags;
};

struct sddr55_card_info {
	long unsigned int capacity;
	int max_log_blks;
	int pageshift;
	int smallpageshift;
	int blocksize;
	int blockshift;
	int blockmask;
	int read_only;
	int force_read_only;
	int *lba_to_pba;
	int *pba_to_lba;
	int fatal_error;
	long unsigned int last_access;
	unsigned char sense_data[18];
};

struct usb_string {
	u8 id;
	const char *s;
};

struct usb_gadget_strings {
	u16 language;
	struct usb_string *strings;
};

struct usb_otg_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bmAttributes;
};

struct usb_otg20_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bmAttributes;
	__le16 bcdOTG;
} __attribute__((packed));

struct usb_ep;

struct usb_request {
	void *buf;
	unsigned int length;
	dma_addr_t dma;
	struct scatterlist *sg;
	unsigned int num_sgs;
	unsigned int num_mapped_sgs;
	unsigned int stream_id: 16;
	unsigned int is_last: 1;
	unsigned int no_interrupt: 1;
	unsigned int zero: 1;
	unsigned int short_not_ok: 1;
	unsigned int dma_mapped: 1;
	void (*complete)(struct usb_ep *, struct usb_request *);
	void *context;
	struct list_head list;
	unsigned int frame_number;
	int status;
	unsigned int actual;
};

struct usb_ep_caps {
	unsigned int type_control: 1;
	unsigned int type_iso: 1;
	unsigned int type_bulk: 1;
	unsigned int type_int: 1;
	unsigned int dir_in: 1;
	unsigned int dir_out: 1;
};

struct usb_ep_ops;

struct usb_ep {
	void *driver_data;
	const char *name;
	const struct usb_ep_ops *ops;
	struct list_head ep_list;
	struct usb_ep_caps caps;
	bool claimed;
	bool enabled;
	unsigned int maxpacket: 16;
	unsigned int maxpacket_limit: 16;
	unsigned int max_streams: 16;
	unsigned int mult: 2;
	unsigned int maxburst: 5;
	u8 address;
	const struct usb_endpoint_descriptor *desc;
	const struct usb_ss_ep_comp_descriptor *comp_desc;
};

struct usb_ep_ops {
	int (*enable)(struct usb_ep *, const struct usb_endpoint_descriptor *);
	int (*disable)(struct usb_ep *);
	void (*dispose)(struct usb_ep *);
	struct usb_request * (*alloc_request)(struct usb_ep *, gfp_t);
	void (*free_request)(struct usb_ep *, struct usb_request *);
	int (*queue)(struct usb_ep *, struct usb_request *, gfp_t);
	int (*dequeue)(struct usb_ep *, struct usb_request *);
	int (*set_halt)(struct usb_ep *, int);
	int (*set_wedge)(struct usb_ep *);
	int (*fifo_status)(struct usb_ep *);
	void (*fifo_flush)(struct usb_ep *);
};

struct usb_dcd_config_params {
	__u8 bU1devExitLat;
	__le16 bU2DevExitLat;
	__u8 besl_baseline;
	__u8 besl_deep;
};

struct usb_gadget;

struct usb_gadget_driver;

struct usb_gadget_ops {
	int (*get_frame)(struct usb_gadget *);
	int (*wakeup)(struct usb_gadget *);
	int (*set_selfpowered)(struct usb_gadget *, int);
	int (*vbus_session)(struct usb_gadget *, int);
	int (*vbus_draw)(struct usb_gadget *, unsigned int);
	int (*pullup)(struct usb_gadget *, int);
	int (*ioctl)(struct usb_gadget *, unsigned int, long unsigned int);
	void (*get_config_params)(struct usb_gadget *, struct usb_dcd_config_params *);
	int (*udc_start)(struct usb_gadget *, struct usb_gadget_driver *);
	int (*udc_stop)(struct usb_gadget *);
	void (*udc_set_speed)(struct usb_gadget *, enum usb_device_speed);
	void (*udc_set_ssp_rate)(struct usb_gadget *, enum usb_ssp_rate);
	void (*udc_async_callbacks)(struct usb_gadget *, bool);
	struct usb_ep * (*match_ep)(struct usb_gadget *, struct usb_endpoint_descriptor *, struct usb_ss_ep_comp_descriptor *);
	int (*check_config)(struct usb_gadget *);
};

struct usb_udc;

struct usb_gadget {
	struct work_struct work;
	struct usb_udc *udc;
	const struct usb_gadget_ops *ops;
	struct usb_ep *ep0;
	struct list_head ep_list;
	enum usb_device_speed speed;
	enum usb_device_speed max_speed;
	enum usb_ssp_rate ssp_rate;
	enum usb_ssp_rate max_ssp_rate;
	enum usb_device_state state;
	const char *name;
	struct device dev;
	unsigned int isoch_delay;
	unsigned int out_epnum;
	unsigned int in_epnum;
	unsigned int mA;
	struct usb_otg_caps *otg_caps;
	unsigned int sg_supported: 1;
	unsigned int is_otg: 1;
	unsigned int is_a_peripheral: 1;
	unsigned int b_hnp_enable: 1;
	unsigned int a_hnp_support: 1;
	unsigned int a_alt_hnp_support: 1;
	unsigned int hnp_polling_support: 1;
	unsigned int host_request_flag: 1;
	unsigned int quirk_ep_out_aligned_size: 1;
	unsigned int quirk_altset_not_supp: 1;
	unsigned int quirk_stall_not_supp: 1;
	unsigned int quirk_zlp_not_supp: 1;
	unsigned int quirk_avoids_skb_reserve: 1;
	unsigned int is_selfpowered: 1;
	unsigned int deactivated: 1;
	unsigned int connected: 1;
	unsigned int lpm_capable: 1;
	int irq;
};

struct usb_gadget_driver {
	char *function;
	enum usb_device_speed max_speed;
	int (*bind)(struct usb_gadget *, struct usb_gadget_driver *);
	void (*unbind)(struct usb_gadget *);
	int (*setup)(struct usb_gadget *, const struct usb_ctrlrequest *);
	void (*disconnect)(struct usb_gadget *);
	void (*suspend)(struct usb_gadget *);
	void (*resume)(struct usb_gadget *);
	void (*reset)(struct usb_gadget *);
	struct device_driver driver;
	char *udc_name;
	struct list_head pending;
	unsigned int match_existing_only: 1;
};

struct usb_os_desc {
	char *ext_compat_id;
	struct list_head ext_prop;
	int ext_prop_len;
	int ext_prop_count;
	struct mutex *opts_mutex;
	struct config_group group;
	struct module *owner;
};

struct usb_os_desc_table {
	int if_id;
	struct usb_os_desc *os_desc;
};

struct usb_configuration;

struct usb_function_instance;

struct usb_function {
	const char *name;
	struct usb_gadget_strings **strings;
	struct usb_descriptor_header **fs_descriptors;
	struct usb_descriptor_header **hs_descriptors;
	struct usb_descriptor_header **ss_descriptors;
	struct usb_descriptor_header **ssp_descriptors;
	struct usb_configuration *config;
	struct usb_os_desc_table *os_desc_table;
	unsigned int os_desc_n;
	int (*bind)(struct usb_configuration *, struct usb_function *);
	void (*unbind)(struct usb_configuration *, struct usb_function *);
	void (*free_func)(struct usb_function *);
	struct module *mod;
	int (*set_alt)(struct usb_function *, unsigned int, unsigned int);
	int (*get_alt)(struct usb_function *, unsigned int);
	void (*disable)(struct usb_function *);
	int (*setup)(struct usb_function *, const struct usb_ctrlrequest *);
	bool (*req_match)(struct usb_function *, const struct usb_ctrlrequest *, bool);
	void (*suspend)(struct usb_function *);
	void (*resume)(struct usb_function *);
	int (*get_status)(struct usb_function *);
	int (*func_suspend)(struct usb_function *, u8);
	struct list_head list;
	long unsigned int endpoints[1];
	const struct usb_function_instance *fi;
	unsigned int bind_deactivated: 1;
};

struct usb_composite_dev;

struct usb_configuration {
	const char *label;
	struct usb_gadget_strings **strings;
	const struct usb_descriptor_header **descriptors;
	void (*unbind)(struct usb_configuration *);
	int (*setup)(struct usb_configuration *, const struct usb_ctrlrequest *);
	u8 bConfigurationValue;
	u8 iConfiguration;
	u8 bmAttributes;
	u16 MaxPower;
	struct usb_composite_dev *cdev;
	struct list_head list;
	struct list_head functions;
	u8 next_interface_id;
	unsigned int superspeed: 1;
	unsigned int highspeed: 1;
	unsigned int fullspeed: 1;
	unsigned int superspeed_plus: 1;
	struct usb_function *interface[16];
};

struct usb_function_driver;

struct usb_function_instance {
	struct config_group group;
	struct list_head cfs_list;
	struct usb_function_driver *fd;
	struct usb_function *f;
	int (*set_inst_name)(struct usb_function_instance *, const char *);
	void (*free_func_inst)(struct usb_function_instance *);
};

struct usb_composite_driver;

struct usb_composite_dev {
	struct usb_gadget *gadget;
	struct usb_request *req;
	struct usb_request *os_desc_req;
	struct usb_configuration *config;
	u8 qw_sign[14];
	u8 b_vendor_code;
	char: 8;
	struct usb_configuration *os_desc_config;
	unsigned int use_os_string: 1;
	unsigned int suspended: 1;
	struct usb_device_descriptor desc;
	long: 40;
	struct list_head configs;
	struct list_head gstrings;
	struct usb_composite_driver *driver;
	u8 next_string_id;
	long: 56;
	char *def_manufacturer;
	unsigned int deactivations;
	int delayed_status;
	spinlock_t lock;
	unsigned int setup_pending: 1;
	unsigned int os_desc_pending: 1;
	int: 30;
} __attribute__((packed));

struct usb_composite_driver {
	const char *name;
	const struct usb_device_descriptor *dev;
	struct usb_gadget_strings **strings;
	enum usb_device_speed max_speed;
	unsigned int needs_serial: 1;
	int (*bind)(struct usb_composite_dev *);
	int (*unbind)(struct usb_composite_dev *);
	void (*disconnect)(struct usb_composite_dev *);
	void (*suspend)(struct usb_composite_dev *);
	void (*resume)(struct usb_composite_dev *);
	struct usb_gadget_driver gadget_driver;
};

struct usb_function_driver {
	const char *name;
	struct module *mod;
	struct list_head list;
	struct usb_function_instance * (*alloc_inst)();
	struct usb_function * (*alloc_func)(struct usb_function_instance *);
};

struct usb_string_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__le16 wData[1];
};

struct usb_gadget_string_container {
	struct list_head list;
	u8 *stash[0];
};

struct usb_os_desc_ext_prop {
	struct list_head entry;
	u8 type;
	int name_len;
	char *name;
	int data_len;
	char *data;
	struct config_item item;
};

enum {
	USB_GADGET_MANUFACTURER_IDX = 0,
	USB_GADGET_PRODUCT_IDX = 1,
	USB_GADGET_SERIAL_IDX = 2,
	USB_GADGET_FIRST_AVAIL_IDX = 3,
};

struct usb_composite_overwrite {
	u16 idVendor;
	u16 idProduct;
	u16 bcdDevice;
	char *serial_number;
	char *manufacturer;
	char *product;
};

struct usb_os_string {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 qwSignature[14];
	__u8 bMS_VendorCode;
	__u8 bPad;
};

struct gadget_info {
	struct config_group group;
	struct config_group functions_group;
	struct config_group configs_group;
	struct config_group strings_group;
	struct config_group os_desc_group;
	struct mutex lock;
	struct usb_gadget_strings *gstrings[3];
	struct list_head string_list;
	struct list_head available_func;
	struct usb_composite_driver composite;
	struct usb_composite_dev cdev;
	bool use_os_desc;
	char b_vendor_code;
	char qw_sign[14];
	spinlock_t spinlock;
	bool unbind;
};

struct config_usb_cfg {
	struct config_group group;
	struct config_group strings_group;
	struct list_head string_list;
	struct usb_configuration c;
	struct list_head func_list;
	struct usb_gadget_strings *gstrings[3];
};

struct gadget_strings {
	struct usb_gadget_strings stringtab_dev;
	struct usb_string strings[3];
	char *manufacturer;
	char *product;
	char *serialnumber;
	struct config_group group;
	struct list_head list;
};

struct os_desc {
	struct config_group group;
};

struct gadget_config_name {
	struct usb_gadget_strings stringtab_dev;
	struct usb_string strings;
	char *configuration;
	struct config_group group;
	struct list_head list;
};

struct usb_udc {
	struct usb_gadget_driver *driver;
	struct usb_gadget *gadget;
	struct device dev;
	struct list_head list;
	bool vbus;
	bool started;
};

struct trace_event_raw_udc_log_gadget {
	struct trace_entry ent;
	enum usb_device_speed speed;
	enum usb_device_speed max_speed;
	enum usb_device_state state;
	unsigned int mA;
	unsigned int sg_supported;
	unsigned int is_otg;
	unsigned int is_a_peripheral;
	unsigned int b_hnp_enable;
	unsigned int a_hnp_support;
	unsigned int hnp_polling_support;
	unsigned int host_request_flag;
	unsigned int quirk_ep_out_aligned_size;
	unsigned int quirk_altset_not_supp;
	unsigned int quirk_stall_not_supp;
	unsigned int quirk_zlp_not_supp;
	unsigned int is_selfpowered;
	unsigned int deactivated;
	unsigned int connected;
	int ret;
	char __data[0];
};

struct trace_event_raw_udc_log_ep {
	struct trace_entry ent;
	u32 __data_loc_name;
	unsigned int maxpacket;
	unsigned int maxpacket_limit;
	unsigned int max_streams;
	unsigned int mult;
	unsigned int maxburst;
	u8 address;
	bool claimed;
	bool enabled;
	int ret;
	char __data[0];
};

struct trace_event_raw_udc_log_req {
	struct trace_entry ent;
	u32 __data_loc_name;
	unsigned int length;
	unsigned int actual;
	unsigned int num_sgs;
	unsigned int num_mapped_sgs;
	unsigned int stream_id;
	unsigned int no_interrupt;
	unsigned int zero;
	unsigned int short_not_ok;
	int status;
	int ret;
	struct usb_request *req;
	char __data[0];
};

struct trace_event_data_offsets_udc_log_gadget {};

struct trace_event_data_offsets_udc_log_ep {
	u32 name;
};

struct trace_event_data_offsets_udc_log_req {
	u32 name;
};

typedef void (*btf_trace_usb_gadget_frame_number)(void *, struct usb_gadget *, int);

typedef void (*btf_trace_usb_gadget_wakeup)(void *, struct usb_gadget *, int);

typedef void (*btf_trace_usb_gadget_set_selfpowered)(void *, struct usb_gadget *, int);

typedef void (*btf_trace_usb_gadget_clear_selfpowered)(void *, struct usb_gadget *, int);

typedef void (*btf_trace_usb_gadget_vbus_connect)(void *, struct usb_gadget *, int);

typedef void (*btf_trace_usb_gadget_vbus_draw)(void *, struct usb_gadget *, int);

typedef void (*btf_trace_usb_gadget_vbus_disconnect)(void *, struct usb_gadget *, int);

typedef void (*btf_trace_usb_gadget_connect)(void *, struct usb_gadget *, int);

typedef void (*btf_trace_usb_gadget_disconnect)(void *, struct usb_gadget *, int);

typedef void (*btf_trace_usb_gadget_deactivate)(void *, struct usb_gadget *, int);

typedef void (*btf_trace_usb_gadget_activate)(void *, struct usb_gadget *, int);

typedef void (*btf_trace_usb_ep_set_maxpacket_limit)(void *, struct usb_ep *, int);

typedef void (*btf_trace_usb_ep_enable)(void *, struct usb_ep *, int);

typedef void (*btf_trace_usb_ep_disable)(void *, struct usb_ep *, int);

typedef void (*btf_trace_usb_ep_set_halt)(void *, struct usb_ep *, int);

typedef void (*btf_trace_usb_ep_clear_halt)(void *, struct usb_ep *, int);

typedef void (*btf_trace_usb_ep_set_wedge)(void *, struct usb_ep *, int);

typedef void (*btf_trace_usb_ep_fifo_status)(void *, struct usb_ep *, int);

typedef void (*btf_trace_usb_ep_fifo_flush)(void *, struct usb_ep *, int);

typedef void (*btf_trace_usb_ep_alloc_request)(void *, struct usb_ep *, struct usb_request *, int);

typedef void (*btf_trace_usb_ep_free_request)(void *, struct usb_ep *, struct usb_request *, int);

typedef void (*btf_trace_usb_ep_queue)(void *, struct usb_ep *, struct usb_request *, int);

typedef void (*btf_trace_usb_ep_dequeue)(void *, struct usb_ep *, struct usb_request *, int);

typedef void (*btf_trace_usb_gadget_giveback_request)(void *, struct usb_ep *, struct usb_request *, int);

enum {
	FUNCTIONFS_DESCRIPTORS_MAGIC = 1,
	FUNCTIONFS_STRINGS_MAGIC = 2,
	FUNCTIONFS_DESCRIPTORS_MAGIC_V2 = 3,
};

enum functionfs_flags {
	FUNCTIONFS_HAS_FS_DESC = 1,
	FUNCTIONFS_HAS_HS_DESC = 2,
	FUNCTIONFS_HAS_SS_DESC = 4,
	FUNCTIONFS_HAS_MS_OS_DESC = 8,
	FUNCTIONFS_VIRTUAL_ADDR = 16,
	FUNCTIONFS_EVENTFD = 32,
	FUNCTIONFS_ALL_CTRL_RECIP = 64,
	FUNCTIONFS_CONFIG0_SETUP = 128,
};

struct usb_os_desc_header {
	__u8 interface;
	__le32 dwLength;
	__le16 bcdVersion;
	__le16 wIndex;
	union {
		struct {
			__u8 bCount;
			__u8 Reserved;
		};
		__le16 wCount;
	};
} __attribute__((packed));

struct usb_ext_compat_desc {
	__u8 bFirstInterfaceNumber;
	__u8 Reserved1;
	__u8 CompatibleID[8];
	__u8 SubCompatibleID[8];
	__u8 Reserved2[6];
};

struct usb_ext_prop_desc {
	__le32 dwSize;
	__le32 dwPropertyDataType;
	__le16 wPropertyNameLength;
} __attribute__((packed));

enum usb_functionfs_event_type {
	FUNCTIONFS_BIND = 0,
	FUNCTIONFS_UNBIND = 1,
	FUNCTIONFS_ENABLE = 2,
	FUNCTIONFS_DISABLE = 3,
	FUNCTIONFS_SETUP = 4,
	FUNCTIONFS_SUSPEND = 5,
	FUNCTIONFS_RESUME = 6,
};

struct usb_functionfs_event {
	union {
		struct usb_ctrlrequest setup;
	} u;
	__u8 type;
	__u8 _pad[3];
};

struct ffs_data;

struct f_fs_opts;

struct ffs_dev {
	struct ffs_data *ffs_data;
	struct f_fs_opts *opts;
	struct list_head entry;
	char name[41];
	bool mounted;
	bool desc_ready;
	bool single;
	int (*ffs_ready_callback)(struct ffs_data *);
	void (*ffs_closed_callback)(struct ffs_data *);
	void * (*ffs_acquire_dev_callback)(struct ffs_dev *);
	void (*ffs_release_dev_callback)(struct ffs_dev *);
};

enum ffs_state {
	FFS_READ_DESCRIPTORS = 0,
	FFS_READ_STRINGS = 1,
	FFS_ACTIVE = 2,
	FFS_DEACTIVATED = 3,
	FFS_CLOSING = 4,
};

enum ffs_setup_state {
	FFS_NO_SETUP = 0,
	FFS_SETUP_PENDING = 1,
	FFS_SETUP_CANCELLED = 2,
};

struct ffs_file_perms {
	umode_t mode;
	kuid_t uid;
	kgid_t gid;
};

struct ffs_function;

struct ffs_epfile;

struct ffs_data {
	struct usb_gadget *gadget;
	struct mutex mutex;
	spinlock_t eps_lock;
	struct usb_request *ep0req;
	struct completion ep0req_completion;
	refcount_t ref;
	atomic_t opened;
	enum ffs_state state;
	enum ffs_setup_state setup_state;
	struct {
		u8 types[4];
		short unsigned int count;
		short unsigned int can_stall;
		struct usb_ctrlrequest setup;
		wait_queue_head_t waitq;
	} ev;
	long unsigned int flags;
	wait_queue_head_t wait;
	struct ffs_function *func;
	const char *dev_name;
	void *private_data;
	const void *raw_descs_data;
	const void *raw_descs;
	unsigned int raw_descs_length;
	unsigned int fs_descs_count;
	unsigned int hs_descs_count;
	unsigned int ss_descs_count;
	unsigned int ms_os_descs_count;
	unsigned int ms_os_descs_ext_prop_count;
	unsigned int ms_os_descs_ext_prop_name_len;
	unsigned int ms_os_descs_ext_prop_data_len;
	void *ms_os_descs_ext_prop_avail;
	void *ms_os_descs_ext_prop_name_avail;
	void *ms_os_descs_ext_prop_data_avail;
	unsigned int user_flags;
	u8 eps_addrmap[31];
	short unsigned int strings_count;
	short unsigned int interfaces_count;
	short unsigned int eps_count;
	short unsigned int _pad1;
	const void *raw_strings;
	struct usb_gadget_strings **stringtabs;
	struct super_block *sb;
	struct ffs_file_perms file_perms;
	struct eventfd_ctx *ffs_eventfd;
	struct workqueue_struct *io_completion_wq;
	bool no_disconnect;
	struct work_struct reset_work;
	struct ffs_epfile *epfiles;
};

struct f_fs_opts {
	struct usb_function_instance func_inst;
	struct ffs_dev *dev;
	unsigned int refcnt;
	bool no_configfs;
};

struct ffs_ep;

struct ffs_function {
	struct usb_configuration *conf;
	struct usb_gadget *gadget;
	struct ffs_data *ffs;
	struct ffs_ep *eps;
	u8 eps_revmap[16];
	short int *interfaces_nums;
	struct usb_function function;
};

struct ffs_buffer;

struct ffs_epfile {
	struct mutex mutex;
	struct ffs_data *ffs;
	struct ffs_ep *ep;
	struct dentry *dentry;
	struct ffs_buffer *read_buffer;
	char name[5];
	unsigned char in;
	unsigned char isoc;
	unsigned char _pad;
};

struct ffs_ep {
	struct usb_ep *ep;
	struct usb_request *req;
	struct usb_endpoint_descriptor *descs[3];
	u8 num;
	int status;
};

struct ffs_buffer {
	size_t length;
	char *data;
	char storage[0];
};

struct ffs_io_data {
	bool aio;
	bool read;
	struct kiocb *kiocb;
	struct iov_iter data;
	const void *to_free;
	char *buf;
	struct mm_struct *mm;
	struct work_struct work;
	struct usb_ep *ep;
	struct usb_request *req;
	struct sg_table sgt;
	bool use_sg;
	struct ffs_data *ffs;
};

struct ffs_desc_helper {
	struct ffs_data *ffs;
	unsigned int interfaces_count;
	unsigned int eps_count;
};

struct ffs_sb_fill_data {
	struct ffs_file_perms perms;
	umode_t root_mode;
	const char *dev_name;
	bool no_disconnect;
	struct ffs_data *ffs_data;
};

enum {
	Opt_no_disconnect = 0,
	Opt_rmode = 1,
	Opt_fmode = 2,
	Opt_mode___6 = 3,
	Opt_uid___7 = 4,
	Opt_gid___8 = 5,
};

enum ffs_entity_type {
	FFS_DESCRIPTOR = 0,
	FFS_INTERFACE = 1,
	FFS_STRING = 2,
	FFS_ENDPOINT = 3,
};

enum ffs_os_desc_type {
	FFS_OS_DESC = 0,
	FFS_OS_DESC_EXT_COMPAT = 1,
	FFS_OS_DESC_EXT_PROP = 2,
};

typedef int (*ffs_entity_callback)(enum ffs_entity_type, u8 *, struct usb_descriptor_header *, void *);

typedef int (*ffs_os_desc_callback)(enum ffs_os_desc_type, struct usb_os_desc_header *, void *, unsigned int, void *);

struct hid_device_id {
	__u16 bus;
	__u16 group;
	__u32 vendor;
	__u32 product;
	kernel_ulong_t driver_data;
};

struct hid_collection {
	int parent_idx;
	unsigned int type;
	unsigned int usage;
	unsigned int level;
};

struct hid_usage {
	unsigned int hid;
	unsigned int collection_index;
	unsigned int usage_index;
	__s8 resolution_multiplier;
	__s8 wheel_factor;
	__u16 code;
	__u8 type;
	__s8 hat_min;
	__s8 hat_max;
	__s8 hat_dir;
	__s16 wheel_accumulated;
};

struct hid_report;

struct hid_input;

struct hid_field {
	unsigned int physical;
	unsigned int logical;
	unsigned int application;
	struct hid_usage *usage;
	unsigned int maxusage;
	unsigned int flags;
	unsigned int report_offset;
	unsigned int report_size;
	unsigned int report_count;
	unsigned int report_type;
	__s32 *value;
	__s32 logical_minimum;
	__s32 logical_maximum;
	__s32 physical_minimum;
	__s32 physical_maximum;
	__s32 unit_exponent;
	unsigned int unit;
	struct hid_report *report;
	unsigned int index;
	struct hid_input *hidinput;
	__u16 dpad;
};

struct hid_device;

struct hid_report {
	struct list_head list;
	struct list_head hidinput_list;
	unsigned int id;
	unsigned int type;
	unsigned int application;
	struct hid_field *field[256];
	unsigned int maxfield;
	unsigned int size;
	struct hid_device *device;
};

struct hid_input {
	struct list_head list;
	struct hid_report *report;
	struct input_dev *input;
	const char *name;
	bool registered;
	struct list_head reports;
	unsigned int application;
};

enum hid_type {
	HID_TYPE_OTHER = 0,
	HID_TYPE_USBMOUSE = 1,
	HID_TYPE_USBNONE = 2,
};

struct hid_report_enum {
	unsigned int numbered;
	struct list_head report_list;
	struct hid_report *report_id_hash[256];
};

struct hid_driver;

struct hid_ll_driver;

struct hid_device {
	__u8 *dev_rdesc;
	unsigned int dev_rsize;
	__u8 *rdesc;
	unsigned int rsize;
	struct hid_collection *collection;
	unsigned int collection_size;
	unsigned int maxcollection;
	unsigned int maxapplication;
	__u16 bus;
	__u16 group;
	__u32 vendor;
	__u32 product;
	__u32 version;
	enum hid_type type;
	unsigned int country;
	struct hid_report_enum report_enum[3];
	struct work_struct led_work;
	struct semaphore driver_input_lock;
	struct device dev;
	struct hid_driver *driver;
	struct hid_ll_driver *ll_driver;
	struct mutex ll_open_lock;
	unsigned int ll_open_count;
	long unsigned int status;
	unsigned int claimed;
	unsigned int quirks;
	bool io_started;
	struct list_head inputs;
	void *hiddev;
	void *hidraw;
	char name[128];
	char phys[64];
	char uniq[64];
	void *driver_data;
	int (*ff_init)(struct hid_device *);
	int (*hiddev_connect)(struct hid_device *, unsigned int);
	void (*hiddev_disconnect)(struct hid_device *);
	void (*hiddev_hid_event)(struct hid_device *, struct hid_field *, struct hid_usage *, __s32);
	void (*hiddev_report_event)(struct hid_device *, struct hid_report *);
	short unsigned int debug;
	struct dentry *debug_dir;
	struct dentry *debug_rdesc;
	struct dentry *debug_events;
	struct list_head debug_list;
	spinlock_t debug_list_lock;
	wait_queue_head_t debug_wait;
};

struct hid_report_id;

struct hid_usage_id;

struct hid_driver {
	char *name;
	const struct hid_device_id *id_table;
	struct list_head dyn_list;
	spinlock_t dyn_lock;
	bool (*match)(struct hid_device *, bool);
	int (*probe)(struct hid_device *, const struct hid_device_id *);
	void (*remove)(struct hid_device *);
	const struct hid_report_id *report_table;
	int (*raw_event)(struct hid_device *, struct hid_report *, u8 *, int);
	const struct hid_usage_id *usage_table;
	int (*event)(struct hid_device *, struct hid_field *, struct hid_usage *, __s32);
	void (*report)(struct hid_device *, struct hid_report *);
	__u8 * (*report_fixup)(struct hid_device *, __u8 *, unsigned int *);
	int (*input_mapping)(struct hid_device *, struct hid_input *, struct hid_field *, struct hid_usage *, long unsigned int **, int *);
	int (*input_mapped)(struct hid_device *, struct hid_input *, struct hid_field *, struct hid_usage *, long unsigned int **, int *);
	int (*input_configured)(struct hid_device *, struct hid_input *);
	void (*feature_mapping)(struct hid_device *, struct hid_field *, struct hid_usage *);
	int (*suspend)(struct hid_device *, pm_message_t);
	int (*resume)(struct hid_device *);
	int (*reset_resume)(struct hid_device *);
	struct device_driver driver;
};

struct hid_ll_driver {
	int (*start)(struct hid_device *);
	void (*stop)(struct hid_device *);
	int (*open)(struct hid_device *);
	void (*close)(struct hid_device *);
	int (*power)(struct hid_device *, int);
	int (*parse)(struct hid_device *);
	void (*request)(struct hid_device *, struct hid_report *, int);
	int (*wait)(struct hid_device *);
	int (*raw_request)(struct hid_device *, unsigned char, __u8 *, size_t, unsigned char, int);
	int (*output_report)(struct hid_device *, __u8 *, size_t);
	int (*idle)(struct hid_device *, int, int, int);
};

struct hid_report_id {
	__u32 report_type;
};

struct hid_usage_id {
	__u32 usage_hid;
	__u32 usage_type;
	__u32 usage_code;
};

struct acc_dev;

struct acc_hid_dev {
	struct list_head list;
	struct hid_device *hid;
	struct acc_dev *dev;
	int id;
	u8 *report_desc;
	int report_desc_len;
	int report_desc_offset;
};

struct acc_dev_ref;

struct acc_dev {
	struct usb_function function;
	struct usb_composite_dev *cdev;
	spinlock_t lock;
	struct acc_dev_ref *ref;
	struct usb_ep *ep_in;
	struct usb_ep *ep_out;
	int online;
	int disconnected;
	char manufacturer[256];
	char model[256];
	char description[256];
	char version[256];
	char uri[256];
	char serial[256];
	int string_index;
	int start_requested;
	int audio_mode;
	atomic_t open_excl;
	struct list_head tx_idle;
	wait_queue_head_t read_wq;
	wait_queue_head_t write_wq;
	struct usb_request *rx_req[2];
	int rx_done;
	struct delayed_work start_work;
	struct work_struct getprotocol_work;
	struct work_struct sendstring_work;
	struct work_struct hid_work;
	struct list_head hid_list;
	struct list_head new_hid_list;
	struct list_head dead_hid_list;
};

struct acc_dev_ref {
	struct kref kref;
	struct acc_dev *acc_dev;
};

struct acc_instance {
	struct usb_function_instance func_inst;
	const char *name;
};

struct serio_device_id {
	__u8 type;
	__u8 extra;
	__u8 id;
	__u8 proto;
};

struct serio_driver;

struct serio {
	void *port_data;
	char name[32];
	char phys[32];
	char firmware_id[128];
	bool manual_bind;
	struct serio_device_id id;
	spinlock_t lock;
	int (*write)(struct serio *, unsigned char);
	int (*open)(struct serio *);
	void (*close)(struct serio *);
	int (*start)(struct serio *);
	void (*stop)(struct serio *);
	struct serio *parent;
	struct list_head child_node;
	struct list_head children;
	unsigned int depth;
	struct serio_driver *drv;
	struct mutex drv_mutex;
	struct device dev;
	struct list_head node;
	struct mutex *ps2_cmd_mutex;
};

struct serio_driver {
	const char *description;
	const struct serio_device_id *id_table;
	bool manual_bind;
	void (*write_wakeup)(struct serio *);
	irqreturn_t (*interrupt)(struct serio *, unsigned char, unsigned int);
	int (*connect)(struct serio *, struct serio_driver *);
	int (*reconnect)(struct serio *);
	int (*fast_reconnect)(struct serio *);
	void (*disconnect)(struct serio *);
	void (*cleanup)(struct serio *);
	struct device_driver driver;
};

enum serio_event_type {
	SERIO_RESCAN_PORT = 0,
	SERIO_RECONNECT_PORT = 1,
	SERIO_RECONNECT_SUBTREE = 2,
	SERIO_REGISTER_PORT = 3,
	SERIO_ATTACH_DRIVER = 4,
};

struct serio_event {
	enum serio_event_type type;
	void *object;
	struct module *owner;
	struct list_head node;
};

struct serport {
	struct tty_struct *tty;
	wait_queue_head_t wait;
	struct serio *serio;
	struct serio_device_id id;
	spinlock_t lock;
	long unsigned int flags;
};

struct ps2dev {
	struct serio *serio;
	struct mutex cmd_mutex;
	wait_queue_head_t wait;
	long unsigned int flags;
	u8 cmdbuf[8];
	u8 cmdcnt;
	u8 nak;
};

union input_seq_state {
	struct {
		short unsigned int pos;
		bool mutex_acquired;
	};
	void *p;
};

struct input_devres {
	struct input_dev *input;
};

struct input_event {
	__kernel_ulong_t __sec;
	__kernel_ulong_t __usec;
	__u16 type;
	__u16 code;
	__s32 value;
};

struct input_mt_pos {
	s16 x;
	s16 y;
};

struct input_dev_poller {
	void (*poll)(struct input_dev *);
	unsigned int poll_interval;
	unsigned int poll_interval_max;
	unsigned int poll_interval_min;
	struct input_dev *input;
	struct delayed_work work;
};

enum led_brightness {
	LED_OFF = 0,
	LED_ON = 1,
	LED_HALF = 127,
	LED_FULL = 255,
};

struct led_pattern;

struct led_classdev {
	const char *name;
	enum led_brightness brightness;
	enum led_brightness max_brightness;
	int flags;
	long unsigned int work_flags;
	void (*brightness_set)(struct led_classdev *, enum led_brightness);
	int (*brightness_set_blocking)(struct led_classdev *, enum led_brightness);
	enum led_brightness (*brightness_get)(struct led_classdev *);
	int (*blink_set)(struct led_classdev *, long unsigned int *, long unsigned int *);
	int (*pattern_set)(struct led_classdev *, struct led_pattern *, u32, int);
	int (*pattern_clear)(struct led_classdev *);
	struct device *dev;
	const struct attribute_group **groups;
	struct list_head node;
	const char *default_trigger;
	long unsigned int blink_delay_on;
	long unsigned int blink_delay_off;
	struct timer_list blink_timer;
	int blink_brightness;
	int new_blink_brightness;
	void (*flash_resume)(struct led_classdev *);
	struct work_struct set_brightness_work;
	int delayed_set_value;
	struct mutex led_access;
};

struct led_pattern {
	u32 delta_t;
	int brightness;
};

struct input_led {
	struct led_classdev cdev;
	struct input_handle *handle;
	unsigned int code;
};

struct input_leds {
	struct input_handle handle;
	unsigned int num_leds;
	struct input_led leds[0];
};

struct mousedev_hw_data {
	int dx;
	int dy;
	int dz;
	int x;
	int y;
	int abs_event;
	long unsigned int buttons;
};

struct mousedev {
	int open;
	struct input_handle handle;
	wait_queue_head_t wait;
	struct list_head client_list;
	spinlock_t client_lock;
	struct mutex mutex;
	struct device dev;
	struct cdev cdev;
	bool exist;
	struct list_head mixdev_node;
	bool opened_by_mixdev;
	struct mousedev_hw_data packet;
	unsigned int pkt_count;
	int old_x[4];
	int old_y[4];
	int frac_dx;
	int frac_dy;
	long unsigned int touch;
	int (*open_device)(struct mousedev *);
	void (*close_device)(struct mousedev *);
};

enum mousedev_emul {
	MOUSEDEV_EMUL_PS2 = 0,
	MOUSEDEV_EMUL_IMPS = 1,
	MOUSEDEV_EMUL_EXPS = 2,
};

struct mousedev_motion {
	int dx;
	int dy;
	int dz;
	long unsigned int buttons;
};

struct mousedev_client {
	struct fasync_struct *fasync;
	struct mousedev *mousedev;
	struct list_head node;
	struct mousedev_motion packets[16];
	unsigned int head;
	unsigned int tail;
	spinlock_t packet_lock;
	int pos_x;
	int pos_y;
	u8 ps2[6];
	unsigned char ready;
	unsigned char buffer;
	unsigned char bufsiz;
	unsigned char imexseq;
	unsigned char impsseq;
	enum mousedev_emul mode;
	long unsigned int last_buttons;
};

enum {
	FRACTION_DENOM = 128,
};

struct input_mask {
	__u32 type;
	__u32 codes_size;
	__u64 codes_ptr;
};

struct evdev_client;

struct evdev {
	int open;
	struct input_handle handle;
	struct evdev_client *grab;
	struct list_head client_list;
	spinlock_t client_lock;
	struct mutex mutex;
	struct device dev;
	struct cdev cdev;
	bool exist;
};

struct evdev_client {
	unsigned int head;
	unsigned int tail;
	unsigned int packet_head;
	spinlock_t buffer_lock;
	wait_queue_head_t wait;
	struct fasync_struct *fasync;
	struct evdev *evdev;
	struct list_head node;
	enum input_clock_type clk_type;
	bool revoked;
	long unsigned int *evmasks[32];
	unsigned int bufsize;
	struct input_event buffer[0];
};

struct atkbd {
	struct ps2dev ps2dev;
	struct input_dev *dev;
	char name[64];
	char phys[32];
	short unsigned int id;
	short unsigned int keycode[512];
	long unsigned int force_release_mask[8];
	unsigned char set;
	bool translated;
	bool extra;
	bool write;
	bool softrepeat;
	bool softraw;
	bool scroll;
	bool enabled;
	unsigned char emul;
	bool resend;
	bool release;
	long unsigned int xl_bit;
	unsigned int last;
	long unsigned int time;
	long unsigned int err_count;
	struct delayed_work event_work;
	long unsigned int event_jiffies;
	long unsigned int event_mask;
	struct mutex mutex;
	u32 function_row_physmap[24];
	int num_function_row_keys;
};

struct gpio_keys_button {
	unsigned int code;
	int gpio;
	int active_low;
	const char *desc;
	unsigned int type;
	int wakeup;
	int wakeup_event_action;
	int debounce_interval;
	bool can_disable;
	int value;
	unsigned int irq;
};

struct gpio_keys_platform_data {
	const struct gpio_keys_button *buttons;
	int nbuttons;
	unsigned int poll_interval;
	unsigned int rep: 1;
	int (*enable)(struct device *);
	void (*disable)(struct device *);
	const char *name;
};

struct gpio_button_data {
	const struct gpio_keys_button *button;
	struct input_dev *input;
	struct gpio_desc *gpiod;
	short unsigned int *code;
	struct timer_list release_timer;
	unsigned int release_delay;
	struct delayed_work work;
	unsigned int software_debounce;
	unsigned int irq;
	unsigned int wakeup_trigger_type;
	spinlock_t lock;
	bool disabled;
	bool key_pressed;
	bool suspended;
};

struct gpio_keys_drvdata {
	const struct gpio_keys_platform_data *pdata;
	struct input_dev *input;
	struct mutex disable_lock;
	short unsigned int *keymap;
	struct gpio_button_data data[0];
};

enum goodix_irq_pin_access_method {
	IRQ_PIN_ACCESS_NONE = 0,
	IRQ_PIN_ACCESS_GPIO = 1,
	IRQ_PIN_ACCESS_ACPI_GPIO = 2,
	IRQ_PIN_ACCESS_ACPI_METHOD = 3,
};

struct goodix_ts_data;

struct goodix_chip_data {
	u16 config_addr;
	int config_len;
	int (*check_config)(struct goodix_ts_data *, const u8 *, int);
	void (*calc_config_checksum)(struct goodix_ts_data *);
};

struct goodix_ts_data {
	struct i2c_client *client;
	struct input_dev *input_dev;
	const struct goodix_chip_data *chip;
	struct touchscreen_properties prop;
	unsigned int max_touch_num;
	unsigned int int_trigger_type;
	struct regulator *avdd28;
	struct regulator *vddio;
	struct gpio_desc *gpiod_int;
	struct gpio_desc *gpiod_rst;
	int gpio_count;
	int gpio_int_idx;
	char id[5];
	u16 version;
	const char *cfg_name;
	bool reset_controller_at_probe;
	bool load_cfg_from_disk;
	struct completion firmware_loading_complete;
	long unsigned int irq_flags;
	enum goodix_irq_pin_access_method irq_pin_access_method;
	unsigned int contact_size;
	u8 config[240];
	short unsigned int keymap[7];
};

struct goodix_chip_id {
	const char *id;
	const struct goodix_chip_data *data;
};

struct uinput_ff_upload {
	__u32 request_id;
	__s32 retval;
	struct ff_effect effect;
	struct ff_effect old;
};

struct uinput_ff_erase {
	__u32 request_id;
	__s32 retval;
	__u32 effect_id;
};

struct uinput_setup {
	struct input_id id;
	char name[80];
	__u32 ff_effects_max;
};

struct uinput_abs_setup {
	__u16 code;
	struct input_absinfo absinfo;
};

struct uinput_user_dev {
	char name[80];
	struct input_id id;
	__u32 ff_effects_max;
	__s32 absmax[64];
	__s32 absmin[64];
	__s32 absfuzz[64];
	__s32 absflat[64];
};

enum uinput_state {
	UIST_NEW_DEVICE = 0,
	UIST_SETUP_COMPLETE = 1,
	UIST_CREATED = 2,
};

struct uinput_request {
	unsigned int id;
	unsigned int code;
	int retval;
	struct completion done;
	union {
		unsigned int effect_id;
		struct {
			struct ff_effect *effect;
			struct ff_effect *old;
		} upload;
	} u;
};

struct uinput_device {
	struct input_dev *dev;
	struct mutex mutex;
	enum uinput_state state;
	wait_queue_head_t waitq;
	unsigned char ready;
	unsigned char head;
	unsigned char tail;
	struct input_event buff[16];
	unsigned int ff_effects_max;
	struct uinput_request *requests[16];
	wait_queue_head_t requests_waitq;
	spinlock_t requests_lock;
};

struct trace_event_raw_rtc_time_alarm_class {
	struct trace_entry ent;
	time64_t secs;
	int err;
	char __data[0];
};

struct trace_event_raw_rtc_irq_set_freq {
	struct trace_entry ent;
	int freq;
	int err;
	char __data[0];
};

struct trace_event_raw_rtc_irq_set_state {
	struct trace_entry ent;
	int enabled;
	int err;
	char __data[0];
};

struct trace_event_raw_rtc_alarm_irq_enable {
	struct trace_entry ent;
	unsigned int enabled;
	int err;
	char __data[0];
};

struct trace_event_raw_rtc_offset_class {
	struct trace_entry ent;
	long int offset;
	int err;
	char __data[0];
};

struct trace_event_raw_rtc_timer_class {
	struct trace_entry ent;
	struct rtc_timer *timer;
	ktime_t expires;
	ktime_t period;
	char __data[0];
};

struct trace_event_data_offsets_rtc_time_alarm_class {};

struct trace_event_data_offsets_rtc_irq_set_freq {};

struct trace_event_data_offsets_rtc_irq_set_state {};

struct trace_event_data_offsets_rtc_alarm_irq_enable {};

struct trace_event_data_offsets_rtc_offset_class {};

struct trace_event_data_offsets_rtc_timer_class {};

typedef void (*btf_trace_rtc_set_time)(void *, time64_t, int);

typedef void (*btf_trace_rtc_read_time)(void *, time64_t, int);

typedef void (*btf_trace_rtc_set_alarm)(void *, time64_t, int);

typedef void (*btf_trace_rtc_read_alarm)(void *, time64_t, int);

typedef void (*btf_trace_rtc_irq_set_freq)(void *, int, int);

typedef void (*btf_trace_rtc_irq_set_state)(void *, int, int);

typedef void (*btf_trace_rtc_alarm_irq_enable)(void *, unsigned int, int);

typedef void (*btf_trace_rtc_set_offset)(void *, long int, int);

typedef void (*btf_trace_rtc_read_offset)(void *, long int, int);

typedef void (*btf_trace_rtc_timer_enqueue)(void *, struct rtc_timer *);

typedef void (*btf_trace_rtc_timer_dequeue)(void *, struct rtc_timer *);

typedef void (*btf_trace_rtc_timer_fired)(void *, struct rtc_timer *);

enum {
	none = 0,
	day = 1,
	month = 2,
	year = 3,
};

struct xgene_rtc_dev {
	struct rtc_device *rtc;
	void *csr_base;
	struct clk *clk;
	unsigned int irq_wake;
	unsigned int irq_enabled;
};

struct i2c_devinfo {
	struct list_head list;
	int busnum;
	struct i2c_board_info board_info;
};

struct i2c_device_identity {
	u16 manufacturer_id;
	u16 part_id;
	u8 die_revision;
};

struct i2c_timings {
	u32 bus_freq_hz;
	u32 scl_rise_ns;
	u32 scl_fall_ns;
	u32 scl_int_delay_ns;
	u32 sda_fall_ns;
	u32 sda_hold_ns;
	u32 digital_filter_width_ns;
	u32 analog_filter_cutoff_freq_hz;
};

struct trace_event_raw_i2c_write {
	struct trace_entry ent;
	int adapter_nr;
	__u16 msg_nr;
	__u16 addr;
	__u16 flags;
	__u16 len;
	u32 __data_loc_buf;
	char __data[0];
};

struct trace_event_raw_i2c_read {
	struct trace_entry ent;
	int adapter_nr;
	__u16 msg_nr;
	__u16 addr;
	__u16 flags;
	__u16 len;
	char __data[0];
};

struct trace_event_raw_i2c_reply {
	struct trace_entry ent;
	int adapter_nr;
	__u16 msg_nr;
	__u16 addr;
	__u16 flags;
	__u16 len;
	u32 __data_loc_buf;
	char __data[0];
};

struct trace_event_raw_i2c_result {
	struct trace_entry ent;
	int adapter_nr;
	__u16 nr_msgs;
	__s16 ret;
	char __data[0];
};

struct trace_event_data_offsets_i2c_write {
	u32 buf;
};

struct trace_event_data_offsets_i2c_read {};

struct trace_event_data_offsets_i2c_reply {
	u32 buf;
};

struct trace_event_data_offsets_i2c_result {};

typedef void (*btf_trace_i2c_write)(void *, const struct i2c_adapter *, const struct i2c_msg *, int);

typedef void (*btf_trace_i2c_read)(void *, const struct i2c_adapter *, const struct i2c_msg *, int);

typedef void (*btf_trace_i2c_reply)(void *, const struct i2c_adapter *, const struct i2c_msg *, int);

typedef void (*btf_trace_i2c_result)(void *, const struct i2c_adapter *, int, int);

struct i2c_dummy_devres {
	struct i2c_client *client;
};

struct class_compat;

struct i2c_cmd_arg {
	unsigned int cmd;
	void *arg;
};

struct i2c_smbus_alert_setup {
	int irq;
};

struct trace_event_raw_smbus_write {
	struct trace_entry ent;
	int adapter_nr;
	__u16 addr;
	__u16 flags;
	__u8 command;
	__u8 len;
	__u32 protocol;
	__u8 buf[34];
	char __data[0];
};

struct trace_event_raw_smbus_read {
	struct trace_entry ent;
	int adapter_nr;
	__u16 flags;
	__u16 addr;
	__u8 command;
	__u32 protocol;
	__u8 buf[34];
	char __data[0];
};

struct trace_event_raw_smbus_reply {
	struct trace_entry ent;
	int adapter_nr;
	__u16 addr;
	__u16 flags;
	__u8 command;
	__u8 len;
	__u32 protocol;
	__u8 buf[34];
	char __data[0];
};

struct trace_event_raw_smbus_result {
	struct trace_entry ent;
	int adapter_nr;
	__u16 addr;
	__u16 flags;
	__u8 read_write;
	__u8 command;
	__s16 res;
	__u32 protocol;
	char __data[0];
};

struct trace_event_data_offsets_smbus_write {};

struct trace_event_data_offsets_smbus_read {};

struct trace_event_data_offsets_smbus_reply {};

struct trace_event_data_offsets_smbus_result {};

typedef void (*btf_trace_smbus_write)(void *, const struct i2c_adapter *, u16, short unsigned int, char, u8, int, const union i2c_smbus_data *);

typedef void (*btf_trace_smbus_read)(void *, const struct i2c_adapter *, u16, short unsigned int, char, u8, int);

typedef void (*btf_trace_smbus_reply)(void *, const struct i2c_adapter *, u16, short unsigned int, char, u8, int, const union i2c_smbus_data *, int);

typedef void (*btf_trace_smbus_result)(void *, const struct i2c_adapter *, u16, short unsigned int, char, u8, int, int);

struct i2c_smbus_ioctl_data {
	__u8 read_write;
	__u8 command;
	__u32 size;
	union i2c_smbus_data *data;
};

struct i2c_rdwr_ioctl_data {
	struct i2c_msg *msgs;
	__u32 nmsgs;
};

struct i2c_dev {
	struct list_head list;
	struct i2c_adapter *adap;
	struct device dev;
	struct cdev cdev;
};

struct i2c_algo_bit_data {
	void *data;
	void (*setsda)(void *, int);
	void (*setscl)(void *, int);
	int (*getsda)(void *);
	int (*getscl)(void *);
	int (*pre_xfer)(struct i2c_adapter *);
	void (*post_xfer)(struct i2c_adapter *);
	int udelay;
	int timeout;
	bool can_do_atomic;
};

struct dw_i2c_dev {
	struct device *dev;
	struct regmap *map;
	struct regmap *sysmap;
	void *base;
	void *ext;
	struct completion cmd_complete;
	struct clk *clk;
	struct clk *pclk;
	struct reset_control *rst;
	struct i2c_client *slave;
	u32 (*get_clk_rate_khz)(struct dw_i2c_dev *);
	int cmd_err;
	struct i2c_msg *msgs;
	int msgs_num;
	int msg_write_idx;
	u32 tx_buf_len;
	u8 *tx_buf;
	int msg_read_idx;
	u32 rx_buf_len;
	u8 *rx_buf;
	int msg_err;
	unsigned int status;
	u32 abort_source;
	int irq;
	u32 flags;
	struct i2c_adapter adapter;
	u32 functionality;
	u32 master_cfg;
	u32 slave_cfg;
	unsigned int tx_fifo_depth;
	unsigned int rx_fifo_depth;
	int rx_outstanding;
	struct i2c_timings timings;
	u32 sda_hold_time;
	u16 ss_hcnt;
	u16 ss_lcnt;
	u16 fs_hcnt;
	u16 fs_lcnt;
	u16 fp_hcnt;
	u16 fp_lcnt;
	u16 hs_hcnt;
	u16 hs_lcnt;
	int (*acquire_lock)();
	void (*release_lock)();
	bool shared_with_punit;
	void (*disable)(struct dw_i2c_dev *);
	void (*disable_int)(struct dw_i2c_dev *);
	int (*init)(struct dw_i2c_dev *);
	int (*set_sda_hold_time)(struct dw_i2c_dev *);
	int mode;
	struct i2c_bus_recovery_info rinfo;
	bool suspended;
};

struct dw_i2c_platform_data {
	unsigned int i2c_scl_freq;
};

struct media_device_info {
	char driver[16];
	char model[32];
	char serial[40];
	char bus_info[32];
	__u32 media_version;
	__u32 hw_revision;
	__u32 driver_version;
	__u32 reserved[31];
};

struct media_entity_desc {
	__u32 id;
	char name[32];
	__u32 type;
	__u32 revision;
	__u32 flags;
	__u32 group_id;
	__u16 pads;
	__u16 links;
	__u32 reserved[4];
	union {
		struct {
			__u32 major;
			__u32 minor;
		} dev;
		__u8 raw[184];
	};
};

struct media_pad_desc {
	__u32 entity;
	__u16 index;
	__u32 flags;
	__u32 reserved[2];
};

struct media_link_desc {
	struct media_pad_desc source;
	struct media_pad_desc sink;
	__u32 flags;
	__u32 reserved[2];
};

struct media_links_enum {
	__u32 entity;
	struct media_pad_desc *pads;
	struct media_link_desc *links;
	__u32 reserved[4];
};

struct media_v2_entity {
	__u32 id;
	char name[64];
	__u32 function;
	__u32 flags;
	__u32 reserved[5];
};

struct media_v2_intf_devnode {
	__u32 major;
	__u32 minor;
};

struct media_v2_interface {
	__u32 id;
	__u32 intf_type;
	__u32 flags;
	__u32 reserved[9];
	union {
		struct media_v2_intf_devnode devnode;
		__u32 raw[16];
	};
};

struct media_v2_pad {
	__u32 id;
	__u32 entity_id;
	__u32 flags;
	__u32 index;
	__u32 reserved[4];
};

struct media_v2_link {
	__u32 id;
	__u32 source_id;
	__u32 sink_id;
	__u32 flags;
	__u32 reserved[6];
};

struct media_v2_topology {
	__u64 topology_version;
	__u32 num_entities;
	__u32 reserved1;
	__u64 ptr_entities;
	__u32 num_interfaces;
	__u32 reserved2;
	__u64 ptr_interfaces;
	__u32 num_pads;
	__u32 reserved3;
	__u64 ptr_pads;
	__u32 num_links;
	__u32 reserved4;
	__u64 ptr_links;
};

struct media_file_operations {
	struct module *owner;
	ssize_t (*read)(struct file *, char *, size_t, loff_t *);
	ssize_t (*write)(struct file *, const char *, size_t, loff_t *);
	__poll_t (*poll)(struct file *, struct poll_table_struct *);
	long int (*ioctl)(struct file *, unsigned int, long unsigned int);
	long int (*compat_ioctl)(struct file *, unsigned int, long unsigned int);
	int (*open)(struct file *);
	int (*release)(struct file *);
};

struct media_device;

struct media_devnode {
	struct media_device *media_dev;
	const struct media_file_operations *fops;
	struct device dev;
	struct cdev cdev;
	struct device *parent;
	int minor;
	long unsigned int flags;
	void (*release)(struct media_devnode *);
};

struct media_entity_enum {
	long unsigned int *bmap;
	int idx_max;
};

struct media_entity;

struct media_graph {
	struct {
		struct media_entity *entity;
		struct list_head *link;
	} stack[16];
	struct media_entity_enum ent_enum;
	int top;
};

struct media_pipeline;

struct media_device_ops;

struct media_device {
	struct device *dev;
	struct media_devnode *devnode;
	char model[32];
	char driver_name[32];
	char serial[40];
	char bus_info[32];
	u32 hw_revision;
	u64 topology_version;
	u32 id;
	struct ida entity_internal_idx;
	int entity_internal_idx_max;
	struct list_head entities;
	struct list_head interfaces;
	struct list_head pads;
	struct list_head links;
	struct list_head entity_notify;
	struct mutex graph_mutex;
	struct media_graph pm_count_walk;
	void *source_priv;
	int (*enable_source)(struct media_entity *, struct media_pipeline *);
	void (*disable_source)(struct media_entity *);
	const struct media_device_ops *ops;
	struct mutex req_queue_mutex;
	atomic_t request_id;
};

enum media_gobj_type {
	MEDIA_GRAPH_ENTITY = 0,
	MEDIA_GRAPH_PAD = 1,
	MEDIA_GRAPH_LINK = 2,
	MEDIA_GRAPH_INTF_DEVNODE = 3,
};

struct media_gobj {
	struct media_device *mdev;
	u32 id;
	struct list_head list;
};

enum media_entity_type {
	MEDIA_ENTITY_TYPE_BASE = 0,
	MEDIA_ENTITY_TYPE_VIDEO_DEVICE = 1,
	MEDIA_ENTITY_TYPE_V4L2_SUBDEV = 2,
};

struct media_pad;

struct media_entity_operations;

struct media_entity {
	struct media_gobj graph_obj;
	const char *name;
	enum media_entity_type obj_type;
	u32 function;
	long unsigned int flags;
	u16 num_pads;
	u16 num_links;
	u16 num_backlinks;
	int internal_idx;
	struct media_pad *pads;
	struct list_head links;
	const struct media_entity_operations *ops;
	int stream_count;
	int use_count;
	struct media_pipeline *pipe;
	union {
		struct {
			u32 major;
			u32 minor;
		} dev;
	} info;
};

struct media_pipeline {
	int streaming_count;
	struct media_graph graph;
};

enum media_pad_signal_type {
	PAD_SIGNAL_DEFAULT = 0,
	PAD_SIGNAL_ANALOG = 1,
	PAD_SIGNAL_DV = 2,
	PAD_SIGNAL_AUDIO = 3,
};

struct media_pad {
	struct media_gobj graph_obj;
	struct media_entity *entity;
	u16 index;
	enum media_pad_signal_type sig_type;
	long unsigned int flags;
};

struct media_interface {
	struct media_gobj graph_obj;
	struct list_head links;
	u32 type;
	u32 flags;
};

struct media_link {
	struct media_gobj graph_obj;
	struct list_head list;
	union {
		struct media_gobj *gobj0;
		struct media_pad *source;
		struct media_interface *intf;
	};
	union {
		struct media_gobj *gobj1;
		struct media_pad *sink;
		struct media_entity *entity;
	};
	struct media_link *reverse;
	long unsigned int flags;
	bool is_backlink;
};

struct media_entity_operations {
	int (*get_fwnode_pad)(struct media_entity *, struct fwnode_endpoint *);
	int (*link_setup)(struct media_entity *, const struct media_pad *, const struct media_pad *, u32);
	int (*link_validate)(struct media_link *);
};

struct media_intf_devnode {
	struct media_interface intf;
	u32 major;
	u32 minor;
};

struct media_entity_notify {
	struct list_head list;
	void *notify_data;
	void (*notify)(struct media_entity *, void *);
};

struct media_request;

struct media_device_ops {
	int (*link_notify)(struct media_link *, u32, unsigned int);
	struct media_request * (*req_alloc)(struct media_device *);
	void (*req_free)(struct media_request *);
	int (*req_validate)(struct media_request *);
	void (*req_queue)(struct media_request *);
};

enum media_request_state {
	MEDIA_REQUEST_STATE_IDLE = 0,
	MEDIA_REQUEST_STATE_VALIDATING = 1,
	MEDIA_REQUEST_STATE_QUEUED = 2,
	MEDIA_REQUEST_STATE_COMPLETE = 3,
	MEDIA_REQUEST_STATE_CLEANING = 4,
	MEDIA_REQUEST_STATE_UPDATING = 5,
	NR_OF_MEDIA_REQUEST_STATE = 6,
};

struct media_request {
	struct media_device *mdev;
	struct kref kref;
	char debug_str[27];
	enum media_request_state state;
	unsigned int updating_count;
	unsigned int access_count;
	struct list_head objects;
	unsigned int num_incomplete_objects;
	wait_queue_head_t poll_wait;
	spinlock_t lock;
};

struct media_ioctl_info {
	unsigned int cmd;
	short unsigned int flags;
	long int (*fn)(struct media_device *, void *);
	long int (*arg_from_user)(void *, void *, unsigned int);
	long int (*arg_to_user)(void *, void *, unsigned int);
};

struct media_request_object;

struct media_request_object_ops {
	int (*prepare)(struct media_request_object *);
	void (*unprepare)(struct media_request_object *);
	void (*queue)(struct media_request_object *);
	void (*unbind)(struct media_request_object *);
	void (*release)(struct media_request_object *);
};

struct media_request_object {
	const struct media_request_object_ops *ops;
	void *priv;
	struct media_request *req;
	struct list_head list;
	struct kref kref;
	bool completed;
};

struct media_device_instance {
	struct media_device mdev;
	struct module *owner;
	struct list_head list;
	struct kref refcount;
};

struct v4l2_edid {
	__u32 pad;
	__u32 start_block;
	__u32 blocks;
	__u32 reserved[5];
	__u8 *edid;
};

enum v4l2_buf_type {
	V4L2_BUF_TYPE_VIDEO_CAPTURE = 1,
	V4L2_BUF_TYPE_VIDEO_OUTPUT = 2,
	V4L2_BUF_TYPE_VIDEO_OVERLAY = 3,
	V4L2_BUF_TYPE_VBI_CAPTURE = 4,
	V4L2_BUF_TYPE_VBI_OUTPUT = 5,
	V4L2_BUF_TYPE_SLICED_VBI_CAPTURE = 6,
	V4L2_BUF_TYPE_SLICED_VBI_OUTPUT = 7,
	V4L2_BUF_TYPE_VIDEO_OUTPUT_OVERLAY = 8,
	V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE = 9,
	V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE = 10,
	V4L2_BUF_TYPE_SDR_CAPTURE = 11,
	V4L2_BUF_TYPE_SDR_OUTPUT = 12,
	V4L2_BUF_TYPE_META_CAPTURE = 13,
	V4L2_BUF_TYPE_META_OUTPUT = 14,
	V4L2_BUF_TYPE_PRIVATE = 128,
};

enum v4l2_priority {
	V4L2_PRIORITY_UNSET = 0,
	V4L2_PRIORITY_BACKGROUND = 1,
	V4L2_PRIORITY_INTERACTIVE = 2,
	V4L2_PRIORITY_RECORD = 3,
	V4L2_PRIORITY_DEFAULT = 2,
};

struct v4l2_rect {
	__s32 left;
	__s32 top;
	__u32 width;
	__u32 height;
};

struct v4l2_fract {
	__u32 numerator;
	__u32 denominator;
};

struct v4l2_area {
	__u32 width;
	__u32 height;
};

struct v4l2_capability {
	__u8 driver[16];
	__u8 card[32];
	__u8 bus_info[32];
	__u32 version;
	__u32 capabilities;
	__u32 device_caps;
	__u32 reserved[3];
};

struct v4l2_pix_format {
	__u32 width;
	__u32 height;
	__u32 pixelformat;
	__u32 field;
	__u32 bytesperline;
	__u32 sizeimage;
	__u32 colorspace;
	__u32 priv;
	__u32 flags;
	union {
		__u32 ycbcr_enc;
		__u32 hsv_enc;
	};
	__u32 quantization;
	__u32 xfer_func;
};

struct v4l2_fmtdesc {
	__u32 index;
	__u32 type;
	__u32 flags;
	__u8 description[32];
	__u32 pixelformat;
	__u32 mbus_code;
	__u32 reserved[3];
};

struct v4l2_frmsize_discrete {
	__u32 width;
	__u32 height;
};

struct v4l2_frmsize_stepwise {
	__u32 min_width;
	__u32 max_width;
	__u32 step_width;
	__u32 min_height;
	__u32 max_height;
	__u32 step_height;
};

struct v4l2_frmsizeenum {
	__u32 index;
	__u32 pixel_format;
	__u32 type;
	union {
		struct v4l2_frmsize_discrete discrete;
		struct v4l2_frmsize_stepwise stepwise;
	};
	__u32 reserved[2];
};

struct v4l2_frmival_stepwise {
	struct v4l2_fract min;
	struct v4l2_fract max;
	struct v4l2_fract step;
};

struct v4l2_frmivalenum {
	__u32 index;
	__u32 pixel_format;
	__u32 width;
	__u32 height;
	__u32 type;
	union {
		struct v4l2_fract discrete;
		struct v4l2_frmival_stepwise stepwise;
	};
	__u32 reserved[2];
};

struct v4l2_timecode {
	__u32 type;
	__u32 flags;
	__u8 frames;
	__u8 seconds;
	__u8 minutes;
	__u8 hours;
	__u8 userbits[4];
};

struct v4l2_jpegcompression {
	int quality;
	int APPn;
	int APP_len;
	char APP_data[60];
	int COM_len;
	char COM_data[60];
	__u32 jpeg_markers;
};

struct __kernel_v4l2_timeval {
	long long int tv_sec;
	long long int tv_usec;
};

struct v4l2_requestbuffers {
	__u32 count;
	__u32 type;
	__u32 memory;
	__u32 capabilities;
	__u32 reserved[1];
};

struct v4l2_plane {
	__u32 bytesused;
	__u32 length;
	union {
		__u32 mem_offset;
		long unsigned int userptr;
		__s32 fd;
	} m;
	__u32 data_offset;
	__u32 reserved[11];
};

struct v4l2_buffer {
	__u32 index;
	__u32 type;
	__u32 bytesused;
	__u32 flags;
	__u32 field;
	struct __kernel_v4l2_timeval timestamp;
	struct v4l2_timecode timecode;
	__u32 sequence;
	__u32 memory;
	union {
		__u32 offset;
		long unsigned int userptr;
		struct v4l2_plane *planes;
		__s32 fd;
	} m;
	__u32 length;
	__u32 reserved2;
	union {
		__s32 request_fd;
		__u32 reserved;
	};
};

struct v4l2_exportbuffer {
	__u32 type;
	__u32 index;
	__u32 plane;
	__u32 flags;
	__s32 fd;
	__u32 reserved[11];
};

struct v4l2_framebuffer {
	__u32 capability;
	__u32 flags;
	void *base;
	struct {
		__u32 width;
		__u32 height;
		__u32 pixelformat;
		__u32 field;
		__u32 bytesperline;
		__u32 sizeimage;
		__u32 colorspace;
		__u32 priv;
	} fmt;
};

struct v4l2_clip {
	struct v4l2_rect c;
	struct v4l2_clip *next;
};

struct v4l2_window {
	struct v4l2_rect w;
	__u32 field;
	__u32 chromakey;
	struct v4l2_clip *clips;
	__u32 clipcount;
	void *bitmap;
	__u8 global_alpha;
};

struct v4l2_captureparm {
	__u32 capability;
	__u32 capturemode;
	struct v4l2_fract timeperframe;
	__u32 extendedmode;
	__u32 readbuffers;
	__u32 reserved[4];
};

struct v4l2_outputparm {
	__u32 capability;
	__u32 outputmode;
	struct v4l2_fract timeperframe;
	__u32 extendedmode;
	__u32 writebuffers;
	__u32 reserved[4];
};

struct v4l2_selection {
	__u32 type;
	__u32 target;
	__u32 flags;
	struct v4l2_rect r;
	__u32 reserved[9];
};

typedef __u64 v4l2_std_id;

struct v4l2_bt_timings {
	__u32 width;
	__u32 height;
	__u32 interlaced;
	__u32 polarities;
	__u64 pixelclock;
	__u32 hfrontporch;
	__u32 hsync;
	__u32 hbackporch;
	__u32 vfrontporch;
	__u32 vsync;
	__u32 vbackporch;
	__u32 il_vfrontporch;
	__u32 il_vsync;
	__u32 il_vbackporch;
	__u32 standards;
	__u32 flags;
	struct v4l2_fract picture_aspect;
	__u8 cea861_vic;
	__u8 hdmi_vic;
	__u8 reserved[46];
} __attribute__((packed));

struct v4l2_dv_timings {
	__u32 type;
	union {
		struct v4l2_bt_timings bt;
		__u32 reserved[32];
	};
} __attribute__((packed));

struct v4l2_enum_dv_timings {
	__u32 index;
	__u32 pad;
	__u32 reserved[2];
	struct v4l2_dv_timings timings;
} __attribute__((packed));

struct v4l2_bt_timings_cap {
	__u32 min_width;
	__u32 max_width;
	__u32 min_height;
	__u32 max_height;
	__u64 min_pixelclock;
	__u64 max_pixelclock;
	__u32 standards;
	__u32 capabilities;
	__u32 reserved[16];
};

struct v4l2_dv_timings_cap {
	__u32 type;
	__u32 pad;
	__u32 reserved[2];
	union {
		struct v4l2_bt_timings_cap bt;
		__u32 raw_data[32];
	};
};

struct v4l2_input {
	__u32 index;
	__u8 name[32];
	__u32 type;
	__u32 audioset;
	__u32 tuner;
	v4l2_std_id std;
	__u32 status;
	__u32 capabilities;
	__u32 reserved[3];
};

struct v4l2_output {
	__u32 index;
	__u8 name[32];
	__u32 type;
	__u32 audioset;
	__u32 modulator;
	v4l2_std_id std;
	__u32 capabilities;
	__u32 reserved[3];
};

struct v4l2_control {
	__u32 id;
	__s32 value;
};

struct v4l2_ext_control {
	__u32 id;
	__u32 size;
	__u32 reserved2[1];
	union {
		__s32 value;
		__s64 value64;
		char *string;
		__u8 *p_u8;
		__u16 *p_u16;
		__u32 *p_u32;
		struct v4l2_area *p_area;
		void *ptr;
	};
} __attribute__((packed));

struct v4l2_ext_controls {
	union {
		__u32 which;
	};
	__u32 count;
	__u32 error_idx;
	__s32 request_fd;
	__u32 reserved[1];
	struct v4l2_ext_control *controls;
};

struct v4l2_queryctrl {
	__u32 id;
	__u32 type;
	__u8 name[32];
	__s32 minimum;
	__s32 maximum;
	__s32 step;
	__s32 default_value;
	__u32 flags;
	__u32 reserved[2];
};

struct v4l2_query_ext_ctrl {
	__u32 id;
	__u32 type;
	char name[32];
	__s64 minimum;
	__s64 maximum;
	__u64 step;
	__s64 default_value;
	__u32 flags;
	__u32 elem_size;
	__u32 elems;
	__u32 nr_of_dims;
	__u32 dims[4];
	__u32 reserved[32];
};

struct v4l2_querymenu {
	__u32 id;
	__u32 index;
	union {
		__u8 name[32];
		__s64 value;
	};
	__u32 reserved;
} __attribute__((packed));

struct v4l2_tuner {
	__u32 index;
	__u8 name[32];
	__u32 type;
	__u32 capability;
	__u32 rangelow;
	__u32 rangehigh;
	__u32 rxsubchans;
	__u32 audmode;
	__s32 signal;
	__s32 afc;
	__u32 reserved[4];
};

struct v4l2_modulator {
	__u32 index;
	__u8 name[32];
	__u32 capability;
	__u32 rangelow;
	__u32 rangehigh;
	__u32 txsubchans;
	__u32 type;
	__u32 reserved[3];
};

struct v4l2_frequency {
	__u32 tuner;
	__u32 type;
	__u32 frequency;
	__u32 reserved[8];
};

struct v4l2_frequency_band {
	__u32 tuner;
	__u32 type;
	__u32 index;
	__u32 capability;
	__u32 rangelow;
	__u32 rangehigh;
	__u32 modulation;
	__u32 reserved[9];
};

struct v4l2_hw_freq_seek {
	__u32 tuner;
	__u32 type;
	__u32 seek_upward;
	__u32 wrap_around;
	__u32 spacing;
	__u32 rangelow;
	__u32 rangehigh;
	__u32 reserved[5];
};

struct v4l2_audio {
	__u32 index;
	__u8 name[32];
	__u32 capability;
	__u32 mode;
	__u32 reserved[2];
};

struct v4l2_audioout {
	__u32 index;
	__u8 name[32];
	__u32 capability;
	__u32 mode;
	__u32 reserved[2];
};

struct v4l2_enc_idx_entry {
	__u64 offset;
	__u64 pts;
	__u32 length;
	__u32 flags;
	__u32 reserved[2];
};

struct v4l2_enc_idx {
	__u32 entries;
	__u32 entries_cap;
	__u32 reserved[4];
	struct v4l2_enc_idx_entry entry[64];
};

struct v4l2_encoder_cmd {
	__u32 cmd;
	__u32 flags;
	union {
		struct {
			__u32 data[8];
		} raw;
	};
};

struct v4l2_decoder_cmd {
	__u32 cmd;
	__u32 flags;
	union {
		struct {
			__u64 pts;
		} stop;
		struct {
			__s32 speed;
			__u32 format;
		} start;
		struct {
			__u32 data[16];
		} raw;
	};
};

struct v4l2_vbi_format {
	__u32 sampling_rate;
	__u32 offset;
	__u32 samples_per_line;
	__u32 sample_format;
	__s32 start[2];
	__u32 count[2];
	__u32 flags;
	__u32 reserved[2];
};

struct v4l2_sliced_vbi_format {
	__u16 service_set;
	__u16 service_lines[48];
	__u32 io_size;
	__u32 reserved[2];
};

struct v4l2_sliced_vbi_cap {
	__u16 service_set;
	__u16 service_lines[48];
	__u32 type;
	__u32 reserved[3];
};

struct v4l2_sliced_vbi_data {
	__u32 id;
	__u32 field;
	__u32 line;
	__u32 reserved;
	__u8 data[48];
};

struct v4l2_plane_pix_format {
	__u32 sizeimage;
	__u32 bytesperline;
	__u16 reserved[6];
};

struct v4l2_pix_format_mplane {
	__u32 width;
	__u32 height;
	__u32 pixelformat;
	__u32 field;
	__u32 colorspace;
	struct v4l2_plane_pix_format plane_fmt[8];
	__u8 num_planes;
	__u8 flags;
	union {
		__u8 ycbcr_enc;
		__u8 hsv_enc;
	};
	__u8 quantization;
	__u8 xfer_func;
	__u8 reserved[7];
};

struct v4l2_sdr_format {
	__u32 pixelformat;
	__u32 buffersize;
	__u8 reserved[24];
};

struct v4l2_meta_format {
	__u32 dataformat;
	__u32 buffersize;
};

struct v4l2_format {
	__u32 type;
	union {
		struct v4l2_pix_format pix;
		struct v4l2_pix_format_mplane pix_mp;
		struct v4l2_window win;
		struct v4l2_vbi_format vbi;
		struct v4l2_sliced_vbi_format sliced;
		struct v4l2_sdr_format sdr;
		struct v4l2_meta_format meta;
		__u8 raw_data[200];
	} fmt;
};

struct v4l2_streamparm {
	__u32 type;
	union {
		struct v4l2_captureparm capture;
		struct v4l2_outputparm output;
		__u8 raw_data[200];
	} parm;
};

struct v4l2_event_subscription {
	__u32 type;
	__u32 id;
	__u32 flags;
	__u32 reserved[5];
};

struct v4l2_create_buffers {
	__u32 index;
	__u32 count;
	__u32 memory;
	struct v4l2_format format;
	__u32 capabilities;
	__u32 reserved[7];
};

enum vfl_devnode_type {
	VFL_TYPE_VIDEO = 0,
	VFL_TYPE_VBI = 1,
	VFL_TYPE_RADIO = 2,
	VFL_TYPE_SUBDEV = 3,
	VFL_TYPE_SDR = 4,
	VFL_TYPE_TOUCH = 5,
	VFL_TYPE_MAX = 6,
};

enum vfl_devnode_direction {
	VFL_DIR_RX = 0,
	VFL_DIR_TX = 1,
	VFL_DIR_M2M = 2,
};

enum v4l2_video_device_flags {
	V4L2_FL_REGISTERED = 0,
	V4L2_FL_USES_V4L2_FH = 1,
	V4L2_FL_QUIRK_INVERTED_CROP = 2,
	V4L2_FL_SUBDEV_RO_DEVNODE = 3,
};

struct v4l2_prio_state {
	atomic_t prios[4];
};

struct v4l2_file_operations {
	struct module *owner;
	ssize_t (*read)(struct file *, char *, size_t, loff_t *);
	ssize_t (*write)(struct file *, const char *, size_t, loff_t *);
	__poll_t (*poll)(struct file *, struct poll_table_struct *);
	long int (*unlocked_ioctl)(struct file *, unsigned int, long unsigned int);
	long unsigned int (*get_unmapped_area)(struct file *, long unsigned int, long unsigned int, long unsigned int, long unsigned int);
	int (*mmap)(struct file *, struct vm_area_struct *);
	int (*open)(struct file *);
	int (*release)(struct file *);
};

struct v4l2_device;

struct v4l2_ctrl_handler;

struct vb2_queue;

struct v4l2_ioctl_ops;

struct video_device {
	struct media_entity entity;
	struct media_intf_devnode *intf_devnode;
	struct media_pipeline pipe;
	const struct v4l2_file_operations *fops;
	u32 device_caps;
	struct device dev;
	struct cdev *cdev;
	struct v4l2_device *v4l2_dev;
	struct device *dev_parent;
	struct v4l2_ctrl_handler *ctrl_handler;
	struct vb2_queue *queue;
	struct v4l2_prio_state *prio;
	char name[32];
	enum vfl_devnode_type vfl_type;
	enum vfl_devnode_direction vfl_dir;
	int minor;
	u16 num;
	long unsigned int flags;
	int index;
	spinlock_t fh_lock;
	struct list_head fh_list;
	int dev_debug;
	v4l2_std_id tvnorms;
	void (*release)(struct video_device *);
	const struct v4l2_ioctl_ops *ioctl_ops;
	long unsigned int valid_ioctls[3];
	struct mutex *lock;
};

struct v4l2_subdev;

struct v4l2_device {
	struct device *dev;
	struct media_device *mdev;
	struct list_head subdevs;
	spinlock_t lock;
	char name[36];
	void (*notify)(struct v4l2_subdev *, unsigned int, void *);
	struct v4l2_ctrl_handler *ctrl_handler;
	struct v4l2_prio_state prio;
	struct kref ref;
	void (*release)(struct v4l2_device *);
};

struct v4l2_fh;

struct v4l2_ioctl_ops {
	int (*vidioc_querycap)(struct file *, void *, struct v4l2_capability *);
	int (*vidioc_enum_fmt_vid_cap)(struct file *, void *, struct v4l2_fmtdesc *);
	int (*vidioc_enum_fmt_vid_overlay)(struct file *, void *, struct v4l2_fmtdesc *);
	int (*vidioc_enum_fmt_vid_out)(struct file *, void *, struct v4l2_fmtdesc *);
	int (*vidioc_enum_fmt_sdr_cap)(struct file *, void *, struct v4l2_fmtdesc *);
	int (*vidioc_enum_fmt_sdr_out)(struct file *, void *, struct v4l2_fmtdesc *);
	int (*vidioc_enum_fmt_meta_cap)(struct file *, void *, struct v4l2_fmtdesc *);
	int (*vidioc_enum_fmt_meta_out)(struct file *, void *, struct v4l2_fmtdesc *);
	int (*vidioc_g_fmt_vid_cap)(struct file *, void *, struct v4l2_format *);
	int (*vidioc_g_fmt_vid_overlay)(struct file *, void *, struct v4l2_format *);
	int (*vidioc_g_fmt_vid_out)(struct file *, void *, struct v4l2_format *);
	int (*vidioc_g_fmt_vid_out_overlay)(struct file *, void *, struct v4l2_format *);
	int (*vidioc_g_fmt_vbi_cap)(struct file *, void *, struct v4l2_format *);
	int (*vidioc_g_fmt_vbi_out)(struct file *, void *, struct v4l2_format *);
	int (*vidioc_g_fmt_sliced_vbi_cap)(struct file *, void *, struct v4l2_format *);
	int (*vidioc_g_fmt_sliced_vbi_out)(struct file *, void *, struct v4l2_format *);
	int (*vidioc_g_fmt_vid_cap_mplane)(struct file *, void *, struct v4l2_format *);
	int (*vidioc_g_fmt_vid_out_mplane)(struct file *, void *, struct v4l2_format *);
	int (*vidioc_g_fmt_sdr_cap)(struct file *, void *, struct v4l2_format *);
	int (*vidioc_g_fmt_sdr_out)(struct file *, void *, struct v4l2_format *);
	int (*vidioc_g_fmt_meta_cap)(struct file *, void *, struct v4l2_format *);
	int (*vidioc_g_fmt_meta_out)(struct file *, void *, struct v4l2_format *);
	int (*vidioc_s_fmt_vid_cap)(struct file *, void *, struct v4l2_format *);
	int (*vidioc_s_fmt_vid_overlay)(struct file *, void *, struct v4l2_format *);
	int (*vidioc_s_fmt_vid_out)(struct file *, void *, struct v4l2_format *);
	int (*vidioc_s_fmt_vid_out_overlay)(struct file *, void *, struct v4l2_format *);
	int (*vidioc_s_fmt_vbi_cap)(struct file *, void *, struct v4l2_format *);
	int (*vidioc_s_fmt_vbi_out)(struct file *, void *, struct v4l2_format *);
	int (*vidioc_s_fmt_sliced_vbi_cap)(struct file *, void *, struct v4l2_format *);
	int (*vidioc_s_fmt_sliced_vbi_out)(struct file *, void *, struct v4l2_format *);
	int (*vidioc_s_fmt_vid_cap_mplane)(struct file *, void *, struct v4l2_format *);
	int (*vidioc_s_fmt_vid_out_mplane)(struct file *, void *, struct v4l2_format *);
	int (*vidioc_s_fmt_sdr_cap)(struct file *, void *, struct v4l2_format *);
	int (*vidioc_s_fmt_sdr_out)(struct file *, void *, struct v4l2_format *);
	int (*vidioc_s_fmt_meta_cap)(struct file *, void *, struct v4l2_format *);
	int (*vidioc_s_fmt_meta_out)(struct file *, void *, struct v4l2_format *);
	int (*vidioc_try_fmt_vid_cap)(struct file *, void *, struct v4l2_format *);
	int (*vidioc_try_fmt_vid_overlay)(struct file *, void *, struct v4l2_format *);
	int (*vidioc_try_fmt_vid_out)(struct file *, void *, struct v4l2_format *);
	int (*vidioc_try_fmt_vid_out_overlay)(struct file *, void *, struct v4l2_format *);
	int (*vidioc_try_fmt_vbi_cap)(struct file *, void *, struct v4l2_format *);
	int (*vidioc_try_fmt_vbi_out)(struct file *, void *, struct v4l2_format *);
	int (*vidioc_try_fmt_sliced_vbi_cap)(struct file *, void *, struct v4l2_format *);
	int (*vidioc_try_fmt_sliced_vbi_out)(struct file *, void *, struct v4l2_format *);
	int (*vidioc_try_fmt_vid_cap_mplane)(struct file *, void *, struct v4l2_format *);
	int (*vidioc_try_fmt_vid_out_mplane)(struct file *, void *, struct v4l2_format *);
	int (*vidioc_try_fmt_sdr_cap)(struct file *, void *, struct v4l2_format *);
	int (*vidioc_try_fmt_sdr_out)(struct file *, void *, struct v4l2_format *);
	int (*vidioc_try_fmt_meta_cap)(struct file *, void *, struct v4l2_format *);
	int (*vidioc_try_fmt_meta_out)(struct file *, void *, struct v4l2_format *);
	int (*vidioc_reqbufs)(struct file *, void *, struct v4l2_requestbuffers *);
	int (*vidioc_querybuf)(struct file *, void *, struct v4l2_buffer *);
	int (*vidioc_qbuf)(struct file *, void *, struct v4l2_buffer *);
	int (*vidioc_expbuf)(struct file *, void *, struct v4l2_exportbuffer *);
	int (*vidioc_dqbuf)(struct file *, void *, struct v4l2_buffer *);
	int (*vidioc_create_bufs)(struct file *, void *, struct v4l2_create_buffers *);
	int (*vidioc_prepare_buf)(struct file *, void *, struct v4l2_buffer *);
	int (*vidioc_overlay)(struct file *, void *, unsigned int);
	int (*vidioc_g_fbuf)(struct file *, void *, struct v4l2_framebuffer *);
	int (*vidioc_s_fbuf)(struct file *, void *, const struct v4l2_framebuffer *);
	int (*vidioc_streamon)(struct file *, void *, enum v4l2_buf_type);
	int (*vidioc_streamoff)(struct file *, void *, enum v4l2_buf_type);
	int (*vidioc_g_std)(struct file *, void *, v4l2_std_id *);
	int (*vidioc_s_std)(struct file *, void *, v4l2_std_id);
	int (*vidioc_querystd)(struct file *, void *, v4l2_std_id *);
	int (*vidioc_enum_input)(struct file *, void *, struct v4l2_input *);
	int (*vidioc_g_input)(struct file *, void *, unsigned int *);
	int (*vidioc_s_input)(struct file *, void *, unsigned int);
	int (*vidioc_enum_output)(struct file *, void *, struct v4l2_output *);
	int (*vidioc_g_output)(struct file *, void *, unsigned int *);
	int (*vidioc_s_output)(struct file *, void *, unsigned int);
	int (*vidioc_queryctrl)(struct file *, void *, struct v4l2_queryctrl *);
	int (*vidioc_query_ext_ctrl)(struct file *, void *, struct v4l2_query_ext_ctrl *);
	int (*vidioc_g_ctrl)(struct file *, void *, struct v4l2_control *);
	int (*vidioc_s_ctrl)(struct file *, void *, struct v4l2_control *);
	int (*vidioc_g_ext_ctrls)(struct file *, void *, struct v4l2_ext_controls *);
	int (*vidioc_s_ext_ctrls)(struct file *, void *, struct v4l2_ext_controls *);
	int (*vidioc_try_ext_ctrls)(struct file *, void *, struct v4l2_ext_controls *);
	int (*vidioc_querymenu)(struct file *, void *, struct v4l2_querymenu *);
	int (*vidioc_enumaudio)(struct file *, void *, struct v4l2_audio *);
	int (*vidioc_g_audio)(struct file *, void *, struct v4l2_audio *);
	int (*vidioc_s_audio)(struct file *, void *, const struct v4l2_audio *);
	int (*vidioc_enumaudout)(struct file *, void *, struct v4l2_audioout *);
	int (*vidioc_g_audout)(struct file *, void *, struct v4l2_audioout *);
	int (*vidioc_s_audout)(struct file *, void *, const struct v4l2_audioout *);
	int (*vidioc_g_modulator)(struct file *, void *, struct v4l2_modulator *);
	int (*vidioc_s_modulator)(struct file *, void *, const struct v4l2_modulator *);
	int (*vidioc_g_pixelaspect)(struct file *, void *, int, struct v4l2_fract *);
	int (*vidioc_g_selection)(struct file *, void *, struct v4l2_selection *);
	int (*vidioc_s_selection)(struct file *, void *, struct v4l2_selection *);
	int (*vidioc_g_jpegcomp)(struct file *, void *, struct v4l2_jpegcompression *);
	int (*vidioc_s_jpegcomp)(struct file *, void *, const struct v4l2_jpegcompression *);
	int (*vidioc_g_enc_index)(struct file *, void *, struct v4l2_enc_idx *);
	int (*vidioc_encoder_cmd)(struct file *, void *, struct v4l2_encoder_cmd *);
	int (*vidioc_try_encoder_cmd)(struct file *, void *, struct v4l2_encoder_cmd *);
	int (*vidioc_decoder_cmd)(struct file *, void *, struct v4l2_decoder_cmd *);
	int (*vidioc_try_decoder_cmd)(struct file *, void *, struct v4l2_decoder_cmd *);
	int (*vidioc_g_parm)(struct file *, void *, struct v4l2_streamparm *);
	int (*vidioc_s_parm)(struct file *, void *, struct v4l2_streamparm *);
	int (*vidioc_g_tuner)(struct file *, void *, struct v4l2_tuner *);
	int (*vidioc_s_tuner)(struct file *, void *, const struct v4l2_tuner *);
	int (*vidioc_g_frequency)(struct file *, void *, struct v4l2_frequency *);
	int (*vidioc_s_frequency)(struct file *, void *, const struct v4l2_frequency *);
	int (*vidioc_enum_freq_bands)(struct file *, void *, struct v4l2_frequency_band *);
	int (*vidioc_g_sliced_vbi_cap)(struct file *, void *, struct v4l2_sliced_vbi_cap *);
	int (*vidioc_log_status)(struct file *, void *);
	int (*vidioc_s_hw_freq_seek)(struct file *, void *, const struct v4l2_hw_freq_seek *);
	int (*vidioc_enum_framesizes)(struct file *, void *, struct v4l2_frmsizeenum *);
	int (*vidioc_enum_frameintervals)(struct file *, void *, struct v4l2_frmivalenum *);
	int (*vidioc_s_dv_timings)(struct file *, void *, struct v4l2_dv_timings *);
	int (*vidioc_g_dv_timings)(struct file *, void *, struct v4l2_dv_timings *);
	int (*vidioc_query_dv_timings)(struct file *, void *, struct v4l2_dv_timings *);
	int (*vidioc_enum_dv_timings)(struct file *, void *, struct v4l2_enum_dv_timings *);
	int (*vidioc_dv_timings_cap)(struct file *, void *, struct v4l2_dv_timings_cap *);
	int (*vidioc_g_edid)(struct file *, void *, struct v4l2_edid *);
	int (*vidioc_s_edid)(struct file *, void *, struct v4l2_edid *);
	int (*vidioc_subscribe_event)(struct v4l2_fh *, const struct v4l2_event_subscription *);
	int (*vidioc_unsubscribe_event)(struct v4l2_fh *, const struct v4l2_event_subscription *);
	long int (*vidioc_default)(struct file *, void *, bool, unsigned int, void *);
};

struct v4l2_priv_tun_config {
	int tuner;
	void *priv;
};

struct v4l2_mbus_framefmt {
	__u32 width;
	__u32 height;
	__u32 code;
	__u32 field;
	__u32 colorspace;
	union {
		__u16 ycbcr_enc;
		__u16 hsv_enc;
	};
	__u16 quantization;
	__u16 xfer_func;
	__u16 flags;
	__u16 reserved[10];
};

struct v4l2_subdev_format {
	__u32 which;
	__u32 pad;
	struct v4l2_mbus_framefmt format;
	__u32 reserved[8];
};

struct v4l2_subdev_mbus_code_enum {
	__u32 pad;
	__u32 index;
	__u32 code;
	__u32 which;
	__u32 flags;
	__u32 reserved[7];
};

struct v4l2_subdev_frame_size_enum {
	__u32 index;
	__u32 pad;
	__u32 code;
	__u32 min_width;
	__u32 max_width;
	__u32 min_height;
	__u32 max_height;
	__u32 which;
	__u32 reserved[8];
};

struct v4l2_subdev_frame_interval {
	__u32 pad;
	struct v4l2_fract interval;
	__u32 reserved[9];
};

struct v4l2_subdev_frame_interval_enum {
	__u32 index;
	__u32 pad;
	__u32 code;
	__u32 width;
	__u32 height;
	struct v4l2_fract interval;
	__u32 which;
	__u32 reserved[8];
};

struct v4l2_subdev_selection {
	__u32 which;
	__u32 pad;
	__u32 target;
	__u32 flags;
	struct v4l2_rect r;
	__u32 reserved[8];
};

enum v4l2_async_match_type {
	V4L2_ASYNC_MATCH_CUSTOM = 0,
	V4L2_ASYNC_MATCH_DEVNAME = 1,
	V4L2_ASYNC_MATCH_I2C = 2,
	V4L2_ASYNC_MATCH_FWNODE = 3,
};

struct v4l2_async_subdev {
	enum v4l2_async_match_type match_type;
	union {
		struct fwnode_handle *fwnode;
		const char *device_name;
		struct {
			int adapter_id;
			short unsigned int address;
		} i2c;
		struct {
			bool (*match)(struct device *, struct v4l2_async_subdev *);
			void *priv;
		} custom;
	} match;
	struct list_head list;
	struct list_head asd_list;
};

struct v4l2_async_notifier;

struct v4l2_async_notifier_operations {
	int (*bound)(struct v4l2_async_notifier *, struct v4l2_subdev *, struct v4l2_async_subdev *);
	int (*complete)(struct v4l2_async_notifier *);
	void (*unbind)(struct v4l2_async_notifier *, struct v4l2_subdev *, struct v4l2_async_subdev *);
};

struct v4l2_async_notifier {
	const struct v4l2_async_notifier_operations *ops;
	struct v4l2_device *v4l2_dev;
	struct v4l2_subdev *sd;
	struct v4l2_async_notifier *parent;
	struct list_head asd_list;
	struct list_head waiting;
	struct list_head done;
	struct list_head list;
};

struct v4l2_subdev_ops;

struct v4l2_subdev_internal_ops;

struct v4l2_subdev_platform_data;

struct v4l2_subdev {
	struct media_entity entity;
	struct list_head list;
	struct module *owner;
	bool owner_v4l2_dev;
	u32 flags;
	struct v4l2_device *v4l2_dev;
	const struct v4l2_subdev_ops *ops;
	const struct v4l2_subdev_internal_ops *internal_ops;
	struct v4l2_ctrl_handler *ctrl_handler;
	char name[32];
	u32 grp_id;
	void *dev_priv;
	void *host_priv;
	struct video_device *devnode;
	struct device *dev;
	struct fwnode_handle *fwnode;
	struct list_head async_list;
	struct v4l2_async_subdev *asd;
	struct v4l2_async_notifier *notifier;
	struct v4l2_async_notifier *subdev_notifier;
	struct v4l2_subdev_platform_data *pdata;
};

struct v4l2_m2m_ctx;

struct v4l2_fh {
	struct list_head list;
	struct video_device *vdev;
	struct v4l2_ctrl_handler *ctrl_handler;
	enum v4l2_priority prio;
	wait_queue_head_t wait;
	struct mutex subscribe_lock;
	struct list_head subscribed;
	struct list_head available;
	unsigned int navailable;
	u32 sequence;
	struct v4l2_m2m_ctx *m2m_ctx;
};

enum v4l2_mbus_type {
	V4L2_MBUS_UNKNOWN = 0,
	V4L2_MBUS_PARALLEL = 1,
	V4L2_MBUS_BT656 = 2,
	V4L2_MBUS_CSI1 = 3,
	V4L2_MBUS_CCP2 = 4,
	V4L2_MBUS_CSI2_DPHY = 5,
	V4L2_MBUS_CSI2_CPHY = 6,
	V4L2_MBUS_INVALID = 7,
};

struct v4l2_mbus_config {
	enum v4l2_mbus_type type;
	unsigned int flags;
};

struct v4l2_decode_vbi_line {
	u32 is_second_field;
	u8 *p;
	u32 line;
	u32 type;
};

struct v4l2_subdev_io_pin_config {
	u32 flags;
	u8 pin;
	u8 function;
	u8 value;
	u8 strength;
};

struct v4l2_subdev_core_ops {
	int (*log_status)(struct v4l2_subdev *);
	int (*s_io_pin_config)(struct v4l2_subdev *, size_t, struct v4l2_subdev_io_pin_config *);
	int (*init)(struct v4l2_subdev *, u32);
	int (*load_fw)(struct v4l2_subdev *);
	int (*reset)(struct v4l2_subdev *, u32);
	int (*s_gpio)(struct v4l2_subdev *, u32);
	long int (*ioctl)(struct v4l2_subdev *, unsigned int, void *);
	int (*s_power)(struct v4l2_subdev *, int);
	int (*interrupt_service_routine)(struct v4l2_subdev *, u32, bool *);
	int (*subscribe_event)(struct v4l2_subdev *, struct v4l2_fh *, struct v4l2_event_subscription *);
	int (*unsubscribe_event)(struct v4l2_subdev *, struct v4l2_fh *, struct v4l2_event_subscription *);
};

struct tuner_setup;

struct v4l2_subdev_tuner_ops {
	int (*standby)(struct v4l2_subdev *);
	int (*s_radio)(struct v4l2_subdev *);
	int (*s_frequency)(struct v4l2_subdev *, const struct v4l2_frequency *);
	int (*g_frequency)(struct v4l2_subdev *, struct v4l2_frequency *);
	int (*enum_freq_bands)(struct v4l2_subdev *, struct v4l2_frequency_band *);
	int (*g_tuner)(struct v4l2_subdev *, struct v4l2_tuner *);
	int (*s_tuner)(struct v4l2_subdev *, const struct v4l2_tuner *);
	int (*g_modulator)(struct v4l2_subdev *, struct v4l2_modulator *);
	int (*s_modulator)(struct v4l2_subdev *, const struct v4l2_modulator *);
	int (*s_type_addr)(struct v4l2_subdev *, struct tuner_setup *);
	int (*s_config)(struct v4l2_subdev *, const struct v4l2_priv_tun_config *);
};

struct v4l2_subdev_audio_ops {
	int (*s_clock_freq)(struct v4l2_subdev *, u32);
	int (*s_i2s_clock_freq)(struct v4l2_subdev *, u32);
	int (*s_routing)(struct v4l2_subdev *, u32, u32, u32);
	int (*s_stream)(struct v4l2_subdev *, int);
};

enum v4l2_mbus_frame_desc_flags {
	V4L2_MBUS_FRAME_DESC_FL_LEN_MAX = 1,
	V4L2_MBUS_FRAME_DESC_FL_BLOB = 2,
};

struct v4l2_mbus_frame_desc_entry {
	enum v4l2_mbus_frame_desc_flags flags;
	u32 pixelcode;
	u32 length;
};

struct v4l2_mbus_frame_desc {
	struct v4l2_mbus_frame_desc_entry entry[4];
	short unsigned int num_entries;
};

struct v4l2_subdev_video_ops {
	int (*s_routing)(struct v4l2_subdev *, u32, u32, u32);
	int (*s_crystal_freq)(struct v4l2_subdev *, u32, u32);
	int (*g_std)(struct v4l2_subdev *, v4l2_std_id *);
	int (*s_std)(struct v4l2_subdev *, v4l2_std_id);
	int (*s_std_output)(struct v4l2_subdev *, v4l2_std_id);
	int (*g_std_output)(struct v4l2_subdev *, v4l2_std_id *);
	int (*querystd)(struct v4l2_subdev *, v4l2_std_id *);
	int (*g_tvnorms)(struct v4l2_subdev *, v4l2_std_id *);
	int (*g_tvnorms_output)(struct v4l2_subdev *, v4l2_std_id *);
	int (*g_input_status)(struct v4l2_subdev *, u32 *);
	int (*s_stream)(struct v4l2_subdev *, int);
	int (*g_pixelaspect)(struct v4l2_subdev *, struct v4l2_fract *);
	int (*g_frame_interval)(struct v4l2_subdev *, struct v4l2_subdev_frame_interval *);
	int (*s_frame_interval)(struct v4l2_subdev *, struct v4l2_subdev_frame_interval *);
	int (*s_dv_timings)(struct v4l2_subdev *, struct v4l2_dv_timings *);
	int (*g_dv_timings)(struct v4l2_subdev *, struct v4l2_dv_timings *);
	int (*query_dv_timings)(struct v4l2_subdev *, struct v4l2_dv_timings *);
	int (*s_rx_buffer)(struct v4l2_subdev *, void *, unsigned int *);
};

struct v4l2_subdev_vbi_ops {
	int (*decode_vbi_line)(struct v4l2_subdev *, struct v4l2_decode_vbi_line *);
	int (*s_vbi_data)(struct v4l2_subdev *, const struct v4l2_sliced_vbi_data *);
	int (*g_vbi_data)(struct v4l2_subdev *, struct v4l2_sliced_vbi_data *);
	int (*g_sliced_vbi_cap)(struct v4l2_subdev *, struct v4l2_sliced_vbi_cap *);
	int (*s_raw_fmt)(struct v4l2_subdev *, struct v4l2_vbi_format *);
	int (*g_sliced_fmt)(struct v4l2_subdev *, struct v4l2_sliced_vbi_format *);
	int (*s_sliced_fmt)(struct v4l2_subdev *, struct v4l2_sliced_vbi_format *);
};

struct v4l2_subdev_sensor_ops {
	int (*g_skip_top_lines)(struct v4l2_subdev *, u32 *);
	int (*g_skip_frames)(struct v4l2_subdev *, u32 *);
};

enum v4l2_subdev_ir_mode {
	V4L2_SUBDEV_IR_MODE_PULSE_WIDTH = 0,
};

struct v4l2_subdev_ir_parameters {
	unsigned int bytes_per_data_element;
	enum v4l2_subdev_ir_mode mode;
	bool enable;
	bool interrupt_enable;
	bool shutdown;
	bool modulation;
	u32 max_pulse_width;
	unsigned int carrier_freq;
	unsigned int duty_cycle;
	bool invert_level;
	bool invert_carrier_sense;
	u32 noise_filter_min_width;
	unsigned int carrier_range_lower;
	unsigned int carrier_range_upper;
	u32 resolution;
};

struct v4l2_subdev_ir_ops {
	int (*rx_read)(struct v4l2_subdev *, u8 *, size_t, ssize_t *);
	int (*rx_g_parameters)(struct v4l2_subdev *, struct v4l2_subdev_ir_parameters *);
	int (*rx_s_parameters)(struct v4l2_subdev *, struct v4l2_subdev_ir_parameters *);
	int (*tx_write)(struct v4l2_subdev *, u8 *, size_t, ssize_t *);
	int (*tx_g_parameters)(struct v4l2_subdev *, struct v4l2_subdev_ir_parameters *);
	int (*tx_s_parameters)(struct v4l2_subdev *, struct v4l2_subdev_ir_parameters *);
};

struct v4l2_subdev_pad_config {
	struct v4l2_mbus_framefmt try_fmt;
	struct v4l2_rect try_crop;
	struct v4l2_rect try_compose;
};

struct v4l2_subdev_pad_ops {
	int (*init_cfg)(struct v4l2_subdev *, struct v4l2_subdev_pad_config *);
	int (*enum_mbus_code)(struct v4l2_subdev *, struct v4l2_subdev_pad_config *, struct v4l2_subdev_mbus_code_enum *);
	int (*enum_frame_size)(struct v4l2_subdev *, struct v4l2_subdev_pad_config *, struct v4l2_subdev_frame_size_enum *);
	int (*enum_frame_interval)(struct v4l2_subdev *, struct v4l2_subdev_pad_config *, struct v4l2_subdev_frame_interval_enum *);
	int (*get_fmt)(struct v4l2_subdev *, struct v4l2_subdev_pad_config *, struct v4l2_subdev_format *);
	int (*set_fmt)(struct v4l2_subdev *, struct v4l2_subdev_pad_config *, struct v4l2_subdev_format *);
	int (*get_selection)(struct v4l2_subdev *, struct v4l2_subdev_pad_config *, struct v4l2_subdev_selection *);
	int (*set_selection)(struct v4l2_subdev *, struct v4l2_subdev_pad_config *, struct v4l2_subdev_selection *);
	int (*get_edid)(struct v4l2_subdev *, struct v4l2_edid *);
	int (*set_edid)(struct v4l2_subdev *, struct v4l2_edid *);
	int (*dv_timings_cap)(struct v4l2_subdev *, struct v4l2_dv_timings_cap *);
	int (*enum_dv_timings)(struct v4l2_subdev *, struct v4l2_enum_dv_timings *);
	int (*link_validate)(struct v4l2_subdev *, struct media_link *, struct v4l2_subdev_format *, struct v4l2_subdev_format *);
	int (*get_frame_desc)(struct v4l2_subdev *, unsigned int, struct v4l2_mbus_frame_desc *);
	int (*set_frame_desc)(struct v4l2_subdev *, unsigned int, struct v4l2_mbus_frame_desc *);
	int (*get_mbus_config)(struct v4l2_subdev *, unsigned int, struct v4l2_mbus_config *);
	int (*set_mbus_config)(struct v4l2_subdev *, unsigned int, struct v4l2_mbus_config *);
};

struct v4l2_subdev_ops {
	const struct v4l2_subdev_core_ops *core;
	const struct v4l2_subdev_tuner_ops *tuner;
	const struct v4l2_subdev_audio_ops *audio;
	const struct v4l2_subdev_video_ops *video;
	const struct v4l2_subdev_vbi_ops *vbi;
	const struct v4l2_subdev_ir_ops *ir;
	const struct v4l2_subdev_sensor_ops *sensor;
	const struct v4l2_subdev_pad_ops *pad;
};

struct v4l2_subdev_fh;

struct v4l2_subdev_internal_ops {
	int (*registered)(struct v4l2_subdev *);
	void (*unregistered)(struct v4l2_subdev *);
	int (*open)(struct v4l2_subdev *, struct v4l2_subdev_fh *);
	int (*close)(struct v4l2_subdev *, struct v4l2_subdev_fh *);
	void (*release)(struct v4l2_subdev *);
};

struct v4l2_subdev_fh {
	struct v4l2_fh vfh;
	struct module *owner;
};

struct regulator_bulk_data;

struct v4l2_subdev_platform_data {
	struct regulator_bulk_data *regulators;
	int num_regulators;
	void *host_priv;
};

struct v4l2_ctrl_hdr10_cll_info {
	__u16 max_content_light_level;
	__u16 max_pic_average_light_level;
};

struct v4l2_ctrl_hdr10_mastering_display {
	__u16 display_primaries_x[3];
	__u16 display_primaries_y[3];
	__u16 white_point_x;
	__u16 white_point_y;
	__u32 max_display_mastering_luminance;
	__u32 min_display_mastering_luminance;
};

enum v4l2_field {
	V4L2_FIELD_ANY = 0,
	V4L2_FIELD_NONE = 1,
	V4L2_FIELD_TOP = 2,
	V4L2_FIELD_BOTTOM = 3,
	V4L2_FIELD_INTERLACED = 4,
	V4L2_FIELD_SEQ_TB = 5,
	V4L2_FIELD_SEQ_BT = 6,
	V4L2_FIELD_ALTERNATE = 7,
	V4L2_FIELD_INTERLACED_TB = 8,
	V4L2_FIELD_INTERLACED_BT = 9,
};

enum v4l2_tuner_type {
	V4L2_TUNER_RADIO = 1,
	V4L2_TUNER_ANALOG_TV = 2,
	V4L2_TUNER_DIGITAL_TV = 3,
	V4L2_TUNER_SDR = 4,
	V4L2_TUNER_RF = 5,
};

enum v4l2_memory {
	V4L2_MEMORY_MMAP = 1,
	V4L2_MEMORY_USERPTR = 2,
	V4L2_MEMORY_OVERLAY = 3,
	V4L2_MEMORY_DMABUF = 4,
};

enum v4l2_colorspace {
	V4L2_COLORSPACE_DEFAULT = 0,
	V4L2_COLORSPACE_SMPTE170M = 1,
	V4L2_COLORSPACE_SMPTE240M = 2,
	V4L2_COLORSPACE_REC709 = 3,
	V4L2_COLORSPACE_BT878 = 4,
	V4L2_COLORSPACE_470_SYSTEM_M = 5,
	V4L2_COLORSPACE_470_SYSTEM_BG = 6,
	V4L2_COLORSPACE_JPEG = 7,
	V4L2_COLORSPACE_SRGB = 8,
	V4L2_COLORSPACE_OPRGB = 9,
	V4L2_COLORSPACE_BT2020 = 10,
	V4L2_COLORSPACE_RAW = 11,
	V4L2_COLORSPACE_DCI_P3 = 12,
};

enum v4l2_frmsizetypes {
	V4L2_FRMSIZE_TYPE_DISCRETE = 1,
	V4L2_FRMSIZE_TYPE_CONTINUOUS = 2,
	V4L2_FRMSIZE_TYPE_STEPWISE = 3,
};

enum v4l2_frmivaltypes {
	V4L2_FRMIVAL_TYPE_DISCRETE = 1,
	V4L2_FRMIVAL_TYPE_CONTINUOUS = 2,
	V4L2_FRMIVAL_TYPE_STEPWISE = 3,
};

struct v4l2_cropcap {
	__u32 type;
	struct v4l2_rect bounds;
	struct v4l2_rect defrect;
	struct v4l2_fract pixelaspect;
};

struct v4l2_crop {
	__u32 type;
	struct v4l2_rect c;
};

struct v4l2_standard {
	__u32 index;
	v4l2_std_id id;
	__u8 name[24];
	struct v4l2_fract frameperiod;
	__u32 framelines;
	__u32 reserved[4];
};

enum v4l2_ctrl_type {
	V4L2_CTRL_TYPE_INTEGER = 1,
	V4L2_CTRL_TYPE_BOOLEAN = 2,
	V4L2_CTRL_TYPE_MENU = 3,
	V4L2_CTRL_TYPE_BUTTON = 4,
	V4L2_CTRL_TYPE_INTEGER64 = 5,
	V4L2_CTRL_TYPE_CTRL_CLASS = 6,
	V4L2_CTRL_TYPE_STRING = 7,
	V4L2_CTRL_TYPE_BITMASK = 8,
	V4L2_CTRL_TYPE_INTEGER_MENU = 9,
	V4L2_CTRL_COMPOUND_TYPES = 256,
	V4L2_CTRL_TYPE_U8 = 256,
	V4L2_CTRL_TYPE_U16 = 257,
	V4L2_CTRL_TYPE_U32 = 258,
	V4L2_CTRL_TYPE_AREA = 262,
	V4L2_CTRL_TYPE_HDR10_CLL_INFO = 272,
	V4L2_CTRL_TYPE_HDR10_MASTERING_DISPLAY = 273,
	V4L2_CTRL_TYPE_H264_SPS = 512,
	V4L2_CTRL_TYPE_H264_PPS = 513,
	V4L2_CTRL_TYPE_H264_SCALING_MATRIX = 514,
	V4L2_CTRL_TYPE_H264_SLICE_PARAMS = 515,
	V4L2_CTRL_TYPE_H264_DECODE_PARAMS = 516,
	V4L2_CTRL_TYPE_H264_PRED_WEIGHTS = 517,
};

struct v4l2_event_vsync {
	__u8 field;
};

struct v4l2_event_ctrl {
	__u32 changes;
	__u32 type;
	union {
		__s32 value;
		__s64 value64;
	};
	__u32 flags;
	__s32 minimum;
	__s32 maximum;
	__s32 step;
	__s32 default_value;
};

struct v4l2_event_frame_sync {
	__u32 frame_sequence;
};

struct v4l2_event_src_change {
	__u32 changes;
};

struct v4l2_event_motion_det {
	__u32 flags;
	__u32 frame_sequence;
	__u32 region_mask;
};

struct v4l2_event {
	__u32 type;
	union {
		struct v4l2_event_vsync vsync;
		struct v4l2_event_ctrl ctrl;
		struct v4l2_event_frame_sync frame_sync;
		struct v4l2_event_src_change src_change;
		struct v4l2_event_motion_det motion_det;
		__u8 data[64];
	} u;
	__u32 pending;
	__u32 sequence;
	struct __kernel_timespec timestamp;
	__u32 id;
	__u32 reserved[8];
};

struct v4l2_dbg_match {
	__u32 type;
	union {
		__u32 addr;
		char name[32];
	};
};

struct v4l2_dbg_register {
	struct v4l2_dbg_match match;
	__u32 size;
	__u64 reg;
	__u64 val;
};

struct v4l2_dbg_chip_info {
	struct v4l2_dbg_match match;
	char name[32];
	__u32 flags;
	__u32 reserved[32];
};

struct v4l2_ctrl;

typedef void (*v4l2_ctrl_notify_fnc)(struct v4l2_ctrl *, void *);

struct v4l2_ctrl_ref;

struct v4l2_ctrl_handler {
	struct mutex _lock;
	struct mutex *lock;
	struct list_head ctrls;
	struct list_head ctrl_refs;
	struct v4l2_ctrl_ref *cached;
	struct v4l2_ctrl_ref **buckets;
	v4l2_ctrl_notify_fnc notify;
	void *notify_priv;
	u16 nr_of_buckets;
	int error;
	bool request_is_queued;
	struct list_head requests;
	struct list_head requests_queued;
	struct media_request_object req_obj;
};

struct vb2_ops;

struct vb2_mem_ops;

struct vb2_buf_ops;

struct vb2_buffer;

struct vb2_fileio_data;

struct vb2_threadio_data;

struct vb2_queue {
	unsigned int type;
	unsigned int io_modes;
	struct device *dev;
	long unsigned int dma_attrs;
	unsigned int bidirectional: 1;
	unsigned int fileio_read_once: 1;
	unsigned int fileio_write_immediately: 1;
	unsigned int allow_zero_bytesused: 1;
	unsigned int quirk_poll_must_check_waiting_for_buffers: 1;
	unsigned int supports_requests: 1;
	unsigned int requires_requests: 1;
	unsigned int uses_qbuf: 1;
	unsigned int uses_requests: 1;
	unsigned int allow_cache_hints: 1;
	struct mutex *lock;
	void *owner;
	const struct vb2_ops *ops;
	const struct vb2_mem_ops *mem_ops;
	const struct vb2_buf_ops *buf_ops;
	void *drv_priv;
	u32 subsystem_flags;
	unsigned int buf_struct_size;
	u32 timestamp_flags;
	gfp_t gfp_flags;
	u32 min_buffers_needed;
	struct device *alloc_devs[8];
	struct mutex mmap_lock;
	unsigned int memory;
	enum dma_data_direction dma_dir;
	struct vb2_buffer *bufs[64];
	unsigned int num_buffers;
	struct list_head queued_list;
	unsigned int queued_count;
	atomic_t owned_by_drv_count;
	struct list_head done_list;
	spinlock_t done_lock;
	wait_queue_head_t done_wq;
	unsigned int streaming: 1;
	unsigned int start_streaming_called: 1;
	unsigned int error: 1;
	unsigned int waiting_for_buffers: 1;
	unsigned int waiting_in_dqbuf: 1;
	unsigned int is_multiplanar: 1;
	unsigned int is_output: 1;
	unsigned int copy_timestamp: 1;
	unsigned int last_buffer_dequeued: 1;
	struct vb2_fileio_data *fileio;
	struct vb2_threadio_data *threadio;
	char name[32];
};

typedef long int (*v4l2_kioctl)(struct file *, unsigned int, void *);

struct v4l2_mpeg2_sequence {
	__u16 horizontal_size;
	__u16 vertical_size;
	__u32 vbv_buffer_size;
	__u16 profile_and_level_indication;
	__u8 progressive_sequence;
	__u8 chroma_format;
};

struct v4l2_mpeg2_picture {
	__u8 picture_coding_type;
	__u8 f_code[4];
	__u8 intra_dc_precision;
	__u8 picture_structure;
	__u8 top_field_first;
	__u8 frame_pred_frame_dct;
	__u8 concealment_motion_vectors;
	__u8 q_scale_type;
	__u8 intra_vlc_format;
	__u8 alternate_scan;
	__u8 repeat_first_field;
	__u16 progressive_frame;
};

struct v4l2_ctrl_mpeg2_slice_params {
	__u32 bit_size;
	__u32 data_bit_offset;
	__u64 backward_ref_ts;
	__u64 forward_ref_ts;
	struct v4l2_mpeg2_sequence sequence;
	struct v4l2_mpeg2_picture picture;
	__u32 quantiser_scale_code;
};

struct v4l2_ctrl_mpeg2_quantization {
	__u8 load_intra_quantiser_matrix;
	__u8 load_non_intra_quantiser_matrix;
	__u8 load_chroma_intra_quantiser_matrix;
	__u8 load_chroma_non_intra_quantiser_matrix;
	__u8 intra_quantiser_matrix[64];
	__u8 non_intra_quantiser_matrix[64];
	__u8 chroma_intra_quantiser_matrix[64];
	__u8 chroma_non_intra_quantiser_matrix[64];
};

struct v4l2_ctrl_fwht_params {
	__u64 backward_ref_ts;
	__u32 version;
	__u32 width;
	__u32 height;
	__u32 flags;
	__u32 colorspace;
	__u32 xfer_func;
	__u32 ycbcr_enc;
	__u32 quantization;
};

struct v4l2_ctrl_h264_sps {
	__u8 profile_idc;
	__u8 constraint_set_flags;
	__u8 level_idc;
	__u8 seq_parameter_set_id;
	__u8 chroma_format_idc;
	__u8 bit_depth_luma_minus8;
	__u8 bit_depth_chroma_minus8;
	__u8 log2_max_frame_num_minus4;
	__u8 pic_order_cnt_type;
	__u8 log2_max_pic_order_cnt_lsb_minus4;
	__u8 max_num_ref_frames;
	__u8 num_ref_frames_in_pic_order_cnt_cycle;
	__s32 offset_for_ref_frame[255];
	__s32 offset_for_non_ref_pic;
	__s32 offset_for_top_to_bottom_field;
	__u16 pic_width_in_mbs_minus1;
	__u16 pic_height_in_map_units_minus1;
	__u32 flags;
};

struct v4l2_ctrl_h264_pps {
	__u8 pic_parameter_set_id;
	__u8 seq_parameter_set_id;
	__u8 num_slice_groups_minus1;
	__u8 num_ref_idx_l0_default_active_minus1;
	__u8 num_ref_idx_l1_default_active_minus1;
	__u8 weighted_bipred_idc;
	__s8 pic_init_qp_minus26;
	__s8 pic_init_qs_minus26;
	__s8 chroma_qp_index_offset;
	__s8 second_chroma_qp_index_offset;
	__u16 flags;
};

struct v4l2_ctrl_h264_scaling_matrix {
	__u8 scaling_list_4x4[96];
	__u8 scaling_list_8x8[384];
};

struct v4l2_h264_weight_factors {
	__s16 luma_weight[32];
	__s16 luma_offset[32];
	__s16 chroma_weight[64];
	__s16 chroma_offset[64];
};

struct v4l2_ctrl_h264_pred_weights {
	__u16 luma_log2_weight_denom;
	__u16 chroma_log2_weight_denom;
	struct v4l2_h264_weight_factors weight_factors[2];
};

struct v4l2_h264_reference {
	__u8 fields;
	__u8 index;
};

struct v4l2_ctrl_h264_slice_params {
	__u32 header_bit_size;
	__u32 first_mb_in_slice;
	__u8 slice_type;
	__u8 colour_plane_id;
	__u8 redundant_pic_cnt;
	__u8 cabac_init_idc;
	__s8 slice_qp_delta;
	__s8 slice_qs_delta;
	__u8 disable_deblocking_filter_idc;
	__s8 slice_alpha_c0_offset_div2;
	__s8 slice_beta_offset_div2;
	__u8 num_ref_idx_l0_active_minus1;
	__u8 num_ref_idx_l1_active_minus1;
	__u8 reserved;
	struct v4l2_h264_reference ref_pic_list0[32];
	struct v4l2_h264_reference ref_pic_list1[32];
	__u32 flags;
};

struct v4l2_h264_dpb_entry {
	__u64 reference_ts;
	__u32 pic_num;
	__u16 frame_num;
	__u8 fields;
	__u8 reserved[5];
	__s32 top_field_order_cnt;
	__s32 bottom_field_order_cnt;
	__u32 flags;
};

struct v4l2_ctrl_h264_decode_params {
	struct v4l2_h264_dpb_entry dpb[16];
	__u16 nal_ref_idc;
	__u16 frame_num;
	__s32 top_field_order_cnt;
	__s32 bottom_field_order_cnt;
	__u16 idr_pic_id;
	__u16 pic_order_cnt_lsb;
	__s32 delta_pic_order_cnt_bottom;
	__s32 delta_pic_order_cnt0;
	__s32 delta_pic_order_cnt1;
	__u32 dec_ref_pic_marking_bit_size;
	__u32 pic_order_cnt_bit_size;
	__u32 slice_group_change_cycle;
	__u32 reserved;
	__u32 flags;
};

struct v4l2_vp8_segment_header {
	__s8 quant_update[4];
	__s8 lf_update[4];
	__u8 segment_probs[3];
	__u8 padding;
	__u32 flags;
};

struct v4l2_vp8_loopfilter_header {
	__s8 ref_frm_delta[4];
	__s8 mb_mode_delta[4];
	__u8 sharpness_level;
	__u8 level;
	__u16 padding;
	__u32 flags;
};

struct v4l2_vp8_quantization_header {
	__u8 y_ac_qi;
	__s8 y_dc_delta;
	__s8 y2_dc_delta;
	__s8 y2_ac_delta;
	__s8 uv_dc_delta;
	__s8 uv_ac_delta;
	__u16 padding;
};

struct v4l2_vp8_entropy_header {
	__u8 coeff_probs[1056];
	__u8 y_mode_probs[4];
	__u8 uv_mode_probs[3];
	__u8 mv_probs[38];
	__u8 padding[3];
};

struct v4l2_vp8_entropy_coder_state {
	__u8 range;
	__u8 value;
	__u8 bit_count;
	__u8 padding;
};

struct v4l2_ctrl_vp8_frame_header {
	struct v4l2_vp8_segment_header segment_header;
	struct v4l2_vp8_loopfilter_header lf_header;
	struct v4l2_vp8_quantization_header quant_header;
	struct v4l2_vp8_entropy_header entropy_header;
	struct v4l2_vp8_entropy_coder_state coder_state;
	__u16 width;
	__u16 height;
	__u8 horizontal_scale;
	__u8 vertical_scale;
	__u8 version;
	__u8 prob_skip_false;
	__u8 prob_intra;
	__u8 prob_last;
	__u8 prob_gf;
	__u8 num_dct_parts;
	__u32 first_part_size;
	__u32 first_part_header_bits;
	__u32 dct_part_sizes[8];
	__u64 last_frame_ts;
	__u64 golden_frame_ts;
	__u64 alt_frame_ts;
	__u64 flags;
};

struct v4l2_ctrl_hevc_sps {
	__u16 pic_width_in_luma_samples;
	__u16 pic_height_in_luma_samples;
	__u8 bit_depth_luma_minus8;
	__u8 bit_depth_chroma_minus8;
	__u8 log2_max_pic_order_cnt_lsb_minus4;
	__u8 sps_max_dec_pic_buffering_minus1;
	__u8 sps_max_num_reorder_pics;
	__u8 sps_max_latency_increase_plus1;
	__u8 log2_min_luma_coding_block_size_minus3;
	__u8 log2_diff_max_min_luma_coding_block_size;
	__u8 log2_min_luma_transform_block_size_minus2;
	__u8 log2_diff_max_min_luma_transform_block_size;
	__u8 max_transform_hierarchy_depth_inter;
	__u8 max_transform_hierarchy_depth_intra;
	__u8 pcm_sample_bit_depth_luma_minus1;
	__u8 pcm_sample_bit_depth_chroma_minus1;
	__u8 log2_min_pcm_luma_coding_block_size_minus3;
	__u8 log2_diff_max_min_pcm_luma_coding_block_size;
	__u8 num_short_term_ref_pic_sets;
	__u8 num_long_term_ref_pics_sps;
	__u8 chroma_format_idc;
	__u8 padding;
	__u64 flags;
};

struct v4l2_ctrl_hevc_pps {
	__u8 num_extra_slice_header_bits;
	__s8 init_qp_minus26;
	__u8 diff_cu_qp_delta_depth;
	__s8 pps_cb_qp_offset;
	__s8 pps_cr_qp_offset;
	__u8 num_tile_columns_minus1;
	__u8 num_tile_rows_minus1;
	__u8 column_width_minus1[20];
	__u8 row_height_minus1[22];
	__s8 pps_beta_offset_div2;
	__s8 pps_tc_offset_div2;
	__u8 log2_parallel_merge_level_minus2;
	__u8 padding[4];
	__u64 flags;
};

struct v4l2_hevc_dpb_entry {
	__u64 timestamp;
	__u8 rps;
	__u8 field_pic;
	__u16 pic_order_cnt[2];
	__u8 padding[2];
};

struct v4l2_hevc_pred_weight_table {
	__s8 delta_luma_weight_l0[16];
	__s8 luma_offset_l0[16];
	__s8 delta_chroma_weight_l0[32];
	__s8 chroma_offset_l0[32];
	__s8 delta_luma_weight_l1[16];
	__s8 luma_offset_l1[16];
	__s8 delta_chroma_weight_l1[32];
	__s8 chroma_offset_l1[32];
	__u8 padding[6];
	__u8 luma_log2_weight_denom;
	__s8 delta_chroma_log2_weight_denom;
};

struct v4l2_ctrl_hevc_slice_params {
	__u32 bit_size;
	__u32 data_bit_offset;
	__u8 nal_unit_type;
	__u8 nuh_temporal_id_plus1;
	__u8 slice_type;
	__u8 colour_plane_id;
	__u16 slice_pic_order_cnt;
	__u8 num_ref_idx_l0_active_minus1;
	__u8 num_ref_idx_l1_active_minus1;
	__u8 collocated_ref_idx;
	__u8 five_minus_max_num_merge_cand;
	__s8 slice_qp_delta;
	__s8 slice_cb_qp_offset;
	__s8 slice_cr_qp_offset;
	__s8 slice_act_y_qp_offset;
	__s8 slice_act_cb_qp_offset;
	__s8 slice_act_cr_qp_offset;
	__s8 slice_beta_offset_div2;
	__s8 slice_tc_offset_div2;
	__u8 pic_struct;
	__u8 num_active_dpb_entries;
	__u8 ref_idx_l0[16];
	__u8 ref_idx_l1[16];
	__u8 num_rps_poc_st_curr_before;
	__u8 num_rps_poc_st_curr_after;
	__u8 num_rps_poc_lt_curr;
	__u8 padding;
	struct v4l2_hevc_dpb_entry dpb[16];
	struct v4l2_hevc_pred_weight_table pred_weight_table;
	__u64 flags;
};

union v4l2_ctrl_ptr {
	s32 *p_s32;
	s64 *p_s64;
	u8 *p_u8;
	u16 *p_u16;
	u32 *p_u32;
	char *p_char;
	struct v4l2_ctrl_mpeg2_slice_params *p_mpeg2_slice_params;
	struct v4l2_ctrl_mpeg2_quantization *p_mpeg2_quantization;
	struct v4l2_ctrl_fwht_params *p_fwht_params;
	struct v4l2_ctrl_h264_sps *p_h264_sps;
	struct v4l2_ctrl_h264_pps *p_h264_pps;
	struct v4l2_ctrl_h264_scaling_matrix *p_h264_scaling_matrix;
	struct v4l2_ctrl_h264_slice_params *p_h264_slice_params;
	struct v4l2_ctrl_h264_decode_params *p_h264_decode_params;
	struct v4l2_ctrl_h264_pred_weights *p_h264_pred_weights;
	struct v4l2_ctrl_vp8_frame_header *p_vp8_frame_header;
	struct v4l2_ctrl_hevc_sps *p_hevc_sps;
	struct v4l2_ctrl_hevc_pps *p_hevc_pps;
	struct v4l2_ctrl_hevc_slice_params *p_hevc_slice_params;
	struct v4l2_ctrl_hdr10_cll_info *p_hdr10_cll;
	struct v4l2_ctrl_hdr10_mastering_display *p_hdr10_mastering;
	struct v4l2_area *p_area;
	void *p;
	const void *p_const;
};

struct v4l2_ctrl_ops {
	int (*g_volatile_ctrl)(struct v4l2_ctrl *);
	int (*try_ctrl)(struct v4l2_ctrl *);
	int (*s_ctrl)(struct v4l2_ctrl *);
};

struct v4l2_ctrl_type_ops;

struct v4l2_ctrl {
	struct list_head node;
	struct list_head ev_subs;
	struct v4l2_ctrl_handler *handler;
	struct v4l2_ctrl **cluster;
	unsigned int ncontrols;
	unsigned int done: 1;
	unsigned int is_new: 1;
	unsigned int has_changed: 1;
	unsigned int is_private: 1;
	unsigned int is_auto: 1;
	unsigned int is_int: 1;
	unsigned int is_string: 1;
	unsigned int is_ptr: 1;
	unsigned int is_array: 1;
	unsigned int has_volatiles: 1;
	unsigned int call_notify: 1;
	unsigned int manual_mode_value: 8;
	const struct v4l2_ctrl_ops *ops;
	const struct v4l2_ctrl_type_ops *type_ops;
	u32 id;
	const char *name;
	enum v4l2_ctrl_type type;
	s64 minimum;
	s64 maximum;
	s64 default_value;
	u32 elems;
	u32 elem_size;
	u32 dims[4];
	u32 nr_of_dims;
	union {
		u64 step;
		u64 menu_skip_mask;
	};
	union {
		const char * const *qmenu;
		const s64 *qmenu_int;
	};
	long unsigned int flags;
	void *priv;
	s32 val;
	struct {
		s32 val;
	} cur;
	union v4l2_ctrl_ptr p_def;
	union v4l2_ctrl_ptr p_new;
	union v4l2_ctrl_ptr p_cur;
};

struct v4l2_ctrl_type_ops {
	bool (*equal)(const struct v4l2_ctrl *, u32, union v4l2_ctrl_ptr, union v4l2_ctrl_ptr);
	void (*init)(const struct v4l2_ctrl *, u32, union v4l2_ctrl_ptr);
	void (*log)(const struct v4l2_ctrl *);
	int (*validate)(const struct v4l2_ctrl *, u32, union v4l2_ctrl_ptr);
};

struct v4l2_ctrl_helper;

struct v4l2_ctrl_ref {
	struct list_head node;
	struct v4l2_ctrl_ref *next;
	struct v4l2_ctrl *ctrl;
	struct v4l2_ctrl_helper *helper;
	bool from_other_dev;
	bool req_done;
	bool valid_p_req;
	union v4l2_ctrl_ptr p_req;
};

struct v4l2_m2m_dev;

struct v4l2_m2m_queue_ctx {
	struct vb2_queue q;
	struct list_head rdy_queue;
	spinlock_t rdy_spinlock;
	u8 num_rdy;
	bool buffered;
};

struct vb2_v4l2_buffer;

struct v4l2_m2m_ctx {
	struct mutex *q_lock;
	bool new_frame;
	bool is_draining;
	struct vb2_v4l2_buffer *last_src_buf;
	bool next_buf_last;
	bool has_stopped;
	struct v4l2_m2m_dev *m2m_dev;
	struct v4l2_m2m_queue_ctx cap_q_ctx;
	struct v4l2_m2m_queue_ctx out_q_ctx;
	struct list_head queue;
	long unsigned int job_flags;
	wait_queue_head_t finished;
	void *priv;
};

struct vb2_mem_ops {
	void * (*alloc)(struct device *, long unsigned int, long unsigned int, enum dma_data_direction, gfp_t);
	void (*put)(void *);
	struct dma_buf * (*get_dmabuf)(void *, long unsigned int);
	void * (*get_userptr)(struct device *, long unsigned int, long unsigned int, enum dma_data_direction);
	void (*put_userptr)(void *);
	void (*prepare)(void *);
	void (*finish)(void *);
	void * (*attach_dmabuf)(struct device *, struct dma_buf *, long unsigned int, enum dma_data_direction);
	void (*detach_dmabuf)(void *);
	int (*map_dmabuf)(void *);
	void (*unmap_dmabuf)(void *);
	void * (*vaddr)(void *);
	void * (*cookie)(void *);
	unsigned int (*num_users)(void *);
	int (*mmap)(void *, struct vm_area_struct *);
};

struct vb2_plane {
	void *mem_priv;
	struct dma_buf *dbuf;
	unsigned int dbuf_mapped;
	unsigned int bytesused;
	unsigned int length;
	unsigned int min_length;
	union {
		unsigned int offset;
		long unsigned int userptr;
		int fd;
	} m;
	unsigned int data_offset;
};

enum vb2_buffer_state {
	VB2_BUF_STATE_DEQUEUED = 0,
	VB2_BUF_STATE_IN_REQUEST = 1,
	VB2_BUF_STATE_PREPARING = 2,
	VB2_BUF_STATE_QUEUED = 3,
	VB2_BUF_STATE_ACTIVE = 4,
	VB2_BUF_STATE_DONE = 5,
	VB2_BUF_STATE_ERROR = 6,
};

struct vb2_buffer {
	struct vb2_queue *vb2_queue;
	unsigned int index;
	unsigned int type;
	unsigned int memory;
	unsigned int num_planes;
	u64 timestamp;
	struct media_request *request;
	struct media_request_object req_obj;
	enum vb2_buffer_state state;
	unsigned int synced: 1;
	unsigned int prepared: 1;
	unsigned int copied_timestamp: 1;
	unsigned int need_cache_sync_on_prepare: 1;
	unsigned int need_cache_sync_on_finish: 1;
	struct vb2_plane planes[8];
	struct list_head queued_entry;
	struct list_head done_entry;
};

struct vb2_ops {
	int (*queue_setup)(struct vb2_queue *, unsigned int *, unsigned int *, unsigned int *, struct device **);
	void (*wait_prepare)(struct vb2_queue *);
	void (*wait_finish)(struct vb2_queue *);
	int (*buf_out_validate)(struct vb2_buffer *);
	int (*buf_init)(struct vb2_buffer *);
	int (*buf_prepare)(struct vb2_buffer *);
	void (*buf_finish)(struct vb2_buffer *);
	void (*buf_cleanup)(struct vb2_buffer *);
	int (*start_streaming)(struct vb2_queue *, unsigned int);
	void (*stop_streaming)(struct vb2_queue *);
	void (*buf_queue)(struct vb2_buffer *);
	void (*buf_request_complete)(struct vb2_buffer *);
};

struct vb2_buf_ops {
	int (*verify_planes_array)(struct vb2_buffer *, const void *);
	void (*init_buffer)(struct vb2_buffer *);
	void (*fill_user_buffer)(struct vb2_buffer *, void *);
	int (*fill_vb2_buffer)(struct vb2_buffer *, struct vb2_plane *);
	void (*copy_timestamp)(struct vb2_buffer *, const void *);
};

struct vb2_v4l2_buffer {
	struct vb2_buffer vb2_buf;
	__u32 flags;
	__u32 field;
	struct v4l2_timecode timecode;
	__u32 sequence;
	__s32 request_fd;
	bool is_held;
	struct vb2_plane planes[8];
};

struct std_descr {
	v4l2_std_id std;
	const char *descr;
};

struct v4l2_ioctl_info {
	unsigned int ioctl;
	u32 flags;
	const char * const name;
	int (*func)(const struct v4l2_ioctl_ops *, struct file *, void *, void *);
	void (*debug)(const void *, bool);
};

struct v4l2_subscribed_event;

struct v4l2_kevent {
	struct list_head list;
	struct v4l2_subscribed_event *sev;
	struct v4l2_event event;
	u64 ts;
};

struct v4l2_subscribed_event_ops;

struct v4l2_subscribed_event {
	struct list_head list;
	u32 type;
	u32 id;
	u32 flags;
	struct v4l2_fh *fh;
	struct list_head node;
	const struct v4l2_subscribed_event_ops *ops;
	unsigned int elems;
	unsigned int first;
	unsigned int in_use;
	struct v4l2_kevent events[0];
};

struct v4l2_subscribed_event_ops {
	int (*add)(struct v4l2_subscribed_event *, unsigned int);
	void (*del)(struct v4l2_subscribed_event *);
	void (*replace)(struct v4l2_event *, const struct v4l2_event *);
	void (*merge)(const struct v4l2_event *, struct v4l2_event *);
};

struct v4l2_subdev;

struct v4l2_ctrl_helper {
	struct v4l2_ctrl_ref *mref;
	struct v4l2_ctrl_ref *ref;
	u32 next;
};

struct v4l2_ctrl_config {
	const struct v4l2_ctrl_ops *ops;
	const struct v4l2_ctrl_type_ops *type_ops;
	u32 id;
	const char *name;
	enum v4l2_ctrl_type type;
	s64 min;
	s64 max;
	u64 step;
	s64 def;
	union v4l2_ctrl_ptr p_def;
	u32 dims[4];
	u32 elem_size;
	u32 flags;
	u64 menu_skip_mask;
	const char * const *qmenu;
	const s64 *qmenu_int;
	unsigned int is_private: 1;
};

enum v4l2_fwnode_orientation {
	V4L2_FWNODE_ORIENTATION_FRONT = 0,
	V4L2_FWNODE_ORIENTATION_BACK = 1,
	V4L2_FWNODE_ORIENTATION_EXTERNAL = 2,
};

struct v4l2_fwnode_device_properties {
	enum v4l2_fwnode_orientation orientation;
	unsigned int rotation;
};

enum v4l2_subdev_format_whence {
	V4L2_SUBDEV_FORMAT_TRY = 0,
	V4L2_SUBDEV_FORMAT_ACTIVE = 1,
};

struct v4l2_clk_ops;

struct v4l2_clk {
	struct list_head list;
	const struct v4l2_clk_ops *ops;
	const char *dev_id;
	int enable;
	struct mutex lock;
	atomic_t use_count;
	struct clk *clk;
	void *priv;
};

struct v4l2_clk_ops {
	struct module *owner;
	int (*enable)(struct v4l2_clk *);
	void (*disable)(struct v4l2_clk *);
	long unsigned int (*get_rate)(struct v4l2_clk *);
	int (*set_rate)(struct v4l2_clk *, long unsigned int);
};

struct v4l2_clk_fixed {
	long unsigned int rate;
	struct v4l2_clk_ops ops;
};

enum v4l2_pixel_encoding {
	V4L2_PIXEL_ENC_UNKNOWN = 0,
	V4L2_PIXEL_ENC_YUV = 1,
	V4L2_PIXEL_ENC_RGB = 2,
	V4L2_PIXEL_ENC_BAYER = 3,
};

struct v4l2_format_info {
	u32 format;
	u8 pixel_enc;
	u8 mem_planes;
	u8 comp_planes;
	u8 bpp[4];
	u8 hdiv;
	u8 vdiv;
	u8 block_w[4];
	u8 block_h[4];
};

struct trace_event_raw_v4l2_event_class {
	struct trace_entry ent;
	int minor;
	u32 index;
	u32 type;
	u32 bytesused;
	u32 flags;
	u32 field;
	s64 timestamp;
	u32 timecode_type;
	u32 timecode_flags;
	u8 timecode_frames;
	u8 timecode_seconds;
	u8 timecode_minutes;
	u8 timecode_hours;
	u8 timecode_userbits0;
	u8 timecode_userbits1;
	u8 timecode_userbits2;
	u8 timecode_userbits3;
	u32 sequence;
	char __data[0];
};

struct trace_event_raw_vb2_v4l2_event_class {
	struct trace_entry ent;
	int minor;
	u32 flags;
	u32 field;
	u64 timestamp;
	u32 timecode_type;
	u32 timecode_flags;
	u8 timecode_frames;
	u8 timecode_seconds;
	u8 timecode_minutes;
	u8 timecode_hours;
	u8 timecode_userbits0;
	u8 timecode_userbits1;
	u8 timecode_userbits2;
	u8 timecode_userbits3;
	u32 sequence;
	char __data[0];
};

struct trace_event_data_offsets_v4l2_event_class {};

struct trace_event_data_offsets_vb2_v4l2_event_class {};

typedef void (*btf_trace_v4l2_dqbuf)(void *, int, struct v4l2_buffer *);

typedef void (*btf_trace_v4l2_qbuf)(void *, int, struct v4l2_buffer *);

typedef void (*btf_trace_vb2_v4l2_buf_done)(void *, struct vb2_queue *, struct vb2_buffer *);

typedef void (*btf_trace_vb2_v4l2_buf_queue)(void *, struct vb2_queue *, struct vb2_buffer *);

typedef void (*btf_trace_vb2_v4l2_dqbuf)(void *, struct vb2_queue *, struct vb2_buffer *);

typedef void (*btf_trace_vb2_v4l2_qbuf)(void *, struct vb2_queue *, struct vb2_buffer *);

enum v4l2_i2c_tuner_type {
	ADDRS_RADIO = 0,
	ADDRS_DEMOD = 1,
	ADDRS_TV = 2,
	ADDRS_TV_WITH_DEMOD = 3,
};

enum v4l2_xfer_func {
	V4L2_XFER_FUNC_DEFAULT = 0,
	V4L2_XFER_FUNC_709 = 1,
	V4L2_XFER_FUNC_SRGB = 2,
	V4L2_XFER_FUNC_OPRGB = 3,
	V4L2_XFER_FUNC_SMPTE240M = 4,
	V4L2_XFER_FUNC_NONE = 5,
	V4L2_XFER_FUNC_DCI_P3 = 6,
	V4L2_XFER_FUNC_SMPTE2084 = 7,
};

enum v4l2_quantization {
	V4L2_QUANTIZATION_DEFAULT = 0,
	V4L2_QUANTIZATION_FULL_RANGE = 1,
	V4L2_QUANTIZATION_LIM_RANGE = 2,
};

typedef bool v4l2_check_dv_timings_fnc(const struct v4l2_dv_timings *, void *);

struct v4l2_hdmi_colorimetry {
	enum v4l2_colorspace colorspace;
	enum v4l2_ycbcr_encoding ycbcr_enc;
	enum v4l2_quantization quantization;
	enum v4l2_xfer_func xfer_func;
};

enum vb2_memory {
	VB2_MEMORY_UNKNOWN = 0,
	VB2_MEMORY_MMAP = 1,
	VB2_MEMORY_USERPTR = 2,
	VB2_MEMORY_DMABUF = 4,
};

enum vb2_io_modes {
	VB2_MMAP = 1,
	VB2_USERPTR = 2,
	VB2_READ = 4,
	VB2_WRITE = 8,
	VB2_DMABUF = 16,
};

struct vb2_fileio_buf {
	void *vaddr;
	unsigned int size;
	unsigned int pos;
	unsigned int queued: 1;
};

struct vb2_fileio_data {
	unsigned int count;
	unsigned int type;
	unsigned int memory;
	struct vb2_fileio_buf bufs[64];
	unsigned int cur_index;
	unsigned int initial_index;
	unsigned int q_count;
	unsigned int dq_count;
	unsigned int read_once: 1;
	unsigned int write_immediately: 1;
};

typedef int (*vb2_thread_fnc)(struct vb2_buffer *, void *);

struct vb2_threadio_data {
	struct task_struct *thread;
	vb2_thread_fnc fnc;
	void *priv;
	bool stop;
};

struct trace_event_raw_vb2_event_class {
	struct trace_entry ent;
	void *owner;
	u32 queued_count;
	int owned_by_drv_count;
	u32 index;
	u32 type;
	u32 bytesused;
	u64 timestamp;
	char __data[0];
};

struct trace_event_data_offsets_vb2_event_class {};

typedef void (*btf_trace_vb2_buf_done)(void *, struct vb2_queue *, struct vb2_buffer *);

typedef void (*btf_trace_vb2_buf_queue)(void *, struct vb2_queue *, struct vb2_buffer *);

typedef void (*btf_trace_vb2_dqbuf)(void *, struct vb2_queue *, struct vb2_buffer *);

typedef void (*btf_trace_vb2_qbuf)(void *, struct vb2_queue *, struct vb2_buffer *);

struct vb2_vmarea_handler {
	refcount_t *refcount;
	void (*put)(void *);
	void *arg;
};

struct vb2_dc_buf {
	struct device *dev;
	void *vaddr;
	long unsigned int size;
	void *cookie;
	dma_addr_t dma_addr;
	long unsigned int attrs;
	enum dma_data_direction dma_dir;
	struct sg_table *dma_sgt;
	struct frame_vector *vec;
	struct vb2_vmarea_handler handler;
	refcount_t refcount;
	struct sg_table *sgt_base;
	struct dma_buf_attachment *db_attach;
};

struct vb2_dc_attachment {
	struct sg_table sgt;
	enum dma_data_direction dma_dir;
};

enum v4l2_jpeg_chroma_subsampling {
	V4L2_JPEG_CHROMA_SUBSAMPLING_444 = 0,
	V4L2_JPEG_CHROMA_SUBSAMPLING_422 = 1,
	V4L2_JPEG_CHROMA_SUBSAMPLING_420 = 2,
	V4L2_JPEG_CHROMA_SUBSAMPLING_411 = 3,
	V4L2_JPEG_CHROMA_SUBSAMPLING_410 = 4,
	V4L2_JPEG_CHROMA_SUBSAMPLING_GRAY = 5,
};

enum {
	VIDEO_MODE_DETECT_DONE = 0,
	VIDEO_RES_CHANGE = 1,
	VIDEO_RES_DETECT = 2,
	VIDEO_STREAMING = 3,
	VIDEO_FRAME_INPRG = 4,
	VIDEO_STOPPED = 5,
	VIDEO_CLOCKS_ON = 6,
};

struct aspeed_video_addr {
	unsigned int size;
	dma_addr_t dma;
	void *virt;
};

struct aspeed_video_buffer {
	struct vb2_v4l2_buffer vb;
	struct list_head link;
};

struct aspeed_video {
	void *base;
	struct clk *eclk;
	struct clk *vclk;
	struct device *dev;
	struct v4l2_ctrl_handler ctrl_handler;
	struct v4l2_device v4l2_dev;
	struct v4l2_pix_format pix_fmt;
	struct v4l2_bt_timings active_timings;
	struct v4l2_bt_timings detected_timings;
	u32 v4l2_input_status;
	int: 32;
	struct vb2_queue queue;
	struct video_device vdev;
	struct mutex video_lock;
	u32 jpeg_mode;
	u32 comp_size_read;
	wait_queue_head_t wait;
	spinlock_t lock;
	int: 32;
	struct delayed_work res_work;
	struct list_head buffers;
	long unsigned int flags;
	unsigned int sequence;
	unsigned int max_compressed_size;
	struct aspeed_video_addr srcs[2];
	struct aspeed_video_addr jpeg;
	bool yuv420;
	int: 24;
	unsigned int frame_rate;
	unsigned int jpeg_quality;
	unsigned int frame_bottom;
	unsigned int frame_left;
	unsigned int frame_right;
	unsigned int frame_top;
	int: 32;
} __attribute__((packed));

struct aspeed_video_config {
	u32 jpeg_mode;
	u32 comp_size_read;
};

enum power_supply_property {
	POWER_SUPPLY_PROP_STATUS = 0,
	POWER_SUPPLY_PROP_CHARGE_TYPE = 1,
	POWER_SUPPLY_PROP_HEALTH = 2,
	POWER_SUPPLY_PROP_PRESENT = 3,
	POWER_SUPPLY_PROP_ONLINE = 4,
	POWER_SUPPLY_PROP_AUTHENTIC = 5,
	POWER_SUPPLY_PROP_TECHNOLOGY = 6,
	POWER_SUPPLY_PROP_CYCLE_COUNT = 7,
	POWER_SUPPLY_PROP_VOLTAGE_MAX = 8,
	POWER_SUPPLY_PROP_VOLTAGE_MIN = 9,
	POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN = 10,
	POWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN = 11,
	POWER_SUPPLY_PROP_VOLTAGE_NOW = 12,
	POWER_SUPPLY_PROP_VOLTAGE_AVG = 13,
	POWER_SUPPLY_PROP_VOLTAGE_OCV = 14,
	POWER_SUPPLY_PROP_VOLTAGE_BOOT = 15,
	POWER_SUPPLY_PROP_CURRENT_MAX = 16,
	POWER_SUPPLY_PROP_CURRENT_NOW = 17,
	POWER_SUPPLY_PROP_CURRENT_AVG = 18,
	POWER_SUPPLY_PROP_CURRENT_BOOT = 19,
	POWER_SUPPLY_PROP_POWER_NOW = 20,
	POWER_SUPPLY_PROP_POWER_AVG = 21,
	POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN = 22,
	POWER_SUPPLY_PROP_CHARGE_EMPTY_DESIGN = 23,
	POWER_SUPPLY_PROP_CHARGE_FULL = 24,
	POWER_SUPPLY_PROP_CHARGE_EMPTY = 25,
	POWER_SUPPLY_PROP_CHARGE_NOW = 26,
	POWER_SUPPLY_PROP_CHARGE_AVG = 27,
	POWER_SUPPLY_PROP_CHARGE_COUNTER = 28,
	POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT = 29,
	POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT_MAX = 30,
	POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE = 31,
	POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE_MAX = 32,
	POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT = 33,
	POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT_MAX = 34,
	POWER_SUPPLY_PROP_CHARGE_CONTROL_START_THRESHOLD = 35,
	POWER_SUPPLY_PROP_CHARGE_CONTROL_END_THRESHOLD = 36,
	POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT = 37,
	POWER_SUPPLY_PROP_INPUT_VOLTAGE_LIMIT = 38,
	POWER_SUPPLY_PROP_INPUT_POWER_LIMIT = 39,
	POWER_SUPPLY_PROP_ENERGY_FULL_DESIGN = 40,
	POWER_SUPPLY_PROP_ENERGY_EMPTY_DESIGN = 41,
	POWER_SUPPLY_PROP_ENERGY_FULL = 42,
	POWER_SUPPLY_PROP_ENERGY_EMPTY = 43,
	POWER_SUPPLY_PROP_ENERGY_NOW = 44,
	POWER_SUPPLY_PROP_ENERGY_AVG = 45,
	POWER_SUPPLY_PROP_CAPACITY = 46,
	POWER_SUPPLY_PROP_CAPACITY_ALERT_MIN = 47,
	POWER_SUPPLY_PROP_CAPACITY_ALERT_MAX = 48,
	POWER_SUPPLY_PROP_CAPACITY_ERROR_MARGIN = 49,
	POWER_SUPPLY_PROP_CAPACITY_LEVEL = 50,
	POWER_SUPPLY_PROP_TEMP = 51,
	POWER_SUPPLY_PROP_TEMP_MAX = 52,
	POWER_SUPPLY_PROP_TEMP_MIN = 53,
	POWER_SUPPLY_PROP_TEMP_ALERT_MIN = 54,
	POWER_SUPPLY_PROP_TEMP_ALERT_MAX = 55,
	POWER_SUPPLY_PROP_TEMP_AMBIENT = 56,
	POWER_SUPPLY_PROP_TEMP_AMBIENT_ALERT_MIN = 57,
	POWER_SUPPLY_PROP_TEMP_AMBIENT_ALERT_MAX = 58,
	POWER_SUPPLY_PROP_TIME_TO_EMPTY_NOW = 59,
	POWER_SUPPLY_PROP_TIME_TO_EMPTY_AVG = 60,
	POWER_SUPPLY_PROP_TIME_TO_FULL_NOW = 61,
	POWER_SUPPLY_PROP_TIME_TO_FULL_AVG = 62,
	POWER_SUPPLY_PROP_TYPE = 63,
	POWER_SUPPLY_PROP_USB_TYPE = 64,
	POWER_SUPPLY_PROP_SCOPE = 65,
	POWER_SUPPLY_PROP_PRECHARGE_CURRENT = 66,
	POWER_SUPPLY_PROP_CHARGE_TERM_CURRENT = 67,
	POWER_SUPPLY_PROP_CALIBRATE = 68,
	POWER_SUPPLY_PROP_MANUFACTURE_YEAR = 69,
	POWER_SUPPLY_PROP_MANUFACTURE_MONTH = 70,
	POWER_SUPPLY_PROP_MANUFACTURE_DAY = 71,
	POWER_SUPPLY_PROP_MODEL_NAME = 72,
	POWER_SUPPLY_PROP_MANUFACTURER = 73,
	POWER_SUPPLY_PROP_SERIAL_NUMBER = 74,
};

enum power_supply_type {
	POWER_SUPPLY_TYPE_UNKNOWN = 0,
	POWER_SUPPLY_TYPE_BATTERY = 1,
	POWER_SUPPLY_TYPE_UPS = 2,
	POWER_SUPPLY_TYPE_MAINS = 3,
	POWER_SUPPLY_TYPE_USB = 4,
	POWER_SUPPLY_TYPE_USB_DCP = 5,
	POWER_SUPPLY_TYPE_USB_CDP = 6,
	POWER_SUPPLY_TYPE_USB_ACA = 7,
	POWER_SUPPLY_TYPE_USB_TYPE_C = 8,
	POWER_SUPPLY_TYPE_USB_PD = 9,
	POWER_SUPPLY_TYPE_USB_PD_DRP = 10,
	POWER_SUPPLY_TYPE_APPLE_BRICK_ID = 11,
	POWER_SUPPLY_TYPE_WIRELESS = 12,
};

enum power_supply_usb_type {
	POWER_SUPPLY_USB_TYPE_UNKNOWN = 0,
	POWER_SUPPLY_USB_TYPE_SDP = 1,
	POWER_SUPPLY_USB_TYPE_DCP = 2,
	POWER_SUPPLY_USB_TYPE_CDP = 3,
	POWER_SUPPLY_USB_TYPE_ACA = 4,
	POWER_SUPPLY_USB_TYPE_C = 5,
	POWER_SUPPLY_USB_TYPE_PD = 6,
	POWER_SUPPLY_USB_TYPE_PD_DRP = 7,
	POWER_SUPPLY_USB_TYPE_PD_PPS = 8,
	POWER_SUPPLY_USB_TYPE_APPLE_BRICK_ID = 9,
};

enum power_supply_notifier_events {
	PSY_EVENT_PROP_CHANGED = 0,
};

union power_supply_propval {
	int intval;
	const char *strval;
};

struct power_supply_config {
	struct device_node *of_node;
	struct fwnode_handle *fwnode;
	void *drv_data;
	const struct attribute_group **attr_grp;
	char **supplied_to;
	size_t num_supplicants;
};

struct power_supply;

struct power_supply_desc {
	const char *name;
	enum power_supply_type type;
	const enum power_supply_usb_type *usb_types;
	size_t num_usb_types;
	const enum power_supply_property *properties;
	size_t num_properties;
	int (*get_property)(struct power_supply *, enum power_supply_property, union power_supply_propval *);
	int (*set_property)(struct power_supply *, enum power_supply_property, const union power_supply_propval *);
	int (*property_is_writeable)(struct power_supply *, enum power_supply_property);
	void (*external_power_changed)(struct power_supply *);
	void (*set_charged)(struct power_supply *);
	bool no_thermal;
	int use_for_apm;
};

struct thermal_zone_device;

struct power_supply {
	const struct power_supply_desc *desc;
	char **supplied_to;
	size_t num_supplicants;
	char **supplied_from;
	size_t num_supplies;
	struct device_node *of_node;
	void *drv_data;
	struct device dev;
	struct work_struct changed_work;
	struct delayed_work deferred_register_work;
	spinlock_t changed_lock;
	bool changed;
	bool initialized;
	bool removing;
	atomic_t use_cnt;
	struct thermal_zone_device *tzd;
	struct thermal_cooling_device *tcd;
};

enum thermal_device_mode {
	THERMAL_DEVICE_DISABLED = 0,
	THERMAL_DEVICE_ENABLED = 1,
};

enum thermal_notify_event {
	THERMAL_EVENT_UNSPECIFIED = 0,
	THERMAL_EVENT_TEMP_SAMPLE = 1,
	THERMAL_TRIP_VIOLATED = 2,
	THERMAL_TRIP_CHANGED = 3,
	THERMAL_DEVICE_DOWN = 4,
	THERMAL_DEVICE_UP = 5,
	THERMAL_DEVICE_POWER_CAPABILITY_CHANGED = 6,
	THERMAL_TABLE_CHANGED = 7,
	THERMAL_EVENT_KEEP_ALIVE = 8,
};

struct thermal_attr;

struct thermal_zone_device_ops;

struct thermal_zone_params;

struct thermal_governor;

struct thermal_zone_device {
	int id;
	char type[20];
	struct device device;
	struct attribute_group trips_attribute_group;
	struct thermal_attr *trip_temp_attrs;
	struct thermal_attr *trip_type_attrs;
	struct thermal_attr *trip_hyst_attrs;
	enum thermal_device_mode mode;
	void *devdata;
	int trips;
	long unsigned int trips_disabled;
	int passive_delay;
	int polling_delay;
	int temperature;
	int last_temperature;
	int emul_temperature;
	int passive;
	int prev_low_trip;
	int prev_high_trip;
	unsigned int forced_passive;
	atomic_t need_update;
	struct thermal_zone_device_ops *ops;
	struct thermal_zone_params *tzp;
	struct thermal_governor *governor;
	void *governor_data;
	struct list_head thermal_instances;
	struct ida ida;
	struct mutex lock;
	struct list_head node;
	struct delayed_work poll_queue;
	enum thermal_notify_event notify_event;
};

struct thermal_cooling_device_ops;

struct thermal_cooling_device {
	int id;
	char type[20];
	struct device device;
	struct device_node *np;
	void *devdata;
	void *stats;
	const struct thermal_cooling_device_ops *ops;
	bool updated;
	struct mutex lock;
	struct list_head thermal_instances;
	struct list_head node;
};

struct power_supply_battery_ocv_table {
	int ocv;
	int capacity;
};

struct power_supply_resistance_temp_table {
	int temp;
	int resistance;
};

struct power_supply_battery_info {
	int energy_full_design_uwh;
	int charge_full_design_uah;
	int voltage_min_design_uv;
	int voltage_max_design_uv;
	int tricklecharge_current_ua;
	int precharge_current_ua;
	int precharge_voltage_max_uv;
	int charge_term_current_ua;
	int charge_restart_voltage_uv;
	int overvoltage_limit_uv;
	int constant_charge_current_max_ua;
	int constant_charge_voltage_max_uv;
	int factory_internal_resistance_uohm;
	int ocv_temp[20];
	int temp_ambient_alert_min;
	int temp_ambient_alert_max;
	int temp_alert_min;
	int temp_alert_max;
	int temp_min;
	int temp_max;
	struct power_supply_battery_ocv_table *ocv_table[20];
	int ocv_table_size[20];
	struct power_supply_resistance_temp_table *resist_table;
	int resist_table_size;
};

enum thermal_trip_type {
	THERMAL_TRIP_ACTIVE = 0,
	THERMAL_TRIP_PASSIVE = 1,
	THERMAL_TRIP_HOT = 2,
	THERMAL_TRIP_CRITICAL = 3,
};

enum thermal_trend {
	THERMAL_TREND_STABLE = 0,
	THERMAL_TREND_RAISING = 1,
	THERMAL_TREND_DROPPING = 2,
	THERMAL_TREND_RAISE_FULL = 3,
	THERMAL_TREND_DROP_FULL = 4,
};

struct thermal_zone_device_ops {
	int (*bind)(struct thermal_zone_device *, struct thermal_cooling_device *);
	int (*unbind)(struct thermal_zone_device *, struct thermal_cooling_device *);
	int (*get_temp)(struct thermal_zone_device *, int *);
	int (*set_trips)(struct thermal_zone_device *, int, int);
	int (*change_mode)(struct thermal_zone_device *, enum thermal_device_mode);
	int (*get_trip_type)(struct thermal_zone_device *, int, enum thermal_trip_type *);
	int (*get_trip_temp)(struct thermal_zone_device *, int, int *);
	int (*set_trip_temp)(struct thermal_zone_device *, int, int);
	int (*get_trip_hyst)(struct thermal_zone_device *, int, int *);
	int (*set_trip_hyst)(struct thermal_zone_device *, int, int);
	int (*get_crit_temp)(struct thermal_zone_device *, int *);
	int (*set_emul_temp)(struct thermal_zone_device *, int);
	int (*get_trend)(struct thermal_zone_device *, int, enum thermal_trend *);
	int (*notify)(struct thermal_zone_device *, int, enum thermal_trip_type);
};

struct thermal_cooling_device_ops {
	int (*get_max_state)(struct thermal_cooling_device *, long unsigned int *);
	int (*get_cur_state)(struct thermal_cooling_device *, long unsigned int *);
	int (*set_cur_state)(struct thermal_cooling_device *, long unsigned int);
	int (*get_requested_power)(struct thermal_cooling_device *, u32 *);
	int (*state2power)(struct thermal_cooling_device *, long unsigned int, u32 *);
	int (*power2state)(struct thermal_cooling_device *, u32, long unsigned int *);
};

struct thermal_bind_params;

struct thermal_zone_params {
	char governor_name[20];
	bool no_hwmon;
	int num_tbps;
	struct thermal_bind_params *tbp;
	u32 sustainable_power;
	s32 k_po;
	s32 k_pu;
	s32 k_i;
	s32 k_d;
	s32 integral_cutoff;
	int slope;
	int offset;
};

struct thermal_governor {
	char name[20];
	int (*bind_to_tz)(struct thermal_zone_device *);
	void (*unbind_from_tz)(struct thermal_zone_device *);
	int (*throttle)(struct thermal_zone_device *, int);
	struct list_head governor_list;
};

struct thermal_bind_params {
	struct thermal_cooling_device *cdev;
	int weight;
	int trip_mask;
	long unsigned int *binding_limits;
	int (*match)(struct thermal_zone_device *, struct thermal_cooling_device *);
};

struct match_device_node_array_param {
	struct device_node *parent_of_node;
	struct power_supply **psy;
	ssize_t psy_size;
	ssize_t psy_count;
};

struct psy_am_i_supplied_data {
	struct power_supply *psy;
	unsigned int count;
};

enum {
	POWER_SUPPLY_STATUS_UNKNOWN = 0,
	POWER_SUPPLY_STATUS_CHARGING = 1,
	POWER_SUPPLY_STATUS_DISCHARGING = 2,
	POWER_SUPPLY_STATUS_NOT_CHARGING = 3,
	POWER_SUPPLY_STATUS_FULL = 4,
};

enum {
	POWER_SUPPLY_CHARGE_TYPE_UNKNOWN = 0,
	POWER_SUPPLY_CHARGE_TYPE_NONE = 1,
	POWER_SUPPLY_CHARGE_TYPE_TRICKLE = 2,
	POWER_SUPPLY_CHARGE_TYPE_FAST = 3,
	POWER_SUPPLY_CHARGE_TYPE_STANDARD = 4,
	POWER_SUPPLY_CHARGE_TYPE_ADAPTIVE = 5,
	POWER_SUPPLY_CHARGE_TYPE_CUSTOM = 6,
	POWER_SUPPLY_CHARGE_TYPE_LONGLIFE = 7,
	POWER_SUPPLY_CHARGE_TYPE_TAPER = 50,
};

enum {
	POWER_SUPPLY_HEALTH_UNKNOWN = 0,
	POWER_SUPPLY_HEALTH_GOOD = 1,
	POWER_SUPPLY_HEALTH_OVERHEAT = 2,
	POWER_SUPPLY_HEALTH_DEAD = 3,
	POWER_SUPPLY_HEALTH_OVERVOLTAGE = 4,
	POWER_SUPPLY_HEALTH_UNSPEC_FAILURE = 5,
	POWER_SUPPLY_HEALTH_COLD = 6,
	POWER_SUPPLY_HEALTH_WATCHDOG_TIMER_EXPIRE = 7,
	POWER_SUPPLY_HEALTH_SAFETY_TIMER_EXPIRE = 8,
	POWER_SUPPLY_HEALTH_OVERCURRENT = 9,
	POWER_SUPPLY_HEALTH_CALIBRATION_REQUIRED = 10,
	POWER_SUPPLY_HEALTH_WARM = 11,
	POWER_SUPPLY_HEALTH_COOL = 12,
	POWER_SUPPLY_HEALTH_HOT = 13,
};

enum {
	POWER_SUPPLY_TECHNOLOGY_UNKNOWN = 0,
	POWER_SUPPLY_TECHNOLOGY_NiMH = 1,
	POWER_SUPPLY_TECHNOLOGY_LION = 2,
	POWER_SUPPLY_TECHNOLOGY_LIPO = 3,
	POWER_SUPPLY_TECHNOLOGY_LiFe = 4,
	POWER_SUPPLY_TECHNOLOGY_NiCd = 5,
	POWER_SUPPLY_TECHNOLOGY_LiMn = 6,
};

enum {
	POWER_SUPPLY_CAPACITY_LEVEL_UNKNOWN = 0,
	POWER_SUPPLY_CAPACITY_LEVEL_CRITICAL = 1,
	POWER_SUPPLY_CAPACITY_LEVEL_LOW = 2,
	POWER_SUPPLY_CAPACITY_LEVEL_NORMAL = 3,
	POWER_SUPPLY_CAPACITY_LEVEL_HIGH = 4,
	POWER_SUPPLY_CAPACITY_LEVEL_FULL = 5,
};

enum {
	POWER_SUPPLY_SCOPE_UNKNOWN = 0,
	POWER_SUPPLY_SCOPE_SYSTEM = 1,
	POWER_SUPPLY_SCOPE_DEVICE = 2,
};

struct power_supply_attr {
	const char *prop_name;
	char attr_name[31];
	struct device_attribute dev_attr;
	const char * const *text_values;
	int text_values_len;
};

enum hwmon_sensor_types {
	hwmon_chip = 0,
	hwmon_temp = 1,
	hwmon_in = 2,
	hwmon_curr = 3,
	hwmon_power = 4,
	hwmon_energy = 5,
	hwmon_humidity = 6,
	hwmon_fan = 7,
	hwmon_pwm = 8,
	hwmon_intrusion = 9,
	hwmon_max = 10,
};

enum hwmon_temp_attributes {
	hwmon_temp_enable = 0,
	hwmon_temp_input = 1,
	hwmon_temp_type = 2,
	hwmon_temp_lcrit = 3,
	hwmon_temp_lcrit_hyst = 4,
	hwmon_temp_min = 5,
	hwmon_temp_min_hyst = 6,
	hwmon_temp_max = 7,
	hwmon_temp_max_hyst = 8,
	hwmon_temp_crit = 9,
	hwmon_temp_crit_hyst = 10,
	hwmon_temp_emergency = 11,
	hwmon_temp_emergency_hyst = 12,
	hwmon_temp_alarm = 13,
	hwmon_temp_lcrit_alarm = 14,
	hwmon_temp_min_alarm = 15,
	hwmon_temp_max_alarm = 16,
	hwmon_temp_crit_alarm = 17,
	hwmon_temp_emergency_alarm = 18,
	hwmon_temp_fault = 19,
	hwmon_temp_offset = 20,
	hwmon_temp_label = 21,
	hwmon_temp_lowest = 22,
	hwmon_temp_highest = 23,
	hwmon_temp_reset_history = 24,
	hwmon_temp_rated_min = 25,
	hwmon_temp_rated_max = 26,
};

enum hwmon_in_attributes {
	hwmon_in_enable = 0,
	hwmon_in_input = 1,
	hwmon_in_min = 2,
	hwmon_in_max = 3,
	hwmon_in_lcrit = 4,
	hwmon_in_crit = 5,
	hwmon_in_average = 6,
	hwmon_in_lowest = 7,
	hwmon_in_highest = 8,
	hwmon_in_reset_history = 9,
	hwmon_in_label = 10,
	hwmon_in_alarm = 11,
	hwmon_in_min_alarm = 12,
	hwmon_in_max_alarm = 13,
	hwmon_in_lcrit_alarm = 14,
	hwmon_in_crit_alarm = 15,
	hwmon_in_rated_min = 16,
	hwmon_in_rated_max = 17,
};

enum hwmon_curr_attributes {
	hwmon_curr_enable = 0,
	hwmon_curr_input = 1,
	hwmon_curr_min = 2,
	hwmon_curr_max = 3,
	hwmon_curr_lcrit = 4,
	hwmon_curr_crit = 5,
	hwmon_curr_average = 6,
	hwmon_curr_lowest = 7,
	hwmon_curr_highest = 8,
	hwmon_curr_reset_history = 9,
	hwmon_curr_label = 10,
	hwmon_curr_alarm = 11,
	hwmon_curr_min_alarm = 12,
	hwmon_curr_max_alarm = 13,
	hwmon_curr_lcrit_alarm = 14,
	hwmon_curr_crit_alarm = 15,
	hwmon_curr_rated_min = 16,
	hwmon_curr_rated_max = 17,
};

struct hwmon_ops {
	umode_t (*is_visible)(const void *, enum hwmon_sensor_types, u32, int);
	int (*read)(struct device *, enum hwmon_sensor_types, u32, int, long int *);
	int (*read_string)(struct device *, enum hwmon_sensor_types, u32, int, const char **);
	int (*write)(struct device *, enum hwmon_sensor_types, u32, int, long int);
};

struct hwmon_channel_info {
	enum hwmon_sensor_types type;
	const u32 *config;
};

struct hwmon_chip_info {
	const struct hwmon_ops *ops;
	const struct hwmon_channel_info **info;
};

struct power_supply_hwmon {
	struct power_supply *psy;
	long unsigned int *props;
};

struct hwmon_type_attr_list {
	const u32 *attrs;
	size_t n_attrs;
};

enum hwmon_chip_attributes {
	hwmon_chip_temp_reset_history = 0,
	hwmon_chip_in_reset_history = 1,
	hwmon_chip_curr_reset_history = 2,
	hwmon_chip_power_reset_history = 3,
	hwmon_chip_register_tz = 4,
	hwmon_chip_update_interval = 5,
	hwmon_chip_alarms = 6,
	hwmon_chip_samples = 7,
	hwmon_chip_curr_samples = 8,
	hwmon_chip_in_samples = 9,
	hwmon_chip_power_samples = 10,
	hwmon_chip_temp_samples = 11,
};

enum hwmon_power_attributes {
	hwmon_power_enable = 0,
	hwmon_power_average = 1,
	hwmon_power_average_interval = 2,
	hwmon_power_average_interval_max = 3,
	hwmon_power_average_interval_min = 4,
	hwmon_power_average_highest = 5,
	hwmon_power_average_lowest = 6,
	hwmon_power_average_max = 7,
	hwmon_power_average_min = 8,
	hwmon_power_input = 9,
	hwmon_power_input_highest = 10,
	hwmon_power_input_lowest = 11,
	hwmon_power_reset_history = 12,
	hwmon_power_accuracy = 13,
	hwmon_power_cap = 14,
	hwmon_power_cap_hyst = 15,
	hwmon_power_cap_max = 16,
	hwmon_power_cap_min = 17,
	hwmon_power_min = 18,
	hwmon_power_max = 19,
	hwmon_power_crit = 20,
	hwmon_power_lcrit = 21,
	hwmon_power_label = 22,
	hwmon_power_alarm = 23,
	hwmon_power_cap_alarm = 24,
	hwmon_power_min_alarm = 25,
	hwmon_power_max_alarm = 26,
	hwmon_power_lcrit_alarm = 27,
	hwmon_power_crit_alarm = 28,
	hwmon_power_rated_min = 29,
	hwmon_power_rated_max = 30,
};

enum hwmon_energy_attributes {
	hwmon_energy_enable = 0,
	hwmon_energy_input = 1,
	hwmon_energy_label = 2,
};

enum hwmon_humidity_attributes {
	hwmon_humidity_enable = 0,
	hwmon_humidity_input = 1,
	hwmon_humidity_label = 2,
	hwmon_humidity_min = 3,
	hwmon_humidity_min_hyst = 4,
	hwmon_humidity_max = 5,
	hwmon_humidity_max_hyst = 6,
	hwmon_humidity_alarm = 7,
	hwmon_humidity_fault = 8,
	hwmon_humidity_rated_min = 9,
	hwmon_humidity_rated_max = 10,
};

enum hwmon_fan_attributes {
	hwmon_fan_enable = 0,
	hwmon_fan_input = 1,
	hwmon_fan_label = 2,
	hwmon_fan_min = 3,
	hwmon_fan_max = 4,
	hwmon_fan_div = 5,
	hwmon_fan_pulses = 6,
	hwmon_fan_target = 7,
	hwmon_fan_alarm = 8,
	hwmon_fan_min_alarm = 9,
	hwmon_fan_max_alarm = 10,
	hwmon_fan_fault = 11,
};

enum hwmon_pwm_attributes {
	hwmon_pwm_input = 0,
	hwmon_pwm_enable = 1,
	hwmon_pwm_mode = 2,
	hwmon_pwm_freq = 3,
};

enum hwmon_intrusion_attributes {
	hwmon_intrusion_alarm = 0,
	hwmon_intrusion_beep = 1,
};

struct thermal_zone_of_device_ops {
	int (*get_temp)(void *, int *);
	int (*get_trend)(void *, int, enum thermal_trend *);
	int (*set_trips)(void *, int, int);
	int (*set_emul_temp)(void *, int);
	int (*set_trip_temp)(void *, int, int);
};

struct trace_event_raw_hwmon_attr_class {
	struct trace_entry ent;
	int index;
	u32 __data_loc_attr_name;
	long int val;
	char __data[0];
};

struct trace_event_raw_hwmon_attr_show_string {
	struct trace_entry ent;
	int index;
	u32 __data_loc_attr_name;
	u32 __data_loc_label;
	char __data[0];
};

struct trace_event_data_offsets_hwmon_attr_class {
	u32 attr_name;
};

struct trace_event_data_offsets_hwmon_attr_show_string {
	u32 attr_name;
	u32 label;
};

typedef void (*btf_trace_hwmon_attr_show)(void *, int, const char *, long int);

typedef void (*btf_trace_hwmon_attr_store)(void *, int, const char *, long int);

typedef void (*btf_trace_hwmon_attr_show_string)(void *, int, const char *, const char *);

struct hwmon_device {
	const char *name;
	struct device dev;
	const struct hwmon_chip_info *chip;
	struct list_head tzdata;
	struct attribute_group group;
	const struct attribute_group **groups;
};

struct hwmon_device_attribute {
	struct device_attribute dev_attr;
	const struct hwmon_ops *ops;
	enum hwmon_sensor_types type;
	u32 attr;
	int index;
	char name[32];
};

struct hwmon_thermal_data {
	struct list_head node;
	struct device *dev;
	int index;
	struct thermal_zone_device *tzd;
};

struct pvt_device {
	struct regmap *c_map;
	struct regmap *t_map;
	struct regmap *p_map;
	struct regmap *v_map;
	struct clk *clk;
	struct reset_control *rst;
	u32 t_num;
	u32 p_num;
	u32 v_num;
	u32 ip_freq;
	u8 *vm_idx;
};

struct thermal_attr {
	struct device_attribute attr;
	char name[20];
};

struct trace_event_raw_thermal_temperature {
	struct trace_entry ent;
	u32 __data_loc_thermal_zone;
	int id;
	int temp_prev;
	int temp;
	char __data[0];
};

struct trace_event_raw_cdev_update {
	struct trace_entry ent;
	u32 __data_loc_type;
	long unsigned int target;
	char __data[0];
};

struct trace_event_raw_thermal_zone_trip {
	struct trace_entry ent;
	u32 __data_loc_thermal_zone;
	int id;
	int trip;
	enum thermal_trip_type trip_type;
	char __data[0];
};

struct trace_event_raw_thermal_power_cpu_get_power {
	struct trace_entry ent;
	u32 __data_loc_cpumask;
	long unsigned int freq;
	u32 __data_loc_load;
	size_t load_len;
	u32 dynamic_power;
	char __data[0];
};

struct trace_event_raw_thermal_power_cpu_limit {
	struct trace_entry ent;
	u32 __data_loc_cpumask;
	unsigned int freq;
	long unsigned int cdev_state;
	u32 power;
	char __data[0];
};

struct trace_event_data_offsets_thermal_temperature {
	u32 thermal_zone;
};

struct trace_event_data_offsets_cdev_update {
	u32 type;
};

struct trace_event_data_offsets_thermal_zone_trip {
	u32 thermal_zone;
};

struct trace_event_data_offsets_thermal_power_cpu_get_power {
	u32 cpumask;
	u32 load;
};

struct trace_event_data_offsets_thermal_power_cpu_limit {
	u32 cpumask;
};

typedef void (*btf_trace_thermal_temperature)(void *, struct thermal_zone_device *);

typedef void (*btf_trace_cdev_update)(void *, struct thermal_cooling_device *, long unsigned int);

typedef void (*btf_trace_thermal_zone_trip)(void *, struct thermal_zone_device *, int, enum thermal_trip_type);

typedef void (*btf_trace_thermal_power_cpu_get_power)(void *, const struct cpumask *, long unsigned int, u32 *, size_t, u32);

typedef void (*btf_trace_thermal_power_cpu_limit)(void *, const struct cpumask *, unsigned int, long unsigned int, u32);

struct thermal_instance {
	int id;
	char name[20];
	struct thermal_zone_device *tz;
	struct thermal_cooling_device *cdev;
	int trip;
	bool initialized;
	long unsigned int upper;
	long unsigned int lower;
	long unsigned int target;
	char attr_name[20];
	struct device_attribute attr;
	char weight_attr_name[20];
	struct device_attribute weight_attr;
	struct list_head tz_node;
	struct list_head cdev_node;
	unsigned int weight;
};

struct thermal_hwmon_device {
	char type[20];
	struct device *device;
	int count;
	struct list_head tz_list;
	struct list_head node;
};

struct thermal_hwmon_attr {
	struct device_attribute attr;
	char name[16];
};

struct thermal_hwmon_temp {
	struct list_head hwmon_node;
	struct thermal_zone_device *tz;
	struct thermal_hwmon_attr temp_input;
	struct thermal_hwmon_attr temp_crit;
};

struct thermal_trip {
	struct device_node *np;
	int temperature;
	int hysteresis;
	enum thermal_trip_type type;
};

struct __thermal_cooling_bind_param {
	struct device_node *cooling_device;
	long unsigned int min;
	long unsigned int max;
};

struct __thermal_bind_params {
	struct __thermal_cooling_bind_param *tcbp;
	unsigned int count;
	unsigned int trip_id;
	unsigned int usage;
};

struct __thermal_zone {
	int passive_delay;
	int polling_delay;
	int slope;
	int offset;
	int ntrips;
	struct thermal_trip *trips;
	int num_tbps;
	struct __thermal_bind_params *tbps;
	void *sensor_data;
	const struct thermal_zone_of_device_ops *ops;
};

struct time_in_idle {
	u64 time;
	u64 timestamp;
};

struct cpufreq_cooling_device {
	int id;
	u32 last_load;
	unsigned int cpufreq_state;
	unsigned int max_level;
	struct em_perf_domain *em;
	struct cpufreq_policy *policy;
	struct list_head node;
	struct time_in_idle *idle_time;
	struct freq_qos_request qos_req;
};

struct watchdog_info {
	__u32 options;
	__u32 firmware_version;
	__u8 identity[32];
};

struct watchdog_device;

struct watchdog_ops {
	struct module *owner;
	int (*start)(struct watchdog_device *);
	int (*stop)(struct watchdog_device *);
	int (*ping)(struct watchdog_device *);
	unsigned int (*status)(struct watchdog_device *);
	int (*set_timeout)(struct watchdog_device *, unsigned int);
	int (*set_pretimeout)(struct watchdog_device *, unsigned int);
	unsigned int (*get_timeleft)(struct watchdog_device *);
	int (*restart)(struct watchdog_device *, long unsigned int, void *);
	long int (*ioctl)(struct watchdog_device *, unsigned int, long unsigned int);
};

struct watchdog_governor;

struct watchdog_core_data;

struct watchdog_device {
	int id;
	struct device *parent;
	const struct attribute_group **groups;
	const struct watchdog_info *info;
	const struct watchdog_ops *ops;
	const struct watchdog_governor *gov;
	unsigned int bootstatus;
	unsigned int timeout;
	unsigned int pretimeout;
	unsigned int min_timeout;
	unsigned int max_timeout;
	unsigned int min_hw_heartbeat_ms;
	unsigned int max_hw_heartbeat_ms;
	struct notifier_block reboot_nb;
	struct notifier_block restart_nb;
	void *driver_data;
	struct watchdog_core_data *wd_data;
	long unsigned int status;
	struct list_head deferred;
};

struct watchdog_governor {
	const char name[20];
	void (*pretimeout)(struct watchdog_device *);
};

struct watchdog_core_data {
	struct device dev;
	struct cdev cdev;
	struct watchdog_device *wdd;
	struct mutex lock;
	ktime_t last_keepalive;
	ktime_t last_hw_keepalive;
	ktime_t open_deadline;
	struct hrtimer timer;
	struct kthread_work work;
	long unsigned int status;
};

struct watchdog_pretimeout {
	struct watchdog_device *wdd;
	struct list_head entry;
};

struct governor_priv {
	struct watchdog_governor *gov;
	struct list_head entry;
};

enum dw_wdt_rmod {
	DW_WDT_RMOD_RESET = 1,
	DW_WDT_RMOD_IRQ = 2,
};

struct dw_wdt_timeout {
	u32 top_val;
	unsigned int sec;
	unsigned int msec;
};

struct dw_wdt {
	void *regs;
	struct clk *clk;
	struct clk *pclk;
	long unsigned int rate;
	enum dw_wdt_rmod rmod;
	struct dw_wdt_timeout timeouts[16];
	struct watchdog_device wdd;
	struct reset_control *rst;
	u32 control;
	u32 timeout;
	struct dentry *dbgfs_dir;
};

struct ice_wdt_dev {
	struct watchdog_device wdt_dev;
	void *wdt_base;
};

struct light_aon_msg_wdg_ctrl {
	struct light_aon_rpc_msg_hdr hdr;
	u32 timeout;
	u32 running_state;
	u32 reserved[4];
};

struct light_wdt_device {
	struct device *dev;
	struct light_aon_ipc *ipc_handle;
	struct light_aon_msg_wdg_ctrl msg;
	unsigned int is_aon_wdt_ena;
};

typedef struct {
	__u8 b[6];
} bdaddr_t;

struct l2cap_chan;

struct l2cap_ctrl {
	u8 sframe: 1;
	u8 poll: 1;
	u8 final: 1;
	u8 fcs: 1;
	u8 sar: 2;
	u8 super: 2;
	u16 reqseq;
	u16 txseq;
	u8 retries;
	__le16 psm;
	bdaddr_t bdaddr;
	struct l2cap_chan *chan;
};

struct sco_ctrl {
	u8 pkt_status;
};

struct hci_dev;

typedef void (*hci_req_complete_t)(struct hci_dev *, u8, u16);

struct amp_assoc {
	__u16 len;
	__u16 offset;
	__u16 rem_len;
	__u16 len_so_far;
	__u8 data[672];
};

struct discovery_state {
	int type;
	enum {
		DISCOVERY_STOPPED = 0,
		DISCOVERY_STARTING = 1,
		DISCOVERY_FINDING = 2,
		DISCOVERY_RESOLVING = 3,
		DISCOVERY_STOPPING = 4,
	} state;
	struct list_head all;
	struct list_head unknown;
	struct list_head resolve;
	__u32 timestamp;
	bdaddr_t last_adv_addr;
	u8 last_adv_addr_type;
	s8 last_adv_rssi;
	u32 last_adv_flags;
	u8 last_adv_data[31];
	u8 last_adv_data_len;
	bool report_invalid_rssi;
	bool result_filtering;
	bool limited;
	s8 rssi;
	u16 uuid_count;
	u8 (*uuids)[16];
	long unsigned int scan_start;
	long unsigned int scan_duration;
};

enum suspended_state {
	BT_RUNNING = 0,
	BT_SUSPEND_DISCONNECT = 1,
	BT_SUSPEND_CONFIGURE_WAKE = 2,
};

struct hci_conn_hash {
	struct list_head list;
	unsigned int acl_num;
	unsigned int amp_num;
	unsigned int sco_num;
	unsigned int le_num;
	unsigned int le_num_slave;
};

struct hci_dev_stats {
	__u32 err_rx;
	__u32 err_tx;
	__u32 cmd_tx;
	__u32 evt_rx;
	__u32 acl_tx;
	__u32 acl_rx;
	__u32 sco_tx;
	__u32 sco_rx;
	__u32 byte_rx;
	__u32 byte_tx;
};

struct rfkill;

struct hci_dev {
	struct list_head list;
	struct mutex lock;
	char name[8];
	long unsigned int flags;
	__u16 id;
	__u8 bus;
	__u8 dev_type;
	bdaddr_t bdaddr;
	bdaddr_t setup_addr;
	bdaddr_t public_addr;
	bdaddr_t random_addr;
	bdaddr_t static_addr;
	__u8 adv_addr_type;
	__u8 dev_name[248];
	__u8 short_name[10];
	__u8 eir[240];
	__u16 appearance;
	__u8 dev_class[3];
	__u8 major_class;
	__u8 minor_class;
	__u8 max_page;
	__u8 features[24];
	__u8 le_features[8];
	__u8 le_white_list_size;
	__u8 le_resolv_list_size;
	__u8 le_num_of_adv_sets;
	__u8 le_states[8];
	__u8 commands[64];
	__u8 hci_ver;
	__u16 hci_rev;
	__u8 lmp_ver;
	__u16 manufacturer;
	__u16 lmp_subver;
	__u16 voice_setting;
	__u8 num_iac;
	__u8 stored_max_keys;
	__u8 stored_num_keys;
	__u8 io_capability;
	__s8 inq_tx_power;
	__u8 err_data_reporting;
	__u16 page_scan_interval;
	__u16 page_scan_window;
	__u8 page_scan_type;
	__u8 le_adv_channel_map;
	__u16 le_adv_min_interval;
	__u16 le_adv_max_interval;
	__u8 le_scan_type;
	__u16 le_scan_interval;
	__u16 le_scan_window;
	__u16 le_scan_int_suspend;
	__u16 le_scan_window_suspend;
	__u16 le_scan_int_discovery;
	__u16 le_scan_window_discovery;
	__u16 le_scan_int_adv_monitor;
	__u16 le_scan_window_adv_monitor;
	__u16 le_scan_int_connect;
	__u16 le_scan_window_connect;
	__u16 le_conn_min_interval;
	__u16 le_conn_max_interval;
	__u16 le_conn_latency;
	__u16 le_supv_timeout;
	__u16 le_def_tx_len;
	__u16 le_def_tx_time;
	__u16 le_max_tx_len;
	__u16 le_max_tx_time;
	__u16 le_max_rx_len;
	__u16 le_max_rx_time;
	__u8 le_max_key_size;
	__u8 le_min_key_size;
	__u16 discov_interleaved_timeout;
	__u16 conn_info_min_age;
	__u16 conn_info_max_age;
	__u16 auth_payload_timeout;
	__u8 min_enc_key_size;
	__u8 max_enc_key_size;
	__u8 pairing_opts;
	__u8 ssp_debug_mode;
	__u8 hw_error_code;
	__u32 clock;
	__u16 devid_source;
	__u16 devid_vendor;
	__u16 devid_product;
	__u16 devid_version;
	__u8 def_page_scan_type;
	__u16 def_page_scan_int;
	__u16 def_page_scan_window;
	__u8 def_inq_scan_type;
	__u16 def_inq_scan_int;
	__u16 def_inq_scan_window;
	__u16 def_br_lsto;
	__u16 def_page_timeout;
	__u16 def_multi_adv_rotation_duration;
	__u16 def_le_autoconnect_timeout;
	__u16 pkt_type;
	__u16 esco_type;
	__u16 link_policy;
	__u16 link_mode;
	__u32 idle_timeout;
	__u16 sniff_min_interval;
	__u16 sniff_max_interval;
	__u8 amp_status;
	__u32 amp_total_bw;
	__u32 amp_max_bw;
	__u32 amp_min_latency;
	__u32 amp_max_pdu;
	__u8 amp_type;
	__u16 amp_pal_cap;
	__u16 amp_assoc_size;
	__u32 amp_max_flush_to;
	__u32 amp_be_flush_to;
	struct amp_assoc loc_assoc;
	__u8 flow_ctl_mode;
	unsigned int auto_accept_delay;
	long unsigned int quirks;
	atomic_t cmd_cnt;
	unsigned int acl_cnt;
	unsigned int sco_cnt;
	unsigned int le_cnt;
	unsigned int acl_mtu;
	unsigned int sco_mtu;
	unsigned int le_mtu;
	unsigned int acl_pkts;
	unsigned int sco_pkts;
	unsigned int le_pkts;
	__u16 block_len;
	__u16 block_mtu;
	__u16 num_blocks;
	__u16 block_cnt;
	long unsigned int acl_last_tx;
	long unsigned int sco_last_tx;
	long unsigned int le_last_tx;
	__u8 le_tx_def_phys;
	__u8 le_rx_def_phys;
	struct workqueue_struct *workqueue;
	struct workqueue_struct *req_workqueue;
	struct work_struct power_on;
	struct delayed_work power_off;
	struct work_struct error_reset;
	__u16 discov_timeout;
	struct delayed_work discov_off;
	struct delayed_work service_cache;
	struct delayed_work cmd_timer;
	struct work_struct rx_work;
	struct work_struct cmd_work;
	struct work_struct tx_work;
	struct work_struct discov_update;
	struct work_struct bg_scan_update;
	struct work_struct scan_update;
	struct work_struct connectable_update;
	struct work_struct discoverable_update;
	struct delayed_work le_scan_disable;
	struct delayed_work le_scan_restart;
	struct sk_buff_head rx_q;
	struct sk_buff_head raw_q;
	struct sk_buff_head cmd_q;
	struct sk_buff *sent_cmd;
	struct mutex req_lock;
	wait_queue_head_t req_wait_q;
	__u32 req_status;
	__u32 req_result;
	struct sk_buff *req_skb;
	void *smp_data;
	void *smp_bredr_data;
	struct discovery_state discovery;
	int discovery_old_state;
	bool discovery_paused;
	int advertising_old_state;
	bool advertising_paused;
	struct notifier_block suspend_notifier;
	struct work_struct suspend_prepare;
	enum suspended_state suspend_state_next;
	enum suspended_state suspend_state;
	bool scanning_paused;
	bool suspended;
	u8 wake_reason;
	bdaddr_t wake_addr;
	u8 wake_addr_type;
	wait_queue_head_t suspend_wait_q;
	long unsigned int suspend_tasks[1];
	struct hci_conn_hash conn_hash;
	struct list_head mgmt_pending;
	struct list_head blacklist;
	struct list_head whitelist;
	struct list_head uuids;
	struct list_head link_keys;
	struct list_head long_term_keys;
	struct list_head identity_resolving_keys;
	struct list_head remote_oob_data;
	struct list_head le_white_list;
	struct list_head le_resolv_list;
	struct list_head le_conn_params;
	struct list_head pend_le_conns;
	struct list_head pend_le_reports;
	struct list_head blocked_keys;
	struct hci_dev_stats stat;
	atomic_t promisc;
	const char *hw_info;
	const char *fw_info;
	struct dentry *debugfs;
	struct device dev;
	struct rfkill *rfkill;
	long unsigned int dev_flags[1];
	__s8 adv_tx_power;
	__u8 adv_data[31];
	__u8 adv_data_len;
	__u8 scan_rsp_data[31];
	__u8 scan_rsp_data_len;
	struct list_head adv_instances;
	unsigned int adv_instance_cnt;
	__u8 cur_adv_instance;
	__u16 adv_instance_timeout;
	struct delayed_work adv_instance_expire;
	struct idr adv_monitors_idr;
	unsigned int adv_monitors_cnt;
	__u8 irk[16];
	__u32 rpa_timeout;
	struct delayed_work rpa_expired;
	bdaddr_t rpa;
	int (*open)(struct hci_dev *);
	int (*close)(struct hci_dev *);
	int (*flush)(struct hci_dev *);
	int (*setup)(struct hci_dev *);
	int (*shutdown)(struct hci_dev *);
	int (*send)(struct hci_dev *, struct sk_buff *);
	void (*notify)(struct hci_dev *, unsigned int);
	void (*hw_error)(struct hci_dev *, u8);
	int (*post_init)(struct hci_dev *);
	int (*set_diag)(struct hci_dev *, bool);
	int (*set_bdaddr)(struct hci_dev *, const bdaddr_t *);
	void (*cmd_timeout)(struct hci_dev *);
	bool (*prevent_wake)(struct hci_dev *);
};

typedef void (*hci_req_complete_skb_t)(struct hci_dev *, u8, u16, struct sk_buff *);

struct hci_ctrl {
	u16 opcode;
	u8 req_flags;
	u8 req_event;
	union {
		hci_req_complete_t req_complete;
		hci_req_complete_skb_t req_complete_skb;
	};
};

struct bt_skb_cb {
	u8 pkt_type;
	u8 force_active;
	u16 expect;
	u8 incoming: 1;
	union {
		struct l2cap_ctrl l2cap;
		struct sco_ctrl sco;
		struct hci_ctrl hci;
	};
};

enum {
	HCI_QUIRK_RESET_ON_CLOSE = 0,
	HCI_QUIRK_RAW_DEVICE = 1,
	HCI_QUIRK_FIXUP_BUFFER_SIZE = 2,
	HCI_QUIRK_FIXUP_INQUIRY_MODE = 3,
	HCI_QUIRK_BROKEN_LOCAL_COMMANDS = 4,
	HCI_QUIRK_BROKEN_STORED_LINK_KEY = 5,
	HCI_QUIRK_EXTERNAL_CONFIG = 6,
	HCI_QUIRK_INVALID_BDADDR = 7,
	HCI_QUIRK_USE_BDADDR_PROPERTY = 8,
	HCI_QUIRK_STRICT_DUPLICATE_FILTER = 9,
	HCI_QUIRK_SIMULTANEOUS_DISCOVERY = 10,
	HCI_QUIRK_NON_PERSISTENT_DIAG = 11,
	HCI_QUIRK_NON_PERSISTENT_SETUP = 12,
	HCI_QUIRK_WIDEBAND_SPEECH_SUPPORTED = 13,
	HCI_QUIRK_VALID_LE_STATES = 14,
	HCI_QUIRK_BROKEN_ERR_DATA_REPORTING = 15,
	HCI_QUIRK_NO_SUSPEND_NOTIFIER = 16,
};

enum {
	HCI_UP = 0,
	HCI_INIT = 1,
	HCI_RUNNING = 2,
	HCI_PSCAN = 3,
	HCI_ISCAN = 4,
	HCI_AUTH = 5,
	HCI_ENCRYPT = 6,
	HCI_INQUIRY = 7,
	HCI_RAW = 8,
	HCI_RESET = 9,
};

enum {
	HCI_SETUP = 0,
	HCI_CONFIG = 1,
	HCI_AUTO_OFF = 2,
	HCI_RFKILLED = 3,
	HCI_MGMT = 4,
	HCI_BONDABLE = 5,
	HCI_SERVICE_CACHE = 6,
	HCI_KEEP_DEBUG_KEYS = 7,
	HCI_USE_DEBUG_KEYS = 8,
	HCI_UNREGISTER = 9,
	HCI_UNCONFIGURED = 10,
	HCI_USER_CHANNEL = 11,
	HCI_EXT_CONFIGURED = 12,
	HCI_LE_ADV = 13,
	HCI_LE_SCAN = 14,
	HCI_SSP_ENABLED = 15,
	HCI_SC_ENABLED = 16,
	HCI_SC_ONLY = 17,
	HCI_PRIVACY = 18,
	HCI_LIMITED_PRIVACY = 19,
	HCI_RPA_EXPIRED = 20,
	HCI_RPA_RESOLVING = 21,
	HCI_HS_ENABLED = 22,
	HCI_LE_ENABLED = 23,
	HCI_ADVERTISING = 24,
	HCI_ADVERTISING_CONNECTABLE = 25,
	HCI_CONNECTABLE = 26,
	HCI_DISCOVERABLE = 27,
	HCI_LIMITED_DISCOVERABLE = 28,
	HCI_LINK_SECURITY = 29,
	HCI_PERIODIC_INQ = 30,
	HCI_FAST_CONNECTABLE = 31,
	HCI_BREDR_ENABLED = 32,
	HCI_LE_SCAN_INTERRUPTED = 33,
	HCI_WIDEBAND_SPEECH_ENABLED = 34,
	HCI_DUT_MODE = 35,
	HCI_VENDOR_DIAG = 36,
	HCI_FORCE_BREDR_SMP = 37,
	HCI_FORCE_STATIC_ADDR = 38,
	HCI_LL_RPA_RESOLUTION = 39,
	HCI_ENABLE_LL_PRIVACY = 40,
	HCI_CMD_PENDING = 41,
	HCI_FORCE_NO_MITM = 42,
	__HCI_NUM_FLAGS = 43,
};

enum suspend_tasks {
	SUSPEND_PAUSE_DISCOVERY = 0,
	SUSPEND_UNPAUSE_DISCOVERY = 1,
	SUSPEND_PAUSE_ADVERTISING = 2,
	SUSPEND_UNPAUSE_ADVERTISING = 3,
	SUSPEND_SCAN_DISABLE = 4,
	SUSPEND_SCAN_ENABLE = 5,
	SUSPEND_DISCONNECTING = 6,
	SUSPEND_POWERING_DOWN = 7,
	SUSPEND_PREPARE_NOTIFIER = 8,
	__SUSPEND_NUM_TASKS = 9,
};

enum hci_conn_flags {
	HCI_CONN_FLAG_REMOTE_WAKEUP = 0,
	HCI_CONN_FLAG_MAX = 1,
};

struct hci_uart;

struct hci_uart_proto {
	unsigned int id;
	int (*open)(struct hci_uart *);
	int (*close)(struct hci_uart *);
	int (*flush)(struct hci_uart *);
	int (*recv)(struct hci_uart *, void *, int);
	int (*enqueue)(struct hci_uart *, struct sk_buff *);
	struct sk_buff * (*dequeue)(struct hci_uart *);
};

struct hci_uart {
	struct tty_struct *tty;
	struct hci_dev *hdev;
	long unsigned int flags;
	long unsigned int hdev_flags;
	struct work_struct write_work;
	struct workqueue_struct *hci_uart_wq;
	struct hci_uart_proto *proto;
	struct percpu_rw_semaphore proto_lock;
	void *priv;
	struct semaphore tx_sem;
	struct sk_buff *tx_skb;
	long unsigned int tx_state;
};

struct hci_event_hdr {
	__u8 evt;
	__u8 plen;
};

struct hci_acl_hdr {
	__le16 handle;
	__le16 dlen;
};

struct hci_sco_hdr {
	__le16 handle;
	__u8 dlen;
} __attribute__((packed));

struct h4_struct {
	long unsigned int rx_state;
	long unsigned int rx_count;
	struct sk_buff *rx_skb;
	struct sk_buff_head txq;
};

typedef s8 int8_t;

struct l2cap_seq_list {
	__u16 head;
	__u16 tail;
	__u16 mask;
	__u16 *list;
};

struct l2cap_conn;

struct hci_conn;

struct hci_chan;

struct l2cap_ops;

struct l2cap_chan {
	struct l2cap_conn *conn;
	struct hci_conn *hs_hcon;
	struct hci_chan *hs_hchan;
	struct kref kref;
	atomic_t nesting;
	__u8 state;
	bdaddr_t dst;
	__u8 dst_type;
	bdaddr_t src;
	__u8 src_type;
	__le16 psm;
	__le16 sport;
	__u16 dcid;
	__u16 scid;
	__u16 imtu;
	__u16 omtu;
	__u16 flush_to;
	__u8 mode;
	__u8 chan_type;
	__u8 chan_policy;
	__u8 sec_level;
	__u8 ident;
	__u8 conf_req[64];
	__u8 conf_len;
	__u8 num_conf_req;
	__u8 num_conf_rsp;
	__u8 fcs;
	__u16 tx_win;
	__u16 tx_win_max;
	__u16 ack_win;
	__u8 max_tx;
	__u16 retrans_timeout;
	__u16 monitor_timeout;
	__u16 mps;
	__u16 tx_credits;
	__u16 rx_credits;
	__u8 tx_state;
	__u8 rx_state;
	long unsigned int conf_state;
	long unsigned int conn_state;
	long unsigned int flags;
	__u8 remote_amp_id;
	__u8 local_amp_id;
	__u8 move_id;
	__u8 move_state;
	__u8 move_role;
	__u16 next_tx_seq;
	__u16 expected_ack_seq;
	__u16 expected_tx_seq;
	__u16 buffer_seq;
	__u16 srej_save_reqseq;
	__u16 last_acked_seq;
	__u16 frames_sent;
	__u16 unacked_frames;
	__u8 retry_count;
	__u16 sdu_len;
	struct sk_buff *sdu;
	struct sk_buff *sdu_last_frag;
	__u16 remote_tx_win;
	__u8 remote_max_tx;
	__u16 remote_mps;
	__u8 local_id;
	__u8 local_stype;
	__u16 local_msdu;
	__u32 local_sdu_itime;
	__u32 local_acc_lat;
	__u32 local_flush_to;
	__u8 remote_id;
	__u8 remote_stype;
	__u16 remote_msdu;
	__u32 remote_sdu_itime;
	__u32 remote_acc_lat;
	__u32 remote_flush_to;
	struct delayed_work chan_timer;
	struct delayed_work retrans_timer;
	struct delayed_work monitor_timer;
	struct delayed_work ack_timer;
	struct sk_buff *tx_send_head;
	struct sk_buff_head tx_q;
	struct sk_buff_head srej_q;
	struct l2cap_seq_list srej_list;
	struct l2cap_seq_list retrans_list;
	struct list_head list;
	struct list_head global_l;
	void *data;
	const struct l2cap_ops *ops;
	struct mutex lock;
};

enum conn_reasons {
	CONN_REASON_PAIR_DEVICE = 0,
	CONN_REASON_L2CAP_CHAN = 1,
	CONN_REASON_SCO_CONNECT = 2,
};

struct amp_mgr;

struct hci_conn {
	struct list_head list;
	atomic_t refcnt;
	bdaddr_t dst;
	__u8 dst_type;
	bdaddr_t src;
	__u8 src_type;
	bdaddr_t init_addr;
	__u8 init_addr_type;
	bdaddr_t resp_addr;
	__u8 resp_addr_type;
	__u16 handle;
	__u16 state;
	__u8 mode;
	__u8 type;
	__u8 role;
	bool out;
	__u8 attempt;
	__u8 dev_class[3];
	__u8 features[24];
	__u16 pkt_type;
	__u16 link_policy;
	__u8 key_type;
	__u8 auth_type;
	__u8 sec_level;
	__u8 pending_sec_level;
	__u8 pin_length;
	__u8 enc_key_size;
	__u8 io_capability;
	__u32 passkey_notify;
	__u8 passkey_entered;
	__u16 disc_timeout;
	__u16 conn_timeout;
	__u16 setting;
	__u16 auth_payload_timeout;
	__u16 le_conn_min_interval;
	__u16 le_conn_max_interval;
	__u16 le_conn_interval;
	__u16 le_conn_latency;
	__u16 le_supv_timeout;
	__u8 le_adv_data[31];
	__u8 le_adv_data_len;
	__u8 le_tx_phy;
	__u8 le_rx_phy;
	__s8 rssi;
	__s8 tx_power;
	__s8 max_tx_power;
	long unsigned int flags;
	enum conn_reasons conn_reason;
	__u32 clock;
	__u16 clock_accuracy;
	long unsigned int conn_info_timestamp;
	__u8 remote_cap;
	__u8 remote_auth;
	__u8 remote_id;
	unsigned int sent;
	struct sk_buff_head data_q;
	struct list_head chan_list;
	struct delayed_work disc_work;
	struct delayed_work auto_accept_work;
	struct delayed_work idle_work;
	struct delayed_work le_conn_timeout;
	struct work_struct le_scan_cleanup;
	struct device dev;
	struct dentry *debugfs;
	struct hci_dev *hdev;
	void *l2cap_data;
	void *sco_data;
	struct amp_mgr *amp_mgr;
	struct hci_conn *link;
	void (*connect_cfm_cb)(struct hci_conn *, u8);
	void (*security_cfm_cb)(struct hci_conn *, u8);
	void (*disconn_cfm_cb)(struct hci_conn *, u8);
};

struct hci_chan {
	struct list_head list;
	__u16 handle;
	struct hci_conn *conn;
	struct sk_buff_head data_q;
	unsigned int sent;
	__u8 state;
	bool amp;
};

struct l2cap_conn {
	struct hci_conn *hcon;
	struct hci_chan *hchan;
	unsigned int mtu;
	__u32 feat_mask;
	__u8 remote_fixed_chan;
	__u8 local_fixed_chan;
	__u8 info_state;
	__u8 info_ident;
	struct delayed_work info_timer;
	struct sk_buff *rx_skb;
	__u32 rx_len;
	__u8 tx_ident;
	struct mutex ident_lock;
	struct sk_buff_head pending_rx;
	struct work_struct pending_rx_work;
	struct work_struct id_addr_update_work;
	__u8 disc_reason;
	struct l2cap_chan *smp;
	struct list_head chan_l;
	struct mutex chan_lock;
	struct kref ref;
	struct list_head users;
};

struct l2cap_ops {
	char *name;
	struct l2cap_chan * (*new_connection)(struct l2cap_chan *);
	int (*recv)(struct l2cap_chan *, struct sk_buff *);
	void (*teardown)(struct l2cap_chan *, int);
	void (*close)(struct l2cap_chan *);
	void (*state_change)(struct l2cap_chan *, int, int);
	void (*ready)(struct l2cap_chan *);
	void (*defer)(struct l2cap_chan *);
	void (*resume)(struct l2cap_chan *);
	void (*suspend)(struct l2cap_chan *);
	void (*set_shutdown)(struct l2cap_chan *);
	long int (*get_sndtimeo)(struct l2cap_chan *);
	struct pid * (*get_peer_pid)(struct l2cap_chan *);
	struct sk_buff * (*alloc_skb)(struct l2cap_chan *, long unsigned int, long unsigned int, int);
	int (*filter)(struct l2cap_chan *, struct sk_buff *);
};

enum {
	profile_sco = 0,
	profile_hid = 1,
	profile_a2dp = 2,
	profile_pan = 3,
	profile_hid_interval = 4,
	profile_hogp = 5,
	profile_voice = 6,
	profile_sink = 7,
	profile_max = 8,
};

typedef struct {
	struct list_head list;
	uint16_t handle;
	uint16_t psm;
	uint16_t dcid;
	uint16_t scid;
	uint8_t profile_index;
	uint8_t flags;
} rtk_prof_info;

struct rtl_hci_conn {
	struct list_head list;
	uint16_t handle;
	uint8_t type;
	uint8_t profile_bitmap;
	int8_t profile_refcount[8];
};

typedef struct rtl_hci_conn rtk_conn_prof;

struct rtl_hci_ev {
	__u8 data[32];
	__u16 len;
	struct list_head list;
};

struct rtl_l2_buff {
	__u8 data[128];
	__u16 len;
	__u16 out;
	struct list_head list;
};

struct urb;

struct rtl_coex_struct {
	struct list_head conn_hash;
	struct list_head profile_list;
	struct hci_dev *hdev;
	struct timer_list a2dp_count_timer;
	struct timer_list pan_count_timer;
	struct timer_list hogp_count_timer;
	struct workqueue_struct *fw_wq;
	struct delayed_work fw_work;
	struct delayed_work l2_work;
	struct urb *urb;
	spinlock_t spin_lock_sock;
	spinlock_t spin_lock_profile;
	uint32_t a2dp_packet_count;
	uint32_t pan_packet_count;
	uint32_t hogp_packet_count;
	uint32_t voice_packet_count;
	uint8_t profile_bitmap;
	uint8_t profile_status;
	int8_t profile_refcount[8];
	uint8_t ispairing;
	uint8_t isinquirying;
	uint8_t ispaging;
	uint16_t hci_reversion;
	uint16_t lmp_subversion;
	long unsigned int cmd_last_tx;
	struct list_head ev_used_list;
	struct list_head ev_free_list;
	spinlock_t rxlock;
	__u8 pkt_type;
	__u16 expect;
	__u8 *tbuff;
	__u16 elen;
	__u8 back_buff[260];
	struct list_head l2_used_list;
	struct list_head l2_free_list;
	spinlock_t buff_lock;
	long unsigned int pages_addr;
	long unsigned int buff_size;
	long unsigned int flags;
};

struct sbc_frame_hdr {
	uint8_t syncword: 8;
	uint8_t subbands: 1;
	uint8_t allocation_method: 1;
	uint8_t channel_mode: 2;
	uint8_t blocks: 2;
	uint8_t sampling_frequency: 2;
	uint8_t bitpool: 8;
	uint8_t crc_check: 8;
};

struct rtp_header {
	unsigned int cc: 4;
	unsigned int x: 1;
	unsigned int p: 1;
	unsigned int v: 2;
	unsigned int pt: 7;
	unsigned int m: 1;
	uint16_t sequence_number;
	uint32_t timestamp;
	uint32_t ssrc;
	uint32_t csrc[0];
};

struct h5_struct {
	struct sk_buff_head unack;
	struct sk_buff_head rel;
	struct sk_buff_head unrel;
	long unsigned int rx_count;
	struct sk_buff *rx_skb;
	struct delayed_work retrans_work;
	struct hci_uart *hu;
	enum {
		H5_W4_PKT_DELIMITER = 0,
		H5_W4_PKT_START = 1,
		H5_W4_HDR = 2,
		H5_W4_DATA = 3,
		H5_W4_CRC = 4,
	} rx_state;
	enum {
		H5_ESCSTATE_NOESC = 0,
		H5_ESCSTATE_ESC = 1,
	} rx_esc_state;
	u16 message_crc;
	u8 use_crc;
	u8 rxack;
	u8 rxseq_txack;
	u8 txack_req;
	u8 msgq_txseq;
	spinlock_t lock;
};

enum opp_table_access {
	OPP_TABLE_ACCESS_UNKNOWN = 0,
	OPP_TABLE_ACCESS_EXCLUSIVE = 1,
	OPP_TABLE_ACCESS_SHARED = 2,
};

struct icc_path;

struct dev_pm_opp;

struct dev_pm_set_opp_data;

struct opp_table {
	struct list_head node;
	struct blocking_notifier_head head;
	struct list_head dev_list;
	struct list_head opp_list;
	struct kref kref;
	struct mutex lock;
	struct device_node *np;
	long unsigned int clock_latency_ns_max;
	unsigned int voltage_tolerance_v1;
	unsigned int parsed_static_opps;
	enum opp_table_access shared_opp;
	struct dev_pm_opp *suspend_opp;
	struct mutex genpd_virt_dev_lock;
	struct device **genpd_virt_devs;
	struct opp_table **required_opp_tables;
	unsigned int required_opp_count;
	unsigned int *supported_hw;
	unsigned int supported_hw_count;
	const char *prop_name;
	struct clk *clk;
	struct regulator **regulators;
	int regulator_count;
	struct icc_path **paths;
	unsigned int path_count;
	bool enabled;
	bool genpd_performance_state;
	bool is_genpd;
	int (*set_opp)(struct dev_pm_set_opp_data *);
	struct dev_pm_set_opp_data *set_opp_data;
	struct dentry *dentry;
	char dentry_name[255];
};

struct dev_pm_opp_supply;

struct dev_pm_opp_icc_bw;

struct dev_pm_opp {
	struct list_head node;
	struct kref kref;
	bool available;
	bool dynamic;
	bool turbo;
	bool suspend;
	unsigned int pstate;
	long unsigned int rate;
	unsigned int level;
	struct dev_pm_opp_supply *supplies;
	struct dev_pm_opp_icc_bw *bandwidth;
	long unsigned int clock_latency_ns;
	struct dev_pm_opp **required_opps;
	struct opp_table *opp_table;
	struct device_node *np;
	struct dentry *dentry;
};

enum dev_pm_opp_event {
	OPP_EVENT_ADD = 0,
	OPP_EVENT_REMOVE = 1,
	OPP_EVENT_ENABLE = 2,
	OPP_EVENT_DISABLE = 3,
	OPP_EVENT_ADJUST_VOLTAGE = 4,
};

struct dev_pm_opp_supply {
	long unsigned int u_volt;
	long unsigned int u_volt_min;
	long unsigned int u_volt_max;
	long unsigned int u_amp;
};

struct dev_pm_opp_icc_bw {
	u32 avg;
	u32 peak;
};

struct dev_pm_opp_info {
	long unsigned int rate;
	struct dev_pm_opp_supply *supplies;
};

struct dev_pm_set_opp_data {
	struct dev_pm_opp_info old_opp;
	struct dev_pm_opp_info new_opp;
	struct regulator **regulators;
	unsigned int regulator_count;
	struct clk *clk;
	struct device *dev;
};

struct opp_device {
	struct list_head node;
	const struct device *dev;
	struct dentry *dentry;
};

struct em_data_callback {};

struct cpufreq_policy_data {
	struct cpufreq_cpuinfo cpuinfo;
	struct cpufreq_frequency_table *freq_table;
	unsigned int cpu;
	unsigned int min;
	unsigned int max;
};

struct cpufreq_freqs {
	struct cpufreq_policy *policy;
	unsigned int old;
	unsigned int new;
	u8 flags;
};

struct freq_attr {
	struct attribute attr;
	ssize_t (*show)(struct cpufreq_policy *, char *);
	ssize_t (*store)(struct cpufreq_policy *, const char *, size_t);
};

struct cpufreq_driver {
	char name[16];
	u16 flags;
	void *driver_data;
	int (*init)(struct cpufreq_policy *);
	int (*verify)(struct cpufreq_policy_data *);
	int (*setpolicy)(struct cpufreq_policy *);
	int (*target)(struct cpufreq_policy *, unsigned int, unsigned int);
	int (*target_index)(struct cpufreq_policy *, unsigned int);
	unsigned int (*fast_switch)(struct cpufreq_policy *, unsigned int);
	unsigned int (*resolve_freq)(struct cpufreq_policy *, unsigned int);
	unsigned int (*get_intermediate)(struct cpufreq_policy *, unsigned int);
	int (*target_intermediate)(struct cpufreq_policy *, unsigned int);
	unsigned int (*get)(unsigned int);
	void (*update_limits)(unsigned int);
	int (*bios_limit)(int, unsigned int *);
	int (*online)(struct cpufreq_policy *);
	int (*offline)(struct cpufreq_policy *);
	int (*exit)(struct cpufreq_policy *);
	void (*stop_cpu)(struct cpufreq_policy *);
	int (*suspend)(struct cpufreq_policy *);
	int (*resume)(struct cpufreq_policy *);
	void (*ready)(struct cpufreq_policy *);
	struct freq_attr **attr;
	bool boost_enabled;
	int (*set_boost)(struct cpufreq_policy *, int);
};

struct cpufreq_stats {
	unsigned int total_trans;
	long long unsigned int last_time;
	unsigned int max_state;
	unsigned int state_num;
	unsigned int last_index;
	u64 *time_in_state;
	unsigned int *freq_table;
	unsigned int *trans_table;
	unsigned int reset_pending;
	long long unsigned int reset_time;
};

enum {
	OD_NORMAL_SAMPLE = 0,
	OD_SUB_SAMPLE = 1,
};

struct dbs_data {
	struct gov_attr_set attr_set;
	void *tuners;
	unsigned int ignore_nice_load;
	unsigned int sampling_rate;
	unsigned int sampling_down_factor;
	unsigned int up_threshold;
	unsigned int io_is_busy;
};

struct policy_dbs_info {
	struct cpufreq_policy *policy;
	struct mutex update_mutex;
	u64 last_sample_time;
	s64 sample_delay_ns;
	atomic_t work_count;
	struct irq_work irq_work;
	struct work_struct work;
	struct dbs_data *dbs_data;
	struct list_head list;
	unsigned int rate_mult;
	unsigned int idle_periods;
	bool is_shared;
	bool work_in_progress;
};

struct dbs_governor {
	struct cpufreq_governor gov;
	struct kobj_type kobj_type;
	struct dbs_data *gdbs_data;
	unsigned int (*gov_dbs_update)(struct cpufreq_policy *);
	struct policy_dbs_info * (*alloc)();
	void (*free)(struct policy_dbs_info *);
	int (*init)(struct dbs_data *);
	void (*exit)(struct dbs_data *);
	void (*start)(struct cpufreq_policy *);
};

struct od_ops {
	unsigned int (*powersave_bias_target)(struct cpufreq_policy *, unsigned int, unsigned int);
};

struct od_policy_dbs_info {
	struct policy_dbs_info policy_dbs;
	unsigned int freq_lo;
	unsigned int freq_lo_delay_us;
	unsigned int freq_hi_delay_us;
	unsigned int sample_type: 1;
};

struct od_dbs_tuners {
	unsigned int powersave_bias;
};

struct cs_policy_dbs_info {
	struct policy_dbs_info policy_dbs;
	unsigned int down_skip;
	unsigned int requested_freq;
};

struct cs_dbs_tuners {
	unsigned int down_threshold;
	unsigned int freq_step;
};

struct cpu_dbs_info {
	u64 prev_cpu_idle;
	u64 prev_update_time;
	u64 prev_cpu_nice;
	unsigned int prev_load;
	struct update_util_data update_util;
	struct policy_dbs_info *policy_dbs;
};

struct cpufreq_dt_platform_data {
	bool have_governor_per_policy;
	unsigned int (*get_intermediate)(struct cpufreq_policy *, unsigned int);
	int (*target_intermediate)(struct cpufreq_policy *, unsigned int);
	int (*suspend)(struct cpufreq_policy *);
	int (*resume)(struct cpufreq_policy *);
};

struct private_data {
	struct list_head node;
	cpumask_var_t cpus;
	struct device *cpu_dev;
	struct opp_table *opp_table;
	struct opp_table *reg_opp_table;
	bool have_static_opps;
};

enum LIGHT_MPW_CPUFREQ_CLKS {
	LIGHT_C910_CCLK = 0,
	LIGHT_C910_CCLK_I0 = 1,
	LIGHT_CPU_PLL1_FOUTPOSTDIV = 2,
	LIGHT_CPU_PLL0_FOUTPOSTDIV = 3,
};

struct cpuidle_governor {
	char name[16];
	struct list_head governor_list;
	unsigned int rating;
	int (*enable)(struct cpuidle_driver *, struct cpuidle_device *);
	void (*disable)(struct cpuidle_driver *, struct cpuidle_device *);
	int (*select)(struct cpuidle_driver *, struct cpuidle_device *, bool *);
	void (*reflect)(struct cpuidle_device *, int);
};

enum tick_broadcast_mode {
	TICK_BROADCAST_OFF = 0,
	TICK_BROADCAST_ON = 1,
	TICK_BROADCAST_FORCE = 2,
};

struct cpuidle_state_kobj {
	struct cpuidle_state *state;
	struct cpuidle_state_usage *state_usage;
	struct completion kobj_unregister;
	struct kobject kobj;
	struct cpuidle_device *device;
};

struct cpuidle_device_kobj {
	struct cpuidle_device *dev;
	struct completion kobj_unregister;
	struct kobject kobj;
};

struct cpuidle_attr {
	struct attribute attr;
	ssize_t (*show)(struct cpuidle_device *, char *);
	ssize_t (*store)(struct cpuidle_device *, const char *, size_t);
};

struct cpuidle_state_attr {
	struct attribute attr;
	ssize_t (*show)(struct cpuidle_state *, struct cpuidle_state_usage *, char *);
	ssize_t (*store)(struct cpuidle_state *, struct cpuidle_state_usage *, const char *, size_t);
};

struct ladder_device_state {
	struct {
		u32 promotion_count;
		u32 demotion_count;
		u64 promotion_time_ns;
		u64 demotion_time_ns;
	} threshold;
	struct {
		int promotion_count;
		int demotion_count;
	} stats;
};

struct ladder_device {
	struct ladder_device_state states[10];
};

struct menu_device {
	int needs_update;
	int tick_wakeup;
	u64 next_timer_ns;
	unsigned int bucket;
	unsigned int correction_factor[12];
	unsigned int intervals[8];
	int interval_ptr;
};

struct led_trigger {};

struct mmc_pwrseq_ops;

struct mmc_pwrseq {
	const struct mmc_pwrseq_ops *ops;
	struct device *dev;
	struct list_head pwrseq_node;
	struct module *owner;
};

struct trace_event_raw_mmc_request_start {
	struct trace_entry ent;
	u32 cmd_opcode;
	u32 cmd_arg;
	unsigned int cmd_flags;
	unsigned int cmd_retries;
	u32 stop_opcode;
	u32 stop_arg;
	unsigned int stop_flags;
	unsigned int stop_retries;
	u32 sbc_opcode;
	u32 sbc_arg;
	unsigned int sbc_flags;
	unsigned int sbc_retries;
	unsigned int blocks;
	unsigned int blk_addr;
	unsigned int blksz;
	unsigned int data_flags;
	int tag;
	unsigned int can_retune;
	unsigned int doing_retune;
	unsigned int retune_now;
	int need_retune;
	int hold_retune;
	unsigned int retune_period;
	struct mmc_request *mrq;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_mmc_request_done {
	struct trace_entry ent;
	u32 cmd_opcode;
	int cmd_err;
	u32 cmd_resp[4];
	unsigned int cmd_retries;
	u32 stop_opcode;
	int stop_err;
	u32 stop_resp[4];
	unsigned int stop_retries;
	u32 sbc_opcode;
	int sbc_err;
	u32 sbc_resp[4];
	unsigned int sbc_retries;
	unsigned int bytes_xfered;
	int data_err;
	int tag;
	unsigned int can_retune;
	unsigned int doing_retune;
	unsigned int retune_now;
	int need_retune;
	int hold_retune;
	unsigned int retune_period;
	struct mmc_request *mrq;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_data_offsets_mmc_request_start {
	u32 name;
};

struct trace_event_data_offsets_mmc_request_done {
	u32 name;
};

typedef void (*btf_trace_mmc_request_start)(void *, struct mmc_host *, struct mmc_request *);

typedef void (*btf_trace_mmc_request_done)(void *, struct mmc_host *, struct mmc_request *);

struct mmc_pwrseq_ops {
	void (*pre_power_on)(struct mmc_host *);
	void (*post_power_on)(struct mmc_host *);
	void (*power_off)(struct mmc_host *);
	void (*reset)(struct mmc_host *);
};

enum mmc_busy_cmd {
	MMC_BUSY_CMD6 = 0,
	MMC_BUSY_ERASE = 1,
	MMC_BUSY_HPI = 2,
};

struct mmc_driver {
	struct device_driver drv;
	int (*probe)(struct mmc_card *);
	void (*remove)(struct mmc_card *);
	void (*shutdown)(struct mmc_card *);
};

struct mmc_fixup {
	const char *name;
	u64 rev_start;
	u64 rev_end;
	unsigned int manfid;
	short unsigned int oemid;
	u16 cis_vendor;
	u16 cis_device;
	unsigned int ext_csd_rev;
	void (*vendor_fixup)(struct mmc_card *, int);
	int data;
};

typedef int tpl_parse_t(struct mmc_card *, struct sdio_func *, const unsigned char *, unsigned int);

struct cis_tpl {
	unsigned char code;
	unsigned char min_size;
	tpl_parse_t *parse;
};

struct mmc_gpio {
	struct gpio_desc *ro_gpio;
	struct gpio_desc *cd_gpio;
	irqreturn_t (*cd_gpio_isr)(int, void *);
	char *ro_label;
	char *cd_label;
	u32 cd_debounce_delay_ms;
};

struct mmc_pwrseq_simple {
	struct mmc_pwrseq pwrseq;
	bool clk_enabled;
	u32 post_power_on_delay_ms;
	u32 power_off_delay_us;
	struct clk *ext_clk;
	struct gpio_descs *reset_gpios;
};

struct mmc_pwrseq_emmc {
	struct mmc_pwrseq pwrseq;
	struct notifier_block reset_nb;
	struct gpio_desc *reset_gpio;
};

struct mmc_ioc_cmd {
	int write_flag;
	int is_acmd;
	__u32 opcode;
	__u32 arg;
	__u32 response[4];
	unsigned int flags;
	unsigned int blksz;
	unsigned int blocks;
	unsigned int postsleep_min_us;
	unsigned int postsleep_max_us;
	unsigned int data_timeout_ns;
	unsigned int cmd_timeout_ms;
	__u32 __pad;
	__u64 data_ptr;
};

struct mmc_ioc_multi_cmd {
	__u64 num_of_cmds;
	struct mmc_ioc_cmd cmds[0];
};

enum mmc_issued {
	MMC_REQ_STARTED = 0,
	MMC_REQ_BUSY = 1,
	MMC_REQ_FAILED_TO_START = 2,
	MMC_REQ_FINISHED = 3,
};

enum mmc_issue_type {
	MMC_ISSUE_SYNC = 0,
	MMC_ISSUE_DCMD = 1,
	MMC_ISSUE_ASYNC = 2,
	MMC_ISSUE_MAX = 3,
};

struct mmc_blk_request {
	struct mmc_request mrq;
	struct mmc_command sbc;
	struct mmc_command cmd;
	struct mmc_command stop;
	struct mmc_data data;
};

enum mmc_drv_op {
	MMC_DRV_OP_IOCTL = 0,
	MMC_DRV_OP_IOCTL_RPMB = 1,
	MMC_DRV_OP_BOOT_WP = 2,
	MMC_DRV_OP_GET_CARD_STATUS = 3,
	MMC_DRV_OP_GET_EXT_CSD = 4,
};

struct mmc_queue_req {
	struct mmc_blk_request brq;
	struct scatterlist *sg;
	enum mmc_drv_op drv_op;
	int drv_op_result;
	void *drv_op_data;
	unsigned int ioc_count;
	int retries;
};

struct mmc_blk_data;

struct mmc_queue {
	struct mmc_card *card;
	struct mmc_ctx ctx;
	struct blk_mq_tag_set tag_set;
	struct mmc_blk_data *blkdata;
	struct request_queue *queue;
	spinlock_t lock;
	int in_flight[3];
	unsigned int cqe_busy;
	bool busy;
	bool use_cqe;
	bool recovery_needed;
	bool in_recovery;
	bool rw_wait;
	bool waiting;
	struct work_struct recovery_work;
	wait_queue_head_t wait;
	struct request *recovery_req;
	struct request *complete_req;
	struct mutex complete_lock;
	struct work_struct complete_work;
};

struct mmc_blk_data {
	struct device *parent;
	struct gendisk *disk;
	struct mmc_queue queue;
	struct list_head part;
	struct list_head rpmbs;
	unsigned int flags;
	unsigned int usage;
	unsigned int read_only;
	unsigned int part_type;
	unsigned int reset_done;
	unsigned int part_curr;
	struct device_attribute force_ro;
	struct device_attribute power_ro_lock;
	int area_type;
	struct dentry *status_dentry;
	struct dentry *ext_csd_dentry;
};

struct mmc_rpmb_data {
	struct device dev;
	struct cdev chrdev;
	int id;
	unsigned int part_index;
	struct mmc_blk_data *md;
	struct list_head node;
};

struct mmc_blk_ioc_data {
	struct mmc_ioc_cmd ic;
	unsigned char *buf;
	u64 buf_bytes;
	struct mmc_rpmb_data *rpmb;
};

struct sdhci_adma2_64_desc {
	__le16 cmd;
	__le16 len;
	__le32 addr_lo;
	__le32 addr_hi;
};

enum sdhci_cookie {
	COOKIE_UNMAPPED = 0,
	COOKIE_PRE_MAPPED = 1,
	COOKIE_MAPPED = 2,
};

struct sdhci_ops;

struct sdhci_host {
	const char *hw_name;
	unsigned int quirks;
	unsigned int quirks2;
	int irq;
	void *ioaddr;
	phys_addr_t mapbase;
	char *bounce_buffer;
	dma_addr_t bounce_addr;
	unsigned int bounce_buffer_size;
	const struct sdhci_ops *ops;
	struct mmc_host *mmc;
	struct mmc_host_ops mmc_host_ops;
	u64 dma_mask;
	struct led_classdev led;
	char led_name[32];
	spinlock_t lock;
	int flags;
	unsigned int version;
	unsigned int max_clk;
	unsigned int timeout_clk;
	unsigned int clk_mul;
	unsigned int clock;
	u8 pwr;
	bool runtime_suspended;
	bool bus_on;
	bool preset_enabled;
	bool pending_reset;
	bool irq_wake_enabled;
	bool v4_mode;
	bool use_external_dma;
	bool always_defer_done;
	struct mmc_request *mrqs_done[2];
	struct mmc_command *cmd;
	struct mmc_command *data_cmd;
	struct mmc_command *deferred_cmd;
	struct mmc_data *data;
	unsigned int data_early: 1;
	struct sg_mapping_iter sg_miter;
	unsigned int blocks;
	int sg_count;
	void *adma_table;
	void *align_buffer;
	size_t adma_table_sz;
	size_t align_buffer_sz;
	dma_addr_t adma_addr;
	dma_addr_t align_addr;
	unsigned int desc_sz;
	unsigned int alloc_desc_sz;
	struct workqueue_struct *complete_wq;
	struct work_struct complete_work;
	struct timer_list timer;
	struct timer_list data_timer;
	u32 caps;
	u32 caps1;
	bool read_caps;
	bool sdhci_core_to_disable_vqmmc;
	unsigned int ocr_avail_sdio;
	unsigned int ocr_avail_sd;
	unsigned int ocr_avail_mmc;
	u32 ocr_mask;
	unsigned int timing;
	u32 thread_isr;
	u32 ier;
	bool cqe_on;
	u32 cqe_ier;
	u32 cqe_err_ier;
	wait_queue_head_t buf_ready_int;
	unsigned int tuning_done;
	unsigned int tuning_count;
	unsigned int tuning_mode;
	unsigned int tuning_err;
	int tuning_delay;
	int tuning_loop_count;
	u32 sdma_boundary;
	u32 adma_table_cnt;
	u64 data_timeout;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long unsigned int private[0];
};

struct sdhci_ops {
	void (*set_clock)(struct sdhci_host *, unsigned int);
	void (*set_power)(struct sdhci_host *, unsigned char, short unsigned int);
	u32 (*irq)(struct sdhci_host *, u32);
	int (*set_dma_mask)(struct sdhci_host *);
	int (*enable_dma)(struct sdhci_host *);
	unsigned int (*get_max_clock)(struct sdhci_host *);
	unsigned int (*get_min_clock)(struct sdhci_host *);
	unsigned int (*get_timeout_clock)(struct sdhci_host *);
	unsigned int (*get_max_timeout_count)(struct sdhci_host *);
	void (*set_timeout)(struct sdhci_host *, struct mmc_command *);
	void (*set_bus_width)(struct sdhci_host *, int);
	void (*platform_send_init_74_clocks)(struct sdhci_host *, u8);
	unsigned int (*get_ro)(struct sdhci_host *);
	void (*reset)(struct sdhci_host *, u8);
	int (*platform_execute_tuning)(struct sdhci_host *, u32);
	void (*set_uhs_signaling)(struct sdhci_host *, unsigned int);
	void (*hw_reset)(struct sdhci_host *);
	void (*adma_workaround)(struct sdhci_host *, u32);
	void (*card_event)(struct sdhci_host *);
	void (*voltage_switch)(struct sdhci_host *);
	void (*adma_write_desc)(struct sdhci_host *, void **, dma_addr_t, int, unsigned int);
	void (*copy_to_bounce_buffer)(struct sdhci_host *, struct mmc_data *, unsigned int);
	void (*request_done)(struct sdhci_host *, struct mmc_request *);
	void (*dump_vendor_regs)(struct sdhci_host *);
};

struct sdhci_pltfm_data {
	const struct sdhci_ops *ops;
	unsigned int quirks;
	unsigned int quirks2;
};

struct sdhci_pltfm_host {
	struct clk *clk;
	unsigned int clock;
	u16 xfer_mode_shadow;
	long: 16;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long unsigned int private[0];
};

struct dwcmshc_priv {
	struct clk *bus_clk;
	void *soc_base;
	bool is_emmc_card;
	bool pull_up_en;
	bool io_fixed_1v8;
	bool wprtn_ignore;
	long int reset_cnt;
};

struct led_init_data {
	struct fwnode_handle *fwnode;
	const char *default_label;
	const char *devicename;
	bool devname_mandatory;
};

struct led_properties {
	u32 color;
	bool color_present;
	const char *function;
	u32 func_enum;
	bool func_enum_present;
	const char *label;
};

typedef int (*gpio_blink_set_t)(struct gpio_desc *, int, long unsigned int *, long unsigned int *);

struct gpio_led {
	const char *name;
	const char *default_trigger;
	unsigned int gpio;
	unsigned int active_low: 1;
	unsigned int retain_state_suspended: 1;
	unsigned int panic_indicator: 1;
	unsigned int default_state: 2;
	unsigned int retain_state_shutdown: 1;
	struct gpio_desc *gpiod;
};

struct gpio_led_platform_data {
	int num_leds;
	const struct gpio_led *leds;
	gpio_blink_set_t gpio_blink_set;
};

struct gpio_led_data {
	struct led_classdev cdev;
	struct gpio_desc *gpiod;
	u8 can_sleep;
	u8 blinking;
	gpio_blink_set_t platform_gpio_blink_set;
};

struct gpio_leds_priv {
	int num_leds;
	struct gpio_led_data leds[0];
};

typedef long unsigned int efi_status_t;

typedef u8 efi_bool_t;

typedef u16 efi_char16_t;

typedef struct {
	u64 signature;
	u32 revision;
	u32 headersize;
	u32 crc32;
	u32 reserved;
} efi_table_hdr_t;

typedef struct {
	efi_guid_t guid;
	u32 headersize;
	u32 flags;
	u32 imagesize;
} efi_capsule_header_t;

typedef struct {
	u16 year;
	u8 month;
	u8 day;
	u8 hour;
	u8 minute;
	u8 second;
	u8 pad1;
	u32 nanosecond;
	s16 timezone;
	u8 daylight;
	u8 pad2;
} efi_time_t;

typedef struct {
	u32 resolution;
	u32 accuracy;
	u8 sets_to_zero;
} efi_time_cap_t;

typedef struct {
	efi_table_hdr_t hdr;
	u32 get_time;
	u32 set_time;
	u32 get_wakeup_time;
	u32 set_wakeup_time;
	u32 set_virtual_address_map;
	u32 convert_pointer;
	u32 get_variable;
	u32 get_next_variable;
	u32 set_variable;
	u32 get_next_high_mono_count;
	u32 reset_system;
	u32 update_capsule;
	u32 query_capsule_caps;
	u32 query_variable_info;
} efi_runtime_services_32_t;

typedef efi_status_t efi_get_time_t(efi_time_t *, efi_time_cap_t *);

typedef efi_status_t efi_set_time_t(efi_time_t *);

typedef efi_status_t efi_get_wakeup_time_t(efi_bool_t *, efi_bool_t *, efi_time_t *);

typedef efi_status_t efi_set_wakeup_time_t(efi_bool_t, efi_time_t *);

typedef efi_status_t efi_get_variable_t(efi_char16_t *, efi_guid_t *, u32 *, long unsigned int *, void *);

typedef efi_status_t efi_get_next_variable_t(long unsigned int *, efi_char16_t *, efi_guid_t *);

typedef efi_status_t efi_set_variable_t(efi_char16_t *, efi_guid_t *, u32, long unsigned int, void *);

typedef efi_status_t efi_get_next_high_mono_count_t(u32 *);

typedef void efi_reset_system_t(int, efi_status_t, long unsigned int, efi_char16_t *);

typedef efi_status_t efi_set_virtual_address_map_t(long unsigned int, long unsigned int, u32, efi_memory_desc_t *);

typedef efi_status_t efi_query_variable_info_t(u32, u64 *, u64 *, u64 *);

typedef efi_status_t efi_update_capsule_t(efi_capsule_header_t **, long unsigned int, long unsigned int);

typedef efi_status_t efi_query_capsule_caps_t(efi_capsule_header_t **, long unsigned int, u64 *, int *);

typedef efi_status_t efi_query_variable_store_t(u32, long unsigned int, bool);

typedef union {
	struct {
		efi_table_hdr_t hdr;
		efi_get_time_t *get_time;
		efi_set_time_t *set_time;
		efi_get_wakeup_time_t *get_wakeup_time;
		efi_set_wakeup_time_t *set_wakeup_time;
		efi_set_virtual_address_map_t *set_virtual_address_map;
		void *convert_pointer;
		efi_get_variable_t *get_variable;
		efi_get_next_variable_t *get_next_variable;
		efi_set_variable_t *set_variable;
		efi_get_next_high_mono_count_t *get_next_high_mono_count;
		efi_reset_system_t *reset_system;
		efi_update_capsule_t *update_capsule;
		efi_query_capsule_caps_t *query_capsule_caps;
		efi_query_variable_info_t *query_variable_info;
	};
	efi_runtime_services_32_t mixed_mode;
} efi_runtime_services_t;

typedef struct {
	efi_guid_t guid;
	u64 table;
} efi_config_table_64_t;

typedef struct {
	efi_guid_t guid;
	u32 table;
} efi_config_table_32_t;

typedef union {
	struct {
		efi_guid_t guid;
		void *table;
	};
	efi_config_table_32_t mixed_mode;
} efi_config_table_t;

typedef struct {
	efi_guid_t guid;
	long unsigned int *ptr;
	const char name[16];
} efi_config_table_type_t;

struct efi_memory_map {
	phys_addr_t phys_map;
	void *map;
	void *map_end;
	int nr_map;
	long unsigned int desc_version;
	long unsigned int desc_size;
	long unsigned int flags;
};

typedef struct {
	u16 version;
	u16 length;
	u32 runtime_services_supported;
} efi_rt_properties_table_t;

struct efi {
	const efi_runtime_services_t *runtime;
	unsigned int runtime_version;
	unsigned int runtime_supported_mask;
	long unsigned int acpi;
	long unsigned int acpi20;
	long unsigned int smbios;
	long unsigned int smbios3;
	long unsigned int esrt;
	long unsigned int tpm_log;
	long unsigned int tpm_final_log;
	long unsigned int mokvar_table;
	efi_get_time_t *get_time;
	efi_set_time_t *set_time;
	efi_get_wakeup_time_t *get_wakeup_time;
	efi_set_wakeup_time_t *set_wakeup_time;
	efi_get_variable_t *get_variable;
	efi_get_next_variable_t *get_next_variable;
	efi_set_variable_t *set_variable;
	efi_set_variable_t *set_variable_nonblocking;
	efi_query_variable_info_t *query_variable_info;
	efi_query_variable_info_t *query_variable_info_nonblocking;
	efi_update_capsule_t *update_capsule;
	efi_query_capsule_caps_t *query_capsule_caps;
	efi_get_next_high_mono_count_t *get_next_high_mono_count;
	efi_reset_system_t *reset_system;
	struct efi_memory_map memmap;
	long unsigned int flags;
};

struct efivar_operations {
	efi_get_variable_t *get_variable;
	efi_get_next_variable_t *get_next_variable;
	efi_set_variable_t *set_variable;
	efi_set_variable_t *set_variable_nonblocking;
	efi_query_variable_store_t *query_variable_store;
};

struct efivars {
	struct kset *kset;
	struct kobject *kobject;
	const struct efivar_operations *ops;
};

struct linux_efi_random_seed {
	u32 size;
	u8 bits[0];
};

struct linux_efi_memreserve {
	int size;
	atomic_t count;
	phys_addr_t next;
	struct {
		phys_addr_t base;
		phys_addr_t size;
	} entry[0];
};

struct efi_generic_dev_path {
	u8 type;
	u8 sub_type;
	u16 length;
};

struct efi_variable {
	efi_char16_t VariableName[512];
	efi_guid_t VendorGuid;
	long unsigned int DataSize;
	__u8 Data[1024];
	efi_status_t Status;
	__u32 Attributes;
} __attribute__((packed));

struct efivar_entry {
	struct efi_variable var;
	struct list_head list;
	struct kobject kobj;
	bool scanning;
	bool deleting;
};

struct variable_validate {
	efi_guid_t vendor;
	char *name;
	bool (*validate)(efi_char16_t *, int, u8 *, long unsigned int);
};

typedef struct {
	u32 version;
	u32 num_entries;
	u32 desc_size;
	u32 reserved;
	efi_memory_desc_t entry[0];
} efi_memory_attributes_table_t;

typedef int (*efi_memattr_perm_setter)(struct mm_struct *, efi_memory_desc_t *);

struct linux_efi_tpm_eventlog {
	u32 size;
	u32 final_events_preboot_size;
	u8 version;
	u8 log[0];
};

struct efi_tcg2_final_events_table {
	u64 version;
	u64 nr_events;
	u8 events[0];
};

struct tpm_digest {
	u16 alg_id;
	u8 digest[64];
};

enum tpm_duration {
	TPM_SHORT = 0,
	TPM_MEDIUM = 1,
	TPM_LONG = 2,
	TPM_LONG_LONG = 3,
	TPM_UNDEFINED = 4,
	TPM_NUM_DURATIONS = 4,
};

enum tcpa_event_types {
	PREBOOT = 0,
	POST_CODE = 1,
	UNUSED = 2,
	NO_ACTION = 3,
	SEPARATOR = 4,
	ACTION = 5,
	EVENT_TAG = 6,
	SCRTM_CONTENTS = 7,
	SCRTM_VERSION = 8,
	CPU_MICROCODE = 9,
	PLATFORM_CONFIG_FLAGS = 10,
	TABLE_OF_DEVICES = 11,
	COMPACT_HASH = 12,
	IPL = 13,
	IPL_PARTITION_DATA = 14,
	NONHOST_CODE = 15,
	NONHOST_CONFIG = 16,
	NONHOST_INFO = 17,
};

struct tcg_efi_specid_event_algs {
	u16 alg_id;
	u16 digest_size;
};

struct tcg_efi_specid_event_head {
	u8 signature[16];
	u32 platform_class;
	u8 spec_version_minor;
	u8 spec_version_major;
	u8 spec_errata;
	u8 uintnsize;
	u32 num_algs;
	struct tcg_efi_specid_event_algs digest_sizes[0];
};

struct tcg_pcr_event {
	u32 pcr_idx;
	u32 event_type;
	u8 digest[20];
	u32 event_size;
	u8 event[0];
};

struct tcg_event_field {
	u32 event_size;
	u8 event[0];
};

struct tcg_pcr_event2_head {
	u32 pcr_idx;
	u32 event_type;
	u32 count;
	struct tpm_digest digests[0];
};

typedef u64 efi_physical_addr_t;

typedef struct {
	u64 length;
	u64 data;
} efi_capsule_block_desc_t;

struct efi_memory_map_data {
	phys_addr_t phys_map;
	long unsigned int size;
	long unsigned int desc_version;
	long unsigned int desc_size;
	long unsigned int flags;
};

struct efi_mem_range {
	struct range range;
	u64 attribute;
};

enum {
	SYSTAB = 0,
	MMBASE = 1,
	MMSIZE = 2,
	DCSIZE = 3,
	DCVERS = 4,
	PARAMCOUNT = 5,
};

struct efi_system_resource_entry_v1 {
	efi_guid_t fw_class;
	u32 fw_type;
	u32 fw_version;
	u32 lowest_supported_fw_version;
	u32 capsule_flags;
	u32 last_attempt_version;
	u32 last_attempt_status;
};

struct efi_system_resource_table {
	u32 fw_resource_count;
	u32 fw_resource_count_max;
	u64 fw_resource_version;
	u8 entries[0];
};

struct esre_entry {
	union {
		struct efi_system_resource_entry_v1 *esre1;
	} esre;
	struct kobject kobj;
	struct list_head list;
};

struct esre_attribute {
	struct attribute attr;
	ssize_t (*show)(struct esre_entry *, char *);
	ssize_t (*store)(struct esre_entry *, const char *, size_t);
};

enum efi_rts_ids {
	EFI_NONE = 0,
	EFI_GET_TIME = 1,
	EFI_SET_TIME = 2,
	EFI_GET_WAKEUP_TIME = 3,
	EFI_SET_WAKEUP_TIME = 4,
	EFI_GET_VARIABLE = 5,
	EFI_GET_NEXT_VARIABLE = 6,
	EFI_SET_VARIABLE = 7,
	EFI_QUERY_VARIABLE_INFO = 8,
	EFI_GET_NEXT_HIGH_MONO_COUNT = 9,
	EFI_RESET_SYSTEM = 10,
	EFI_UPDATE_CAPSULE = 11,
	EFI_QUERY_CAPSULE_CAPS = 12,
};

struct efi_runtime_work {
	void *arg1;
	void *arg2;
	void *arg3;
	void *arg4;
	void *arg5;
	efi_status_t status;
	struct work_struct work;
	enum efi_rts_ids efi_rts_id;
	struct completion efi_rts_comp;
};

typedef void *efi_event_t;

typedef void (*efi_event_notify_t)(efi_event_t, void *);

typedef enum {
	EfiTimerCancel = 0,
	EfiTimerPeriodic = 1,
	EfiTimerRelative = 2,
} EFI_TIMER_DELAY;

typedef void *efi_handle_t;

typedef struct efi_generic_dev_path efi_device_path_protocol_t;

union efi_boot_services {
	struct {
		efi_table_hdr_t hdr;
		void *raise_tpl;
		void *restore_tpl;
		efi_status_t (*allocate_pages)(int, int, long unsigned int, efi_physical_addr_t *);
		efi_status_t (*free_pages)(efi_physical_addr_t, long unsigned int);
		efi_status_t (*get_memory_map)(long unsigned int *, void *, long unsigned int *, long unsigned int *, u32 *);
		efi_status_t (*allocate_pool)(int, long unsigned int, void **);
		efi_status_t (*free_pool)(void *);
		efi_status_t (*create_event)(u32, long unsigned int, efi_event_notify_t, void *, efi_event_t *);
		efi_status_t (*set_timer)(efi_event_t, EFI_TIMER_DELAY, u64);
		efi_status_t (*wait_for_event)(long unsigned int, efi_event_t *, long unsigned int *);
		void *signal_event;
		efi_status_t (*close_event)(efi_event_t);
		void *check_event;
		void *install_protocol_interface;
		void *reinstall_protocol_interface;
		void *uninstall_protocol_interface;
		efi_status_t (*handle_protocol)(efi_handle_t, efi_guid_t *, void **);
		void *__reserved;
		void *register_protocol_notify;
		efi_status_t (*locate_handle)(int, efi_guid_t *, void *, long unsigned int *, efi_handle_t *);
		efi_status_t (*locate_device_path)(efi_guid_t *, efi_device_path_protocol_t **, efi_handle_t *);
		efi_status_t (*install_configuration_table)(efi_guid_t *, void *);
		void *load_image;
		void *start_image;
		efi_status_t (*exit)(efi_handle_t, efi_status_t, long unsigned int, efi_char16_t *);
		void *unload_image;
		efi_status_t (*exit_boot_services)(efi_handle_t, long unsigned int);
		void *get_next_monotonic_count;
		efi_status_t (*stall)(long unsigned int);
		void *set_watchdog_timer;
		void *connect_controller;
		efi_status_t (*disconnect_controller)(efi_handle_t, efi_handle_t, efi_handle_t);
		void *open_protocol;
		void *close_protocol;
		void *open_protocol_information;
		void *protocols_per_handle;
		void *locate_handle_buffer;
		efi_status_t (*locate_protocol)(efi_guid_t *, void *, void **);
		void *install_multiple_protocol_interfaces;
		void *uninstall_multiple_protocol_interfaces;
		void *calculate_crc32;
		void *copy_mem;
		void *set_mem;
		void *create_event_ex;
	};
	struct {
		efi_table_hdr_t hdr;
		u32 raise_tpl;
		u32 restore_tpl;
		u32 allocate_pages;
		u32 free_pages;
		u32 get_memory_map;
		u32 allocate_pool;
		u32 free_pool;
		u32 create_event;
		u32 set_timer;
		u32 wait_for_event;
		u32 signal_event;
		u32 close_event;
		u32 check_event;
		u32 install_protocol_interface;
		u32 reinstall_protocol_interface;
		u32 uninstall_protocol_interface;
		u32 handle_protocol;
		u32 __reserved;
		u32 register_protocol_notify;
		u32 locate_handle;
		u32 locate_device_path;
		u32 install_configuration_table;
		u32 load_image;
		u32 start_image;
		u32 exit;
		u32 unload_image;
		u32 exit_boot_services;
		u32 get_next_monotonic_count;
		u32 stall;
		u32 set_watchdog_timer;
		u32 connect_controller;
		u32 disconnect_controller;
		u32 open_protocol;
		u32 close_protocol;
		u32 open_protocol_information;
		u32 protocols_per_handle;
		u32 locate_handle_buffer;
		u32 locate_protocol;
		u32 install_multiple_protocol_interfaces;
		u32 uninstall_multiple_protocol_interfaces;
		u32 calculate_crc32;
		u32 copy_mem;
		u32 set_mem;
		u32 create_event_ex;
	} mixed_mode;
};

typedef union efi_boot_services efi_boot_services_t;

typedef struct {
	efi_table_hdr_t hdr;
	u32 fw_vendor;
	u32 fw_revision;
	u32 con_in_handle;
	u32 con_in;
	u32 con_out_handle;
	u32 con_out;
	u32 stderr_handle;
	u32 stderr;
	u32 runtime;
	u32 boottime;
	u32 nr_tables;
	u32 tables;
} efi_system_table_32_t;

typedef struct {
	u16 scan_code;
	efi_char16_t unicode_char;
} efi_input_key_t;

union efi_simple_text_input_protocol;

typedef union efi_simple_text_input_protocol efi_simple_text_input_protocol_t;

union efi_simple_text_input_protocol {
	struct {
		void *reset;
		efi_status_t (*read_keystroke)(efi_simple_text_input_protocol_t *, efi_input_key_t *);
		efi_event_t wait_for_key;
	};
	struct {
		u32 reset;
		u32 read_keystroke;
		u32 wait_for_key;
	} mixed_mode;
};

union efi_simple_text_output_protocol;

typedef union efi_simple_text_output_protocol efi_simple_text_output_protocol_t;

union efi_simple_text_output_protocol {
	struct {
		void *reset;
		efi_status_t (*output_string)(efi_simple_text_output_protocol_t *, efi_char16_t *);
		void *test_string;
	};
	struct {
		u32 reset;
		u32 output_string;
		u32 test_string;
	} mixed_mode;
};

typedef union {
	struct {
		efi_table_hdr_t hdr;
		long unsigned int fw_vendor;
		u32 fw_revision;
		long unsigned int con_in_handle;
		efi_simple_text_input_protocol_t *con_in;
		long unsigned int con_out_handle;
		efi_simple_text_output_protocol_t *con_out;
		long unsigned int stderr_handle;
		long unsigned int stderr;
		efi_runtime_services_t *runtime;
		efi_boot_services_t *boottime;
		long unsigned int nr_tables;
		long unsigned int tables;
	};
	efi_system_table_32_t mixed_mode;
} efi_system_table_t;

struct mbox_client {
	struct device *dev;
	bool tx_block;
	long unsigned int tx_tout;
	bool knows_txdone;
	void (*rx_callback)(struct mbox_client *, void *);
	void (*tx_prepare)(struct mbox_client *, void *);
	void (*tx_done)(struct mbox_client *, void *, int);
};

struct mbox_chan;

struct light_aon_ipc;

struct light_aon_chan {
	struct light_aon_ipc *aon_ipc;
	struct mbox_client cl;
	struct mbox_chan *ch;
	struct completion tx_done;
};

struct light_aon_ipc {
	struct light_aon_chan chans;
	struct device *dev;
	struct mutex lock;
	struct completion done;
	u32 *msg;
};

enum light_aon_error_codes {
	LIGHT_AON_ERR_NONE = 0,
	LIGHT_AON_ERR_VERSION = 1,
	LIGHT_AON_ERR_CONFIG = 2,
	LIGHT_AON_ERR_PARM = 3,
	LIGHT_AON_ERR_NOACCESS = 4,
	LIGHT_AON_ERR_LOCKED = 5,
	LIGHT_AON_ERR_UNAVAILABLE = 6,
	LIGHT_AON_ERR_NOTFOUND = 7,
	LIGHT_AON_ERR_NOPOWER = 8,
	LIGHT_AON_ERR_IPC = 9,
	LIGHT_AON_ERR_BUSY = 10,
	LIGHT_AON_ERR_FAIL = 11,
	LIGHT_AON_ERR_LAST = 12,
};

struct light_aon_msg_req_misc_set_ctrl {
	struct light_aon_rpc_msg_hdr hdr;
	u32 ctrl;
	u32 val;
	u16 resource;
	u16 reserved[7];
};

struct light_aon_msg_req_misc_get_ctrl {
	struct light_aon_rpc_msg_hdr hdr;
	u32 ctrl;
	u16 resource;
	u16 reserved[9];
};

struct light_aon_msg_resp_misc_get_ctrl {
	struct light_aon_rpc_msg_hdr hdr;
	u32 val;
	u32 reserved[5];
};

struct light_aon_device {
	struct device *dev;
	char *test_buf;
	struct light_aon_ipc *ipc_handle;
};

struct light_aon_msg_req_set_resource_power_mode {
	struct light_aon_rpc_msg_hdr hdr;
	u16 resource;
	u16 mode;
	u16 reserved[10];
};

struct light_aon_pm_domain {
	struct generic_pm_domain pd;
	char name[20];
	u16 rsrc;
};

struct light_aon_pd_range {
	char *name;
	u32 rsrc;
	u8 num;
	bool postfix;
	u8 start_from;
};

struct light_aon_pd_soc {
	const struct light_aon_pd_range *pd_ranges;
	u8 num_ranges;
};

struct of_timer_irq {
	int irq;
	int index;
	int percpu;
	const char *name;
	long unsigned int flags;
	irq_handler_t handler;
};

struct of_timer_base {
	void *base;
	const char *name;
	int index;
};

struct of_timer_clk {
	struct clk *clk;
	const char *name;
	int index;
	long unsigned int rate;
	long unsigned int period;
};

struct timer_of {
	unsigned int flags;
	struct device_node *np;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct clock_event_device clkevt;
	struct of_timer_base of_base;
	struct of_timer_irq of_irq;
	struct of_timer_clk of_clk;
	void *private_data;
	long: 64;
	long: 64;
};

typedef int (*of_init_fn_1_ret)(struct device_node *);

struct hid_item {
	unsigned int format;
	__u8 size;
	__u8 type;
	__u8 tag;
	union {
		__u8 u8;
		__s8 s8;
		__u16 u16;
		__s16 s16;
		__u32 u32;
		__s32 s32;
		__u8 *longdata;
	} data;
};

struct hid_global {
	unsigned int usage_page;
	__s32 logical_minimum;
	__s32 logical_maximum;
	__s32 physical_minimum;
	__s32 physical_maximum;
	__s32 unit_exponent;
	unsigned int unit;
	unsigned int report_id;
	unsigned int report_size;
	unsigned int report_count;
};

struct hid_local {
	unsigned int usage[12288];
	u8 usage_size[12288];
	unsigned int collection_index[12288];
	unsigned int usage_index;
	unsigned int usage_minimum;
	unsigned int delimiter_depth;
	unsigned int delimiter_branch;
};

struct hid_parser {
	struct hid_global global;
	struct hid_global global_stack[4];
	unsigned int global_stack_ptr;
	struct hid_local local;
	unsigned int *collection_stack;
	unsigned int collection_stack_ptr;
	unsigned int collection_stack_size;
	struct hid_device *device;
	unsigned int scan_flags;
};

struct hiddev {
	int minor;
	int exist;
	int open;
	struct mutex existancelock;
	wait_queue_head_t wait;
	struct hid_device *hid;
	struct list_head list;
	spinlock_t list_lock;
	bool initialized;
};

struct hidraw {
	unsigned int minor;
	int exist;
	int open;
	wait_queue_head_t wait;
	struct hid_device *hid;
	struct device *dev;
	spinlock_t list_lock;
	struct list_head list;
};

struct hid_dynid {
	struct list_head list;
	struct hid_device_id id;
};

typedef bool (*hid_usage_cmp_t)(struct hid_usage *, unsigned int, unsigned int);

struct quirks_list_struct {
	struct hid_device_id hid_bl_item;
	struct list_head node;
};

struct hid_debug_list {
	struct {
		union {
			struct __kfifo kfifo;
			char *type;
			const char *const_type;
			char (*rectype)[0];
			char *ptr;
			const char *ptr_const;
		};
		char buf[0];
	} hid_debug_fifo;
	struct fasync_struct *fasync;
	struct hid_device *hdev;
	struct list_head node;
	struct mutex read_mutex;
};

struct hid_usage_entry {
	unsigned int page;
	unsigned int usage;
	const char *description;
};

enum uhid_event_type {
	__UHID_LEGACY_CREATE = 0,
	UHID_DESTROY = 1,
	UHID_START = 2,
	UHID_STOP = 3,
	UHID_OPEN = 4,
	UHID_CLOSE = 5,
	UHID_OUTPUT = 6,
	__UHID_LEGACY_OUTPUT_EV = 7,
	__UHID_LEGACY_INPUT = 8,
	UHID_GET_REPORT = 9,
	UHID_GET_REPORT_REPLY = 10,
	UHID_CREATE2 = 11,
	UHID_INPUT2 = 12,
	UHID_SET_REPORT = 13,
	UHID_SET_REPORT_REPLY = 14,
};

struct uhid_create2_req {
	__u8 name[128];
	__u8 phys[64];
	__u8 uniq[64];
	__u16 rd_size;
	__u16 bus;
	__u32 vendor;
	__u32 product;
	__u32 version;
	__u32 country;
	__u8 rd_data[4096];
};

enum uhid_dev_flag {
	UHID_DEV_NUMBERED_FEATURE_REPORTS = 1,
	UHID_DEV_NUMBERED_OUTPUT_REPORTS = 2,
	UHID_DEV_NUMBERED_INPUT_REPORTS = 4,
};

struct uhid_start_req {
	__u64 dev_flags;
};

enum uhid_report_type {
	UHID_FEATURE_REPORT = 0,
	UHID_OUTPUT_REPORT = 1,
	UHID_INPUT_REPORT = 2,
};

struct uhid_input2_req {
	__u16 size;
	__u8 data[4096];
};

struct uhid_output_req {
	__u8 data[4096];
	__u16 size;
	__u8 rtype;
} __attribute__((packed));

struct uhid_get_report_req {
	__u32 id;
	__u8 rnum;
	__u8 rtype;
} __attribute__((packed));

struct uhid_get_report_reply_req {
	__u32 id;
	__u16 err;
	__u16 size;
	__u8 data[4096];
};

struct uhid_set_report_req {
	__u32 id;
	__u8 rnum;
	__u8 rtype;
	__u16 size;
	__u8 data[4096];
};

struct uhid_set_report_reply_req {
	__u32 id;
	__u16 err;
} __attribute__((packed));

enum uhid_legacy_event_type {
	UHID_CREATE = 0,
	UHID_OUTPUT_EV = 7,
	UHID_INPUT = 8,
	UHID_FEATURE = 9,
	UHID_FEATURE_ANSWER = 10,
};

struct uhid_create_req {
	__u8 name[128];
	__u8 phys[64];
	__u8 uniq[64];
	__u8 *rd_data;
	__u16 rd_size;
	__u16 bus;
	__u32 vendor;
	__u32 product;
	__u32 version;
	__u32 country;
} __attribute__((packed));

struct uhid_input_req {
	__u8 data[4096];
	__u16 size;
};

struct uhid_output_ev_req {
	__u16 type;
	__u16 code;
	__s32 value;
};

struct uhid_feature_req {
	__u32 id;
	__u8 rnum;
	__u8 rtype;
} __attribute__((packed));

struct uhid_feature_answer_req {
	__u32 id;
	__u16 err;
	__u16 size;
	__u8 data[4096];
};

struct uhid_event {
	__u32 type;
	union {
		struct uhid_create_req create;
		struct uhid_input_req input;
		struct uhid_output_req output;
		struct uhid_output_ev_req output_ev;
		struct uhid_feature_req feature;
		struct uhid_get_report_req get_report;
		struct uhid_feature_answer_req feature_answer;
		struct uhid_get_report_reply_req get_report_reply;
		struct uhid_create2_req create2;
		struct uhid_input2_req input2;
		struct uhid_set_report_req set_report;
		struct uhid_set_report_reply_req set_report_reply;
		struct uhid_start_req start;
	} u;
} __attribute__((packed));

struct uhid_device {
	struct mutex devlock;
	bool running;
	long: 56;
	__u8 *rd_data;
	uint rd_size;
	int: 32;
	struct hid_device *hid;
	struct uhid_event input_buf;
	int: 32;
	wait_queue_head_t waitq;
	spinlock_t qlock;
	__u8 head;
	__u8 tail;
	short: 16;
	struct uhid_event *outq[32];
	struct mutex report_lock;
	wait_queue_head_t report_wait;
	bool report_running;
	int: 24;
	u32 report_id;
	u32 report_type;
	struct uhid_event report_buf;
	struct work_struct worker;
} __attribute__((packed));

struct hid_control_fifo {
	unsigned char dir;
	struct hid_report *report;
	char *raw_report;
};

struct hid_output_fifo {
	struct hid_report *report;
	char *raw_report;
};

struct hid_class_descriptor {
	__u8 bDescriptorType;
	__le16 wDescriptorLength;
} __attribute__((packed));

struct hid_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__le16 bcdHID;
	__u8 bCountryCode;
	__u8 bNumDescriptors;
	struct hid_class_descriptor desc[1];
} __attribute__((packed));

struct usbhid_device {
	struct hid_device *hid;
	struct usb_interface *intf;
	int ifnum;
	unsigned int bufsize;
	struct urb *urbin;
	char *inbuf;
	dma_addr_t inbuf_dma;
	struct urb *urbctrl;
	struct usb_ctrlrequest *cr;
	struct hid_control_fifo ctrl[256];
	unsigned char ctrlhead;
	unsigned char ctrltail;
	char *ctrlbuf;
	dma_addr_t ctrlbuf_dma;
	long unsigned int last_ctrl;
	struct urb *urbout;
	struct hid_output_fifo out[256];
	unsigned char outhead;
	unsigned char outtail;
	char *outbuf;
	dma_addr_t outbuf_dma;
	long unsigned int last_out;
	struct mutex mutex;
	spinlock_t lock;
	long unsigned int iofl;
	struct timer_list io_retry;
	long unsigned int stop_retry;
	unsigned int retry_delay;
	struct work_struct reset_work;
	wait_queue_head_t wait;
};

struct hiddev_event {
	unsigned int hid;
	int value;
};

struct hiddev_devinfo {
	__u32 bustype;
	__u32 busnum;
	__u32 devnum;
	__u32 ifnum;
	__s16 vendor;
	__s16 product;
	__s16 version;
	__u32 num_applications;
};

struct hiddev_collection_info {
	__u32 index;
	__u32 type;
	__u32 usage;
	__u32 level;
};

struct hiddev_report_info {
	__u32 report_type;
	__u32 report_id;
	__u32 num_fields;
};

struct hiddev_field_info {
	__u32 report_type;
	__u32 report_id;
	__u32 field_index;
	__u32 maxusage;
	__u32 flags;
	__u32 physical;
	__u32 logical;
	__u32 application;
	__s32 logical_minimum;
	__s32 logical_maximum;
	__s32 physical_minimum;
	__s32 physical_maximum;
	__u32 unit_exponent;
	__u32 unit;
};

struct hiddev_usage_ref {
	__u32 report_type;
	__u32 report_id;
	__u32 field_index;
	__u32 usage_index;
	__u32 usage_code;
	__s32 value;
};

struct hiddev_usage_ref_multi {
	struct hiddev_usage_ref uref;
	__u32 num_values;
	__s32 values[1024];
};

struct hiddev_list {
	struct hiddev_usage_ref buffer[2048];
	int head;
	int tail;
	unsigned int flags;
	struct fasync_struct *fasync;
	struct hiddev *hiddev;
	struct list_head node;
	struct mutex thread_lock;
};

struct pidff_usage {
	struct hid_field *field;
	s32 *value;
};

struct pidff_device {
	struct hid_device *hid;
	struct hid_report *reports[13];
	struct pidff_usage set_effect[7];
	struct pidff_usage set_envelope[5];
	struct pidff_usage set_condition[8];
	struct pidff_usage set_periodic[5];
	struct pidff_usage set_constant[2];
	struct pidff_usage set_ramp[3];
	struct pidff_usage device_gain[1];
	struct pidff_usage block_load[2];
	struct pidff_usage pool[3];
	struct pidff_usage effect_operation[2];
	struct pidff_usage block_free[1];
	struct hid_field *create_new_effect_type;
	struct hid_field *set_effect_type;
	struct hid_field *effect_direction;
	struct hid_field *device_control;
	struct hid_field *block_load_status;
	struct hid_field *effect_operation_status;
	int control_id[2];
	int type_id[11];
	int status_id[2];
	int operation_id[2];
	int pid_id[64];
};

struct alias_prop {
	struct list_head link;
	const char *alias;
	struct device_node *np;
	int id;
	char stem[0];
};

struct amba_cs_uci_id {
	unsigned int devarch;
	unsigned int devarch_mask;
	unsigned int devtype;
	void *data;
};

struct amba_device {
	struct device dev;
	struct resource res;
	struct clk *pclk;
	struct device_dma_parameters dma_parms;
	unsigned int periphid;
	unsigned int cid;
	struct amba_cs_uci_id uci;
	unsigned int irq[9];
	char *driver_override;
};

struct of_dev_auxdata {
	char *compatible;
	resource_size_t phys_addr;
	char *name;
	void *platform_data;
};

struct supplier_bindings {
	struct device_node * (*parse_prop)(struct device_node *, const char *, int);
	bool optional;
};

struct of_bus {
	void (*count_cells)(const void *, int, int *, int *);
	u64 (*map)(__be32 *, const __be32 *, int, int, int);
	int (*translate)(__be32 *, u64, int);
};

struct of_bus___2;

struct of_pci_range_parser {
	struct device_node *node;
	struct of_bus___2 *bus;
	const __be32 *range;
	const __be32 *end;
	int na;
	int ns;
	int pna;
	bool dma;
};

struct of_bus___2 {
	const char *name;
	const char *addresses;
	int (*match)(struct device_node *);
	void (*count_cells)(struct device_node *, int *, int *);
	u64 (*map)(__be32 *, const __be32 *, int, int, int);
	int (*translate)(__be32 *, u64, int);
	bool has_flags;
	unsigned int (*get_flags)(const __be32 *);
};

struct of_pci_range {
	union {
		u64 pci_addr;
		u64 bus_addr;
	};
	u64 cpu_addr;
	u64 size;
	u32 flags;
};

struct of_intc_desc {
	struct list_head list;
	of_irq_init_cb_t irq_init_cb;
	struct device_node *dev;
	struct device_node *interrupt_parent;
};

struct rmem_assigned_device {
	struct device *dev;
	struct reserved_mem *rmem;
	struct list_head list;
};

enum {
	VHOST_FEATURES = 1023410176,
};

enum {
	VHOST_NET_FEATURES = 1023442944,
};

enum {
	VHOST_NET_BACKEND_FEATURES = 2,
};

enum {
	VHOST_NET_VQ_RX = 0,
	VHOST_NET_VQ_TX = 1,
	VHOST_NET_VQ_MAX = 2,
};

struct vhost_net_ubuf_ref {
	atomic_t refcount;
	wait_queue_head_t wait;
	struct vhost_virtqueue *vq;
};

struct vhost_net_buf {
	void **queue;
	int tail;
	int head;
};

struct vhost_net_virtqueue {
	struct vhost_virtqueue vq;
	size_t vhost_hlen;
	size_t sock_hlen;
	int upend_idx;
	int done_idx;
	int batched_xdp;
	struct ubuf_info *ubuf_info;
	struct vhost_net_ubuf_ref *ubufs;
	struct ptr_ring *rx_ring;
	struct vhost_net_buf rxq;
	struct xdp_buff *xdp;
};

struct vhost_net {
	struct vhost_dev dev;
	struct vhost_net_virtqueue vqs[2];
	struct vhost_poll poll[2];
	unsigned int tx_packets;
	unsigned int tx_zcopy_err;
	bool tx_flush;
	struct page_frag page_frag;
	int refcnt_bias;
};

struct virtio_vsock_hdr {
	__le64 src_cid;
	__le64 dst_cid;
	__le32 src_port;
	__le32 dst_port;
	__le32 len;
	__le16 type;
	__le16 op;
	__le32 flags;
	__le32 buf_alloc;
	__le32 fwd_cnt;
} __attribute__((packed));

enum virtio_vsock_type {
	VIRTIO_VSOCK_TYPE_STREAM = 1,
};

struct sockaddr_vm {
	__kernel_sa_family_t svm_family;
	short unsigned int svm_reserved1;
	unsigned int svm_port;
	unsigned int svm_cid;
	unsigned char svm_zero[4];
};

struct vsock_transport;

struct vsock_sock {
	struct sock sk;
	const struct vsock_transport *transport;
	struct sockaddr_vm local_addr;
	struct sockaddr_vm remote_addr;
	struct list_head bound_table;
	struct list_head connected_table;
	bool trusted;
	bool cached_peer_allow_dgram;
	u32 cached_peer;
	const struct cred *owner;
	long int connect_timeout;
	struct sock *listener;
	struct list_head pending_links;
	struct list_head accept_queue;
	bool rejected;
	struct delayed_work connect_work;
	struct delayed_work pending_work;
	struct delayed_work close_work;
	bool close_work_scheduled;
	u32 peer_shutdown;
	bool sent_request;
	bool ignore_connecting_rst;
	u64 buffer_size;
	u64 buffer_min_size;
	u64 buffer_max_size;
	void *trans;
};

struct vsock_transport_recv_notify_data;

struct vsock_transport_send_notify_data;

struct vsock_transport {
	struct module *module;
	int (*init)(struct vsock_sock *, struct vsock_sock *);
	void (*destruct)(struct vsock_sock *);
	void (*release)(struct vsock_sock *);
	int (*cancel_pkt)(struct vsock_sock *);
	int (*connect)(struct vsock_sock *);
	int (*dgram_bind)(struct vsock_sock *, struct sockaddr_vm *);
	int (*dgram_dequeue)(struct vsock_sock *, struct msghdr *, size_t, int);
	int (*dgram_enqueue)(struct vsock_sock *, struct sockaddr_vm *, struct msghdr *, size_t);
	bool (*dgram_allow)(u32, u32);
	ssize_t (*stream_dequeue)(struct vsock_sock *, struct msghdr *, size_t, int);
	ssize_t (*stream_enqueue)(struct vsock_sock *, struct msghdr *, size_t);
	s64 (*stream_has_data)(struct vsock_sock *);
	s64 (*stream_has_space)(struct vsock_sock *);
	u64 (*stream_rcvhiwat)(struct vsock_sock *);
	bool (*stream_is_active)(struct vsock_sock *);
	bool (*stream_allow)(u32, u32);
	int (*notify_poll_in)(struct vsock_sock *, size_t, bool *);
	int (*notify_poll_out)(struct vsock_sock *, size_t, bool *);
	int (*notify_recv_init)(struct vsock_sock *, size_t, struct vsock_transport_recv_notify_data *);
	int (*notify_recv_pre_block)(struct vsock_sock *, size_t, struct vsock_transport_recv_notify_data *);
	int (*notify_recv_pre_dequeue)(struct vsock_sock *, size_t, struct vsock_transport_recv_notify_data *);
	int (*notify_recv_post_dequeue)(struct vsock_sock *, size_t, ssize_t, bool, struct vsock_transport_recv_notify_data *);
	int (*notify_send_init)(struct vsock_sock *, struct vsock_transport_send_notify_data *);
	int (*notify_send_pre_block)(struct vsock_sock *, struct vsock_transport_send_notify_data *);
	int (*notify_send_pre_enqueue)(struct vsock_sock *, struct vsock_transport_send_notify_data *);
	int (*notify_send_post_enqueue)(struct vsock_sock *, ssize_t, struct vsock_transport_send_notify_data *);
	void (*notify_buffer_size)(struct vsock_sock *, u64 *);
	int (*shutdown)(struct vsock_sock *, int);
	u32 (*get_local_cid)();
};

struct vsock_transport_recv_notify_data {
	u64 data1;
	u64 data2;
	bool notify_on_block;
};

struct vsock_transport_send_notify_data {
	u64 data1;
	u64 data2;
};

enum {
	VSOCK_VQ_RX = 0,
	VSOCK_VQ_TX = 1,
	VSOCK_VQ_EVENT = 2,
	VSOCK_VQ_MAX = 3,
};

struct virtio_vsock_pkt {
	struct virtio_vsock_hdr hdr;
	struct list_head list;
	struct vsock_sock *vsk;
	void *buf;
	u32 buf_len;
	u32 len;
	u32 off;
	bool reply;
	bool tap_delivered;
};

struct virtio_transport {
	struct vsock_transport transport;
	int (*send_pkt)(struct virtio_vsock_pkt *);
};

enum {
	VHOST_VSOCK_FEATURES = 1023410176,
};

struct vhost_vsock {
	struct vhost_dev dev;
	struct vhost_virtqueue vqs[2];
	struct hlist_node hash;
	struct vhost_work send_pkt_work;
	spinlock_t send_pkt_list_lock;
	struct list_head send_pkt_list;
	atomic_t queued_replies;
	u32 guest_cid;
};

struct vringh_range {
	u64 start;
	u64 end_incl;
	u64 offset;
};

struct vringh_iov {
	struct iovec *iov;
	size_t consumed;
	unsigned int i;
	unsigned int used;
	unsigned int max_num;
};

struct vhost_msg {
	int type;
	union {
		struct vhost_iotlb_msg iotlb;
		__u8 padding[64];
	};
};

struct vhost_msg_v2 {
	__u32 type;
	__u32 reserved;
	union {
		struct vhost_iotlb_msg iotlb;
		__u8 padding[64];
	};
};

struct vhost_memory_region {
	__u64 guest_phys_addr;
	__u64 memory_size;
	__u64 userspace_addr;
	__u64 flags_padding;
};

struct vhost_memory {
	__u32 nregions;
	__u32 padding;
	struct vhost_memory_region regions[0];
};

struct vhost_msg_node {
	union {
		struct vhost_msg msg;
		struct vhost_msg_v2 msg_v2;
	};
	struct vhost_virtqueue *vq;
	struct list_head node;
};

struct vhost_flush_struct {
	struct vhost_work work;
	struct completion wait_event;
};

struct vhost_attach_cgroups_struct {
	struct vhost_work work;
	struct task_struct *owner;
	int ret;
};

struct vhost_vdmabuf;

typedef int (*vhost_vdmabuf_ioctl_t)(struct vhost_vdmabuf *, void *);

struct vhost_vdmabuf {
	struct vhost_dev dev;
	struct vhost_virtqueue vqs[2];
	struct vhost_work send_work;
	struct virtio_vdmabuf_event_queue *eq_import;
	unsigned int vmid;
	struct list_head msg_list;
	struct list_head list;
	spinlock_t local_lock;
	struct hlist_head buf_list_local[128];
	spinlock_t import_lock;
	struct hlist_head buf_list_import[128];
};

struct vhost_vdmabuf_ioctl_desc {
	unsigned int cmd;
	int flags;
	vhost_vdmabuf_ioctl_t func;
	const char *name;
};

enum {
	VHOST_VDMABUF_FEATURES = 0,
};

enum light_mbox_chan_type {
	LIGHT_MBOX_TYPE_TXRX = 0,
	LIGHT_MBOX_TYPE_DB = 1,
};

enum light_mbox_icu_cpu_id {
	LIGHT_MBOX_ICU_CPU0 = 0,
	LIGHT_MBOX_ICU_CPU1 = 1,
	LIGHT_MBOX_ICU_CPU2 = 2,
	LIGHT_MBOX_ICU_CPU3 = 3,
};

struct light_mbox_con_priv {
	enum light_mbox_icu_cpu_id idx;
	enum light_mbox_chan_type type;
	void *comm_local_base;
	void *comm_remote_base;
	char irq_desc[20];
	struct mbox_chan *chan;
	struct tasklet_struct txdb_tasklet;
};

struct light_mbox_priv {
	struct device *dev;
	void *local_icu[4];
	void *remote_icu[3];
	void *cur_cpu_ch_base;
	enum light_mbox_icu_cpu_id cur_icu_cpu_id;
	spinlock_t mbox_lock;
	struct mbox_controller mbox;
	struct mbox_chan mbox_chans[4];
	struct light_mbox_con_priv con_priv[4];
	struct clk *clk;
	int irq;
};

struct mbox_client_light_device {
	struct device *dev;
	void *tx_mmio;
	void *rx_mmio;
	struct mbox_chan *tx_channel;
	struct mbox_chan *rx_channel;
	char *rx_buffer;
	char *message;
	spinlock_t lock;
};

struct virtio_mailbox_config {
	__virtio32 chan_num;
	__virtio32 msg_size;
	__virtio32 msg_g[32];
	__virtio32 msg_h[32];
	__virtio32 ack_g[32];
	__virtio32 ack_h[32];
};

struct virtio_chan___2;

struct virtio_mbox___2 {
	struct mbox_controller controller;
	struct virtio_device *vdev;
	unsigned int chan_num;
	unsigned int msg_size;
	struct mbox_chan *chans;
	struct virtio_chan___2 *vchans;
	struct virtqueue **in_vqs;
	struct virtqueue **out_vqs;
};

struct virtio_chan___2 {
	struct virtqueue *in_vq;
	struct virtqueue *out_vq;
	struct virtio_mbox___2 *vmbox;
	struct mbox_chan *chan;
	bool in_use;
	u8 idx;
	spinlock_t lock;
};

struct hwspinlock;

struct hwspinlock_ops {
	int (*trylock)(struct hwspinlock *);
	void (*unlock)(struct hwspinlock *);
	void (*relax)(struct hwspinlock *);
};

struct hwspinlock_device;

struct hwspinlock {
	struct hwspinlock_device *bank;
	spinlock_t lock;
	void *priv;
};

struct hwspinlock_device {
	struct device *dev;
	const struct hwspinlock_ops *ops;
	int base_id;
	int num_locks;
	struct hwspinlock lock[0];
};

struct light_hwspinlock {
	void *io_base;
	struct hwspinlock_device bank;
};

union extcon_property_value {
	int intval;
};

struct extcon_cable;

struct extcon_dev {
	const char *name;
	const unsigned int *supported_cable;
	const u32 *mutually_exclusive;
	struct device dev;
	struct raw_notifier_head nh_all;
	struct raw_notifier_head *nh;
	struct list_head entry;
	int max_supported;
	spinlock_t lock;
	u32 state;
	struct device_type extcon_dev_type;
	struct extcon_cable *cables;
	struct attribute_group attr_g_muex;
	struct attribute **attrs_muex;
	struct device_attribute *d_attrs_muex;
};

struct extcon_cable {
	struct extcon_dev *edev;
	int cable_index;
	struct attribute_group attr_g;
	struct device_attribute attr_name;
	struct device_attribute attr_state;
	struct attribute *attrs[3];
	union extcon_property_value usb_propval[3];
	union extcon_property_value chg_propval[1];
	union extcon_property_value jack_propval[1];
	union extcon_property_value disp_propval[2];
	long unsigned int usb_bits[1];
	long unsigned int chg_bits[1];
	long unsigned int jack_bits[1];
	long unsigned int disp_bits[1];
};

struct __extcon_info {
	unsigned int type;
	unsigned int id;
	const char *name;
};

struct extcon_dev_notifier_devres {
	struct extcon_dev *edev;
	unsigned int id;
	struct notifier_block *nb;
};

enum iio_chan_type {
	IIO_VOLTAGE = 0,
	IIO_CURRENT = 1,
	IIO_POWER = 2,
	IIO_ACCEL = 3,
	IIO_ANGL_VEL = 4,
	IIO_MAGN = 5,
	IIO_LIGHT = 6,
	IIO_INTENSITY = 7,
	IIO_PROXIMITY = 8,
	IIO_TEMP = 9,
	IIO_INCLI = 10,
	IIO_ROT = 11,
	IIO_ANGL = 12,
	IIO_TIMESTAMP = 13,
	IIO_CAPACITANCE = 14,
	IIO_ALTVOLTAGE = 15,
	IIO_CCT = 16,
	IIO_PRESSURE = 17,
	IIO_HUMIDITYRELATIVE = 18,
	IIO_ACTIVITY = 19,
	IIO_STEPS = 20,
	IIO_ENERGY = 21,
	IIO_DISTANCE = 22,
	IIO_VELOCITY = 23,
	IIO_CONCENTRATION = 24,
	IIO_RESISTANCE = 25,
	IIO_PH = 26,
	IIO_UVINDEX = 27,
	IIO_ELECTRICALCONDUCTIVITY = 28,
	IIO_COUNT = 29,
	IIO_INDEX = 30,
	IIO_GRAVITY = 31,
	IIO_POSITIONRELATIVE = 32,
	IIO_PHASE = 33,
	IIO_MASSCONCENTRATION = 34,
};

enum iio_modifier {
	IIO_NO_MOD = 0,
	IIO_MOD_X = 1,
	IIO_MOD_Y = 2,
	IIO_MOD_Z = 3,
	IIO_MOD_X_AND_Y = 4,
	IIO_MOD_X_AND_Z = 5,
	IIO_MOD_Y_AND_Z = 6,
	IIO_MOD_X_AND_Y_AND_Z = 7,
	IIO_MOD_X_OR_Y = 8,
	IIO_MOD_X_OR_Z = 9,
	IIO_MOD_Y_OR_Z = 10,
	IIO_MOD_X_OR_Y_OR_Z = 11,
	IIO_MOD_LIGHT_BOTH = 12,
	IIO_MOD_LIGHT_IR = 13,
	IIO_MOD_ROOT_SUM_SQUARED_X_Y = 14,
	IIO_MOD_SUM_SQUARED_X_Y_Z = 15,
	IIO_MOD_LIGHT_CLEAR = 16,
	IIO_MOD_LIGHT_RED = 17,
	IIO_MOD_LIGHT_GREEN = 18,
	IIO_MOD_LIGHT_BLUE = 19,
	IIO_MOD_QUATERNION = 20,
	IIO_MOD_TEMP_AMBIENT = 21,
	IIO_MOD_TEMP_OBJECT = 22,
	IIO_MOD_NORTH_MAGN = 23,
	IIO_MOD_NORTH_TRUE = 24,
	IIO_MOD_NORTH_MAGN_TILT_COMP = 25,
	IIO_MOD_NORTH_TRUE_TILT_COMP = 26,
	IIO_MOD_RUNNING = 27,
	IIO_MOD_JOGGING = 28,
	IIO_MOD_WALKING = 29,
	IIO_MOD_STILL = 30,
	IIO_MOD_ROOT_SUM_SQUARED_X_Y_Z = 31,
	IIO_MOD_I = 32,
	IIO_MOD_Q = 33,
	IIO_MOD_CO2 = 34,
	IIO_MOD_VOC = 35,
	IIO_MOD_LIGHT_UV = 36,
	IIO_MOD_LIGHT_DUV = 37,
	IIO_MOD_PM1 = 38,
	IIO_MOD_PM2P5 = 39,
	IIO_MOD_PM4 = 40,
	IIO_MOD_PM10 = 41,
	IIO_MOD_ETHANOL = 42,
	IIO_MOD_H2 = 43,
	IIO_MOD_O2 = 44,
};

enum iio_event_type {
	IIO_EV_TYPE_THRESH = 0,
	IIO_EV_TYPE_MAG = 1,
	IIO_EV_TYPE_ROC = 2,
	IIO_EV_TYPE_THRESH_ADAPTIVE = 3,
	IIO_EV_TYPE_MAG_ADAPTIVE = 4,
	IIO_EV_TYPE_CHANGE = 5,
};

enum iio_event_direction {
	IIO_EV_DIR_EITHER = 0,
	IIO_EV_DIR_RISING = 1,
	IIO_EV_DIR_FALLING = 2,
	IIO_EV_DIR_NONE = 3,
};

enum iio_event_info {
	IIO_EV_INFO_ENABLE = 0,
	IIO_EV_INFO_VALUE = 1,
	IIO_EV_INFO_HYSTERESIS = 2,
	IIO_EV_INFO_PERIOD = 3,
	IIO_EV_INFO_HIGH_PASS_FILTER_3DB = 4,
	IIO_EV_INFO_LOW_PASS_FILTER_3DB = 5,
};

enum iio_available_type {
	IIO_AVAIL_LIST = 0,
	IIO_AVAIL_RANGE = 1,
};

enum iio_chan_info_enum {
	IIO_CHAN_INFO_RAW = 0,
	IIO_CHAN_INFO_PROCESSED = 1,
	IIO_CHAN_INFO_SCALE = 2,
	IIO_CHAN_INFO_OFFSET = 3,
	IIO_CHAN_INFO_CALIBSCALE = 4,
	IIO_CHAN_INFO_CALIBBIAS = 5,
	IIO_CHAN_INFO_PEAK = 6,
	IIO_CHAN_INFO_PEAK_SCALE = 7,
	IIO_CHAN_INFO_QUADRATURE_CORRECTION_RAW = 8,
	IIO_CHAN_INFO_AVERAGE_RAW = 9,
	IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY = 10,
	IIO_CHAN_INFO_HIGH_PASS_FILTER_3DB_FREQUENCY = 11,
	IIO_CHAN_INFO_SAMP_FREQ = 12,
	IIO_CHAN_INFO_FREQUENCY = 13,
	IIO_CHAN_INFO_PHASE = 14,
	IIO_CHAN_INFO_HARDWAREGAIN = 15,
	IIO_CHAN_INFO_HYSTERESIS = 16,
	IIO_CHAN_INFO_INT_TIME = 17,
	IIO_CHAN_INFO_ENABLE = 18,
	IIO_CHAN_INFO_CALIBHEIGHT = 19,
	IIO_CHAN_INFO_CALIBWEIGHT = 20,
	IIO_CHAN_INFO_DEBOUNCE_COUNT = 21,
	IIO_CHAN_INFO_DEBOUNCE_TIME = 22,
	IIO_CHAN_INFO_CALIBEMISSIVITY = 23,
	IIO_CHAN_INFO_OVERSAMPLING_RATIO = 24,
	IIO_CHAN_INFO_THERMOCOUPLE_TYPE = 25,
	IIO_CHAN_INFO_CALIBAMBIENT = 26,
};

enum iio_shared_by {
	IIO_SEPARATE = 0,
	IIO_SHARED_BY_TYPE = 1,
	IIO_SHARED_BY_DIR = 2,
	IIO_SHARED_BY_ALL = 3,
};

enum iio_endian {
	IIO_CPU = 0,
	IIO_BE = 1,
	IIO_LE = 2,
};

struct iio_dev;

struct iio_chan_spec;

struct iio_chan_spec_ext_info {
	const char *name;
	enum iio_shared_by shared;
	ssize_t (*read)(struct iio_dev *, uintptr_t, const struct iio_chan_spec *, char *);
	ssize_t (*write)(struct iio_dev *, uintptr_t, const struct iio_chan_spec *, const char *, size_t);
	uintptr_t private;
};

struct iio_buffer;

struct iio_trigger;

struct iio_poll_func;

struct iio_info;

struct iio_buffer_setup_ops;

struct iio_dev {
	int id;
	struct module *driver_module;
	int modes;
	int currentmode;
	struct device dev;
	struct iio_buffer *buffer;
	int scan_bytes;
	struct mutex mlock;
	const long unsigned int *available_scan_masks;
	unsigned int masklength;
	const long unsigned int *active_scan_mask;
	bool scan_timestamp;
	unsigned int scan_index_timestamp;
	struct iio_trigger *trig;
	bool trig_readonly;
	struct iio_poll_func *pollfunc;
	struct iio_poll_func *pollfunc_event;
	const struct iio_chan_spec *channels;
	int num_channels;
	const char *name;
	const char *label;
	const struct iio_info *info;
	clockid_t clock_id;
	struct mutex info_exist_lock;
	const struct iio_buffer_setup_ops *setup_ops;
	struct cdev chrdev;
	const struct attribute_group *groups[7];
	int groupcounter;
	long unsigned int flags;
	void *priv;
};

struct iio_event_spec;

struct iio_chan_spec {
	enum iio_chan_type type;
	int channel;
	int channel2;
	long unsigned int address;
	int scan_index;
	struct {
		char sign;
		u8 realbits;
		u8 storagebits;
		u8 shift;
		u8 repeat;
		enum iio_endian endianness;
	} scan_type;
	long int info_mask_separate;
	long int info_mask_separate_available;
	long int info_mask_shared_by_type;
	long int info_mask_shared_by_type_available;
	long int info_mask_shared_by_dir;
	long int info_mask_shared_by_dir_available;
	long int info_mask_shared_by_all;
	long int info_mask_shared_by_all_available;
	const struct iio_event_spec *event_spec;
	unsigned int num_event_specs;
	const struct iio_chan_spec_ext_info *ext_info;
	const char *extend_name;
	const char *datasheet_name;
	unsigned int modified: 1;
	unsigned int indexed: 1;
	unsigned int output: 1;
	unsigned int differential: 1;
};

struct iio_enum {
	const char * const *items;
	unsigned int num_items;
	int (*set)(struct iio_dev *, const struct iio_chan_spec *, unsigned int);
	int (*get)(struct iio_dev *, const struct iio_chan_spec *);
};

struct iio_mount_matrix {
	const char *rotation[9];
};

typedef const struct iio_mount_matrix *iio_get_mount_matrix_t(const struct iio_dev *, const struct iio_chan_spec *);

struct iio_event_spec {
	enum iio_event_type type;
	enum iio_event_direction dir;
	long unsigned int mask_separate;
	long unsigned int mask_shared_by_type;
	long unsigned int mask_shared_by_dir;
	long unsigned int mask_shared_by_all;
};

struct iio_info {
	const struct attribute_group *event_attrs;
	const struct attribute_group *attrs;
	int (*read_raw)(struct iio_dev *, const struct iio_chan_spec *, int *, int *, long int);
	int (*read_raw_multi)(struct iio_dev *, const struct iio_chan_spec *, int, int *, int *, long int);
	int (*read_avail)(struct iio_dev *, const struct iio_chan_spec *, const int **, int *, int *, long int);
	int (*write_raw)(struct iio_dev *, const struct iio_chan_spec *, int, int, long int);
	int (*write_raw_get_fmt)(struct iio_dev *, const struct iio_chan_spec *, long int);
	int (*read_event_config)(struct iio_dev *, const struct iio_chan_spec *, enum iio_event_type, enum iio_event_direction);
	int (*write_event_config)(struct iio_dev *, const struct iio_chan_spec *, enum iio_event_type, enum iio_event_direction, int);
	int (*read_event_value)(struct iio_dev *, const struct iio_chan_spec *, enum iio_event_type, enum iio_event_direction, enum iio_event_info, int *, int *);
	int (*write_event_value)(struct iio_dev *, const struct iio_chan_spec *, enum iio_event_type, enum iio_event_direction, enum iio_event_info, int, int);
	int (*validate_trigger)(struct iio_dev *, struct iio_trigger *);
	int (*update_scan_mode)(struct iio_dev *, const long unsigned int *);
	int (*debugfs_reg_access)(struct iio_dev *, unsigned int, unsigned int, unsigned int *);
	int (*of_xlate)(struct iio_dev *, const struct of_phandle_args *);
	int (*hwfifo_set_watermark)(struct iio_dev *, unsigned int);
	int (*hwfifo_flush_to_buffer)(struct iio_dev *, unsigned int);
};

struct iio_buffer_setup_ops {
	int (*preenable)(struct iio_dev *);
	int (*postenable)(struct iio_dev *);
	int (*predisable)(struct iio_dev *);
	int (*postdisable)(struct iio_dev *);
	bool (*validate_scan_mask)(struct iio_dev *, const long unsigned int *);
};

struct iio_event_interface;

struct iio_dev_opaque {
	struct iio_dev indio_dev;
	struct iio_event_interface *event_interface;
	struct list_head buffer_list;
	struct list_head channel_attr_list;
	struct attribute_group chan_attr_group;
	struct dentry *debugfs_dentry;
	unsigned int cached_reg_addr;
	char read_buf[20];
	unsigned int read_buf_len;
};

struct iio_event_data {
	__u64 id;
	__s64 timestamp;
};

struct iio_event_interface {
	wait_queue_head_t wait;
	struct {
		union {
			struct __kfifo kfifo;
			struct iio_event_data *type;
			const struct iio_event_data *const_type;
			char (*rectype)[0];
			struct iio_event_data *ptr;
			const struct iio_event_data *ptr_const;
		};
		struct iio_event_data buf[16];
	} det_events;
	struct list_head dev_attr_list;
	long unsigned int flags;
	struct attribute_group group;
	struct mutex read_lock;
};

struct iio_dev_attr {
	struct device_attribute dev_attr;
	u64 address;
	struct list_head l;
	const struct iio_chan_spec *c;
};

struct iio_const_attr {
	const char *string;
	struct device_attribute dev_attr;
};

struct iio_map {
	const char *adc_channel_label;
	const char *consumer_dev_name;
	const char *consumer_channel;
	void *consumer_data;
};

struct iio_channel {
	struct iio_dev *indio_dev;
	const struct iio_chan_spec *channel;
	void *data;
};

struct iio_map_internal {
	struct iio_dev *indio_dev;
	struct iio_map *map;
	struct list_head l;
};

struct iio_sw_device_ops;

struct iio_sw_device_type {
	const char *name;
	struct module *owner;
	const struct iio_sw_device_ops *ops;
	struct list_head list;
	struct config_group *group;
};

struct iio_sw_device;

struct iio_sw_device_ops {
	struct iio_sw_device * (*probe)(const char *);
	int (*remove)(struct iio_sw_device *);
};

struct iio_sw_device {
	struct iio_dev *device;
	struct iio_sw_device_type *device_type;
	struct config_group group;
};

enum vol_ref {
	LIGHT_ADC_VOL_VREF = 0,
	LIGHT_ADC_VOL_INTE = 1,
};

enum input_mode_sel {
	LIGHT_ADC_SINGLE_ENDED_INPUTS = 0,
	LIGHT_ADC_DIFFERENTIAL_INPUTS = 1,
};

enum selres_sel {
	LIGHT_ADC_SELRES_6BIT = 6,
	LIGHT_ADC_SELRES_8BIT = 8,
	LIGHT_ADC_SELRES_10BIT = 10,
	LIGHT_ADC_SELRES_12BIT = 12,
};

enum offset_mode_sel {
	LIGHT_ADC_OFFSET_DIS = 0,
	LIGHT_ADC_OFFSET_EN = 1,
};

enum conversion_mode_sel {
	LIGHT_ADC_MODE_SINGLE = 0,
	LIGHT_ADC_MODE_CONTINOUS = 1,
};

enum clk_sel {
	LIGHT_ADC_FCLK_TYP_1M = 0,
};

enum int_actual_mask {
	LIGHT_ADC_ACTUAL_CH0 = 0,
	LIGHT_ADC_ACTUAL_CH1 = 1,
	LIGHT_ADC_ACTUAL_ALL = 2,
};

enum int_delta_mask {
	LIGHT_ADC_DETAL_CH0 = 0,
	LIGHT_ADC_DETAL_CH1 = 1,
	LIGHT_ADC_DETAL_ALL = 2,
};

struct light_adc_feature {
	enum selres_sel selres_sel;
	enum input_mode_sel input_mode;
	enum vol_ref vol_ref;
	enum offset_mode_sel offset_mode;
	enum conversion_mode_sel conv_mode;
	enum clk_sel clk_sel;
	enum int_actual_mask int_actual;
	enum int_delta_mask int_detal;
};

struct light_adc {
	struct device *dev;
	void *regs;
	struct clk *clk;
	u32 vref_uv;
	u32 value;
	struct regulator *vref;
	struct light_adc_feature adc_feature;
	u32 current_clk;
	u32 ch0_offmeas;
	u32 ch1_offmeas;
	struct completion completion;
};

enum perf_hw_id {
	PERF_COUNT_HW_CPU_CYCLES = 0,
	PERF_COUNT_HW_INSTRUCTIONS = 1,
	PERF_COUNT_HW_CACHE_REFERENCES = 2,
	PERF_COUNT_HW_CACHE_MISSES = 3,
	PERF_COUNT_HW_BRANCH_INSTRUCTIONS = 4,
	PERF_COUNT_HW_BRANCH_MISSES = 5,
	PERF_COUNT_HW_BUS_CYCLES = 6,
	PERF_COUNT_HW_STALLED_CYCLES_FRONTEND = 7,
	PERF_COUNT_HW_STALLED_CYCLES_BACKEND = 8,
	PERF_COUNT_HW_REF_CPU_CYCLES = 9,
	PERF_COUNT_HW_MAX = 10,
};

enum perf_hw_cache_id {
	PERF_COUNT_HW_CACHE_L1D = 0,
	PERF_COUNT_HW_CACHE_L1I = 1,
	PERF_COUNT_HW_CACHE_LL = 2,
	PERF_COUNT_HW_CACHE_DTLB = 3,
	PERF_COUNT_HW_CACHE_ITLB = 4,
	PERF_COUNT_HW_CACHE_BPU = 5,
	PERF_COUNT_HW_CACHE_NODE = 6,
	PERF_COUNT_HW_CACHE_MAX = 7,
};

enum perf_hw_cache_op_id {
	PERF_COUNT_HW_CACHE_OP_READ = 0,
	PERF_COUNT_HW_CACHE_OP_WRITE = 1,
	PERF_COUNT_HW_CACHE_OP_PREFETCH = 2,
	PERF_COUNT_HW_CACHE_OP_MAX = 3,
};

enum perf_hw_cache_op_result_id {
	PERF_COUNT_HW_CACHE_RESULT_ACCESS = 0,
	PERF_COUNT_HW_CACHE_RESULT_MISS = 1,
	PERF_COUNT_HW_CACHE_RESULT_MAX = 2,
};

struct pmu_hw_events {
	struct perf_event *events[32];
	long unsigned int used_mask[1];
};

struct thead_pmu_t {
	struct pmu pmu;
	struct pmu_hw_events *hw_events;
	struct platform_device *plat_device;
	long unsigned int max_period;
	int irq;
};

struct riscv_pmu_t {
	struct pmu pmu;
	struct pmu_hw_events *hw_events;
	struct platform_device *plat_device;
	u64 max_period;
};

struct nvmem_cell_lookup {
	const char *nvmem_name;
	const char *cell_name;
	const char *dev_id;
	const char *con_id;
	struct list_head node;
};

enum {
	NVMEM_ADD = 1,
	NVMEM_REMOVE = 2,
	NVMEM_CELL_ADD = 3,
	NVMEM_CELL_REMOVE = 4,
};

struct nvmem_cell_table {
	const char *nvmem_name;
	const struct nvmem_cell_info *cells;
	size_t ncells;
	struct list_head node;
};

struct nvmem_device {
	struct module *owner;
	struct device dev;
	int stride;
	int word_size;
	int id;
	struct kref refcnt;
	size_t size;
	bool read_only;
	bool root_only;
	int flags;
	enum nvmem_type type;
	struct bin_attribute eeprom;
	struct device *base_dev;
	struct list_head cells;
	nvmem_reg_read_t reg_read;
	nvmem_reg_write_t reg_write;
	struct gpio_desc *wp_gpio;
	void *priv;
};

struct nvmem_cell {
	const char *name;
	int offset;
	int bytes;
	int bit_offset;
	int nbits;
	struct device_node *np;
	struct nvmem_device *nvmem;
	struct list_head node;
};

struct light_efuse_priv {
	struct device *dev;
	void *base;
	struct regmap *teesys_regs;
	struct clk *clk;
	u32 sysfs_rd_offset;
	u32 sysfs_rd_len;
};

enum permission_type {
	CMD_SPI = 0,
	CMD_UPDATE_LC = 1,
	CMD_READ = 2,
	CMD_WRITE = 3,
	CMD_BLOCK_READ = 4,
	CMD_WP_LOCK = 5,
	CMD_CP_LOCK = 6,
	CMD_RP_LOCK = 7,
	CMD_KEY_TRAN = 8,
	CMD_KEY_MAX = 9,
};

enum con_cmd_type {
	CON_CMD_IDLE = 0,
	CON_CMD_READ = 1,
	CON_CMD_WRITE = 2,
	CON_CMD_BLOCK_RD = 3,
	CON_CMD_WP_LOCK = 4,
	CON_CMD_CP_LOCK = 5,
	CON_CMD_RP_LOCK = 6,
	CON_CMD_UP_LC = 7,
	CON_CMD_MAX = 8,
};

struct tee_ioctl_shm_alloc_data {
	__u64 size;
	__u32 flags;
	__s32 id;
};

struct tee_ioctl_shm_register_fd_data {
	__s64 fd;
	__u64 size;
	__u32 flags;
	__s32 id;
};

struct tee_ioctl_buf_data {
	__u64 buf_ptr;
	__u64 buf_len;
};

struct tee_ioctl_cancel_arg {
	__u32 cancel_id;
	__u32 session;
};

struct tee_ioctl_close_session_arg {
	__u32 session;
};

struct tee_iocl_supp_recv_arg {
	__u32 func;
	__u32 num_params;
	struct tee_ioctl_param params[0];
};

struct tee_iocl_supp_send_arg {
	__u32 ret;
	__u32 num_params;
	struct tee_ioctl_param params[0];
};

struct tee_ioctl_shm_register_data {
	__u64 addr;
	__u64 length;
	__u32 flags;
	__s32 id;
};

struct tee_desc;

struct tee_shm_pool;

struct tee_device {
	char name[32];
	const struct tee_desc *desc;
	int id;
	unsigned int flags;
	struct device dev;
	struct cdev cdev;
	size_t num_users;
	struct completion c_no_users;
	struct mutex mutex;
	struct idr idr;
	struct tee_shm_pool *pool;
};

struct tee_driver_ops {
	void (*get_version)(struct tee_device *, struct tee_ioctl_version_data *);
	int (*open)(struct tee_context *);
	void (*release)(struct tee_context *);
	int (*open_session)(struct tee_context *, struct tee_ioctl_open_session_arg *, struct tee_param *);
	int (*close_session)(struct tee_context *, u32);
	int (*invoke_func)(struct tee_context *, struct tee_ioctl_invoke_arg *, struct tee_param *);
	int (*cancel_req)(struct tee_context *, u32, u32);
	int (*supp_recv)(struct tee_context *, u32 *, u32 *, struct tee_param *);
	int (*supp_send)(struct tee_context *, u32, u32, struct tee_param *);
	int (*shm_register)(struct tee_context *, struct tee_shm *, struct page **, size_t, long unsigned int);
	int (*shm_unregister)(struct tee_context *, struct tee_shm *);
};

struct tee_desc {
	const char *name;
	const struct tee_driver_ops *ops;
	struct module *owner;
	u32 flags;
};

struct tee_shm_pool_mgr_ops;

struct tee_shm_pool_mgr {
	const struct tee_shm_pool_mgr_ops *ops;
	void *private_data;
};

struct tee_shm_pool_mgr_ops {
	int (*alloc)(struct tee_shm_pool_mgr *, struct tee_shm *, size_t);
	void (*free)(struct tee_shm_pool_mgr *, struct tee_shm *);
	void (*destroy_poolmgr)(struct tee_shm_pool_mgr *);
};

struct tee_shm_pool {
	struct tee_shm_pool_mgr *private_mgr;
	struct tee_shm_pool_mgr *dma_buf_mgr;
};

struct match_dev_data {
	struct tee_ioctl_version_data *vers;
	const void *data;
	int (*match)(struct tee_ioctl_version_data *, const void *);
};

struct tee_shm_dmabuf_ref {
	struct tee_shm shm;
	struct dma_buf *dmabuf;
	struct dma_buf_attachment *attach;
	struct sg_table *sgt;
};

struct tee_shm_pool_mem_info {
	long unsigned int vaddr;
	phys_addr_t paddr;
	size_t size;
};

struct arm_smccc_res {
	long unsigned int a0;
	long unsigned int a1;
	long unsigned int a2;
	long unsigned int a3;
};

struct optee_msg_param_tmem {
	u64 buf_ptr;
	u64 size;
	u64 shm_ref;
};

struct optee_msg_param_rmem {
	u64 offs;
	u64 size;
	u64 shm_ref;
};

struct optee_msg_param_value {
	u64 a;
	u64 b;
	u64 c;
};

struct optee_msg_param {
	u64 attr;
	union {
		struct optee_msg_param_tmem tmem;
		struct optee_msg_param_rmem rmem;
		struct optee_msg_param_value value;
		u8 octets[24];
	} u;
};

struct optee_msg_arg {
	u32 cmd;
	u32 func;
	u32 session;
	u32 cancel_id;
	u32 pad;
	u32 ret;
	u32 ret_origin;
	u32 num_params;
	struct optee_msg_param params[0];
};

typedef void optee_invoke_fn(long unsigned int, long unsigned int, long unsigned int, long unsigned int, long unsigned int, long unsigned int, long unsigned int, long unsigned int, struct arm_smccc_res *);

struct optee_call_queue {
	struct mutex mutex;
	struct list_head waiters;
};

struct optee_wait_queue {
	struct mutex mu;
	struct list_head db;
};

struct optee_supp {
	struct mutex mutex;
	struct tee_context *ctx;
	int req_id;
	struct list_head reqs;
	struct idr idr;
	struct completion reqs_c;
};

struct tee_shm_pool;

struct optee {
	struct tee_device *supp_teedev;
	struct tee_device *teedev;
	optee_invoke_fn *invoke_fn;
	struct tee_context *ctx;
	struct optee_call_queue call_queue;
	struct optee_wait_queue wait_queue;
	struct optee_supp supp;
	struct tee_shm_pool *pool;
	void *memremaped_shm;
	u32 sec_caps;
	bool scan_bus_done;
	struct workqueue_struct *scan_bus_wq;
	struct work_struct scan_bus_work;
};

struct optee_session {
	struct list_head list_node;
	u32 session_id;
};

struct optee_context_data {
	struct mutex mutex;
	struct list_head sess_list;
};

struct optee_smc_calls_revision_result {
	long unsigned int major;
	long unsigned int minor;
	long unsigned int reserved0;
	long unsigned int reserved1;
};

struct optee_smc_call_get_os_revision_result {
	long unsigned int major;
	long unsigned int minor;
	long unsigned int build_id;
	long unsigned int reserved1;
};

struct optee_smc_get_shm_config_result {
	long unsigned int status;
	long unsigned int start;
	long unsigned int size;
	long unsigned int settings;
};

struct optee_smc_exchange_capabilities_result {
	long unsigned int status;
	long unsigned int capabilities;
	long unsigned int reserved0;
	long unsigned int reserved1;
};

struct optee_rpc_param {
	u32 a0;
	u32 a1;
	u32 a2;
	u32 a3;
	u32 a4;
	u32 a5;
	u32 a6;
	u32 a7;
};

struct optee_call_ctx {
	void *pages_list;
	size_t num_entries;
};

struct optee_smc_disable_shm_cache_result {
	long unsigned int status;
	long unsigned int shm_upper32;
	long unsigned int shm_lower32;
	long unsigned int reserved0;
};

struct trace_event_raw_optee_invoke_fn_begin {
	struct trace_entry ent;
	void *param;
	u32 args[8];
	char __data[0];
};

struct trace_event_raw_optee_invoke_fn_end {
	struct trace_entry ent;
	void *param;
	long unsigned int rets[4];
	char __data[0];
};

struct trace_event_data_offsets_optee_invoke_fn_begin {};

struct trace_event_data_offsets_optee_invoke_fn_end {};

typedef void (*btf_trace_optee_invoke_fn_begin)(void *, struct optee_rpc_param *);

typedef void (*btf_trace_optee_invoke_fn_end)(void *, struct optee_rpc_param *, struct arm_smccc_res *);

struct optee_call_waiter {
	struct list_head list_node;
	struct completion c;
};

struct optee_time_st {
	uint64_t cnt;
	uint64_t addr;
	uint64_t src;
};

struct optee_ts_cpu_buf {
	uint64_t head;
	uint64_t tail;
	struct optee_time_st stamps[32];
};

struct optee_ts_global {
	uint64_t cores;
	struct optee_ts_cpu_buf cpu_buf[0];
};

struct wq_entry {
	struct list_head link;
	struct completion c;
	u32 key;
};

struct optee_supp_req {
	struct list_head link;
	bool in_queue;
	u32 func;
	u32 ret;
	size_t num_params;
	struct tee_param *param;
	struct completion c;
};

struct snd_shutdown_f_ops;

struct snd_info_entry;

struct snd_card {
	int number;
	char id[16];
	char driver[16];
	char shortname[32];
	char longname[80];
	char irq_descr[32];
	char mixername[80];
	char components[128];
	struct module *module;
	void *private_data;
	void (*private_free)(struct snd_card *);
	struct list_head devices;
	struct device ctl_dev;
	unsigned int last_numid;
	struct rw_semaphore controls_rwsem;
	rwlock_t ctl_files_rwlock;
	int controls_count;
	int user_ctl_count;
	struct list_head controls;
	struct list_head ctl_files;
	struct snd_info_entry *proc_root;
	struct proc_dir_entry *proc_root_link;
	struct list_head files_list;
	struct snd_shutdown_f_ops *s_f_ops;
	spinlock_t files_lock;
	int shutdown;
	struct completion *release_completion;
	struct device *dev;
	struct device card_dev;
	const struct attribute_group *dev_groups[4];
	bool registered;
	int sync_irq;
	wait_queue_head_t remove_sleep;
	size_t total_pcm_alloc_bytes;
	struct mutex memory_mutex;
	unsigned int power_state;
	wait_queue_head_t power_sleep;
};

struct snd_info_buffer;

struct snd_info_entry_text {
	void (*read)(struct snd_info_entry *, struct snd_info_buffer *);
	void (*write)(struct snd_info_entry *, struct snd_info_buffer *);
};

struct snd_info_entry_ops;

struct snd_info_entry {
	const char *name;
	umode_t mode;
	long int size;
	short unsigned int content;
	union {
		struct snd_info_entry_text text;
		const struct snd_info_entry_ops *ops;
	} c;
	struct snd_info_entry *parent;
	struct module *module;
	void *private_data;
	void (*private_free)(struct snd_info_entry *);
	struct proc_dir_entry *p;
	struct mutex access;
	struct list_head children;
	struct list_head list;
};

struct snd_minor {
	int type;
	int card;
	int device;
	const struct file_operations *f_ops;
	void *private_data;
	struct device *dev;
	struct snd_card *card_ptr;
};

struct snd_info_buffer {
	char *buffer;
	unsigned int curr;
	unsigned int size;
	unsigned int len;
	int stop;
	int error;
};

struct snd_info_entry_ops {
	int (*open)(struct snd_info_entry *, short unsigned int, void **);
	int (*release)(struct snd_info_entry *, short unsigned int, void *);
	ssize_t (*read)(struct snd_info_entry *, void *, struct file *, char *, size_t, loff_t);
	ssize_t (*write)(struct snd_info_entry *, void *, struct file *, const char *, size_t, loff_t);
	loff_t (*llseek)(struct snd_info_entry *, void *, struct file *, loff_t, int);
	__poll_t (*poll)(struct snd_info_entry *, void *, struct file *, poll_table *);
	int (*ioctl)(struct snd_info_entry *, void *, struct file *, unsigned int, long unsigned int);
	int (*mmap)(struct snd_info_entry *, void *, struct inode *, struct file *, struct vm_area_struct *);
};

struct snd_monitor_file {
	struct file *file;
	const struct file_operations *disconnected_f_op;
	struct list_head shutdown_list;
	struct list_head list;
};

enum snd_device_type {
	SNDRV_DEV_LOWLEVEL = 0,
	SNDRV_DEV_INFO = 1,
	SNDRV_DEV_BUS = 2,
	SNDRV_DEV_CODEC = 3,
	SNDRV_DEV_PCM = 4,
	SNDRV_DEV_COMPRESS = 5,
	SNDRV_DEV_RAWMIDI = 6,
	SNDRV_DEV_TIMER = 7,
	SNDRV_DEV_SEQUENCER = 8,
	SNDRV_DEV_HWDEP = 9,
	SNDRV_DEV_JACK = 10,
	SNDRV_DEV_CONTROL = 11,
};

enum snd_device_state {
	SNDRV_DEV_BUILD = 0,
	SNDRV_DEV_REGISTERED = 1,
	SNDRV_DEV_DISCONNECTED = 2,
};

struct snd_device;

struct snd_device_ops {
	int (*dev_free)(struct snd_device *);
	int (*dev_register)(struct snd_device *);
	int (*dev_disconnect)(struct snd_device *);
};

struct snd_device {
	struct list_head list;
	struct snd_card *card;
	enum snd_device_state state;
	enum snd_device_type type;
	void *device_data;
	const struct snd_device_ops *ops;
};

struct snd_aes_iec958 {
	unsigned char status[24];
	unsigned char subcode[147];
	unsigned char pad;
	unsigned char dig_subframe[4];
};

struct snd_ctl_card_info {
	int card;
	int pad;
	unsigned char id[16];
	unsigned char driver[16];
	unsigned char name[32];
	unsigned char longname[80];
	unsigned char reserved_[16];
	unsigned char mixername[80];
	unsigned char components[128];
};

typedef int snd_ctl_elem_type_t;

typedef int snd_ctl_elem_iface_t;

struct snd_ctl_elem_id {
	unsigned int numid;
	snd_ctl_elem_iface_t iface;
	unsigned int device;
	unsigned int subdevice;
	unsigned char name[44];
	unsigned int index;
};

struct snd_ctl_elem_list {
	unsigned int offset;
	unsigned int space;
	unsigned int used;
	unsigned int count;
	struct snd_ctl_elem_id *pids;
	unsigned char reserved[50];
};

struct snd_ctl_elem_info {
	struct snd_ctl_elem_id id;
	snd_ctl_elem_type_t type;
	unsigned int access;
	unsigned int count;
	__kernel_pid_t owner;
	union {
		struct {
			long int min;
			long int max;
			long int step;
		} integer;
		struct {
			long long int min;
			long long int max;
			long long int step;
		} integer64;
		struct {
			unsigned int items;
			unsigned int item;
			char name[64];
			__u64 names_ptr;
			unsigned int names_length;
		} enumerated;
		unsigned char reserved[128];
	} value;
	unsigned char reserved[64];
};

struct snd_ctl_elem_value {
	struct snd_ctl_elem_id id;
	unsigned int indirect: 1;
	union {
		union {
			long int value[128];
			long int *value_ptr;
		} integer;
		union {
			long long int value[64];
			long long int *value_ptr;
		} integer64;
		union {
			unsigned int item[128];
			unsigned int *item_ptr;
		} enumerated;
		union {
			unsigned char data[512];
			unsigned char *data_ptr;
		} bytes;
		struct snd_aes_iec958 iec958;
	} value;
	unsigned char reserved[128];
};

struct snd_ctl_tlv {
	unsigned int numid;
	unsigned int length;
	unsigned int tlv[0];
};

enum sndrv_ctl_event_type {
	SNDRV_CTL_EVENT_ELEM = 0,
	SNDRV_CTL_EVENT_LAST = 0,
};

struct snd_ctl_event {
	int type;
	union {
		struct {
			unsigned int mask;
			struct snd_ctl_elem_id id;
		} elem;
		unsigned char data8[60];
	} data;
};

struct snd_kcontrol;

typedef int snd_kcontrol_info_t(struct snd_kcontrol *, struct snd_ctl_elem_info *);

typedef int snd_kcontrol_get_t(struct snd_kcontrol *, struct snd_ctl_elem_value *);

typedef int snd_kcontrol_put_t(struct snd_kcontrol *, struct snd_ctl_elem_value *);

typedef int snd_kcontrol_tlv_rw_t(struct snd_kcontrol *, int, unsigned int, unsigned int *);

struct snd_ctl_file;

struct snd_kcontrol_volatile {
	struct snd_ctl_file *owner;
	unsigned int access;
};

struct snd_kcontrol {
	struct list_head list;
	struct snd_ctl_elem_id id;
	unsigned int count;
	snd_kcontrol_info_t *info;
	snd_kcontrol_get_t *get;
	snd_kcontrol_put_t *put;
	union {
		snd_kcontrol_tlv_rw_t *c;
		const unsigned int *p;
	} tlv;
	long unsigned int private_value;
	void *private_data;
	void (*private_free)(struct snd_kcontrol *);
	struct snd_kcontrol_volatile vd[0];
};

enum {
	SNDRV_CTL_TLV_OP_READ = 0,
	SNDRV_CTL_TLV_OP_WRITE = 1,
	SNDRV_CTL_TLV_OP_CMD = 4294967295,
};

struct snd_kcontrol_new {
	snd_ctl_elem_iface_t iface;
	unsigned int device;
	unsigned int subdevice;
	const char *name;
	unsigned int index;
	unsigned int access;
	unsigned int count;
	snd_kcontrol_info_t *info;
	snd_kcontrol_get_t *get;
	snd_kcontrol_put_t *put;
	union {
		snd_kcontrol_tlv_rw_t *c;
		const unsigned int *p;
	} tlv;
	long unsigned int private_value;
};

struct snd_ctl_file {
	struct list_head list;
	struct snd_card *card;
	struct pid *pid;
	int preferred_subdevice[2];
	wait_queue_head_t change_sleep;
	spinlock_t read_lock;
	struct fasync_struct *fasync;
	int subscribed;
	struct list_head events;
};

struct snd_kctl_event {
	struct list_head list;
	struct snd_ctl_elem_id id;
	unsigned int mask;
};

typedef int (*snd_kctl_ioctl_func_t)(struct snd_card *, struct snd_ctl_file *, unsigned int, long unsigned int);

struct snd_kctl_ioctl {
	struct list_head list;
	snd_kctl_ioctl_func_t fioctl;
};

enum snd_ctl_add_mode {
	CTL_ADD_EXCLUSIVE = 0,
	CTL_REPLACE = 1,
	CTL_ADD_ON_REPLACE = 2,
};

struct user_element {
	struct snd_ctl_elem_info info;
	struct snd_card *card;
	char *elem_data;
	long unsigned int elem_data_size;
	void *tlv_data;
	long unsigned int tlv_data_size;
	void *priv_data;
};

struct snd_info_private_data {
	struct snd_info_buffer *rbuffer;
	struct snd_info_buffer *wbuffer;
	struct snd_info_entry *entry;
	void *file_private_data;
};

enum snd_jack_types {
	SND_JACK_HEADPHONE = 1,
	SND_JACK_MICROPHONE = 2,
	SND_JACK_HEADSET = 3,
	SND_JACK_LINEOUT = 4,
	SND_JACK_MECHANICAL = 8,
	SND_JACK_VIDEOOUT = 16,
	SND_JACK_AVOUT = 20,
	SND_JACK_LINEIN = 32,
	SND_JACK_BTN_0 = 16384,
	SND_JACK_BTN_1 = 8192,
	SND_JACK_BTN_2 = 4096,
	SND_JACK_BTN_3 = 2048,
	SND_JACK_BTN_4 = 1024,
	SND_JACK_BTN_5 = 512,
};

struct snd_jack {
	struct list_head kctl_list;
	struct snd_card *card;
	const char *id;
	struct input_dev *input_dev;
	int registered;
	int type;
	char name[100];
	unsigned int key[6];
	void *private_data;
	void (*private_free)(struct snd_jack *);
};

struct snd_jack_kctl {
	struct snd_kcontrol *kctl;
	struct list_head list;
	unsigned int mask_bits;
};

enum {
	SNDRV_TIMER_CLASS_NONE = 4294967295,
	SNDRV_TIMER_CLASS_SLAVE = 0,
	SNDRV_TIMER_CLASS_GLOBAL = 1,
	SNDRV_TIMER_CLASS_CARD = 2,
	SNDRV_TIMER_CLASS_PCM = 3,
	SNDRV_TIMER_CLASS_LAST = 3,
};

enum {
	SNDRV_TIMER_SCLASS_NONE = 0,
	SNDRV_TIMER_SCLASS_APPLICATION = 1,
	SNDRV_TIMER_SCLASS_SEQUENCER = 2,
	SNDRV_TIMER_SCLASS_OSS_SEQUENCER = 3,
	SNDRV_TIMER_SCLASS_LAST = 3,
};

struct snd_timer_id {
	int dev_class;
	int dev_sclass;
	int card;
	int device;
	int subdevice;
};

struct snd_timer_ginfo {
	struct snd_timer_id tid;
	unsigned int flags;
	int card;
	unsigned char id[64];
	unsigned char name[80];
	long unsigned int reserved0;
	long unsigned int resolution;
	long unsigned int resolution_min;
	long unsigned int resolution_max;
	unsigned int clients;
	unsigned char reserved[32];
};

struct snd_timer_gparams {
	struct snd_timer_id tid;
	long unsigned int period_num;
	long unsigned int period_den;
	unsigned char reserved[32];
};

struct snd_timer_gstatus {
	struct snd_timer_id tid;
	long unsigned int resolution;
	long unsigned int resolution_num;
	long unsigned int resolution_den;
	unsigned char reserved[32];
};

struct snd_timer_select {
	struct snd_timer_id id;
	unsigned char reserved[32];
};

struct snd_timer_info {
	unsigned int flags;
	int card;
	unsigned char id[64];
	unsigned char name[80];
	long unsigned int reserved0;
	long unsigned int resolution;
	unsigned char reserved[64];
};

struct snd_timer_params {
	unsigned int flags;
	unsigned int ticks;
	unsigned int queue_size;
	unsigned int reserved0;
	unsigned int filter;
	unsigned char reserved[60];
};

struct snd_timer_read {
	unsigned int resolution;
	unsigned int ticks;
};

enum {
	SNDRV_TIMER_EVENT_RESOLUTION = 0,
	SNDRV_TIMER_EVENT_TICK = 1,
	SNDRV_TIMER_EVENT_START = 2,
	SNDRV_TIMER_EVENT_STOP = 3,
	SNDRV_TIMER_EVENT_CONTINUE = 4,
	SNDRV_TIMER_EVENT_PAUSE = 5,
	SNDRV_TIMER_EVENT_EARLY = 6,
	SNDRV_TIMER_EVENT_SUSPEND = 7,
	SNDRV_TIMER_EVENT_RESUME = 8,
	SNDRV_TIMER_EVENT_MSTART = 12,
	SNDRV_TIMER_EVENT_MSTOP = 13,
	SNDRV_TIMER_EVENT_MCONTINUE = 14,
	SNDRV_TIMER_EVENT_MPAUSE = 15,
	SNDRV_TIMER_EVENT_MSUSPEND = 17,
	SNDRV_TIMER_EVENT_MRESUME = 18,
};

struct snd_timer;

struct snd_timer_hardware {
	unsigned int flags;
	long unsigned int resolution;
	long unsigned int resolution_min;
	long unsigned int resolution_max;
	long unsigned int ticks;
	int (*open)(struct snd_timer *);
	int (*close)(struct snd_timer *);
	long unsigned int (*c_resolution)(struct snd_timer *);
	int (*start)(struct snd_timer *);
	int (*stop)(struct snd_timer *);
	int (*set_period)(struct snd_timer *, long unsigned int, long unsigned int);
	int (*precise_resolution)(struct snd_timer *, long unsigned int *, long unsigned int *);
};

struct snd_timer {
	int tmr_class;
	struct snd_card *card;
	struct module *module;
	int tmr_device;
	int tmr_subdevice;
	char id[64];
	char name[80];
	unsigned int flags;
	int running;
	long unsigned int sticks;
	void *private_data;
	void (*private_free)(struct snd_timer *);
	struct snd_timer_hardware hw;
	spinlock_t lock;
	struct list_head device_list;
	struct list_head open_list_head;
	struct list_head active_list_head;
	struct list_head ack_list_head;
	struct list_head sack_list_head;
	struct work_struct task_work;
	int max_instances;
	int num_instances;
};

struct snd_timer_instance {
	struct snd_timer *timer;
	char *owner;
	unsigned int flags;
	void *private_data;
	void (*private_free)(struct snd_timer_instance *);
	void (*callback)(struct snd_timer_instance *, long unsigned int, long unsigned int);
	void (*ccallback)(struct snd_timer_instance *, int, struct timespec64 *, long unsigned int);
	void (*disconnect)(struct snd_timer_instance *);
	void *callback_data;
	long unsigned int ticks;
	long unsigned int cticks;
	long unsigned int pticks;
	long unsigned int resolution;
	long unsigned int lost;
	int slave_class;
	unsigned int slave_id;
	struct list_head open_list;
	struct list_head active_list;
	struct list_head ack_list;
	struct list_head slave_list_head;
	struct list_head slave_active_head;
	struct snd_timer_instance *master;
};

enum timer_tread_format {
	TREAD_FORMAT_NONE = 0,
	TREAD_FORMAT_TIME64 = 1,
	TREAD_FORMAT_TIME32 = 2,
};

struct snd_timer_tread32 {
	int event;
	s32 tstamp_sec;
	s32 tstamp_nsec;
	unsigned int val;
};

struct snd_timer_tread64 {
	int event;
	u8 pad1[4];
	s64 tstamp_sec;
	s64 tstamp_nsec;
	unsigned int val;
	u8 pad2[4];
};

struct snd_timer_user {
	struct snd_timer_instance *timeri;
	int tread;
	long unsigned int ticks;
	long unsigned int overrun;
	int qhead;
	int qtail;
	int qused;
	int queue_size;
	bool disconnected;
	struct snd_timer_read *queue;
	struct snd_timer_tread64 *tqueue;
	spinlock_t qlock;
	long unsigned int last_resolution;
	unsigned int filter;
	struct timespec64 tstamp;
	wait_queue_head_t qchange_sleep;
	struct fasync_struct *fasync;
	struct mutex ioctl_lock;
};

struct snd_timer_status32 {
	s32 tstamp_sec;
	s32 tstamp_nsec;
	unsigned int resolution;
	unsigned int lost;
	unsigned int overrun;
	unsigned int queue;
	unsigned char reserved[64];
};

struct snd_timer_status64 {
	s64 tstamp_sec;
	s64 tstamp_nsec;
	unsigned int resolution;
	unsigned int lost;
	unsigned int overrun;
	unsigned int queue;
	unsigned char reserved[64];
};

struct snd_timer_system_private {
	struct timer_list tlist;
	struct snd_timer *snd_timer;
	long unsigned int last_expires;
	long unsigned int last_jiffies;
	long unsigned int correction;
};

enum {
	SNDRV_TIMER_IOCTL_START_OLD = 21536,
	SNDRV_TIMER_IOCTL_STOP_OLD = 21537,
	SNDRV_TIMER_IOCTL_CONTINUE_OLD = 21538,
	SNDRV_TIMER_IOCTL_PAUSE_OLD = 21539,
};

typedef long unsigned int snd_pcm_uframes_t;

typedef long int snd_pcm_sframes_t;

enum {
	SNDRV_PCM_CLASS_GENERIC = 0,
	SNDRV_PCM_CLASS_MULTI = 1,
	SNDRV_PCM_CLASS_MODEM = 2,
	SNDRV_PCM_CLASS_DIGITIZER = 3,
	SNDRV_PCM_CLASS_LAST = 3,
};

typedef int snd_pcm_access_t;

typedef int snd_pcm_format_t;

typedef int snd_pcm_subformat_t;

typedef int snd_pcm_state_t;

union snd_pcm_sync_id {
	unsigned char id[16];
	short unsigned int id16[8];
	unsigned int id32[4];
};

struct snd_pcm_info {
	unsigned int device;
	unsigned int subdevice;
	int stream;
	int card;
	unsigned char id[64];
	unsigned char name[80];
	unsigned char subname[32];
	int dev_class;
	int dev_subclass;
	unsigned int subdevices_count;
	unsigned int subdevices_avail;
	union snd_pcm_sync_id sync;
	unsigned char reserved[64];
};

struct snd_interval {
	unsigned int min;
	unsigned int max;
	unsigned int openmin: 1;
	unsigned int openmax: 1;
	unsigned int integer: 1;
	unsigned int empty: 1;
};

struct snd_mask {
	__u32 bits[8];
};

struct snd_pcm_hw_params {
	unsigned int flags;
	struct snd_mask masks[3];
	struct snd_mask mres[5];
	struct snd_interval intervals[12];
	struct snd_interval ires[9];
	unsigned int rmask;
	unsigned int cmask;
	unsigned int info;
	unsigned int msbits;
	unsigned int rate_num;
	unsigned int rate_den;
	snd_pcm_uframes_t fifo_size;
	unsigned char reserved[64];
};

enum {
	SNDRV_PCM_TSTAMP_NONE = 0,
	SNDRV_PCM_TSTAMP_ENABLE = 1,
	SNDRV_PCM_TSTAMP_LAST = 1,
};

typedef char __pad_before_uframe[0];

typedef char __pad_after_uframe[0];

struct snd_pcm_mmap_status {
	snd_pcm_state_t state;
	__u32 pad1;
	__pad_before_uframe __pad1;
	snd_pcm_uframes_t hw_ptr;
	__pad_after_uframe __pad2;
	struct __kernel_timespec tstamp;
	snd_pcm_state_t suspended_state;
	__u32 pad3;
	struct __kernel_timespec audio_tstamp;
};

struct snd_pcm_mmap_control {
	__pad_before_uframe __pad1;
	snd_pcm_uframes_t appl_ptr;
	__pad_before_uframe __pad2;
	__pad_before_uframe __pad3;
	snd_pcm_uframes_t avail_min;
	__pad_after_uframe __pad4;
};

struct snd_dma_device {
	int type;
	struct device *dev;
};

struct snd_dma_buffer {
	struct snd_dma_device dev;
	unsigned char *area;
	dma_addr_t addr;
	size_t bytes;
	void *private_data;
};

struct snd_pcm_hardware {
	unsigned int info;
	u64 formats;
	unsigned int rates;
	unsigned int rate_min;
	unsigned int rate_max;
	unsigned int channels_min;
	unsigned int channels_max;
	size_t buffer_bytes_max;
	size_t period_bytes_min;
	size_t period_bytes_max;
	unsigned int periods_min;
	unsigned int periods_max;
	size_t fifo_size;
};

struct snd_pcm_substream;

struct snd_pcm_audio_tstamp_config;

struct snd_pcm_audio_tstamp_report;

struct snd_pcm_ops {
	int (*open)(struct snd_pcm_substream *);
	int (*close)(struct snd_pcm_substream *);
	int (*ioctl)(struct snd_pcm_substream *, unsigned int, void *);
	int (*hw_params)(struct snd_pcm_substream *, struct snd_pcm_hw_params *);
	int (*hw_free)(struct snd_pcm_substream *);
	int (*prepare)(struct snd_pcm_substream *);
	int (*trigger)(struct snd_pcm_substream *, int);
	int (*sync_stop)(struct snd_pcm_substream *);
	snd_pcm_uframes_t (*pointer)(struct snd_pcm_substream *);
	int (*get_time_info)(struct snd_pcm_substream *, struct timespec64 *, struct timespec64 *, struct snd_pcm_audio_tstamp_config *, struct snd_pcm_audio_tstamp_report *);
	int (*fill_silence)(struct snd_pcm_substream *, int, long unsigned int, long unsigned int);
	int (*copy_user)(struct snd_pcm_substream *, int, long unsigned int, void *, long unsigned int);
	int (*copy_kernel)(struct snd_pcm_substream *, int, long unsigned int, void *, long unsigned int);
	struct page * (*page)(struct snd_pcm_substream *, long unsigned int);
	int (*mmap)(struct snd_pcm_substream *, struct vm_area_struct *);
	int (*ack)(struct snd_pcm_substream *);
};

struct snd_pcm_group {
	spinlock_t lock;
	struct mutex mutex;
	struct list_head substreams;
	refcount_t refs;
};

struct snd_pcm;

struct snd_pcm_str;

struct snd_pcm_runtime;

struct snd_pcm_substream {
	struct snd_pcm *pcm;
	struct snd_pcm_str *pstr;
	void *private_data;
	int number;
	char name[32];
	int stream;
	struct pm_qos_request latency_pm_qos_req;
	size_t buffer_bytes_max;
	struct snd_dma_buffer dma_buffer;
	size_t dma_max;
	const struct snd_pcm_ops *ops;
	struct snd_pcm_runtime *runtime;
	struct snd_timer *timer;
	unsigned int timer_running: 1;
	long int wait_time;
	struct snd_pcm_substream *next;
	struct list_head link_list;
	struct snd_pcm_group self_group;
	struct snd_pcm_group *group;
	int ref_count;
	atomic_t mmap_count;
	unsigned int f_flags;
	void (*pcm_release)(struct snd_pcm_substream *);
	struct pid *pid;
	struct snd_info_entry *proc_root;
	unsigned int hw_opened: 1;
	unsigned int managed_buffer_alloc: 1;
};

struct snd_pcm_audio_tstamp_config {
	u32 type_requested: 4;
	u32 report_delay: 1;
};

struct snd_pcm_audio_tstamp_report {
	u32 valid: 1;
	u32 actual_type: 4;
	u32 accuracy_report: 1;
	u32 accuracy;
};

struct snd_pcm_hw_rule;

typedef int (*snd_pcm_hw_rule_func_t)(struct snd_pcm_hw_params *, struct snd_pcm_hw_rule *);

struct snd_pcm_hw_rule {
	unsigned int cond;
	int var;
	int deps[4];
	snd_pcm_hw_rule_func_t func;
	void *private;
};

struct snd_pcm_hw_constraints {
	struct snd_mask masks[3];
	struct snd_interval intervals[12];
	unsigned int rules_num;
	unsigned int rules_all;
	struct snd_pcm_hw_rule *rules;
};

struct snd_pcm_runtime {
	struct snd_pcm_substream *trigger_master;
	struct timespec64 trigger_tstamp;
	bool trigger_tstamp_latched;
	int overrange;
	snd_pcm_uframes_t avail_max;
	snd_pcm_uframes_t hw_ptr_base;
	snd_pcm_uframes_t hw_ptr_interrupt;
	long unsigned int hw_ptr_jiffies;
	long unsigned int hw_ptr_buffer_jiffies;
	snd_pcm_sframes_t delay;
	u64 hw_ptr_wrap;
	snd_pcm_access_t access;
	snd_pcm_format_t format;
	snd_pcm_subformat_t subformat;
	unsigned int rate;
	unsigned int channels;
	snd_pcm_uframes_t period_size;
	unsigned int periods;
	snd_pcm_uframes_t buffer_size;
	snd_pcm_uframes_t min_align;
	size_t byte_align;
	unsigned int frame_bits;
	unsigned int sample_bits;
	unsigned int info;
	unsigned int rate_num;
	unsigned int rate_den;
	unsigned int no_period_wakeup: 1;
	int tstamp_mode;
	unsigned int period_step;
	snd_pcm_uframes_t start_threshold;
	snd_pcm_uframes_t stop_threshold;
	snd_pcm_uframes_t silence_threshold;
	snd_pcm_uframes_t silence_size;
	snd_pcm_uframes_t boundary;
	snd_pcm_uframes_t silence_start;
	snd_pcm_uframes_t silence_filled;
	union snd_pcm_sync_id sync;
	struct snd_pcm_mmap_status *status;
	struct snd_pcm_mmap_control *control;
	snd_pcm_uframes_t twake;
	wait_queue_head_t sleep;
	wait_queue_head_t tsleep;
	struct fasync_struct *fasync;
	bool stop_operating;
	void *private_data;
	void (*private_free)(struct snd_pcm_runtime *);
	struct snd_pcm_hardware hw;
	struct snd_pcm_hw_constraints hw_constraints;
	unsigned int timer_resolution;
	int tstamp_type;
	unsigned char *dma_area;
	dma_addr_t dma_addr;
	size_t dma_bytes;
	struct snd_dma_buffer *dma_buffer_p;
	unsigned int buffer_changed: 1;
	struct snd_pcm_audio_tstamp_config audio_tstamp_config;
	struct snd_pcm_audio_tstamp_report audio_tstamp_report;
	struct timespec64 driver_tstamp;
	struct mutex buffer_mutex;
	atomic_t buffer_accessing;
};

struct snd_pcm_str {
	int stream;
	struct snd_pcm *pcm;
	unsigned int substream_count;
	unsigned int substream_opened;
	struct snd_pcm_substream *substream;
	struct snd_info_entry *proc_root;
	struct snd_kcontrol *chmap_kctl;
	struct device dev;
};

struct snd_pcm {
	struct snd_card *card;
	struct list_head list;
	int device;
	unsigned int info_flags;
	short unsigned int dev_class;
	short unsigned int dev_subclass;
	char id[64];
	char name[80];
	struct snd_pcm_str streams[2];
	struct mutex open_mutex;
	wait_queue_head_t open_wait;
	void *private_data;
	void (*private_free)(struct snd_pcm *);
	bool internal;
	bool nonatomic;
	bool no_device_suspend;
};

struct snd_pcm_status64 {
	snd_pcm_state_t state;
	u8 rsvd[4];
	s64 trigger_tstamp_sec;
	s64 trigger_tstamp_nsec;
	s64 tstamp_sec;
	s64 tstamp_nsec;
	snd_pcm_uframes_t appl_ptr;
	snd_pcm_uframes_t hw_ptr;
	snd_pcm_sframes_t delay;
	snd_pcm_uframes_t avail;
	snd_pcm_uframes_t avail_max;
	snd_pcm_uframes_t overrange;
	snd_pcm_state_t suspended_state;
	__u32 audio_tstamp_data;
	s64 audio_tstamp_sec;
	s64 audio_tstamp_nsec;
	s64 driver_tstamp_sec;
	s64 driver_tstamp_nsec;
	__u32 audio_tstamp_accuracy;
	unsigned char reserved[20];
};

enum {
	SNDRV_PCM_MMAP_OFFSET_DATA = 0,
	SNDRV_PCM_MMAP_OFFSET_STATUS_OLD = 2147483648,
	SNDRV_PCM_MMAP_OFFSET_CONTROL_OLD = 2164260864,
	SNDRV_PCM_MMAP_OFFSET_STATUS_NEW = 2181038080,
	SNDRV_PCM_MMAP_OFFSET_CONTROL_NEW = 2197815296,
	SNDRV_PCM_MMAP_OFFSET_STATUS = 2181038080,
	SNDRV_PCM_MMAP_OFFSET_CONTROL = 2197815296,
};

typedef int snd_pcm_hw_param_t;

struct snd_pcm_sw_params {
	int tstamp_mode;
	unsigned int period_step;
	unsigned int sleep_min;
	snd_pcm_uframes_t avail_min;
	snd_pcm_uframes_t xfer_align;
	snd_pcm_uframes_t start_threshold;
	snd_pcm_uframes_t stop_threshold;
	snd_pcm_uframes_t silence_threshold;
	snd_pcm_uframes_t silence_size;
	snd_pcm_uframes_t boundary;
	unsigned int proto;
	unsigned int tstamp_type;
	unsigned char reserved[56];
};

struct snd_pcm_channel_info {
	unsigned int channel;
	__kernel_off_t offset;
	unsigned int first;
	unsigned int step;
};

enum {
	SNDRV_PCM_AUDIO_TSTAMP_TYPE_COMPAT = 0,
	SNDRV_PCM_AUDIO_TSTAMP_TYPE_DEFAULT = 1,
	SNDRV_PCM_AUDIO_TSTAMP_TYPE_LINK = 2,
	SNDRV_PCM_AUDIO_TSTAMP_TYPE_LINK_ABSOLUTE = 3,
	SNDRV_PCM_AUDIO_TSTAMP_TYPE_LINK_ESTIMATED = 4,
	SNDRV_PCM_AUDIO_TSTAMP_TYPE_LINK_SYNCHRONIZED = 5,
	SNDRV_PCM_AUDIO_TSTAMP_TYPE_LAST = 5,
};

struct snd_pcm_sync_ptr {
	__u32 flags;
	__u32 pad1;
	union {
		struct snd_pcm_mmap_status status;
		unsigned char reserved[64];
	} s;
	union {
		struct snd_pcm_mmap_control control;
		unsigned char reserved[64];
	} c;
};

struct snd_xferi {
	snd_pcm_sframes_t result;
	void *buf;
	snd_pcm_uframes_t frames;
};

struct snd_xfern {
	snd_pcm_sframes_t result;
	void **bufs;
	snd_pcm_uframes_t frames;
};

enum {
	SNDRV_PCM_TSTAMP_TYPE_GETTIMEOFDAY = 0,
	SNDRV_PCM_TSTAMP_TYPE_MONOTONIC = 1,
	SNDRV_PCM_TSTAMP_TYPE_MONOTONIC_RAW = 2,
	SNDRV_PCM_TSTAMP_TYPE_LAST = 2,
};

struct snd_pcm_file {
	struct snd_pcm_substream *substream;
	int no_compat_mmap;
	unsigned int user_pversion;
};

struct snd_pcm_hw_constraint_list {
	const unsigned int *list;
	unsigned int count;
	unsigned int mask;
};

struct snd_pcm_status32 {
	snd_pcm_state_t state;
	s32 trigger_tstamp_sec;
	s32 trigger_tstamp_nsec;
	s32 tstamp_sec;
	s32 tstamp_nsec;
	u32 appl_ptr;
	u32 hw_ptr;
	s32 delay;
	u32 avail;
	u32 avail_max;
	u32 overrange;
	snd_pcm_state_t suspended_state;
	u32 audio_tstamp_data;
	s32 audio_tstamp_sec;
	s32 audio_tstamp_nsec;
	s32 driver_tstamp_sec;
	s32 driver_tstamp_nsec;
	u32 audio_tstamp_accuracy;
	unsigned char reserved[36];
};

struct snd_pcm_hw_params_old {
	unsigned int flags;
	unsigned int masks[3];
	struct snd_interval intervals[12];
	unsigned int rmask;
	unsigned int cmask;
	unsigned int info;
	unsigned int msbits;
	unsigned int rate_num;
	unsigned int rate_den;
	snd_pcm_uframes_t fifo_size;
	unsigned char reserved[64];
};

struct action_ops {
	int (*pre_action)(struct snd_pcm_substream *, snd_pcm_state_t);
	int (*do_action)(struct snd_pcm_substream *, snd_pcm_state_t);
	void (*undo_action)(struct snd_pcm_substream *, snd_pcm_state_t);
	void (*post_action)(struct snd_pcm_substream *, snd_pcm_state_t);
};

struct snd_pcm_mmap_status32 {
	snd_pcm_state_t state;
	s32 pad1;
	u32 hw_ptr;
	s32 tstamp_sec;
	s32 tstamp_nsec;
	snd_pcm_state_t suspended_state;
	s32 audio_tstamp_sec;
	s32 audio_tstamp_nsec;
};

struct snd_pcm_mmap_control32 {
	u32 appl_ptr;
	u32 avail_min;
};

struct snd_pcm_sync_ptr32 {
	u32 flags;
	union {
		struct snd_pcm_mmap_status32 status;
		unsigned char reserved[64];
	} s;
	union {
		struct snd_pcm_mmap_control32 control;
		unsigned char reserved[64];
	} c;
};

typedef u64 u_int64_t;

enum {
	SNDRV_CHMAP_UNKNOWN = 0,
	SNDRV_CHMAP_NA = 1,
	SNDRV_CHMAP_MONO = 2,
	SNDRV_CHMAP_FL = 3,
	SNDRV_CHMAP_FR = 4,
	SNDRV_CHMAP_RL = 5,
	SNDRV_CHMAP_RR = 6,
	SNDRV_CHMAP_FC = 7,
	SNDRV_CHMAP_LFE = 8,
	SNDRV_CHMAP_SL = 9,
	SNDRV_CHMAP_SR = 10,
	SNDRV_CHMAP_RC = 11,
	SNDRV_CHMAP_FLC = 12,
	SNDRV_CHMAP_FRC = 13,
	SNDRV_CHMAP_RLC = 14,
	SNDRV_CHMAP_RRC = 15,
	SNDRV_CHMAP_FLW = 16,
	SNDRV_CHMAP_FRW = 17,
	SNDRV_CHMAP_FLH = 18,
	SNDRV_CHMAP_FCH = 19,
	SNDRV_CHMAP_FRH = 20,
	SNDRV_CHMAP_TC = 21,
	SNDRV_CHMAP_TFL = 22,
	SNDRV_CHMAP_TFR = 23,
	SNDRV_CHMAP_TFC = 24,
	SNDRV_CHMAP_TRL = 25,
	SNDRV_CHMAP_TRR = 26,
	SNDRV_CHMAP_TRC = 27,
	SNDRV_CHMAP_TFLC = 28,
	SNDRV_CHMAP_TFRC = 29,
	SNDRV_CHMAP_TSL = 30,
	SNDRV_CHMAP_TSR = 31,
	SNDRV_CHMAP_LLFE = 32,
	SNDRV_CHMAP_RLFE = 33,
	SNDRV_CHMAP_BC = 34,
	SNDRV_CHMAP_BLC = 35,
	SNDRV_CHMAP_BRC = 36,
	SNDRV_CHMAP_LAST = 36,
};

struct snd_ratnum {
	unsigned int num;
	unsigned int den_min;
	unsigned int den_max;
	unsigned int den_step;
};

struct snd_ratden {
	unsigned int num_min;
	unsigned int num_max;
	unsigned int num_step;
	unsigned int den;
};

struct snd_pcm_hw_constraint_ratnums {
	int nrats;
	const struct snd_ratnum *rats;
};

struct snd_pcm_hw_constraint_ratdens {
	int nrats;
	const struct snd_ratden *rats;
};

struct snd_pcm_hw_constraint_ranges {
	unsigned int count;
	const struct snd_interval *ranges;
	unsigned int mask;
};

struct snd_pcm_chmap_elem {
	unsigned char channels;
	unsigned char map[15];
};

struct snd_pcm_chmap {
	struct snd_pcm *pcm;
	int stream;
	struct snd_kcontrol *kctl;
	const struct snd_pcm_chmap_elem *chmap;
	unsigned int max_channels;
	unsigned int channel_mask;
	void *private_data;
};

typedef int (*pcm_transfer_f)(struct snd_pcm_substream *, int, long unsigned int, void *, long unsigned int);

typedef int (*pcm_copy_f)(struct snd_pcm_substream *, snd_pcm_uframes_t, void *, snd_pcm_uframes_t, snd_pcm_uframes_t, pcm_transfer_f);

struct pcm_format_data {
	unsigned char width;
	unsigned char phys;
	signed char le;
	signed char signd;
	unsigned char silence[8];
};

struct snd_dmaengine_dai_dma_data {
	dma_addr_t addr;
	enum dma_slave_buswidth addr_width;
	u32 maxburst;
	unsigned int slave_id;
	void *filter_data;
	const char *chan_name;
	unsigned int fifo_size;
	unsigned int flags;
	void *peripheral_config;
	size_t peripheral_size;
};

struct dmaengine_pcm_runtime_data {
	struct dma_chan *dma_chan;
	dma_cookie_t cookie;
	unsigned int pos;
};

struct snd_enc_wma {
	__u32 super_block_align;
};

struct snd_enc_vorbis {
	__s32 quality;
	__u32 managed;
	__u32 max_bit_rate;
	__u32 min_bit_rate;
	__u32 downmix;
};

struct snd_enc_real {
	__u32 quant_bits;
	__u32 start_region;
	__u32 num_regions;
};

struct snd_enc_flac {
	__u32 num;
	__u32 gain;
};

struct snd_enc_generic {
	__u32 bw;
	__s32 reserved[15];
};

struct snd_dec_flac {
	__u16 sample_size;
	__u16 min_blk_size;
	__u16 max_blk_size;
	__u16 min_frame_size;
	__u16 max_frame_size;
	__u16 reserved;
};

struct snd_dec_wma {
	__u32 encoder_option;
	__u32 adv_encoder_option;
	__u32 adv_encoder_option2;
	__u32 reserved;
};

struct snd_dec_alac {
	__u32 frame_length;
	__u8 compatible_version;
	__u8 pb;
	__u8 mb;
	__u8 kb;
	__u32 max_run;
	__u32 max_frame_bytes;
};

struct snd_dec_ape {
	__u16 compatible_version;
	__u16 compression_level;
	__u32 format_flags;
	__u32 blocks_per_frame;
	__u32 final_frame_blocks;
	__u32 total_frames;
	__u32 seek_table_present;
};

union snd_codec_options {
	struct snd_enc_wma wma;
	struct snd_enc_vorbis vorbis;
	struct snd_enc_real real;
	struct snd_enc_flac flac;
	struct snd_enc_generic generic;
	struct snd_dec_flac flac_d;
	struct snd_dec_wma wma_d;
	struct snd_dec_alac alac_d;
	struct snd_dec_ape ape_d;
};

struct snd_codec_desc {
	__u32 max_ch;
	__u32 sample_rates[32];
	__u32 num_sample_rates;
	__u32 bit_rate[32];
	__u32 num_bitrates;
	__u32 rate_control;
	__u32 profiles;
	__u32 modes;
	__u32 formats;
	__u32 min_buffer;
	__u32 reserved[15];
};

struct snd_codec {
	__u32 id;
	__u32 ch_in;
	__u32 ch_out;
	__u32 sample_rate;
	__u32 bit_rate;
	__u32 rate_control;
	__u32 profile;
	__u32 level;
	__u32 ch_mode;
	__u32 format;
	__u32 align;
	union snd_codec_options options;
	__u32 reserved[3];
};

struct snd_compressed_buffer {
	__u32 fragment_size;
	__u32 fragments;
};

struct snd_compr_params {
	struct snd_compressed_buffer buffer;
	struct snd_codec codec;
	__u8 no_wake_mode;
};

struct snd_compr_tstamp {
	__u32 byte_offset;
	__u32 copied_total;
	__u32 pcm_frames;
	__u32 pcm_io_frames;
	__u32 sampling_rate;
};

enum snd_compr_direction {
	SND_COMPRESS_PLAYBACK = 0,
	SND_COMPRESS_CAPTURE = 1,
};

struct snd_compr_caps {
	__u32 num_codecs;
	__u32 direction;
	__u32 min_fragment_size;
	__u32 max_fragment_size;
	__u32 min_fragments;
	__u32 max_fragments;
	__u32 codecs[32];
	__u32 reserved[11];
};

struct snd_compr_codec_caps {
	__u32 codec;
	__u32 num_descriptors;
	struct snd_codec_desc descriptor[32];
};

struct snd_compr_metadata {
	__u32 key;
	__u32 value[8];
};

struct snd_compr_ops;

struct snd_compr_runtime {
	snd_pcm_state_t state;
	struct snd_compr_ops *ops;
	void *buffer;
	u64 buffer_size;
	u32 fragment_size;
	u32 fragments;
	u64 total_bytes_available;
	u64 total_bytes_transferred;
	wait_queue_head_t sleep;
	void *private_data;
	unsigned char *dma_area;
	dma_addr_t dma_addr;
	size_t dma_bytes;
	struct snd_dma_buffer *dma_buffer_p;
};

struct snd_compr_stream;

struct snd_compr_ops {
	int (*open)(struct snd_compr_stream *);
	int (*free)(struct snd_compr_stream *);
	int (*set_params)(struct snd_compr_stream *, struct snd_compr_params *);
	int (*get_params)(struct snd_compr_stream *, struct snd_codec *);
	int (*set_metadata)(struct snd_compr_stream *, struct snd_compr_metadata *);
	int (*get_metadata)(struct snd_compr_stream *, struct snd_compr_metadata *);
	int (*trigger)(struct snd_compr_stream *, int);
	int (*pointer)(struct snd_compr_stream *, struct snd_compr_tstamp *);
	int (*copy)(struct snd_compr_stream *, char *, size_t);
	int (*mmap)(struct snd_compr_stream *, struct vm_area_struct *);
	int (*ack)(struct snd_compr_stream *, size_t);
	int (*get_caps)(struct snd_compr_stream *, struct snd_compr_caps *);
	int (*get_codec_caps)(struct snd_compr_stream *, struct snd_compr_codec_caps *);
};

struct snd_compr;

struct snd_compr_stream {
	const char *name;
	struct snd_compr_ops *ops;
	struct snd_compr_runtime *runtime;
	struct snd_compr *device;
	struct delayed_work error_work;
	enum snd_compr_direction direction;
	bool metadata_set;
	bool next_track;
	bool partial_drain;
	void *private_data;
	struct snd_dma_buffer dma_buffer;
};

struct snd_compr {
	const char *name;
	struct device dev;
	struct snd_compr_ops *ops;
	void *private_data;
	struct snd_card *card;
	unsigned int direction;
	struct mutex lock;
	int device;
	char id[64];
	struct snd_info_entry *proc_root;
	struct snd_info_entry *proc_info_entry;
};

struct snd_soc_tplg_hdr {
	__le32 magic;
	__le32 abi;
	__le32 version;
	__le32 type;
	__le32 size;
	__le32 vendor_type;
	__le32 payload_size;
	__le32 index;
	__le32 count;
};

struct snd_soc_tplg_vendor_uuid_elem {
	__le32 token;
	char uuid[16];
};

struct snd_soc_tplg_vendor_value_elem {
	__le32 token;
	__le32 value;
};

struct snd_soc_tplg_vendor_string_elem {
	__le32 token;
	char string[44];
};

struct snd_soc_tplg_vendor_array {
	__le32 size;
	__le32 type;
	__le32 num_elems;
	union {
		struct snd_soc_tplg_vendor_uuid_elem uuid[0];
		struct snd_soc_tplg_vendor_value_elem value[0];
		struct snd_soc_tplg_vendor_string_elem string[0];
	};
};

struct snd_soc_tplg_private {
	__le32 size;
	union {
		char data[0];
		struct snd_soc_tplg_vendor_array array[0];
	};
};

struct snd_soc_tplg_tlv_dbscale {
	__le32 min;
	__le32 step;
	__le32 mute;
};

struct snd_soc_tplg_ctl_tlv {
	__le32 size;
	__le32 type;
	union {
		__le32 data[32];
		struct snd_soc_tplg_tlv_dbscale scale;
	};
};

struct snd_soc_tplg_io_ops {
	__le32 get;
	__le32 put;
	__le32 info;
};

struct snd_soc_tplg_ctl_hdr {
	__le32 size;
	__le32 type;
	char name[44];
	__le32 access;
	struct snd_soc_tplg_io_ops ops;
	struct snd_soc_tplg_ctl_tlv tlv;
};

struct snd_soc_tplg_stream_caps {
	__le32 size;
	char name[44];
	__le64 formats;
	__le32 rates;
	__le32 rate_min;
	__le32 rate_max;
	__le32 channels_min;
	__le32 channels_max;
	__le32 periods_min;
	__le32 periods_max;
	__le32 period_size_min;
	__le32 period_size_max;
	__le32 buffer_size_min;
	__le32 buffer_size_max;
	__le32 sig_bits;
};

struct snd_soc_tplg_stream {
	__le32 size;
	char name[44];
	__le64 format;
	__le32 rate;
	__le32 period_bytes;
	__le32 buffer_bytes;
	__le32 channels;
};

struct snd_soc_tplg_hw_config {
	__le32 size;
	__le32 id;
	__le32 fmt;
	__u8 clock_gated;
	__u8 invert_bclk;
	__u8 invert_fsync;
	__u8 bclk_master;
	__u8 fsync_master;
	__u8 mclk_direction;
	__le16 reserved;
	__le32 mclk_rate;
	__le32 bclk_rate;
	__le32 fsync_rate;
	__le32 tdm_slots;
	__le32 tdm_slot_width;
	__le32 tx_slots;
	__le32 rx_slots;
	__le32 tx_channels;
	__le32 tx_chanmap[8];
	__le32 rx_channels;
	__le32 rx_chanmap[8];
};

struct snd_soc_tplg_manifest {
	__le32 size;
	__le32 control_elems;
	__le32 widget_elems;
	__le32 graph_elems;
	__le32 pcm_elems;
	__le32 dai_link_elems;
	__le32 dai_elems;
	__le32 reserved[20];
	struct snd_soc_tplg_private priv;
};

struct snd_soc_tplg_dapm_widget {
	__le32 size;
	__le32 id;
	char name[44];
	char sname[44];
	__le32 reg;
	__le32 shift;
	__le32 mask;
	__le32 subseq;
	__le32 invert;
	__le32 ignore_suspend;
	__le16 event_flags;
	__le16 event_type;
	__le32 num_kcontrols;
	struct snd_soc_tplg_private priv;
};

struct snd_soc_tplg_pcm {
	__le32 size;
	char pcm_name[44];
	char dai_name[44];
	__le32 pcm_id;
	__le32 dai_id;
	__le32 playback;
	__le32 capture;
	__le32 compress;
	struct snd_soc_tplg_stream stream[8];
	__le32 num_streams;
	struct snd_soc_tplg_stream_caps caps[2];
	__le32 flag_mask;
	__le32 flags;
	struct snd_soc_tplg_private priv;
} __attribute__((packed));

struct snd_soc_tplg_link_config {
	__le32 size;
	__le32 id;
	char name[44];
	char stream_name[44];
	struct snd_soc_tplg_stream stream[8];
	__le32 num_streams;
	struct snd_soc_tplg_hw_config hw_config[8];
	__le32 num_hw_configs;
	__le32 default_hw_config_id;
	__le32 flag_mask;
	__le32 flags;
	struct snd_soc_tplg_private priv;
};

enum snd_soc_dobj_type {
	SND_SOC_DOBJ_NONE = 0,
	SND_SOC_DOBJ_MIXER = 1,
	SND_SOC_DOBJ_BYTES = 2,
	SND_SOC_DOBJ_ENUM = 3,
	SND_SOC_DOBJ_GRAPH = 4,
	SND_SOC_DOBJ_WIDGET = 5,
	SND_SOC_DOBJ_DAI_LINK = 6,
	SND_SOC_DOBJ_PCM = 7,
	SND_SOC_DOBJ_CODEC_LINK = 8,
	SND_SOC_DOBJ_BACKEND_LINK = 9,
};

struct snd_soc_dobj_control {
	struct snd_kcontrol *kcontrol;
	char **dtexts;
	long unsigned int *dvalues;
};

struct snd_soc_dobj_widget {
	unsigned int kcontrol_type;
};

struct snd_soc_tplg_ops;

struct snd_soc_dobj {
	enum snd_soc_dobj_type type;
	unsigned int index;
	struct list_head list;
	struct snd_soc_tplg_ops *ops;
	union {
		struct snd_soc_dobj_control control;
		struct snd_soc_dobj_widget widget;
	};
	void *private;
};

struct snd_soc_component;

struct snd_soc_dapm_route;

struct snd_soc_dapm_widget;

struct snd_soc_dai_driver;

struct snd_soc_dai;

struct snd_soc_dai_link;

struct snd_soc_tplg_kcontrol_ops;

struct snd_soc_tplg_bytes_ext_ops;

struct snd_soc_tplg_ops {
	int (*control_load)(struct snd_soc_component *, int, struct snd_kcontrol_new *, struct snd_soc_tplg_ctl_hdr *);
	int (*control_unload)(struct snd_soc_component *, struct snd_soc_dobj *);
	int (*dapm_route_load)(struct snd_soc_component *, int, struct snd_soc_dapm_route *);
	int (*dapm_route_unload)(struct snd_soc_component *, struct snd_soc_dobj *);
	int (*widget_load)(struct snd_soc_component *, int, struct snd_soc_dapm_widget *, struct snd_soc_tplg_dapm_widget *);
	int (*widget_ready)(struct snd_soc_component *, int, struct snd_soc_dapm_widget *, struct snd_soc_tplg_dapm_widget *);
	int (*widget_unload)(struct snd_soc_component *, struct snd_soc_dobj *);
	int (*dai_load)(struct snd_soc_component *, int, struct snd_soc_dai_driver *, struct snd_soc_tplg_pcm *, struct snd_soc_dai *);
	int (*dai_unload)(struct snd_soc_component *, struct snd_soc_dobj *);
	int (*link_load)(struct snd_soc_component *, int, struct snd_soc_dai_link *, struct snd_soc_tplg_link_config *);
	int (*link_unload)(struct snd_soc_component *, struct snd_soc_dobj *);
	int (*vendor_load)(struct snd_soc_component *, int, struct snd_soc_tplg_hdr *);
	int (*vendor_unload)(struct snd_soc_component *, struct snd_soc_tplg_hdr *);
	void (*complete)(struct snd_soc_component *);
	int (*manifest)(struct snd_soc_component *, int, struct snd_soc_tplg_manifest *);
	const struct snd_soc_tplg_kcontrol_ops *io_ops;
	int io_ops_count;
	const struct snd_soc_tplg_bytes_ext_ops *bytes_ext_ops;
	int bytes_ext_ops_count;
};

struct snd_soc_tplg_kcontrol_ops {
	u32 id;
	int (*get)(struct snd_kcontrol *, struct snd_ctl_elem_value *);
	int (*put)(struct snd_kcontrol *, struct snd_ctl_elem_value *);
	int (*info)(struct snd_kcontrol *, struct snd_ctl_elem_info *);
};

struct snd_soc_tplg_bytes_ext_ops {
	u32 id;
	int (*get)(struct snd_kcontrol *, unsigned int *, unsigned int);
	int (*put)(struct snd_kcontrol *, const unsigned int *, unsigned int);
};

enum snd_soc_dapm_type {
	snd_soc_dapm_input = 0,
	snd_soc_dapm_output = 1,
	snd_soc_dapm_mux = 2,
	snd_soc_dapm_demux = 3,
	snd_soc_dapm_mixer = 4,
	snd_soc_dapm_mixer_named_ctl = 5,
	snd_soc_dapm_pga = 6,
	snd_soc_dapm_out_drv = 7,
	snd_soc_dapm_adc = 8,
	snd_soc_dapm_dac = 9,
	snd_soc_dapm_micbias = 10,
	snd_soc_dapm_mic = 11,
	snd_soc_dapm_hp = 12,
	snd_soc_dapm_spk = 13,
	snd_soc_dapm_line = 14,
	snd_soc_dapm_switch = 15,
	snd_soc_dapm_vmid = 16,
	snd_soc_dapm_pre = 17,
	snd_soc_dapm_post = 18,
	snd_soc_dapm_supply = 19,
	snd_soc_dapm_pinctrl = 20,
	snd_soc_dapm_regulator_supply = 21,
	snd_soc_dapm_clock_supply = 22,
	snd_soc_dapm_aif_in = 23,
	snd_soc_dapm_aif_out = 24,
	snd_soc_dapm_siggen = 25,
	snd_soc_dapm_sink = 26,
	snd_soc_dapm_dai_in = 27,
	snd_soc_dapm_dai_out = 28,
	snd_soc_dapm_dai_link = 29,
	snd_soc_dapm_kcontrol = 30,
	snd_soc_dapm_buffer = 31,
	snd_soc_dapm_scheduler = 32,
	snd_soc_dapm_effect = 33,
	snd_soc_dapm_src = 34,
	snd_soc_dapm_asrc = 35,
	snd_soc_dapm_encoder = 36,
	snd_soc_dapm_decoder = 37,
	SND_SOC_DAPM_TYPE_COUNT = 38,
};

struct snd_soc_dapm_context;

struct snd_soc_dapm_widget {
	enum snd_soc_dapm_type id;
	const char *name;
	const char *sname;
	struct list_head list;
	struct snd_soc_dapm_context *dapm;
	void *priv;
	struct regulator *regulator;
	struct pinctrl *pinctrl;
	int reg;
	unsigned char shift;
	unsigned int mask;
	unsigned int on_val;
	unsigned int off_val;
	unsigned char power: 1;
	unsigned char active: 1;
	unsigned char connected: 1;
	unsigned char new: 1;
	unsigned char force: 1;
	unsigned char ignore_suspend: 1;
	unsigned char new_power: 1;
	unsigned char power_checked: 1;
	unsigned char is_supply: 1;
	unsigned char is_ep: 2;
	int subseq;
	int (*power_check)(struct snd_soc_dapm_widget *);
	short unsigned int event_flags;
	int (*event)(struct snd_soc_dapm_widget *, struct snd_kcontrol *, int);
	int num_kcontrols;
	const struct snd_kcontrol_new *kcontrol_news;
	struct snd_kcontrol **kcontrols;
	struct snd_soc_dobj dobj;
	struct list_head edges[2];
	struct list_head work_list;
	struct list_head power_list;
	struct list_head dirty;
	int endpoints[2];
	struct clk *clk;
	int channel;
};

enum snd_soc_bias_level {
	SND_SOC_BIAS_OFF = 0,
	SND_SOC_BIAS_STANDBY = 1,
	SND_SOC_BIAS_PREPARE = 2,
	SND_SOC_BIAS_ON = 3,
};

struct snd_soc_dapm_wcache {
	struct snd_soc_dapm_widget *widget;
};

struct snd_soc_card;

struct snd_soc_dapm_context {
	enum snd_soc_bias_level bias_level;
	unsigned int idle_bias_off: 1;
	unsigned int suspend_bias_off: 1;
	struct device *dev;
	struct snd_soc_component *component;
	struct snd_soc_card *card;
	enum snd_soc_bias_level target_bias_level;
	struct list_head list;
	struct snd_soc_dapm_wcache path_sink_cache;
	struct snd_soc_dapm_wcache path_source_cache;
	struct dentry *debugfs_dapm;
};

struct snd_soc_component_driver;

struct snd_soc_component {
	const char *name;
	int id;
	const char *name_prefix;
	struct device *dev;
	struct snd_soc_card *card;
	unsigned int active;
	unsigned int suspended: 1;
	struct list_head list;
	struct list_head card_aux_list;
	struct list_head card_list;
	const struct snd_soc_component_driver *driver;
	struct list_head dai_list;
	int num_dai;
	struct regmap *regmap;
	int val_bytes;
	struct mutex io_mutex;
	struct list_head dobj_list;
	struct snd_soc_dapm_context dapm;
	int (*init)(struct snd_soc_component *);
	struct snd_pcm_substream *mark_module;
	struct snd_pcm_substream *mark_open;
	void *mark_pm;
	struct dentry *debugfs_root;
	const char *debugfs_prefix;
};

struct snd_soc_dapm_route {
	const char *sink;
	const char *control;
	const char *source;
	int (*connected)(struct snd_soc_dapm_widget *, struct snd_soc_dapm_widget *);
	struct snd_soc_dobj dobj;
};

struct snd_soc_pcm_stream {
	const char *stream_name;
	u64 formats;
	unsigned int rates;
	unsigned int rate_min;
	unsigned int rate_max;
	unsigned int channels_min;
	unsigned int channels_max;
	unsigned int sig_bits;
};

struct snd_soc_pcm_runtime;

struct snd_soc_dai_ops;

struct snd_soc_cdai_ops;

struct snd_soc_dai_driver {
	const char *name;
	unsigned int id;
	unsigned int base;
	struct snd_soc_dobj dobj;
	int (*probe)(struct snd_soc_dai *);
	int (*remove)(struct snd_soc_dai *);
	int (*compress_new)(struct snd_soc_pcm_runtime *, int);
	int (*pcm_new)(struct snd_soc_pcm_runtime *, struct snd_soc_dai *);
	const struct snd_soc_dai_ops *ops;
	const struct snd_soc_cdai_ops *cops;
	struct snd_soc_pcm_stream capture;
	struct snd_soc_pcm_stream playback;
	unsigned int symmetric_rates: 1;
	unsigned int symmetric_channels: 1;
	unsigned int symmetric_samplebits: 1;
	int probe_order;
	int remove_order;
};

struct snd_soc_dai {
	const char *name;
	int id;
	struct device *dev;
	struct snd_soc_dai_driver *driver;
	unsigned int stream_active[2];
	struct snd_soc_dapm_widget *playback_widget;
	struct snd_soc_dapm_widget *capture_widget;
	void *playback_dma_data;
	void *capture_dma_data;
	unsigned int rate;
	unsigned int channels;
	unsigned int sample_bits;
	struct snd_soc_component *component;
	unsigned int tx_mask;
	unsigned int rx_mask;
	struct list_head list;
	struct snd_pcm_substream *mark_startup;
	unsigned int probed: 1;
};

enum snd_soc_dpcm_trigger {
	SND_SOC_DPCM_TRIGGER_PRE = 0,
	SND_SOC_DPCM_TRIGGER_POST = 1,
	SND_SOC_DPCM_TRIGGER_BESPOKE = 2,
};

struct snd_soc_dai_link_component;

struct snd_soc_ops;

struct snd_soc_compr_ops;

struct snd_soc_dai_link {
	const char *name;
	const char *stream_name;
	struct snd_soc_dai_link_component *cpus;
	unsigned int num_cpus;
	struct snd_soc_dai_link_component *codecs;
	unsigned int num_codecs;
	struct snd_soc_dai_link_component *platforms;
	unsigned int num_platforms;
	int id;
	const struct snd_soc_pcm_stream *params;
	unsigned int num_params;
	unsigned int dai_fmt;
	enum snd_soc_dpcm_trigger trigger[2];
	int (*init)(struct snd_soc_pcm_runtime *);
	void (*exit)(struct snd_soc_pcm_runtime *);
	int (*be_hw_params_fixup)(struct snd_soc_pcm_runtime *, struct snd_pcm_hw_params *);
	const struct snd_soc_ops *ops;
	const struct snd_soc_compr_ops *compr_ops;
	unsigned int nonatomic: 1;
	unsigned int playback_only: 1;
	unsigned int capture_only: 1;
	unsigned int ignore_suspend: 1;
	unsigned int symmetric_rates: 1;
	unsigned int symmetric_channels: 1;
	unsigned int symmetric_samplebits: 1;
	unsigned int no_pcm: 1;
	unsigned int dynamic: 1;
	unsigned int dpcm_capture: 1;
	unsigned int dpcm_playback: 1;
	unsigned int dpcm_merged_format: 1;
	unsigned int dpcm_merged_chan: 1;
	unsigned int dpcm_merged_rate: 1;
	unsigned int ignore_pmdown_time: 1;
	unsigned int ignore: 1;
};

struct snd_soc_dapm_path {
	const char *name;
	union {
		struct {
			struct snd_soc_dapm_widget *source;
			struct snd_soc_dapm_widget *sink;
		};
		struct snd_soc_dapm_widget *node[2];
	};
	u32 connect: 1;
	u32 walking: 1;
	u32 weak: 1;
	u32 is_supply: 1;
	int (*connected)(struct snd_soc_dapm_widget *, struct snd_soc_dapm_widget *);
	struct list_head list_node[2];
	struct list_head list_kcontrol;
	struct list_head list;
};

struct snd_soc_dapm_update {
	struct snd_kcontrol *kcontrol;
	int reg;
	int mask;
	int val;
	int reg2;
	int mask2;
	int val2;
	bool has_second_set;
};

enum snd_soc_pcm_subclass {
	SND_SOC_PCM_CLASS_PCM = 0,
	SND_SOC_PCM_CLASS_BE = 1,
};

struct snd_soc_dapm_stats {
	int power_checks;
	int path_checks;
	int neighbour_checks;
};

struct snd_soc_codec_conf;

struct snd_soc_aux_dev;

struct snd_soc_card {
	const char *name;
	const char *long_name;
	const char *driver_name;
	const char *components;
	char topology_shortname[32];
	struct device *dev;
	struct snd_card *snd_card;
	struct module *owner;
	struct mutex mutex;
	struct mutex dapm_mutex;
	struct mutex pcm_mutex;
	enum snd_soc_pcm_subclass pcm_subclass;
	spinlock_t dpcm_lock;
	int (*probe)(struct snd_soc_card *);
	int (*late_probe)(struct snd_soc_card *);
	int (*remove)(struct snd_soc_card *);
	int (*suspend_pre)(struct snd_soc_card *);
	int (*suspend_post)(struct snd_soc_card *);
	int (*resume_pre)(struct snd_soc_card *);
	int (*resume_post)(struct snd_soc_card *);
	int (*set_bias_level)(struct snd_soc_card *, struct snd_soc_dapm_context *, enum snd_soc_bias_level);
	int (*set_bias_level_post)(struct snd_soc_card *, struct snd_soc_dapm_context *, enum snd_soc_bias_level);
	int (*add_dai_link)(struct snd_soc_card *, struct snd_soc_dai_link *);
	void (*remove_dai_link)(struct snd_soc_card *, struct snd_soc_dai_link *);
	long int pmdown_time;
	struct snd_soc_dai_link *dai_link;
	int num_links;
	struct list_head rtd_list;
	int num_rtd;
	struct snd_soc_codec_conf *codec_conf;
	int num_configs;
	struct snd_soc_aux_dev *aux_dev;
	int num_aux_devs;
	struct list_head aux_comp_list;
	const struct snd_kcontrol_new *controls;
	int num_controls;
	const struct snd_soc_dapm_widget *dapm_widgets;
	int num_dapm_widgets;
	const struct snd_soc_dapm_route *dapm_routes;
	int num_dapm_routes;
	const struct snd_soc_dapm_widget *of_dapm_widgets;
	int num_of_dapm_widgets;
	const struct snd_soc_dapm_route *of_dapm_routes;
	int num_of_dapm_routes;
	struct list_head component_dev_list;
	struct list_head list;
	struct list_head widgets;
	struct list_head paths;
	struct list_head dapm_list;
	struct list_head dapm_dirty;
	struct list_head dobj_list;
	struct snd_soc_dapm_context dapm;
	struct snd_soc_dapm_stats dapm_stats;
	struct snd_soc_dapm_update *update;
	struct dentry *debugfs_card_root;
	u32 pop_time;
	unsigned int instantiated: 1;
	unsigned int topology_shortname_created: 1;
	unsigned int fully_routed: 1;
	unsigned int disable_route_checks: 1;
	unsigned int probed: 1;
	void *drvdata;
};

enum snd_soc_dapm_direction {
	SND_SOC_DAPM_DIR_IN = 0,
	SND_SOC_DAPM_DIR_OUT = 1,
};

enum snd_soc_dpcm_update {
	SND_SOC_DPCM_UPDATE_NO = 0,
	SND_SOC_DPCM_UPDATE_BE = 1,
	SND_SOC_DPCM_UPDATE_FE = 2,
};

enum snd_soc_dpcm_state {
	SND_SOC_DPCM_STATE_NEW = 0,
	SND_SOC_DPCM_STATE_OPEN = 1,
	SND_SOC_DPCM_STATE_HW_PARAMS = 2,
	SND_SOC_DPCM_STATE_PREPARE = 3,
	SND_SOC_DPCM_STATE_START = 4,
	SND_SOC_DPCM_STATE_STOP = 5,
	SND_SOC_DPCM_STATE_PAUSED = 6,
	SND_SOC_DPCM_STATE_SUSPEND = 7,
	SND_SOC_DPCM_STATE_HW_FREE = 8,
	SND_SOC_DPCM_STATE_CLOSE = 9,
};

struct snd_soc_dpcm_runtime {
	struct list_head be_clients;
	struct list_head fe_clients;
	int users;
	struct snd_pcm_runtime *runtime;
	struct snd_pcm_hw_params hw_params;
	enum snd_soc_dpcm_update runtime_update;
	enum snd_soc_dpcm_state state;
	int trigger_pending;
};

struct snd_soc_pcm_runtime {
	struct device *dev;
	struct snd_soc_card *card;
	struct snd_soc_dai_link *dai_link;
	struct snd_pcm_ops ops;
	unsigned int params_select;
	struct snd_soc_dpcm_runtime dpcm[2];
	long int pmdown_time;
	struct snd_pcm *pcm;
	struct snd_compr *compr;
	struct snd_soc_dai **dais;
	unsigned int num_codecs;
	unsigned int num_cpus;
	struct snd_soc_dapm_widget *playback_widget;
	struct snd_soc_dapm_widget *capture_widget;
	struct delayed_work delayed_work;
	void (*close_delayed_work_func)(struct snd_soc_pcm_runtime *);
	struct dentry *debugfs_dpcm_root;
	unsigned int num;
	struct list_head list;
	struct snd_pcm_substream *mark_startup;
	unsigned int pop_wait: 1;
	unsigned int fe_compr: 1;
	int num_components;
	struct snd_soc_component *components[0];
};

struct snd_soc_jack {
	struct mutex mutex;
	struct snd_jack *jack;
	struct snd_soc_card *card;
	struct list_head pins;
	int status;
	struct blocking_notifier_head notifier;
	struct list_head jack_zones;
};

struct snd_soc_ops {
	int (*startup)(struct snd_pcm_substream *);
	void (*shutdown)(struct snd_pcm_substream *);
	int (*hw_params)(struct snd_pcm_substream *, struct snd_pcm_hw_params *);
	int (*hw_free)(struct snd_pcm_substream *);
	int (*prepare)(struct snd_pcm_substream *);
	int (*trigger)(struct snd_pcm_substream *, int);
};

struct snd_soc_compr_ops {
	int (*startup)(struct snd_compr_stream *);
	void (*shutdown)(struct snd_compr_stream *);
	int (*set_params)(struct snd_compr_stream *);
	int (*trigger)(struct snd_compr_stream *);
};

struct snd_soc_dai_link_component {
	const char *name;
	struct device_node *of_node;
	const char *dai_name;
};

struct snd_soc_codec_conf {
	struct snd_soc_dai_link_component dlc;
	const char *name_prefix;
};

struct snd_soc_aux_dev {
	struct snd_soc_dai_link_component dlc;
	int (*init)(struct snd_soc_component *);
};

struct soc_multi_mixer_control {
	int min;
	int max;
	int platform_max;
	int count;
	unsigned int reg;
	unsigned int rreg;
	unsigned int shift;
	unsigned int rshift;
	unsigned int invert;
};

struct snd_soc_dai_ops {
	int (*set_sysclk)(struct snd_soc_dai *, int, unsigned int, int);
	int (*set_pll)(struct snd_soc_dai *, int, int, unsigned int, unsigned int);
	int (*set_clkdiv)(struct snd_soc_dai *, int, int);
	int (*set_bclk_ratio)(struct snd_soc_dai *, unsigned int);
	int (*set_fmt)(struct snd_soc_dai *, unsigned int);
	int (*xlate_tdm_slot_mask)(unsigned int, unsigned int *, unsigned int *);
	int (*set_tdm_slot)(struct snd_soc_dai *, unsigned int, unsigned int, int, int);
	int (*set_channel_map)(struct snd_soc_dai *, unsigned int, unsigned int *, unsigned int, unsigned int *);
	int (*get_channel_map)(struct snd_soc_dai *, unsigned int *, unsigned int *, unsigned int *, unsigned int *);
	int (*set_tristate)(struct snd_soc_dai *, int);
	int (*set_sdw_stream)(struct snd_soc_dai *, void *, int);
	void * (*get_sdw_stream)(struct snd_soc_dai *, int);
	int (*mute_stream)(struct snd_soc_dai *, int, int);
	int (*startup)(struct snd_pcm_substream *, struct snd_soc_dai *);
	void (*shutdown)(struct snd_pcm_substream *, struct snd_soc_dai *);
	int (*hw_params)(struct snd_pcm_substream *, struct snd_pcm_hw_params *, struct snd_soc_dai *);
	int (*hw_free)(struct snd_pcm_substream *, struct snd_soc_dai *);
	int (*prepare)(struct snd_pcm_substream *, struct snd_soc_dai *);
	int (*trigger)(struct snd_pcm_substream *, int, struct snd_soc_dai *);
	int (*bespoke_trigger)(struct snd_pcm_substream *, int, struct snd_soc_dai *);
	snd_pcm_sframes_t (*delay)(struct snd_pcm_substream *, struct snd_soc_dai *);
	unsigned int no_capture_mute: 1;
};

struct snd_soc_cdai_ops {
	int (*startup)(struct snd_compr_stream *, struct snd_soc_dai *);
	int (*shutdown)(struct snd_compr_stream *, struct snd_soc_dai *);
	int (*set_params)(struct snd_compr_stream *, struct snd_compr_params *, struct snd_soc_dai *);
	int (*get_params)(struct snd_compr_stream *, struct snd_codec *, struct snd_soc_dai *);
	int (*set_metadata)(struct snd_compr_stream *, struct snd_compr_metadata *, struct snd_soc_dai *);
	int (*get_metadata)(struct snd_compr_stream *, struct snd_compr_metadata *, struct snd_soc_dai *);
	int (*trigger)(struct snd_compr_stream *, int, struct snd_soc_dai *);
	int (*pointer)(struct snd_compr_stream *, struct snd_compr_tstamp *, struct snd_soc_dai *);
	int (*ack)(struct snd_compr_stream *, size_t, struct snd_soc_dai *);
};

struct snd_compress_ops {
	int (*open)(struct snd_soc_component *, struct snd_compr_stream *);
	int (*free)(struct snd_soc_component *, struct snd_compr_stream *);
	int (*set_params)(struct snd_soc_component *, struct snd_compr_stream *, struct snd_compr_params *);
	int (*get_params)(struct snd_soc_component *, struct snd_compr_stream *, struct snd_codec *);
	int (*set_metadata)(struct snd_soc_component *, struct snd_compr_stream *, struct snd_compr_metadata *);
	int (*get_metadata)(struct snd_soc_component *, struct snd_compr_stream *, struct snd_compr_metadata *);
	int (*trigger)(struct snd_soc_component *, struct snd_compr_stream *, int);
	int (*pointer)(struct snd_soc_component *, struct snd_compr_stream *, struct snd_compr_tstamp *);
	int (*copy)(struct snd_soc_component *, struct snd_compr_stream *, char *, size_t);
	int (*mmap)(struct snd_soc_component *, struct snd_compr_stream *, struct vm_area_struct *);
	int (*ack)(struct snd_soc_component *, struct snd_compr_stream *, size_t);
	int (*get_caps)(struct snd_soc_component *, struct snd_compr_stream *, struct snd_compr_caps *);
	int (*get_codec_caps)(struct snd_soc_component *, struct snd_compr_stream *, struct snd_compr_codec_caps *);
};

struct snd_soc_component_driver {
	const char *name;
	const struct snd_kcontrol_new *controls;
	unsigned int num_controls;
	const struct snd_soc_dapm_widget *dapm_widgets;
	unsigned int num_dapm_widgets;
	const struct snd_soc_dapm_route *dapm_routes;
	unsigned int num_dapm_routes;
	int (*probe)(struct snd_soc_component *);
	void (*remove)(struct snd_soc_component *);
	int (*suspend)(struct snd_soc_component *);
	int (*resume)(struct snd_soc_component *);
	unsigned int (*read)(struct snd_soc_component *, unsigned int);
	int (*write)(struct snd_soc_component *, unsigned int, unsigned int);
	int (*pcm_construct)(struct snd_soc_component *, struct snd_soc_pcm_runtime *);
	void (*pcm_destruct)(struct snd_soc_component *, struct snd_pcm *);
	int (*set_sysclk)(struct snd_soc_component *, int, int, unsigned int, int);
	int (*set_pll)(struct snd_soc_component *, int, int, unsigned int, unsigned int);
	int (*set_jack)(struct snd_soc_component *, struct snd_soc_jack *, void *);
	int (*of_xlate_dai_name)(struct snd_soc_component *, struct of_phandle_args *, const char **);
	int (*of_xlate_dai_id)(struct snd_soc_component *, struct device_node *);
	void (*seq_notifier)(struct snd_soc_component *, enum snd_soc_dapm_type, int);
	int (*stream_event)(struct snd_soc_component *, int);
	int (*set_bias_level)(struct snd_soc_component *, enum snd_soc_bias_level);
	int (*open)(struct snd_soc_component *, struct snd_pcm_substream *);
	int (*close)(struct snd_soc_component *, struct snd_pcm_substream *);
	int (*ioctl)(struct snd_soc_component *, struct snd_pcm_substream *, unsigned int, void *);
	int (*hw_params)(struct snd_soc_component *, struct snd_pcm_substream *, struct snd_pcm_hw_params *);
	int (*hw_free)(struct snd_soc_component *, struct snd_pcm_substream *);
	int (*prepare)(struct snd_soc_component *, struct snd_pcm_substream *);
	int (*trigger)(struct snd_soc_component *, struct snd_pcm_substream *, int);
	int (*sync_stop)(struct snd_soc_component *, struct snd_pcm_substream *);
	snd_pcm_uframes_t (*pointer)(struct snd_soc_component *, struct snd_pcm_substream *);
	int (*get_time_info)(struct snd_soc_component *, struct snd_pcm_substream *, struct timespec64 *, struct timespec64 *, struct snd_pcm_audio_tstamp_config *, struct snd_pcm_audio_tstamp_report *);
	int (*copy_user)(struct snd_soc_component *, struct snd_pcm_substream *, int, long unsigned int, void *, long unsigned int);
	struct page * (*page)(struct snd_soc_component *, struct snd_pcm_substream *, long unsigned int);
	int (*mmap)(struct snd_soc_component *, struct snd_pcm_substream *, struct vm_area_struct *);
	int (*ack)(struct snd_soc_component *, struct snd_pcm_substream *);
	const struct snd_compress_ops *compress_ops;
	int probe_order;
	int remove_order;
	unsigned int module_get_upon_open: 1;
	unsigned int idle_bias_on: 1;
	unsigned int suspend_bias_off: 1;
	unsigned int use_pmdown_time: 1;
	unsigned int endianness: 1;
	unsigned int non_legacy_dai_naming: 1;
	const char *ignore_machine;
	const char *topology_name_prefix;
	int (*be_hw_params_fixup)(struct snd_soc_pcm_runtime *, struct snd_pcm_hw_params *);
	bool use_dai_pcm_id;
	int be_pcm_base;
};

struct trace_event_raw_snd_soc_card {
	struct trace_entry ent;
	u32 __data_loc_name;
	int val;
	char __data[0];
};

struct trace_event_raw_snd_soc_dapm_basic {
	struct trace_entry ent;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_snd_soc_dapm_widget {
	struct trace_entry ent;
	u32 __data_loc_name;
	int val;
	char __data[0];
};

struct trace_event_raw_snd_soc_dapm_walk_done {
	struct trace_entry ent;
	u32 __data_loc_name;
	int power_checks;
	int path_checks;
	int neighbour_checks;
	char __data[0];
};

struct trace_event_raw_snd_soc_dapm_path {
	struct trace_entry ent;
	u32 __data_loc_wname;
	u32 __data_loc_pname;
	u32 __data_loc_pnname;
	int path_node;
	int path_connect;
	int path_dir;
	char __data[0];
};

struct trace_event_raw_snd_soc_dapm_connected {
	struct trace_entry ent;
	int paths;
	int stream;
	char __data[0];
};

struct trace_event_raw_snd_soc_jack_irq {
	struct trace_entry ent;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_snd_soc_jack_report {
	struct trace_entry ent;
	u32 __data_loc_name;
	int mask;
	int val;
	char __data[0];
};

struct trace_event_raw_snd_soc_jack_notify {
	struct trace_entry ent;
	u32 __data_loc_name;
	int val;
	char __data[0];
};

struct trace_event_data_offsets_snd_soc_card {
	u32 name;
};

struct trace_event_data_offsets_snd_soc_dapm_basic {
	u32 name;
};

struct trace_event_data_offsets_snd_soc_dapm_widget {
	u32 name;
};

struct trace_event_data_offsets_snd_soc_dapm_walk_done {
	u32 name;
};

struct trace_event_data_offsets_snd_soc_dapm_path {
	u32 wname;
	u32 pname;
	u32 pnname;
};

struct trace_event_data_offsets_snd_soc_dapm_connected {};

struct trace_event_data_offsets_snd_soc_jack_irq {
	u32 name;
};

struct trace_event_data_offsets_snd_soc_jack_report {
	u32 name;
};

struct trace_event_data_offsets_snd_soc_jack_notify {
	u32 name;
};

typedef void (*btf_trace_snd_soc_bias_level_start)(void *, struct snd_soc_card *, int);

typedef void (*btf_trace_snd_soc_bias_level_done)(void *, struct snd_soc_card *, int);

typedef void (*btf_trace_snd_soc_dapm_start)(void *, struct snd_soc_card *);

typedef void (*btf_trace_snd_soc_dapm_done)(void *, struct snd_soc_card *);

typedef void (*btf_trace_snd_soc_dapm_widget_power)(void *, struct snd_soc_dapm_widget *, int);

typedef void (*btf_trace_snd_soc_dapm_widget_event_start)(void *, struct snd_soc_dapm_widget *, int);

typedef void (*btf_trace_snd_soc_dapm_widget_event_done)(void *, struct snd_soc_dapm_widget *, int);

typedef void (*btf_trace_snd_soc_dapm_walk_done)(void *, struct snd_soc_card *);

typedef void (*btf_trace_snd_soc_dapm_path)(void *, struct snd_soc_dapm_widget *, enum snd_soc_dapm_direction, struct snd_soc_dapm_path *);

typedef void (*btf_trace_snd_soc_dapm_connected)(void *, int, int);

typedef void (*btf_trace_snd_soc_jack_irq)(void *, const char *);

typedef void (*btf_trace_snd_soc_jack_report)(void *, struct snd_soc_jack *, int, int);

typedef void (*btf_trace_snd_soc_jack_notify)(void *, struct snd_soc_jack *, int);

struct snd_soc_dapm_widget_list {
	int num_widgets;
	struct snd_soc_dapm_widget *widgets[0];
};

struct snd_soc_dapm_pinctrl_priv {
	const char *active_state;
	const char *sleep_state;
};

struct soc_mixer_control {
	int min;
	int max;
	int platform_max;
	int reg;
	int rreg;
	unsigned int shift;
	unsigned int rshift;
	unsigned int sign_bit;
	unsigned int invert: 1;
	unsigned int autodisable: 1;
};

struct soc_enum {
	int reg;
	unsigned char shift_l;
	unsigned char shift_r;
	unsigned int items;
	unsigned int mask;
	const char * const *texts;
	const unsigned int *values;
	unsigned int autodisable: 1;
};

struct dapm_kcontrol_data {
	unsigned int value;
	struct snd_soc_dapm_widget *widget;
	struct list_head paths;
	struct snd_soc_dapm_widget_list *wlist;
};

struct snd_soc_jack_pin {
	struct list_head list;
	const char *pin;
	int mask;
	bool invert;
};

struct snd_soc_jack_zone {
	unsigned int min_mv;
	unsigned int max_mv;
	unsigned int jack_type;
	unsigned int debounce_time;
	struct list_head list;
};

struct snd_soc_jack_gpio {
	unsigned int gpio;
	unsigned int idx;
	struct device *gpiod_dev;
	const char *name;
	int report;
	int invert;
	int debounce_time;
	bool wake;
	struct snd_soc_jack *jack;
	struct delayed_work work;
	struct notifier_block pm_notifier;
	struct gpio_desc *desc;
	void *data;
	int (*jack_status_check)(void *);
};

struct jack_gpio_tbl {
	int count;
	struct snd_soc_jack *jack;
	struct snd_soc_jack_gpio *gpios;
};

enum snd_soc_dpcm_link_state {
	SND_SOC_DPCM_LINK_STATE_NEW = 0,
	SND_SOC_DPCM_LINK_STATE_FREE = 1,
};

struct snd_soc_dpcm {
	struct snd_soc_pcm_runtime *be;
	struct snd_soc_pcm_runtime *fe;
	enum snd_soc_dpcm_link_state state;
	struct list_head list_be;
	struct list_head list_fe;
	struct snd_pcm_hw_params hw_params;
	struct dentry *debugfs_state;
};

struct snd_dmaengine_pcm_config {
	int (*prepare_slave_config)(struct snd_pcm_substream *, struct snd_pcm_hw_params *, struct dma_slave_config *);
	struct dma_chan * (*compat_request_channel)(struct snd_soc_pcm_runtime *, struct snd_pcm_substream *);
	int (*process)(struct snd_pcm_substream *, int, long unsigned int, void *, long unsigned int);
	dma_filter_fn compat_filter_fn;
	struct device *dma_dev;
	const char *chan_names[2];
	const struct snd_pcm_hardware *pcm_hardware;
	unsigned int prealloc_buffer_size;
};

struct soc_bytes {
	int base;
	int num_regs;
	u32 mask;
};

struct soc_bytes_ext {
	int max;
	int (*get)(struct snd_kcontrol *, unsigned int *, unsigned int);
	int (*put)(struct snd_kcontrol *, const unsigned int *, unsigned int);
};

struct soc_mreg_control {
	long int min;
	long int max;
	unsigned int regbase;
	unsigned int regcount;
	unsigned int nbits;
	unsigned int invert;
};

struct dmaengine_pcm {
	struct dma_chan *chan[2];
	const struct snd_dmaengine_pcm_config *config;
	struct snd_soc_component component;
	unsigned int flags;
};

struct es7210_priv {
	struct regmap *regmap;
	struct i2c_client *i2c_client;
	unsigned int dmic_enable;
	unsigned int sysclk;
	struct clk *mclk;
	struct snd_pcm_hw_constraint_list *sysclk_constraints;
	unsigned int tdm_mode;
	struct delayed_work pcm_pop_work;
};

struct es7210_reg_config {
	unsigned char reg_addr;
	unsigned char reg_v;
};

enum vmidlow {
	VMIDLEVEL0 = 0,
	VMIDLEVEL1 = 1,
	VMIDLEVEL2 = 2,
	VMIDLEVEL3 = 3,
};

struct es8156_priv {
	struct regmap *regmap;
	unsigned int dmic_amic;
	unsigned int sysclk;
	struct snd_pcm_hw_constraint_list *sysclk_constraints;
	struct clk *mclk;
	int debounce_time;
	int hp_det_invert;
	struct delayed_work work;
	int spk_ctl_gpio;
	int hp_det_gpio;
	bool muted;
	bool hp_inserted;
	bool spk_active_level;
	int pwr_count;
};

struct wm8960_data {
	bool capless;
	bool shared_lrclk;
	u32 hp_cfg[3];
	u32 gpio_cfg[2];
};

struct wm8960_priv {
	struct clk *mclk;
	struct regmap *regmap;
	int (*set_bias_level)(struct snd_soc_component *, enum snd_soc_bias_level);
	struct snd_soc_dapm_widget *lout1;
	struct snd_soc_dapm_widget *rout1;
	struct snd_soc_dapm_widget *out3;
	bool deemph;
	int lrclk;
	int bclk;
	int sysclk;
	int clk_id;
	int freq_in;
	bool is_stream_in_use[2];
	struct wm8960_data pdata;
};

struct _pll_div {
	u32 pre_div: 1;
	u32 n: 4;
	u32 k: 24;
};

struct asoc_simple_dai {
	const char *name;
	unsigned int sysclk;
	int clk_direction;
	int slots;
	int slot_width;
	unsigned int tx_slot_mask;
	unsigned int rx_slot_mask;
	struct clk *clk;
};

struct asoc_simple_data {
	u32 convert_rate;
	u32 convert_channels;
};

struct asoc_simple_jack {
	struct snd_soc_jack jack;
	struct snd_soc_jack_pin pin;
	struct snd_soc_jack_gpio gpio;
};

struct simple_dai_props {
	struct asoc_simple_dai *cpu_dai;
	struct asoc_simple_dai *codec_dai;
	struct snd_soc_dai_link_component cpus;
	struct snd_soc_dai_link_component codecs;
	struct snd_soc_dai_link_component platforms;
	struct asoc_simple_data adata;
	struct snd_soc_codec_conf *codec_conf;
	unsigned int mclk_fs;
};

struct asoc_simple_priv {
	struct snd_soc_card snd_card;
	struct simple_dai_props *dai_props;
	struct asoc_simple_jack hp_jack;
	struct asoc_simple_jack mic_jack;
	struct snd_soc_dai_link *dai_link;
	struct asoc_simple_dai *dais;
	struct snd_soc_codec_conf *codec_conf;
	struct gpio_desc *pa_gpio;
};

struct link_info {
	int dais;
	int link;
	int conf;
	int cpu;
};

struct asoc_simple_card_info {
	const char *name;
	const char *card;
	const char *codec;
	const char *platform;
	unsigned int daifmt;
	struct asoc_simple_dai cpu_dai;
	struct asoc_simple_dai codec_dai;
};

struct light_i2s_priv {
	void *base;
	phys_addr_t phys;
	void *regs;
	struct regmap *regmap;
	struct regmap *audio_pin_regmap;
	struct regmap *audio_cpr_regmap;
	struct clk *clk;
	struct snd_dmaengine_dai_dma_data dma_params_tx;
	struct snd_dmaengine_dai_dma_data dma_params_rx;
	u32 fmt;
	unsigned int dai_fmt;
	u32 dma_maxburst;
	unsigned int cfg_off;
	struct device *dev;
	char name[16];
	int chan_num: 16;
	unsigned int clk_master: 1;
};

struct aw87519_container {
	int len;
	unsigned char data[0];
};

struct aw87519 {
	struct i2c_client *i2c_client;
	int reset_gpio;
	unsigned char hwen_flag;
	unsigned char spk_cfg_update_flag;
	unsigned char rcv_cfg_update_flag;
	struct hrtimer cfg_timer;
	struct mutex cfg_lock;
	struct work_struct cfg_work;
	struct delayed_work ram_work;
	struct regmap *regmap;
};

struct net_device_devres {
	struct net_device *ndev;
};

struct __kernel_old_timespec {
	__kernel_old_time_t tv_sec;
	long int tv_nsec;
};

struct __kernel_sock_timeval {
	__s64 tv_sec;
	__s64 tv_usec;
};

struct mmsghdr {
	struct user_msghdr msg_hdr;
	unsigned int msg_len;
};

struct scm_timestamping_internal {
	struct timespec64 ts[3];
};

enum sock_shutdown_cmd {
	SHUT_RD = 0,
	SHUT_WR = 1,
	SHUT_RDWR = 2,
};

struct ifconf {
	int ifc_len;
	union {
		char *ifcu_buf;
		struct ifreq *ifcu_req;
	} ifc_ifcu;
};

struct flowi_tunnel {
	__be64 tun_id;
};

struct flowi_common {
	int flowic_oif;
	int flowic_iif;
	__u32 flowic_mark;
	__u8 flowic_tos;
	__u8 flowic_scope;
	__u8 flowic_proto;
	__u8 flowic_flags;
	__u32 flowic_secid;
	kuid_t flowic_uid;
	struct flowi_tunnel flowic_tun_key;
	__u32 flowic_multipath_hash;
};

union flowi_uli {
	struct {
		__be16 dport;
		__be16 sport;
	} ports;
	struct {
		__u8 type;
		__u8 code;
	} icmpt;
	struct {
		__le16 dport;
		__le16 sport;
	} dnports;
	__be32 spi;
	__be32 gre_key;
	struct {
		__u8 type;
	} mht;
};

struct flowi4 {
	struct flowi_common __fl_common;
	__be32 saddr;
	__be32 daddr;
	union flowi_uli uli;
};

struct flowi6 {
	struct flowi_common __fl_common;
	struct in6_addr daddr;
	struct in6_addr saddr;
	__be32 flowlabel;
	union flowi_uli uli;
	__u32 mp_hash;
};

struct flowidn {
	struct flowi_common __fl_common;
	__le16 daddr;
	__le16 saddr;
	union flowi_uli uli;
};

struct flowi {
	union {
		struct flowi_common __fl_common;
		struct flowi4 ip4;
		struct flowi6 ip6;
		struct flowidn dn;
	} u;
};

enum {
	TCPF_ESTABLISHED = 2,
	TCPF_SYN_SENT = 4,
	TCPF_SYN_RECV = 8,
	TCPF_FIN_WAIT1 = 16,
	TCPF_FIN_WAIT2 = 32,
	TCPF_TIME_WAIT = 64,
	TCPF_CLOSE = 128,
	TCPF_CLOSE_WAIT = 256,
	TCPF_LAST_ACK = 512,
	TCPF_LISTEN = 1024,
	TCPF_CLOSING = 2048,
	TCPF_NEW_SYN_RECV = 4096,
};

struct scm_ts_pktinfo {
	__u32 if_index;
	__u32 pkt_length;
	__u32 reserved[2];
};

struct socket_alloc {
	struct socket socket;
	struct inode vfs_inode;
	long: 64;
	long: 64;
};

struct sock_skb_cb {
	u32 dropcount;
};

struct ip_options {
	__be32 faddr;
	__be32 nexthop;
	unsigned char optlen;
	unsigned char srr;
	unsigned char rr;
	unsigned char ts;
	unsigned char is_strictroute: 1;
	unsigned char srr_is_hit: 1;
	unsigned char is_changed: 1;
	unsigned char rr_needaddr: 1;
	unsigned char ts_needtime: 1;
	unsigned char ts_needaddr: 1;
	unsigned char router_alert;
	unsigned char cipso;
	unsigned char __pad2;
	unsigned char __data[0];
};

struct ip_options_rcu {
	struct callback_head rcu;
	struct ip_options opt;
};

struct ipv6_opt_hdr;

struct ipv6_rt_hdr;

struct ipv6_txoptions {
	refcount_t refcnt;
	int tot_len;
	__u16 opt_flen;
	__u16 opt_nflen;
	struct ipv6_opt_hdr *hopopt;
	struct ipv6_opt_hdr *dst0opt;
	struct ipv6_rt_hdr *srcrt;
	struct ipv6_opt_hdr *dst1opt;
	struct callback_head rcu;
};

struct inet_cork {
	unsigned int flags;
	__be32 addr;
	struct ip_options *opt;
	unsigned int fragsize;
	int length;
	struct dst_entry *dst;
	u8 tx_flags;
	__u8 ttl;
	__s16 tos;
	char priority;
	__u16 gso_size;
	u64 transmit_time;
	u32 mark;
};

struct inet_cork_full {
	struct inet_cork base;
	struct flowi fl;
};

struct ipv6_pinfo;

struct ip_mc_socklist;

struct inet_sock {
	struct sock sk;
	struct ipv6_pinfo *pinet6;
	__be32 inet_saddr;
	__s16 uc_ttl;
	__u16 cmsg_flags;
	__be16 inet_sport;
	__u16 inet_id;
	struct ip_options_rcu *inet_opt;
	int rx_dst_ifindex;
	__u8 tos;
	__u8 min_ttl;
	__u8 mc_ttl;
	__u8 pmtudisc;
	__u8 recverr: 1;
	__u8 is_icsk: 1;
	__u8 freebind: 1;
	__u8 hdrincl: 1;
	__u8 mc_loop: 1;
	__u8 transparent: 1;
	__u8 mc_all: 1;
	__u8 nodefrag: 1;
	__u8 bind_address_no_port: 1;
	__u8 recverr_rfc4884: 1;
	__u8 defer_connect: 1;
	__u8 rcv_tos;
	__u8 convert_csum;
	int uc_index;
	int mc_index;
	__be32 mc_addr;
	struct ip_mc_socklist *mc_list;
	struct inet_cork_full cork;
};

struct in6_pktinfo {
	struct in6_addr ipi6_addr;
	int ipi6_ifindex;
};

struct inet6_cork {
	struct ipv6_txoptions *opt;
	u8 hop_limit;
	u8 tclass;
};

struct ipv6_mc_socklist;

struct ipv6_ac_socklist;

struct ipv6_fl_socklist;

struct ipv6_pinfo {
	struct in6_addr saddr;
	struct in6_pktinfo sticky_pktinfo;
	const struct in6_addr *daddr_cache;
	__be32 flow_label;
	__u32 frag_size;
	__u16 __unused_1: 7;
	__s16 hop_limit: 9;
	__u16 mc_loop: 1;
	__u16 __unused_2: 6;
	__s16 mcast_hops: 9;
	int ucast_oif;
	int mcast_oif;
	union {
		struct {
			__u16 srcrt: 1;
			__u16 osrcrt: 1;
			__u16 rxinfo: 1;
			__u16 rxoinfo: 1;
			__u16 rxhlim: 1;
			__u16 rxohlim: 1;
			__u16 hopopts: 1;
			__u16 ohopopts: 1;
			__u16 dstopts: 1;
			__u16 odstopts: 1;
			__u16 rxflow: 1;
			__u16 rxtclass: 1;
			__u16 rxpmtu: 1;
			__u16 rxorigdstaddr: 1;
			__u16 recvfragsize: 1;
		} bits;
		__u16 all;
	} rxopt;
	__u16 recverr: 1;
	__u16 sndflow: 1;
	__u16 repflow: 1;
	__u16 pmtudisc: 3;
	__u16 padding: 1;
	__u16 srcprefs: 3;
	__u16 dontfrag: 1;
	__u16 autoflowlabel: 1;
	__u16 autoflowlabel_set: 1;
	__u16 mc_all: 1;
	__u16 recverr_rfc4884: 1;
	__u16 rtalert_isolate: 1;
	__u8 min_hopcount;
	__u8 tclass;
	__be32 rcv_flowinfo;
	__u32 dst_cookie;
	__u32 rx_dst_cookie;
	struct ipv6_mc_socklist *ipv6_mc_list;
	struct ipv6_ac_socklist *ipv6_ac_list;
	struct ipv6_fl_socklist *ipv6_fl_list;
	struct ipv6_txoptions *opt;
	struct sk_buff *pktoptions;
	struct sk_buff *rxpmtu;
	struct inet6_cork cork;
};

struct ipv6_rt_hdr {
	__u8 nexthdr;
	__u8 hdrlen;
	__u8 type;
	__u8 segments_left;
};

struct ipv6_opt_hdr {
	__u8 nexthdr;
	__u8 hdrlen;
};

struct inet6_skb_parm {
	int iif;
	__be16 ra;
	__u16 dst0;
	__u16 srcrt;
	__u16 dst1;
	__u16 lastopt;
	__u16 nhoff;
	__u16 flags;
	__u16 frag_max_size;
};

struct ip6_sf_socklist;

struct ipv6_mc_socklist {
	struct in6_addr addr;
	int ifindex;
	unsigned int sfmode;
	struct ipv6_mc_socklist *next;
	rwlock_t sflock;
	struct ip6_sf_socklist *sflist;
	struct callback_head rcu;
};

struct ipv6_ac_socklist {
	struct in6_addr acl_addr;
	int acl_ifindex;
	struct ipv6_ac_socklist *acl_next;
};

struct ip6_flowlabel;

struct ipv6_fl_socklist {
	struct ipv6_fl_socklist *next;
	struct ip6_flowlabel *fl;
	struct callback_head rcu;
};

struct ip6_sf_socklist {
	unsigned int sl_max;
	unsigned int sl_count;
	struct in6_addr sl_addr[0];
};

struct ip6_flowlabel {
	struct ip6_flowlabel *next;
	__be32 label;
	atomic_t users;
	struct in6_addr dst;
	struct ipv6_txoptions *opt;
	long unsigned int linger;
	struct callback_head rcu;
	u8 share;
	union {
		struct pid *pid;
		kuid_t uid;
	} owner;
	long unsigned int lastuse;
	long unsigned int expires;
	struct net *fl_net;
};

struct inet_skb_parm {
	int iif;
	struct ip_options opt;
	u16 flags;
	u16 frag_max_size;
};

struct sock_ee_data_rfc4884 {
	__u16 len;
	__u8 flags;
	__u8 reserved;
};

struct sock_extended_err {
	__u32 ee_errno;
	__u8 ee_origin;
	__u8 ee_type;
	__u8 ee_code;
	__u8 ee_pad;
	__u32 ee_info;
	union {
		__u32 ee_data;
		struct sock_ee_data_rfc4884 ee_rfc4884;
	};
};

struct sock_exterr_skb {
	union {
		struct inet_skb_parm h4;
		struct inet6_skb_parm h6;
	} header;
	struct sock_extended_err ee;
	u16 addr_offset;
	__be16 port;
	u8 opt_stats: 1;
	u8 unused: 7;
};

struct used_address {
	struct __kernel_sockaddr_storage name;
	unsigned int name_len;
};

struct linger {
	int l_onoff;
	int l_linger;
};

struct ucred {
	__u32 pid;
	__u32 uid;
	__u32 gid;
};

struct prot_inuse {
	int val[64];
};

enum {
	XFRM_POLICY_TYPE_MAIN = 0,
	XFRM_POLICY_TYPE_SUB = 1,
	XFRM_POLICY_TYPE_MAX = 2,
	XFRM_POLICY_TYPE_ANY = 255,
};

enum {
	XFRM_MSG_BASE = 16,
	XFRM_MSG_NEWSA = 16,
	XFRM_MSG_DELSA = 17,
	XFRM_MSG_GETSA = 18,
	XFRM_MSG_NEWPOLICY = 19,
	XFRM_MSG_DELPOLICY = 20,
	XFRM_MSG_GETPOLICY = 21,
	XFRM_MSG_ALLOCSPI = 22,
	XFRM_MSG_ACQUIRE = 23,
	XFRM_MSG_EXPIRE = 24,
	XFRM_MSG_UPDPOLICY = 25,
	XFRM_MSG_UPDSA = 26,
	XFRM_MSG_POLEXPIRE = 27,
	XFRM_MSG_FLUSHSA = 28,
	XFRM_MSG_FLUSHPOLICY = 29,
	XFRM_MSG_NEWAE = 30,
	XFRM_MSG_GETAE = 31,
	XFRM_MSG_REPORT = 32,
	XFRM_MSG_MIGRATE = 33,
	XFRM_MSG_NEWSADINFO = 34,
	XFRM_MSG_GETSADINFO = 35,
	XFRM_MSG_NEWSPDINFO = 36,
	XFRM_MSG_GETSPDINFO = 37,
	XFRM_MSG_MAPPING = 38,
	__XFRM_MSG_MAX = 39,
};

enum xfrm_attr_type_t {
	XFRMA_UNSPEC = 0,
	XFRMA_ALG_AUTH = 1,
	XFRMA_ALG_CRYPT = 2,
	XFRMA_ALG_COMP = 3,
	XFRMA_ENCAP = 4,
	XFRMA_TMPL = 5,
	XFRMA_SA = 6,
	XFRMA_POLICY = 7,
	XFRMA_SEC_CTX = 8,
	XFRMA_LTIME_VAL = 9,
	XFRMA_REPLAY_VAL = 10,
	XFRMA_REPLAY_THRESH = 11,
	XFRMA_ETIMER_THRESH = 12,
	XFRMA_SRCADDR = 13,
	XFRMA_COADDR = 14,
	XFRMA_LASTUSED = 15,
	XFRMA_POLICY_TYPE = 16,
	XFRMA_MIGRATE = 17,
	XFRMA_ALG_AEAD = 18,
	XFRMA_KMADDRESS = 19,
	XFRMA_ALG_AUTH_TRUNC = 20,
	XFRMA_MARK = 21,
	XFRMA_TFCPAD = 22,
	XFRMA_REPLAY_ESN_VAL = 23,
	XFRMA_SA_EXTRA_FLAGS = 24,
	XFRMA_PROTO = 25,
	XFRMA_ADDRESS_FILTER = 26,
	XFRMA_PAD = 27,
	XFRMA_OFFLOAD_DEV = 28,
	XFRMA_SET_MARK = 29,
	XFRMA_SET_MARK_MASK = 30,
	XFRMA_IF_ID = 31,
	__XFRMA_MAX = 32,
};

enum txtime_flags {
	SOF_TXTIME_DEADLINE_MODE = 1,
	SOF_TXTIME_REPORT_ERRORS = 2,
	SOF_TXTIME_FLAGS_LAST = 2,
	SOF_TXTIME_FLAGS_MASK = 3,
};

struct sock_txtime {
	__kernel_clockid_t clockid;
	__u32 flags;
};

enum sk_pacing {
	SK_PACING_NONE = 0,
	SK_PACING_NEEDED = 1,
	SK_PACING_FQ = 2,
};

struct sockcm_cookie {
	u64 transmit_time;
	u32 mark;
	u16 tsflags;
};

struct fastopen_queue {
	struct request_sock *rskq_rst_head;
	struct request_sock *rskq_rst_tail;
	spinlock_t lock;
	int qlen;
	int max_qlen;
	struct tcp_fastopen_context *ctx;
};

struct request_sock_queue {
	spinlock_t rskq_lock;
	u8 rskq_defer_accept;
	u32 synflood_warned;
	atomic_t qlen;
	atomic_t young;
	struct request_sock *rskq_accept_head;
	struct request_sock *rskq_accept_tail;
	struct fastopen_queue fastopenq;
};

struct inet_connection_sock_af_ops {
	int (*queue_xmit)(struct sock *, struct sk_buff *, struct flowi *);
	void (*send_check)(struct sock *, struct sk_buff *);
	int (*rebuild_header)(struct sock *);
	void (*sk_rx_dst_set)(struct sock *, const struct sk_buff *);
	int (*conn_request)(struct sock *, struct sk_buff *);
	struct sock * (*syn_recv_sock)(const struct sock *, struct sk_buff *, struct request_sock *, struct dst_entry *, struct request_sock *, bool *);
	u16 net_header_len;
	u16 net_frag_header_len;
	u16 sockaddr_len;
	int (*setsockopt)(struct sock *, int, int, sockptr_t, unsigned int);
	int (*getsockopt)(struct sock *, int, int, char *, int *);
	void (*addr2sockaddr)(struct sock *, struct sockaddr *);
	void (*mtu_reduced)(struct sock *);
};

struct inet_bind_bucket;

struct tcp_ulp_ops;

struct inet_connection_sock {
	struct inet_sock icsk_inet;
	struct request_sock_queue icsk_accept_queue;
	struct inet_bind_bucket *icsk_bind_hash;
	long unsigned int icsk_timeout;
	struct timer_list icsk_retransmit_timer;
	struct timer_list icsk_delack_timer;
	__u32 icsk_rto;
	__u32 icsk_rto_min;
	__u32 icsk_delack_max;
	__u32 icsk_pmtu_cookie;
	const struct tcp_congestion_ops *icsk_ca_ops;
	const struct inet_connection_sock_af_ops *icsk_af_ops;
	const struct tcp_ulp_ops *icsk_ulp_ops;
	void *icsk_ulp_data;
	void (*icsk_clean_acked)(struct sock *, u32);
	struct hlist_node icsk_listen_portaddr_node;
	unsigned int (*icsk_sync_mss)(struct sock *, u32);
	__u8 icsk_ca_state: 5;
	__u8 icsk_ca_initialized: 1;
	__u8 icsk_ca_setsockopt: 1;
	__u8 icsk_ca_dst_locked: 1;
	__u8 icsk_retransmits;
	__u8 icsk_pending;
	__u8 icsk_backoff;
	__u8 icsk_syn_retries;
	__u8 icsk_probes_out;
	__u16 icsk_ext_hdr_len;
	struct {
		__u8 pending;
		__u8 quick;
		__u8 pingpong;
		__u8 retry;
		__u32 ato;
		long unsigned int timeout;
		__u32 lrcvtime;
		__u16 last_seg_size;
		__u16 rcv_mss;
	} icsk_ack;
	struct {
		int enabled;
		int search_high;
		int search_low;
		int probe_size;
		u32 probe_timestamp;
	} icsk_mtup;
	u32 icsk_probes_tstamp;
	u32 icsk_user_timeout;
	u64 icsk_ca_priv[13];
};

struct inet_bind_bucket {
	possible_net_t ib_net;
	int l3mdev;
	short unsigned int port;
	signed char fastreuse;
	signed char fastreuseport;
	kuid_t fastuid;
	struct in6_addr fast_v6_rcv_saddr;
	__be32 fast_rcv_saddr;
	short unsigned int fast_sk_family;
	bool fast_ipv6_only;
	struct hlist_node node;
	struct hlist_head owners;
};

struct tcp_ulp_ops {
	struct list_head list;
	int (*init)(struct sock *);
	void (*update)(struct sock *, struct proto *, void (*)(struct sock *));
	void (*release)(struct sock *);
	int (*get_info)(const struct sock *, struct sk_buff *);
	size_t (*get_info_size)(const struct sock *);
	void (*clone)(const struct request_sock *, struct sock *, const gfp_t);
	char name[16];
	struct module *owner;
};

struct tcp_fastopen_cookie {
	__le64 val[2];
	s8 len;
	bool exp;
};

struct tcp_sack_block {
	u32 start_seq;
	u32 end_seq;
};

struct tcp_options_received {
	int ts_recent_stamp;
	u32 ts_recent;
	u32 rcv_tsval;
	u32 rcv_tsecr;
	u16 saw_tstamp: 1;
	u16 tstamp_ok: 1;
	u16 dsack: 1;
	u16 wscale_ok: 1;
	u16 sack_ok: 3;
	u16 smc_ok: 1;
	u16 snd_wscale: 4;
	u16 rcv_wscale: 4;
	u8 saw_unknown: 1;
	u8 unused: 7;
	u8 num_sacks;
	u16 user_mss;
	u16 mss_clamp;
};

struct tcp_rack {
	u64 mstamp;
	u32 rtt_us;
	u32 end_seq;
	u32 last_delivered;
	u8 reo_wnd_steps;
	u8 reo_wnd_persist: 5;
	u8 dsack_seen: 1;
	u8 advanced: 1;
};

struct tcp_fastopen_request;

struct tcp_sock {
	struct inet_connection_sock inet_conn;
	u16 tcp_header_len;
	u16 gso_segs;
	__be32 pred_flags;
	u64 bytes_received;
	u32 segs_in;
	u32 data_segs_in;
	u32 rcv_nxt;
	u32 copied_seq;
	u32 rcv_wup;
	u32 snd_nxt;
	u32 segs_out;
	u32 data_segs_out;
	u64 bytes_sent;
	u64 bytes_acked;
	u32 dsack_dups;
	u32 snd_una;
	u32 snd_sml;
	u32 rcv_tstamp;
	u32 lsndtime;
	u32 last_oow_ack_time;
	u32 compressed_ack_rcv_nxt;
	u32 tsoffset;
	struct list_head tsq_node;
	struct list_head tsorted_sent_queue;
	u32 snd_wl1;
	u32 snd_wnd;
	u32 max_window;
	u32 mss_cache;
	u32 window_clamp;
	u32 rcv_ssthresh;
	struct tcp_rack rack;
	u16 advmss;
	u8 compressed_ack;
	u8 dup_ack_counter: 2;
	u8 tlp_retrans: 1;
	u8 unused: 5;
	u32 chrono_start;
	u32 chrono_stat[3];
	u8 chrono_type: 2;
	u8 rate_app_limited: 1;
	u8 fastopen_connect: 1;
	u8 fastopen_no_cookie: 1;
	u8 is_sack_reneg: 1;
	u8 fastopen_client_fail: 2;
	u8 nonagle: 4;
	u8 thin_lto: 1;
	u8 recvmsg_inq: 1;
	u8 repair: 1;
	u8 frto: 1;
	u8 repair_queue;
	u8 save_syn: 2;
	u8 syn_data: 1;
	u8 syn_fastopen: 1;
	u8 syn_fastopen_exp: 1;
	u8 syn_fastopen_ch: 1;
	u8 syn_data_acked: 1;
	u8 is_cwnd_limited: 1;
	u32 tlp_high_seq;
	u32 tcp_tx_delay;
	u64 tcp_wstamp_ns;
	u64 tcp_clock_cache;
	u64 tcp_mstamp;
	u32 srtt_us;
	u32 mdev_us;
	u32 mdev_max_us;
	u32 rttvar_us;
	u32 rtt_seq;
	struct minmax rtt_min;
	u32 packets_out;
	u32 retrans_out;
	u32 max_packets_out;
	u32 max_packets_seq;
	u16 urg_data;
	u8 ecn_flags;
	u8 keepalive_probes;
	u32 reordering;
	u32 reord_seen;
	u32 snd_up;
	struct tcp_options_received rx_opt;
	u32 snd_ssthresh;
	u32 snd_cwnd;
	u32 snd_cwnd_cnt;
	u32 snd_cwnd_clamp;
	u32 snd_cwnd_used;
	u32 snd_cwnd_stamp;
	u32 prior_cwnd;
	u32 prr_delivered;
	u32 prr_out;
	u32 delivered;
	u32 delivered_ce;
	u32 lost;
	u32 app_limited;
	u64 first_tx_mstamp;
	u64 delivered_mstamp;
	u32 rate_delivered;
	u32 rate_interval_us;
	u32 rcv_wnd;
	u32 write_seq;
	u32 notsent_lowat;
	u32 pushed_seq;
	u32 lost_out;
	u32 sacked_out;
	struct hrtimer pacing_timer;
	struct hrtimer compressed_ack_timer;
	struct sk_buff *lost_skb_hint;
	struct sk_buff *retransmit_skb_hint;
	struct rb_root out_of_order_queue;
	struct sk_buff *ooo_last_skb;
	struct tcp_sack_block duplicate_sack[1];
	struct tcp_sack_block selective_acks[4];
	struct tcp_sack_block recv_sack_cache[4];
	struct sk_buff *highest_sack;
	int lost_cnt_hint;
	u32 prior_ssthresh;
	u32 high_seq;
	u32 retrans_stamp;
	u32 undo_marker;
	int undo_retrans;
	u64 bytes_retrans;
	u32 total_retrans;
	u32 urg_seq;
	unsigned int keepalive_time;
	unsigned int keepalive_intvl;
	int linger2;
	u8 bpf_sock_ops_cb_flags;
	u16 timeout_rehash;
	u32 rcv_ooopack;
	u32 rcv_rtt_last_tsecr;
	struct {
		u32 rtt_us;
		u32 seq;
		u64 time;
	} rcv_rtt_est;
	struct {
		u32 space;
		u32 seq;
		u64 time;
	} rcvq_space;
	struct {
		u32 probe_seq_start;
		u32 probe_seq_end;
	} mtu_probe;
	u32 mtu_info;
	struct tcp_fastopen_request *fastopen_req;
	struct request_sock *fastopen_rsk;
	struct saved_syn *saved_syn;
};

struct tcp_fastopen_request {
	struct tcp_fastopen_cookie cookie;
	struct msghdr *data;
	size_t size;
	int copied;
	struct ubuf_info *uarg;
};

struct net_protocol {
	int (*early_demux)(struct sk_buff *);
	int (*early_demux_handler)(struct sk_buff *);
	int (*handler)(struct sk_buff *);
	int (*err_handler)(struct sk_buff *, u32);
	unsigned int no_policy: 1;
	unsigned int netns_ok: 1;
	unsigned int icmp_strict_tag_validation: 1;
};

enum {
	SK_MEMINFO_RMEM_ALLOC = 0,
	SK_MEMINFO_RCVBUF = 1,
	SK_MEMINFO_WMEM_ALLOC = 2,
	SK_MEMINFO_SNDBUF = 3,
	SK_MEMINFO_FWD_ALLOC = 4,
	SK_MEMINFO_WMEM_QUEUED = 5,
	SK_MEMINFO_OPTMEM = 6,
	SK_MEMINFO_BACKLOG = 7,
	SK_MEMINFO_DROPS = 8,
	SK_MEMINFO_VARS = 9,
};

enum sknetlink_groups {
	SKNLGRP_NONE = 0,
	SKNLGRP_INET_TCP_DESTROY = 1,
	SKNLGRP_INET_UDP_DESTROY = 2,
	SKNLGRP_INET6_TCP_DESTROY = 3,
	SKNLGRP_INET6_UDP_DESTROY = 4,
	__SKNLGRP_MAX = 5,
};

struct inet_request_sock {
	struct request_sock req;
	u16 snd_wscale: 4;
	u16 rcv_wscale: 4;
	u16 tstamp_ok: 1;
	u16 sack_ok: 1;
	u16 wscale_ok: 1;
	u16 ecn_ok: 1;
	u16 acked: 1;
	u16 no_srccheck: 1;
	u16 smc_ok: 1;
	u32 ir_mark;
	union {
		struct ip_options_rcu *ireq_opt;
		struct {
			struct ipv6_txoptions *ipv6_opt;
			struct sk_buff *pktopts;
		};
	};
};

struct tcp_request_sock_ops;

struct tcp_request_sock {
	struct inet_request_sock req;
	const struct tcp_request_sock_ops *af_specific;
	u64 snt_synack;
	bool tfo_listener;
	bool is_mptcp;
	u32 txhash;
	u32 rcv_isn;
	u32 snt_isn;
	u32 ts_off;
	u32 last_oow_ack_time;
	u32 rcv_nxt;
	u8 syn_tos;
};

enum tcp_synack_type {
	TCP_SYNACK_NORMAL = 0,
	TCP_SYNACK_FASTOPEN = 1,
	TCP_SYNACK_COOKIE = 2,
};

struct tcp_request_sock_ops {
	u16 mss_clamp;
	void (*init_req)(struct request_sock *, const struct sock *, struct sk_buff *);
	struct dst_entry * (*route_req)(const struct sock *, struct flowi *, const struct request_sock *);
	u32 (*init_seq)(const struct sk_buff *);
	u32 (*init_ts_off)(const struct net *, const struct sk_buff *);
	int (*send_synack)(const struct sock *, struct dst_entry *, struct flowi *, struct request_sock *, struct tcp_fastopen_cookie *, enum tcp_synack_type, struct sk_buff *);
};

struct ts_state {
	unsigned int offset;
	char cb[40];
};

struct ts_config;

struct ts_ops {
	const char *name;
	struct ts_config * (*init)(const void *, unsigned int, gfp_t, int);
	unsigned int (*find)(struct ts_config *, struct ts_state *);
	void (*destroy)(struct ts_config *);
	void * (*get_pattern)(struct ts_config *);
	unsigned int (*get_pattern_len)(struct ts_config *);
	struct module *owner;
	struct list_head list;
};

struct ts_config {
	struct ts_ops *ops;
	int flags;
	unsigned int (*get_next_block)(unsigned int, const u8 **, struct ts_config *, struct ts_state *);
	void (*finish)(struct ts_config *, struct ts_state *);
};

enum {
	SKB_FCLONE_UNAVAILABLE = 0,
	SKB_FCLONE_ORIG = 1,
	SKB_FCLONE_CLONE = 2,
};

struct sk_buff_fclones {
	struct sk_buff skb1;
	struct sk_buff skb2;
	refcount_t fclone_ref;
};

struct skb_seq_state {
	__u32 lower_offset;
	__u32 upper_offset;
	__u32 frag_idx;
	__u32 stepped_offset;
	struct sk_buff *root_skb;
	struct sk_buff *cur_skb;
	__u8 *frag_data;
};

struct skb_checksum_ops {
	__wsum (*update)(const void *, int, __wsum);
	__wsum (*combine)(__wsum, __wsum, int, int);
};

struct skb_gso_cb {
	union {
		int mac_offset;
		int data_offset;
	};
	int encap_level;
	__wsum csum;
	__u16 csum_start;
};

struct napi_gro_cb {
	void *frag0;
	unsigned int frag0_len;
	int data_offset;
	u16 flush;
	u16 flush_id;
	u16 count;
	u16 gro_remcsum_start;
	long unsigned int age;
	u16 proto;
	u8 same_flow: 1;
	u8 encap_mark: 1;
	u8 csum_valid: 1;
	u8 csum_cnt: 3;
	u8 free: 2;
	u8 is_ipv6: 1;
	u8 is_fou: 1;
	u8 is_atomic: 1;
	u8 recursion_counter: 4;
	u8 is_flist: 1;
	__wsum csum;
	struct sk_buff *last;
};

struct vlan_hdr {
	__be16 h_vlan_TCI;
	__be16 h_vlan_encapsulated_proto;
};

enum sctp_msg_flags {
	MSG_NOTIFICATION = 32768,
};

struct ip_auth_hdr {
	__u8 nexthdr;
	__u8 hdrlen;
	__be16 reserved;
	__be32 spi;
	__be32 seq_no;
	__u8 auth_data[0];
};

struct frag_hdr {
	__u8 nexthdr;
	__u8 reserved;
	__be16 frag_off;
	__be32 identification;
};

enum {
	SCM_TSTAMP_SND = 0,
	SCM_TSTAMP_SCHED = 1,
	SCM_TSTAMP_ACK = 2,
};

struct mpls_shim_hdr {
	__be32 label_stack_entry;
};

struct napi_alloc_cache {
	struct page_frag_cache page;
	unsigned int skb_count;
	void *skb_cache[64];
};

struct ahash_request;

struct scm_cookie {
	struct pid *pid;
	struct scm_fp_list *fp;
	struct scm_creds creds;
};

struct scm_timestamping {
	struct __kernel_old_timespec ts[3];
};

struct scm_timestamping64 {
	struct __kernel_timespec ts[3];
};

enum {
	TCA_STATS_UNSPEC = 0,
	TCA_STATS_BASIC = 1,
	TCA_STATS_RATE_EST = 2,
	TCA_STATS_QUEUE = 3,
	TCA_STATS_APP = 4,
	TCA_STATS_RATE_EST64 = 5,
	TCA_STATS_PAD = 6,
	TCA_STATS_BASIC_HW = 7,
	TCA_STATS_PKT64 = 8,
	__TCA_STATS_MAX = 9,
};

struct gnet_stats_basic {
	__u64 bytes;
	__u32 packets;
};

struct gnet_stats_rate_est {
	__u32 bps;
	__u32 pps;
};

struct gnet_stats_rate_est64 {
	__u64 bps;
	__u64 pps;
};

struct gnet_estimator {
	signed char interval;
	unsigned char ewma_log;
};

struct net_rate_estimator {
	struct gnet_stats_basic_packed *bstats;
	spinlock_t *stats_lock;
	seqcount_t *running;
	struct gnet_stats_basic_cpu *cpu_bstats;
	u8 ewma_log;
	u8 intvl_log;
	seqcount_t seq;
	u64 last_packets;
	u64 last_bytes;
	u64 avpps;
	u64 avbps;
	long unsigned int next_jiffies;
	struct timer_list timer;
	struct callback_head rcu;
};

enum {
	RTM_BASE = 16,
	RTM_NEWLINK = 16,
	RTM_DELLINK = 17,
	RTM_GETLINK = 18,
	RTM_SETLINK = 19,
	RTM_NEWADDR = 20,
	RTM_DELADDR = 21,
	RTM_GETADDR = 22,
	RTM_NEWROUTE = 24,
	RTM_DELROUTE = 25,
	RTM_GETROUTE = 26,
	RTM_NEWNEIGH = 28,
	RTM_DELNEIGH = 29,
	RTM_GETNEIGH = 30,
	RTM_NEWRULE = 32,
	RTM_DELRULE = 33,
	RTM_GETRULE = 34,
	RTM_NEWQDISC = 36,
	RTM_DELQDISC = 37,
	RTM_GETQDISC = 38,
	RTM_NEWTCLASS = 40,
	RTM_DELTCLASS = 41,
	RTM_GETTCLASS = 42,
	RTM_NEWTFILTER = 44,
	RTM_DELTFILTER = 45,
	RTM_GETTFILTER = 46,
	RTM_NEWACTION = 48,
	RTM_DELACTION = 49,
	RTM_GETACTION = 50,
	RTM_NEWPREFIX = 52,
	RTM_GETMULTICAST = 58,
	RTM_GETANYCAST = 62,
	RTM_NEWNEIGHTBL = 64,
	RTM_GETNEIGHTBL = 66,
	RTM_SETNEIGHTBL = 67,
	RTM_NEWNDUSEROPT = 68,
	RTM_NEWADDRLABEL = 72,
	RTM_DELADDRLABEL = 73,
	RTM_GETADDRLABEL = 74,
	RTM_GETDCB = 78,
	RTM_SETDCB = 79,
	RTM_NEWNETCONF = 80,
	RTM_DELNETCONF = 81,
	RTM_GETNETCONF = 82,
	RTM_NEWMDB = 84,
	RTM_DELMDB = 85,
	RTM_GETMDB = 86,
	RTM_NEWNSID = 88,
	RTM_DELNSID = 89,
	RTM_GETNSID = 90,
	RTM_NEWSTATS = 92,
	RTM_GETSTATS = 94,
	RTM_NEWCACHEREPORT = 96,
	RTM_NEWCHAIN = 100,
	RTM_DELCHAIN = 101,
	RTM_GETCHAIN = 102,
	RTM_NEWNEXTHOP = 104,
	RTM_DELNEXTHOP = 105,
	RTM_GETNEXTHOP = 106,
	RTM_NEWLINKPROP = 108,
	RTM_DELLINKPROP = 109,
	RTM_GETLINKPROP = 110,
	RTM_NEWVLAN = 112,
	RTM_DELVLAN = 113,
	RTM_GETVLAN = 114,
	__RTM_MAX = 115,
};

struct rtgenmsg {
	unsigned char rtgen_family;
};

enum rtnetlink_groups {
	RTNLGRP_NONE = 0,
	RTNLGRP_LINK = 1,
	RTNLGRP_NOTIFY = 2,
	RTNLGRP_NEIGH = 3,
	RTNLGRP_TC = 4,
	RTNLGRP_IPV4_IFADDR = 5,
	RTNLGRP_IPV4_MROUTE = 6,
	RTNLGRP_IPV4_ROUTE = 7,
	RTNLGRP_IPV4_RULE = 8,
	RTNLGRP_IPV6_IFADDR = 9,
	RTNLGRP_IPV6_MROUTE = 10,
	RTNLGRP_IPV6_ROUTE = 11,
	RTNLGRP_IPV6_IFINFO = 12,
	RTNLGRP_DECnet_IFADDR = 13,
	RTNLGRP_NOP2 = 14,
	RTNLGRP_DECnet_ROUTE = 15,
	RTNLGRP_DECnet_RULE = 16,
	RTNLGRP_NOP4 = 17,
	RTNLGRP_IPV6_PREFIX = 18,
	RTNLGRP_IPV6_RULE = 19,
	RTNLGRP_ND_USEROPT = 20,
	RTNLGRP_PHONET_IFADDR = 21,
	RTNLGRP_PHONET_ROUTE = 22,
	RTNLGRP_DCB = 23,
	RTNLGRP_IPV4_NETCONF = 24,
	RTNLGRP_IPV6_NETCONF = 25,
	RTNLGRP_MDB = 26,
	RTNLGRP_MPLS_ROUTE = 27,
	RTNLGRP_NSID = 28,
	RTNLGRP_MPLS_NETCONF = 29,
	RTNLGRP_IPV4_MROUTE_R = 30,
	RTNLGRP_IPV6_MROUTE_R = 31,
	RTNLGRP_NEXTHOP = 32,
	RTNLGRP_BRVLAN = 33,
	__RTNLGRP_MAX = 34,
};

enum {
	NETNSA_NONE = 0,
	NETNSA_NSID = 1,
	NETNSA_PID = 2,
	NETNSA_FD = 3,
	NETNSA_TARGET_NSID = 4,
	NETNSA_CURRENT_NSID = 5,
	__NETNSA_MAX = 6,
};

struct pcpu_gen_cookie {
	local_t nesting;
	u64 last;
};

struct gen_cookie {
	struct pcpu_gen_cookie *local;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	atomic64_t forward_last;
	atomic64_t reverse_last;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

enum rtnl_link_flags {
	RTNL_FLAG_DOIT_UNLOCKED = 1,
};

struct net_fill_args {
	u32 portid;
	u32 seq;
	int flags;
	int cmd;
	int nsid;
	bool add_ref;
	int ref_nsid;
};

struct rtnl_net_dump_cb {
	struct net *tgt_net;
	struct net *ref_net;
	struct sk_buff *skb;
	struct net_fill_args fillargs;
	int idx;
	int s_idx;
};

enum flow_dissect_ret {
	FLOW_DISSECT_RET_OUT_GOOD = 0,
	FLOW_DISSECT_RET_OUT_BAD = 1,
	FLOW_DISSECT_RET_PROTO_AGAIN = 2,
	FLOW_DISSECT_RET_IPPROTO_AGAIN = 3,
	FLOW_DISSECT_RET_CONTINUE = 4,
};

struct flow_dissector_key_tags {
	u32 flow_label;
};

struct flow_dissector_key_vlan {
	union {
		struct {
			u16 vlan_id: 12;
			u16 vlan_dei: 1;
			u16 vlan_priority: 3;
		};
		__be16 vlan_tci;
	};
	__be16 vlan_tpid;
	__be16 vlan_eth_type;
	u16 padding;
};

struct flow_dissector_mpls_lse {
	u32 mpls_ttl: 8;
	u32 mpls_bos: 1;
	u32 mpls_tc: 3;
	u32 mpls_label: 20;
};

struct flow_dissector_key_mpls {
	struct flow_dissector_mpls_lse ls[7];
	u8 used_lses;
};

struct flow_dissector_key_enc_opts {
	u8 data[255];
	u8 len;
	__be16 dst_opt_type;
};

struct flow_dissector_key_keyid {
	__be32 keyid;
};

struct flow_dissector_key_ipv6_addrs {
	struct in6_addr src;
	struct in6_addr dst;
};

struct flow_dissector_key_tipc {
	__be32 key;
};

struct flow_dissector_key_addrs {
	union {
		struct flow_dissector_key_ipv4_addrs v4addrs;
		struct flow_dissector_key_ipv6_addrs v6addrs;
		struct flow_dissector_key_tipc tipckey;
	};
};

struct flow_dissector_key_arp {
	__u32 sip;
	__u32 tip;
	__u8 op;
	unsigned char sha[6];
	unsigned char tha[6];
};

struct flow_dissector_key_icmp {
	struct {
		u8 type;
		u8 code;
	};
	u16 id;
};

struct flow_dissector_key_eth_addrs {
	unsigned char dst[6];
	unsigned char src[6];
};

struct flow_dissector_key_tcp {
	__be16 flags;
};

struct flow_dissector_key_ip {
	__u8 tos;
	__u8 ttl;
};

struct flow_dissector_key_meta {
	int ingress_ifindex;
	u16 ingress_iftype;
};

struct flow_dissector_key_hash {
	u32 hash;
};

struct flow_dissector_key {
	enum flow_dissector_key_id key_id;
	size_t offset;
};

struct flow_keys {
	struct flow_dissector_key_control control;
	struct flow_dissector_key_basic basic;
	struct flow_dissector_key_tags tags;
	struct flow_dissector_key_vlan vlan;
	struct flow_dissector_key_vlan cvlan;
	struct flow_dissector_key_keyid keyid;
	struct flow_dissector_key_ports ports;
	struct flow_dissector_key_icmp icmp;
	struct flow_dissector_key_addrs addrs;
	int: 32;
};

struct flow_keys_digest {
	u8 data[16];
};

enum bpf_ret_code {
	BPF_OK = 0,
	BPF_DROP = 2,
	BPF_REDIRECT = 7,
	BPF_LWT_REROUTE = 128,
};

enum {
	BPF_FLOW_DISSECTOR_F_PARSE_1ST_FRAG = 1,
	BPF_FLOW_DISSECTOR_F_STOP_AT_FLOW_LABEL = 2,
	BPF_FLOW_DISSECTOR_F_STOP_AT_ENCAP = 4,
};

struct ip_tunnel_key {
	__be64 tun_id;
	union {
		struct {
			__be32 src;
			__be32 dst;
		} ipv4;
		struct {
			struct in6_addr src;
			struct in6_addr dst;
		} ipv6;
	} u;
	__be16 tun_flags;
	u8 tos;
	u8 ttl;
	__be32 label;
	__be16 tp_src;
	__be16 tp_dst;
};

struct dst_cache_pcpu;

struct dst_cache {
	struct dst_cache_pcpu *cache;
	long unsigned int reset_ts;
};

struct ip_tunnel_info {
	struct ip_tunnel_key key;
	struct dst_cache dst_cache;
	u8 options_len;
	u8 mode;
};

union tcp_word_hdr {
	struct tcphdr hdr;
	__be32 words[5];
};

enum lwtunnel_encap_types {
	LWTUNNEL_ENCAP_NONE = 0,
	LWTUNNEL_ENCAP_MPLS = 1,
	LWTUNNEL_ENCAP_IP = 2,
	LWTUNNEL_ENCAP_ILA = 3,
	LWTUNNEL_ENCAP_IP6 = 4,
	LWTUNNEL_ENCAP_SEG6 = 5,
	LWTUNNEL_ENCAP_BPF = 6,
	LWTUNNEL_ENCAP_SEG6_LOCAL = 7,
	LWTUNNEL_ENCAP_RPL = 8,
	__LWTUNNEL_ENCAP_MAX = 9,
};

enum metadata_type {
	METADATA_IP_TUNNEL = 0,
	METADATA_HW_PORT_MUX = 1,
};

struct hw_port_info {
	struct net_device *lower_dev;
	u32 port_id;
};

struct metadata_dst {
	struct dst_entry dst;
	enum metadata_type type;
	union {
		struct ip_tunnel_info tun_info;
		struct hw_port_info port_info;
	} u;
};

struct gre_base_hdr {
	__be16 flags;
	__be16 protocol;
};

struct gre_full_hdr {
	struct gre_base_hdr fixed_header;
	__be16 csum;
	__be16 reserved1;
	__be32 key;
	__be32 seq;
};

struct pptp_gre_header {
	struct gre_base_hdr gre_hd;
	__be16 payload_len;
	__be16 call_id;
	__be32 seq;
	__be32 ack;
};

struct tipc_basic_hdr {
	__be32 w[4];
};

struct icmphdr {
	__u8 type;
	__u8 code;
	__sum16 checksum;
	union {
		struct {
			__be16 id;
			__be16 sequence;
		} echo;
		__be32 gateway;
		struct {
			__be16 __unused;
			__be16 mtu;
		} frag;
		__u8 reserved[4];
	} un;
};

enum dccp_state {
	DCCP_OPEN = 1,
	DCCP_REQUESTING = 2,
	DCCP_LISTEN = 10,
	DCCP_RESPOND = 3,
	DCCP_ACTIVE_CLOSEREQ = 4,
	DCCP_PASSIVE_CLOSE = 8,
	DCCP_CLOSING = 11,
	DCCP_TIME_WAIT = 6,
	DCCP_CLOSED = 7,
	DCCP_NEW_SYN_RECV = 12,
	DCCP_PARTOPEN = 13,
	DCCP_PASSIVE_CLOSEREQ = 14,
	DCCP_MAX_STATES = 15,
};

enum l2tp_debug_flags {
	L2TP_MSG_DEBUG = 1,
	L2TP_MSG_CONTROL = 2,
	L2TP_MSG_SEQ = 4,
	L2TP_MSG_DATA = 8,
};

struct mpls_label {
	__be32 entry;
};

enum batadv_packettype {
	BATADV_IV_OGM = 0,
	BATADV_BCAST = 1,
	BATADV_CODED = 2,
	BATADV_ELP = 3,
	BATADV_OGM2 = 4,
	BATADV_UNICAST = 64,
	BATADV_UNICAST_FRAG = 65,
	BATADV_UNICAST_4ADDR = 66,
	BATADV_ICMP = 67,
	BATADV_UNICAST_TVLV = 68,
};

struct batadv_unicast_packet {
	__u8 packet_type;
	__u8 version;
	__u8 ttl;
	__u8 ttvn;
	__u8 dest[6];
};

struct _flow_keys_digest_data {
	__be16 n_proto;
	u8 ip_proto;
	u8 padding;
	__be32 ports;
	__be32 src;
	__be32 dst;
};

enum {
	IF_OPER_UNKNOWN = 0,
	IF_OPER_NOTPRESENT = 1,
	IF_OPER_DOWN = 2,
	IF_OPER_LOWERLAYERDOWN = 3,
	IF_OPER_TESTING = 4,
	IF_OPER_DORMANT = 5,
	IF_OPER_UP = 6,
};

struct ifbond {
	__s32 bond_mode;
	__s32 num_slaves;
	__s32 miimon;
};

typedef struct ifbond ifbond;

struct ifslave {
	__s32 slave_id;
	char slave_name[16];
	__s8 link;
	__s8 state;
	__u32 link_failure_count;
};

typedef struct ifslave ifslave;

struct netdev_boot_setup {
	char name[16];
	struct ifmap map;
};

enum {
	NAPIF_STATE_SCHED = 1,
	NAPIF_STATE_MISSED = 2,
	NAPIF_STATE_DISABLE = 4,
	NAPIF_STATE_NPSVC = 8,
	NAPIF_STATE_LISTED = 16,
	NAPIF_STATE_NO_BUSY_POLL = 32,
	NAPIF_STATE_IN_BUSY_POLL = 64,
};

struct bpf_xdp_link {
	struct bpf_link link;
	struct net_device *dev;
	int flags;
};

struct netdev_net_notifier {
	struct list_head list;
	struct notifier_block *nb;
};

struct udp_tunnel_info {
	short unsigned int type;
	sa_family_t sa_family;
	__be16 port;
	u8 hw_priv;
};

struct packet_type {
	__be16 type;
	bool ignore_outgoing;
	struct net_device *dev;
	int (*func)(struct sk_buff *, struct net_device *, struct packet_type *, struct net_device *);
	void (*list_func)(struct list_head *, struct packet_type *, struct net_device *);
	bool (*id_match)(struct packet_type *, struct sock *);
	struct net *af_packet_net;
	void *af_packet_priv;
	struct list_head list;
};

struct offload_callbacks {
	struct sk_buff * (*gso_segment)(struct sk_buff *, netdev_features_t);
	struct sk_buff * (*gro_receive)(struct list_head *, struct sk_buff *);
	int (*gro_complete)(struct sk_buff *, int);
};

struct packet_offload {
	__be16 type;
	u16 priority;
	struct offload_callbacks callbacks;
	struct list_head list;
};

struct netdev_notifier_info_ext {
	struct netdev_notifier_info info;
	union {
		u32 mtu;
	} ext;
};

struct netdev_notifier_change_info {
	struct netdev_notifier_info info;
	unsigned int flags_changed;
};

struct netdev_notifier_changeupper_info {
	struct netdev_notifier_info info;
	struct net_device *upper_dev;
	bool master;
	bool linking;
	void *upper_info;
};

struct netdev_notifier_changelowerstate_info {
	struct netdev_notifier_info info;
	void *lower_state_info;
};

struct netdev_notifier_pre_changeaddr_info {
	struct netdev_notifier_info info;
	const unsigned char *dev_addr;
};

typedef int (*bpf_op_t)(struct net_device *, struct netdev_bpf *);

enum {
	NESTED_SYNC_IMM_BIT = 0,
	NESTED_SYNC_TODO_BIT = 1,
};

struct netdev_nested_priv {
	unsigned char flags;
	void *data;
};

struct netdev_bonding_info {
	ifslave slave;
	ifbond master;
};

struct netdev_notifier_bonding_info {
	struct netdev_notifier_info info;
	struct netdev_bonding_info bonding_info;
};

enum qdisc_state_t {
	__QDISC_STATE_SCHED = 0,
	__QDISC_STATE_DEACTIVATED = 1,
	__QDISC_STATE_MISSED = 2,
};

struct udp_hslot;

struct udp_table {
	struct udp_hslot *hash;
	struct udp_hslot *hash2;
	unsigned int mask;
	unsigned int log;
};

enum {
	IPV4_DEVCONF_FORWARDING = 1,
	IPV4_DEVCONF_MC_FORWARDING = 2,
	IPV4_DEVCONF_PROXY_ARP = 3,
	IPV4_DEVCONF_ACCEPT_REDIRECTS = 4,
	IPV4_DEVCONF_SECURE_REDIRECTS = 5,
	IPV4_DEVCONF_SEND_REDIRECTS = 6,
	IPV4_DEVCONF_SHARED_MEDIA = 7,
	IPV4_DEVCONF_RP_FILTER = 8,
	IPV4_DEVCONF_ACCEPT_SOURCE_ROUTE = 9,
	IPV4_DEVCONF_BOOTP_RELAY = 10,
	IPV4_DEVCONF_LOG_MARTIANS = 11,
	IPV4_DEVCONF_TAG = 12,
	IPV4_DEVCONF_ARPFILTER = 13,
	IPV4_DEVCONF_MEDIUM_ID = 14,
	IPV4_DEVCONF_NOXFRM = 15,
	IPV4_DEVCONF_NOPOLICY = 16,
	IPV4_DEVCONF_FORCE_IGMP_VERSION = 17,
	IPV4_DEVCONF_ARP_ANNOUNCE = 18,
	IPV4_DEVCONF_ARP_IGNORE = 19,
	IPV4_DEVCONF_PROMOTE_SECONDARIES = 20,
	IPV4_DEVCONF_ARP_ACCEPT = 21,
	IPV4_DEVCONF_ARP_NOTIFY = 22,
	IPV4_DEVCONF_ACCEPT_LOCAL = 23,
	IPV4_DEVCONF_SRC_VMARK = 24,
	IPV4_DEVCONF_PROXY_ARP_PVLAN = 25,
	IPV4_DEVCONF_ROUTE_LOCALNET = 26,
	IPV4_DEVCONF_IGMPV2_UNSOLICITED_REPORT_INTERVAL = 27,
	IPV4_DEVCONF_IGMPV3_UNSOLICITED_REPORT_INTERVAL = 28,
	IPV4_DEVCONF_IGNORE_ROUTES_WITH_LINKDOWN = 29,
	IPV4_DEVCONF_DROP_UNICAST_IN_L2_MULTICAST = 30,
	IPV4_DEVCONF_DROP_GRATUITOUS_ARP = 31,
	IPV4_DEVCONF_BC_FORWARDING = 32,
	__IPV4_DEVCONF_MAX = 33,
};

struct udp_hslot {
	struct hlist_head head;
	int count;
	spinlock_t lock;
};

struct udp_tunnel_nic_shared {
	struct udp_tunnel_nic *udp_tunnel_nic_info;
	struct list_head devices;
};

struct dev_kfree_skb_cb {
	enum skb_free_reason reason;
};

struct netdev_adjacent {
	struct net_device *dev;
	bool master;
	bool ignore;
	u16 ref_nr;
	void *private;
	struct list_head list;
	struct callback_head rcu;
};

enum {
	NDA_UNSPEC = 0,
	NDA_DST = 1,
	NDA_LLADDR = 2,
	NDA_CACHEINFO = 3,
	NDA_PROBES = 4,
	NDA_VLAN = 5,
	NDA_PORT = 6,
	NDA_VNI = 7,
	NDA_IFINDEX = 8,
	NDA_MASTER = 9,
	NDA_LINK_NETNSID = 10,
	NDA_SRC_VNI = 11,
	NDA_PROTOCOL = 12,
	NDA_NH_ID = 13,
	NDA_FDB_EXT_ATTRS = 14,
	__NDA_MAX = 15,
};

struct nda_cacheinfo {
	__u32 ndm_confirmed;
	__u32 ndm_used;
	__u32 ndm_updated;
	__u32 ndm_refcnt;
};

struct ndt_stats {
	__u64 ndts_allocs;
	__u64 ndts_destroys;
	__u64 ndts_hash_grows;
	__u64 ndts_res_failed;
	__u64 ndts_lookups;
	__u64 ndts_hits;
	__u64 ndts_rcv_probes_mcast;
	__u64 ndts_rcv_probes_ucast;
	__u64 ndts_periodic_gc_runs;
	__u64 ndts_forced_gc_runs;
	__u64 ndts_table_fulls;
};

enum {
	NDTPA_UNSPEC = 0,
	NDTPA_IFINDEX = 1,
	NDTPA_REFCNT = 2,
	NDTPA_REACHABLE_TIME = 3,
	NDTPA_BASE_REACHABLE_TIME = 4,
	NDTPA_RETRANS_TIME = 5,
	NDTPA_GC_STALETIME = 6,
	NDTPA_DELAY_PROBE_TIME = 7,
	NDTPA_QUEUE_LEN = 8,
	NDTPA_APP_PROBES = 9,
	NDTPA_UCAST_PROBES = 10,
	NDTPA_MCAST_PROBES = 11,
	NDTPA_ANYCAST_DELAY = 12,
	NDTPA_PROXY_DELAY = 13,
	NDTPA_PROXY_QLEN = 14,
	NDTPA_LOCKTIME = 15,
	NDTPA_QUEUE_LENBYTES = 16,
	NDTPA_MCAST_REPROBES = 17,
	NDTPA_PAD = 18,
	__NDTPA_MAX = 19,
};

struct ndtmsg {
	__u8 ndtm_family;
	__u8 ndtm_pad1;
	__u16 ndtm_pad2;
};

struct ndt_config {
	__u16 ndtc_key_len;
	__u16 ndtc_entry_size;
	__u32 ndtc_entries;
	__u32 ndtc_last_flush;
	__u32 ndtc_last_rand;
	__u32 ndtc_hash_rnd;
	__u32 ndtc_hash_mask;
	__u32 ndtc_hash_chain_gc;
	__u32 ndtc_proxy_qlen;
};

enum {
	NDTA_UNSPEC = 0,
	NDTA_NAME = 1,
	NDTA_THRESH1 = 2,
	NDTA_THRESH2 = 3,
	NDTA_THRESH3 = 4,
	NDTA_CONFIG = 5,
	NDTA_PARMS = 6,
	NDTA_STATS = 7,
	NDTA_GC_INTERVAL = 8,
	NDTA_PAD = 9,
	__NDTA_MAX = 10,
};

enum {
	RTN_UNSPEC = 0,
	RTN_UNICAST = 1,
	RTN_LOCAL = 2,
	RTN_BROADCAST = 3,
	RTN_ANYCAST = 4,
	RTN_MULTICAST = 5,
	RTN_BLACKHOLE = 6,
	RTN_UNREACHABLE = 7,
	RTN_PROHIBIT = 8,
	RTN_THROW = 9,
	RTN_NAT = 10,
	RTN_XRESOLVE = 11,
	__RTN_MAX = 12,
};

enum {
	NEIGH_ARP_TABLE = 0,
	NEIGH_ND_TABLE = 1,
	NEIGH_DN_TABLE = 2,
	NEIGH_NR_TABLES = 3,
	NEIGH_LINK_TABLE = 3,
};

struct neigh_seq_state {
	struct seq_net_private p;
	struct neigh_table *tbl;
	struct neigh_hash_table *nht;
	void * (*neigh_sub_iter)(struct neigh_seq_state *, struct neighbour *, loff_t *);
	unsigned int bucket;
	unsigned int flags;
};

struct neighbour_cb {
	long unsigned int sched_next;
	unsigned int flags;
};

enum netevent_notif_type {
	NETEVENT_NEIGH_UPDATE = 1,
	NETEVENT_REDIRECT = 2,
	NETEVENT_DELAY_PROBE_TIME_UPDATE = 3,
	NETEVENT_IPV4_MPATH_HASH_UPDATE = 4,
	NETEVENT_IPV6_MPATH_HASH_UPDATE = 5,
	NETEVENT_IPV4_FWD_UPDATE_PRIORITY_UPDATE = 6,
};

struct neigh_dump_filter {
	int master_idx;
	int dev_idx;
};

struct neigh_sysctl_table {
	struct ctl_table_header *sysctl_header;
	struct ctl_table neigh_vars[21];
};

struct netlink_dump_control {
	int (*start)(struct netlink_callback *);
	int (*dump)(struct sk_buff *, struct netlink_callback *);
	int (*done)(struct netlink_callback *);
	void *data;
	struct module *module;
	u32 min_dump_alloc;
};

struct rtnl_link_stats {
	__u32 rx_packets;
	__u32 tx_packets;
	__u32 rx_bytes;
	__u32 tx_bytes;
	__u32 rx_errors;
	__u32 tx_errors;
	__u32 rx_dropped;
	__u32 tx_dropped;
	__u32 multicast;
	__u32 collisions;
	__u32 rx_length_errors;
	__u32 rx_over_errors;
	__u32 rx_crc_errors;
	__u32 rx_frame_errors;
	__u32 rx_fifo_errors;
	__u32 rx_missed_errors;
	__u32 tx_aborted_errors;
	__u32 tx_carrier_errors;
	__u32 tx_fifo_errors;
	__u32 tx_heartbeat_errors;
	__u32 tx_window_errors;
	__u32 rx_compressed;
	__u32 tx_compressed;
	__u32 rx_nohandler;
};

struct rtnl_link_ifmap {
	__u64 mem_start;
	__u64 mem_end;
	__u64 base_addr;
	__u16 irq;
	__u8 dma;
	__u8 port;
};

enum {
	IFLA_UNSPEC = 0,
	IFLA_ADDRESS = 1,
	IFLA_BROADCAST = 2,
	IFLA_IFNAME = 3,
	IFLA_MTU = 4,
	IFLA_LINK = 5,
	IFLA_QDISC = 6,
	IFLA_STATS = 7,
	IFLA_COST = 8,
	IFLA_PRIORITY = 9,
	IFLA_MASTER = 10,
	IFLA_WIRELESS = 11,
	IFLA_PROTINFO = 12,
	IFLA_TXQLEN = 13,
	IFLA_MAP = 14,
	IFLA_WEIGHT = 15,
	IFLA_OPERSTATE = 16,
	IFLA_LINKMODE = 17,
	IFLA_LINKINFO = 18,
	IFLA_NET_NS_PID = 19,
	IFLA_IFALIAS = 20,
	IFLA_NUM_VF = 21,
	IFLA_VFINFO_LIST = 22,
	IFLA_STATS64 = 23,
	IFLA_VF_PORTS = 24,
	IFLA_PORT_SELF = 25,
	IFLA_AF_SPEC = 26,
	IFLA_GROUP = 27,
	IFLA_NET_NS_FD = 28,
	IFLA_EXT_MASK = 29,
	IFLA_PROMISCUITY = 30,
	IFLA_NUM_TX_QUEUES = 31,
	IFLA_NUM_RX_QUEUES = 32,
	IFLA_CARRIER = 33,
	IFLA_PHYS_PORT_ID = 34,
	IFLA_CARRIER_CHANGES = 35,
	IFLA_PHYS_SWITCH_ID = 36,
	IFLA_LINK_NETNSID = 37,
	IFLA_PHYS_PORT_NAME = 38,
	IFLA_PROTO_DOWN = 39,
	IFLA_GSO_MAX_SEGS = 40,
	IFLA_GSO_MAX_SIZE = 41,
	IFLA_PAD = 42,
	IFLA_XDP = 43,
	IFLA_EVENT = 44,
	IFLA_NEW_NETNSID = 45,
	IFLA_IF_NETNSID = 46,
	IFLA_TARGET_NETNSID = 46,
	IFLA_CARRIER_UP_COUNT = 47,
	IFLA_CARRIER_DOWN_COUNT = 48,
	IFLA_NEW_IFINDEX = 49,
	IFLA_MIN_MTU = 50,
	IFLA_MAX_MTU = 51,
	IFLA_PROP_LIST = 52,
	IFLA_ALT_IFNAME = 53,
	IFLA_PERM_ADDRESS = 54,
	IFLA_PROTO_DOWN_REASON = 55,
	__IFLA_MAX = 56,
};

enum {
	IFLA_PROTO_DOWN_REASON_UNSPEC = 0,
	IFLA_PROTO_DOWN_REASON_MASK = 1,
	IFLA_PROTO_DOWN_REASON_VALUE = 2,
	__IFLA_PROTO_DOWN_REASON_CNT = 3,
	IFLA_PROTO_DOWN_REASON_MAX = 2,
};

enum {
	IFLA_BRPORT_UNSPEC = 0,
	IFLA_BRPORT_STATE = 1,
	IFLA_BRPORT_PRIORITY = 2,
	IFLA_BRPORT_COST = 3,
	IFLA_BRPORT_MODE = 4,
	IFLA_BRPORT_GUARD = 5,
	IFLA_BRPORT_PROTECT = 6,
	IFLA_BRPORT_FAST_LEAVE = 7,
	IFLA_BRPORT_LEARNING = 8,
	IFLA_BRPORT_UNICAST_FLOOD = 9,
	IFLA_BRPORT_PROXYARP = 10,
	IFLA_BRPORT_LEARNING_SYNC = 11,
	IFLA_BRPORT_PROXYARP_WIFI = 12,
	IFLA_BRPORT_ROOT_ID = 13,
	IFLA_BRPORT_BRIDGE_ID = 14,
	IFLA_BRPORT_DESIGNATED_PORT = 15,
	IFLA_BRPORT_DESIGNATED_COST = 16,
	IFLA_BRPORT_ID = 17,
	IFLA_BRPORT_NO = 18,
	IFLA_BRPORT_TOPOLOGY_CHANGE_ACK = 19,
	IFLA_BRPORT_CONFIG_PENDING = 20,
	IFLA_BRPORT_MESSAGE_AGE_TIMER = 21,
	IFLA_BRPORT_FORWARD_DELAY_TIMER = 22,
	IFLA_BRPORT_HOLD_TIMER = 23,
	IFLA_BRPORT_FLUSH = 24,
	IFLA_BRPORT_MULTICAST_ROUTER = 25,
	IFLA_BRPORT_PAD = 26,
	IFLA_BRPORT_MCAST_FLOOD = 27,
	IFLA_BRPORT_MCAST_TO_UCAST = 28,
	IFLA_BRPORT_VLAN_TUNNEL = 29,
	IFLA_BRPORT_BCAST_FLOOD = 30,
	IFLA_BRPORT_GROUP_FWD_MASK = 31,
	IFLA_BRPORT_NEIGH_SUPPRESS = 32,
	IFLA_BRPORT_ISOLATED = 33,
	IFLA_BRPORT_BACKUP_PORT = 34,
	IFLA_BRPORT_MRP_RING_OPEN = 35,
	IFLA_BRPORT_MRP_IN_OPEN = 36,
	__IFLA_BRPORT_MAX = 37,
};

enum {
	IFLA_INFO_UNSPEC = 0,
	IFLA_INFO_KIND = 1,
	IFLA_INFO_DATA = 2,
	IFLA_INFO_XSTATS = 3,
	IFLA_INFO_SLAVE_KIND = 4,
	IFLA_INFO_SLAVE_DATA = 5,
	__IFLA_INFO_MAX = 6,
};

enum {
	IFLA_VF_INFO_UNSPEC = 0,
	IFLA_VF_INFO = 1,
	__IFLA_VF_INFO_MAX = 2,
};

enum {
	IFLA_VF_UNSPEC = 0,
	IFLA_VF_MAC = 1,
	IFLA_VF_VLAN = 2,
	IFLA_VF_TX_RATE = 3,
	IFLA_VF_SPOOFCHK = 4,
	IFLA_VF_LINK_STATE = 5,
	IFLA_VF_RATE = 6,
	IFLA_VF_RSS_QUERY_EN = 7,
	IFLA_VF_STATS = 8,
	IFLA_VF_TRUST = 9,
	IFLA_VF_IB_NODE_GUID = 10,
	IFLA_VF_IB_PORT_GUID = 11,
	IFLA_VF_VLAN_LIST = 12,
	IFLA_VF_BROADCAST = 13,
	__IFLA_VF_MAX = 14,
};

struct ifla_vf_mac {
	__u32 vf;
	__u8 mac[32];
};

struct ifla_vf_broadcast {
	__u8 broadcast[32];
};

struct ifla_vf_vlan {
	__u32 vf;
	__u32 vlan;
	__u32 qos;
};

enum {
	IFLA_VF_VLAN_INFO_UNSPEC = 0,
	IFLA_VF_VLAN_INFO = 1,
	__IFLA_VF_VLAN_INFO_MAX = 2,
};

struct ifla_vf_vlan_info {
	__u32 vf;
	__u32 vlan;
	__u32 qos;
	__be16 vlan_proto;
};

struct ifla_vf_tx_rate {
	__u32 vf;
	__u32 rate;
};

struct ifla_vf_rate {
	__u32 vf;
	__u32 min_tx_rate;
	__u32 max_tx_rate;
};

struct ifla_vf_spoofchk {
	__u32 vf;
	__u32 setting;
};

struct ifla_vf_link_state {
	__u32 vf;
	__u32 link_state;
};

struct ifla_vf_rss_query_en {
	__u32 vf;
	__u32 setting;
};

enum {
	IFLA_VF_STATS_RX_PACKETS = 0,
	IFLA_VF_STATS_TX_PACKETS = 1,
	IFLA_VF_STATS_RX_BYTES = 2,
	IFLA_VF_STATS_TX_BYTES = 3,
	IFLA_VF_STATS_BROADCAST = 4,
	IFLA_VF_STATS_MULTICAST = 5,
	IFLA_VF_STATS_PAD = 6,
	IFLA_VF_STATS_RX_DROPPED = 7,
	IFLA_VF_STATS_TX_DROPPED = 8,
	__IFLA_VF_STATS_MAX = 9,
};

struct ifla_vf_trust {
	__u32 vf;
	__u32 setting;
};

enum {
	IFLA_VF_PORT_UNSPEC = 0,
	IFLA_VF_PORT = 1,
	__IFLA_VF_PORT_MAX = 2,
};

enum {
	IFLA_PORT_UNSPEC = 0,
	IFLA_PORT_VF = 1,
	IFLA_PORT_PROFILE = 2,
	IFLA_PORT_VSI_TYPE = 3,
	IFLA_PORT_INSTANCE_UUID = 4,
	IFLA_PORT_HOST_UUID = 5,
	IFLA_PORT_REQUEST = 6,
	IFLA_PORT_RESPONSE = 7,
	__IFLA_PORT_MAX = 8,
};

struct if_stats_msg {
	__u8 family;
	__u8 pad1;
	__u16 pad2;
	__u32 ifindex;
	__u32 filter_mask;
};

enum {
	IFLA_STATS_UNSPEC = 0,
	IFLA_STATS_LINK_64 = 1,
	IFLA_STATS_LINK_XSTATS = 2,
	IFLA_STATS_LINK_XSTATS_SLAVE = 3,
	IFLA_STATS_LINK_OFFLOAD_XSTATS = 4,
	IFLA_STATS_AF_SPEC = 5,
	__IFLA_STATS_MAX = 6,
};

enum {
	IFLA_OFFLOAD_XSTATS_UNSPEC = 0,
	IFLA_OFFLOAD_XSTATS_CPU_HIT = 1,
	__IFLA_OFFLOAD_XSTATS_MAX = 2,
};

enum {
	XDP_ATTACHED_NONE = 0,
	XDP_ATTACHED_DRV = 1,
	XDP_ATTACHED_SKB = 2,
	XDP_ATTACHED_HW = 3,
	XDP_ATTACHED_MULTI = 4,
};

enum {
	IFLA_XDP_UNSPEC = 0,
	IFLA_XDP_FD = 1,
	IFLA_XDP_ATTACHED = 2,
	IFLA_XDP_FLAGS = 3,
	IFLA_XDP_PROG_ID = 4,
	IFLA_XDP_DRV_PROG_ID = 5,
	IFLA_XDP_SKB_PROG_ID = 6,
	IFLA_XDP_HW_PROG_ID = 7,
	IFLA_XDP_EXPECTED_FD = 8,
	__IFLA_XDP_MAX = 9,
};

enum {
	IFLA_EVENT_NONE = 0,
	IFLA_EVENT_REBOOT = 1,
	IFLA_EVENT_FEATURES = 2,
	IFLA_EVENT_BONDING_FAILOVER = 3,
	IFLA_EVENT_NOTIFY_PEERS = 4,
	IFLA_EVENT_IGMP_RESEND = 5,
	IFLA_EVENT_BONDING_OPTIONS = 6,
};

enum {
	IFLA_BRIDGE_FLAGS = 0,
	IFLA_BRIDGE_MODE = 1,
	IFLA_BRIDGE_VLAN_INFO = 2,
	IFLA_BRIDGE_VLAN_TUNNEL_INFO = 3,
	IFLA_BRIDGE_MRP = 4,
	__IFLA_BRIDGE_MAX = 5,
};

enum {
	BR_MCAST_DIR_RX = 0,
	BR_MCAST_DIR_TX = 1,
	BR_MCAST_DIR_SIZE = 2,
};

enum rtattr_type_t {
	RTA_UNSPEC = 0,
	RTA_DST = 1,
	RTA_SRC = 2,
	RTA_IIF = 3,
	RTA_OIF = 4,
	RTA_GATEWAY = 5,
	RTA_PRIORITY = 6,
	RTA_PREFSRC = 7,
	RTA_METRICS = 8,
	RTA_MULTIPATH = 9,
	RTA_PROTOINFO = 10,
	RTA_FLOW = 11,
	RTA_CACHEINFO = 12,
	RTA_SESSION = 13,
	RTA_MP_ALGO = 14,
	RTA_TABLE = 15,
	RTA_MARK = 16,
	RTA_MFC_STATS = 17,
	RTA_VIA = 18,
	RTA_NEWDST = 19,
	RTA_PREF = 20,
	RTA_ENCAP_TYPE = 21,
	RTA_ENCAP = 22,
	RTA_EXPIRES = 23,
	RTA_PAD = 24,
	RTA_UID = 25,
	RTA_TTL_PROPAGATE = 26,
	RTA_IP_PROTO = 27,
	RTA_SPORT = 28,
	RTA_DPORT = 29,
	RTA_NH_ID = 30,
	__RTA_MAX = 31,
};

struct rta_cacheinfo {
	__u32 rta_clntref;
	__u32 rta_lastuse;
	__s32 rta_expires;
	__u32 rta_error;
	__u32 rta_used;
	__u32 rta_id;
	__u32 rta_ts;
	__u32 rta_tsage;
};

struct ifinfomsg {
	unsigned char ifi_family;
	unsigned char __ifi_pad;
	short unsigned int ifi_type;
	int ifi_index;
	unsigned int ifi_flags;
	unsigned int ifi_change;
};

typedef int (*rtnl_doit_func)(struct sk_buff *, struct nlmsghdr *, struct netlink_ext_ack *);

typedef int (*rtnl_dumpit_func)(struct sk_buff *, struct netlink_callback *);

struct rtnl_af_ops {
	struct list_head list;
	int family;
	int (*fill_link_af)(struct sk_buff *, const struct net_device *, u32);
	size_t (*get_link_af_size)(const struct net_device *, u32);
	int (*validate_link_af)(const struct net_device *, const struct nlattr *);
	int (*set_link_af)(struct net_device *, const struct nlattr *);
	int (*fill_stats_af)(struct sk_buff *, const struct net_device *);
	size_t (*get_stats_af_size)(const struct net_device *);
};

struct rtnl_link {
	rtnl_doit_func doit;
	rtnl_dumpit_func dumpit;
	struct module *owner;
	unsigned int flags;
	struct callback_head rcu;
};

enum {
	IF_LINK_MODE_DEFAULT = 0,
	IF_LINK_MODE_DORMANT = 1,
	IF_LINK_MODE_TESTING = 2,
};

enum lw_bits {
	LW_URGENT = 0,
};

struct seg6_pernet_data {
	struct mutex lock;
	struct in6_addr *tun_src;
};

enum {
	BPF_F_RECOMPUTE_CSUM = 1,
	BPF_F_INVALIDATE_HASH = 2,
};

enum {
	BPF_F_HDR_FIELD_MASK = 15,
};

enum {
	BPF_F_PSEUDO_HDR = 16,
	BPF_F_MARK_MANGLED_0 = 32,
	BPF_F_MARK_ENFORCE = 64,
};

enum {
	BPF_F_INGRESS = 1,
};

enum {
	BPF_F_TUNINFO_IPV6 = 1,
};

enum {
	BPF_F_ZERO_CSUM_TX = 2,
	BPF_F_DONT_FRAGMENT = 4,
	BPF_F_SEQ_NUMBER = 8,
};

enum {
	BPF_CSUM_LEVEL_QUERY = 0,
	BPF_CSUM_LEVEL_INC = 1,
	BPF_CSUM_LEVEL_DEC = 2,
	BPF_CSUM_LEVEL_RESET = 3,
};

enum {
	BPF_F_ADJ_ROOM_FIXED_GSO = 1,
	BPF_F_ADJ_ROOM_ENCAP_L3_IPV4 = 2,
	BPF_F_ADJ_ROOM_ENCAP_L3_IPV6 = 4,
	BPF_F_ADJ_ROOM_ENCAP_L4_GRE = 8,
	BPF_F_ADJ_ROOM_ENCAP_L4_UDP = 16,
	BPF_F_ADJ_ROOM_NO_CSUM_RESET = 32,
};

enum {
	BPF_ADJ_ROOM_ENCAP_L2_MASK = 255,
	BPF_ADJ_ROOM_ENCAP_L2_SHIFT = 56,
};

enum {
	BPF_SK_LOOKUP_F_REPLACE = 1,
	BPF_SK_LOOKUP_F_NO_REUSEPORT = 2,
};

enum bpf_adj_room_mode {
	BPF_ADJ_ROOM_NET = 0,
	BPF_ADJ_ROOM_MAC = 1,
};

enum bpf_hdr_start_off {
	BPF_HDR_START_MAC = 0,
	BPF_HDR_START_NET = 1,
};

struct bpf_tunnel_key {
	__u32 tunnel_id;
	union {
		__u32 remote_ipv4;
		__u32 remote_ipv6[4];
	};
	__u8 tunnel_tos;
	__u8 tunnel_ttl;
	__u16 tunnel_ext;
	__u32 tunnel_label;
};

struct bpf_tcp_sock {
	__u32 snd_cwnd;
	__u32 srtt_us;
	__u32 rtt_min;
	__u32 snd_ssthresh;
	__u32 rcv_nxt;
	__u32 snd_nxt;
	__u32 snd_una;
	__u32 mss_cache;
	__u32 ecn_flags;
	__u32 rate_delivered;
	__u32 rate_interval_us;
	__u32 packets_out;
	__u32 retrans_out;
	__u32 total_retrans;
	__u32 segs_in;
	__u32 data_segs_in;
	__u32 segs_out;
	__u32 data_segs_out;
	__u32 lost_out;
	__u32 sacked_out;
	__u64 bytes_received;
	__u64 bytes_acked;
	__u32 dsack_dups;
	__u32 delivered;
	__u32 delivered_ce;
	__u32 icsk_retransmits;
};

struct bpf_sock_tuple {
	union {
		struct {
			__be32 saddr;
			__be32 daddr;
			__be16 sport;
			__be16 dport;
		} ipv4;
		struct {
			__be32 saddr[4];
			__be32 daddr[4];
			__be16 sport;
			__be16 dport;
		} ipv6;
	};
};

struct bpf_xdp_sock {
	__u32 queue_id;
};

struct bpf_sock_addr {
	__u32 user_family;
	__u32 user_ip4;
	__u32 user_ip6[4];
	__u32 user_port;
	__u32 family;
	__u32 type;
	__u32 protocol;
	__u32 msg_src_ip4;
	__u32 msg_src_ip6[4];
	union {
		struct bpf_sock *sk;
	};
};

enum {
	BPF_SOCK_OPS_RTO_CB_FLAG = 1,
	BPF_SOCK_OPS_RETRANS_CB_FLAG = 2,
	BPF_SOCK_OPS_STATE_CB_FLAG = 4,
	BPF_SOCK_OPS_RTT_CB_FLAG = 8,
	BPF_SOCK_OPS_PARSE_ALL_HDR_OPT_CB_FLAG = 16,
	BPF_SOCK_OPS_PARSE_UNKNOWN_HDR_OPT_CB_FLAG = 32,
	BPF_SOCK_OPS_WRITE_HDR_OPT_CB_FLAG = 64,
	BPF_SOCK_OPS_ALL_CB_FLAGS = 127,
};

enum {
	BPF_SOCK_OPS_VOID = 0,
	BPF_SOCK_OPS_TIMEOUT_INIT = 1,
	BPF_SOCK_OPS_RWND_INIT = 2,
	BPF_SOCK_OPS_TCP_CONNECT_CB = 3,
	BPF_SOCK_OPS_ACTIVE_ESTABLISHED_CB = 4,
	BPF_SOCK_OPS_PASSIVE_ESTABLISHED_CB = 5,
	BPF_SOCK_OPS_NEEDS_ECN = 6,
	BPF_SOCK_OPS_BASE_RTT = 7,
	BPF_SOCK_OPS_RTO_CB = 8,
	BPF_SOCK_OPS_RETRANS_CB = 9,
	BPF_SOCK_OPS_STATE_CB = 10,
	BPF_SOCK_OPS_TCP_LISTEN_CB = 11,
	BPF_SOCK_OPS_RTT_CB = 12,
	BPF_SOCK_OPS_PARSE_HDR_OPT_CB = 13,
	BPF_SOCK_OPS_HDR_OPT_LEN_CB = 14,
	BPF_SOCK_OPS_WRITE_HDR_OPT_CB = 15,
};

enum {
	TCP_BPF_IW = 1001,
	TCP_BPF_SNDCWND_CLAMP = 1002,
	TCP_BPF_DELACK_MAX = 1003,
	TCP_BPF_RTO_MIN = 1004,
	TCP_BPF_SYN = 1005,
	TCP_BPF_SYN_IP = 1006,
	TCP_BPF_SYN_MAC = 1007,
};

enum {
	BPF_LOAD_HDR_OPT_TCP_SYN = 1,
};

enum {
	BPF_FIB_LOOKUP_DIRECT = 1,
	BPF_FIB_LOOKUP_OUTPUT = 2,
};

enum {
	BPF_FIB_LKUP_RET_SUCCESS = 0,
	BPF_FIB_LKUP_RET_BLACKHOLE = 1,
	BPF_FIB_LKUP_RET_UNREACHABLE = 2,
	BPF_FIB_LKUP_RET_PROHIBIT = 3,
	BPF_FIB_LKUP_RET_NOT_FWDED = 4,
	BPF_FIB_LKUP_RET_FWD_DISABLED = 5,
	BPF_FIB_LKUP_RET_UNSUPP_LWT = 6,
	BPF_FIB_LKUP_RET_NO_NEIGH = 7,
	BPF_FIB_LKUP_RET_FRAG_NEEDED = 8,
};

struct bpf_fib_lookup {
	__u8 family;
	__u8 l4_protocol;
	__be16 sport;
	__be16 dport;
	__u16 tot_len;
	__u32 ifindex;
	union {
		__u8 tos;
		__be32 flowinfo;
		__u32 rt_metric;
	};
	union {
		__be32 ipv4_src;
		__u32 ipv6_src[4];
	};
	union {
		__be32 ipv4_dst;
		__u32 ipv6_dst[4];
	};
	__be16 h_vlan_proto;
	__be16 h_vlan_TCI;
	__u8 smac[6];
	__u8 dmac[6];
};

struct bpf_redir_neigh {
	__u32 nh_family;
	union {
		__be32 ipv4_nh;
		__u32 ipv6_nh[4];
	};
};

enum rt_scope_t {
	RT_SCOPE_UNIVERSE = 0,
	RT_SCOPE_SITE = 200,
	RT_SCOPE_LINK = 253,
	RT_SCOPE_HOST = 254,
	RT_SCOPE_NOWHERE = 255,
};

enum rt_class_t {
	RT_TABLE_UNSPEC = 0,
	RT_TABLE_COMPAT = 252,
	RT_TABLE_DEFAULT = 253,
	RT_TABLE_MAIN = 254,
	RT_TABLE_LOCAL = 255,
	RT_TABLE_MAX = 4294967295,
};

struct nl_info {
	struct nlmsghdr *nlh;
	struct net *nl_net;
	u32 portid;
	u8 skip_notify: 1;
	u8 skip_notify_kernel: 1;
};

struct compat_sock_fprog {
	u16 len;
	compat_uptr_t filter;
};

struct bpf_skb_data_end {
	struct qdisc_skb_cb qdisc_cb;
	void *data_meta;
	void *data_end;
};

typedef int (*bpf_aux_classic_check_t)(struct sock_filter *, unsigned int);

struct bpf_sock_addr_kern {
	struct sock *sk;
	struct sockaddr *uaddr;
	u64 tmp_reg;
	void *t_ctx;
};

struct inet_timewait_sock {
	struct sock_common __tw_common;
	__u32 tw_mark;
	volatile unsigned char tw_substate;
	unsigned char tw_rcv_wscale;
	__be16 tw_sport;
	unsigned int tw_kill: 1;
	unsigned int tw_transparent: 1;
	unsigned int tw_flowlabel: 20;
	unsigned int tw_pad: 2;
	unsigned int tw_tos: 8;
	u32 tw_txhash;
	u32 tw_priority;
	struct timer_list tw_timer;
	struct inet_bind_bucket *tw_tb;
};

struct tcp_timewait_sock {
	struct inet_timewait_sock tw_sk;
	u32 tw_rcv_wnd;
	u32 tw_ts_offset;
	u32 tw_ts_recent;
	u32 tw_last_oow_ack_time;
	int tw_ts_recent_stamp;
	u32 tw_tx_delay;
};

struct udp_sock {
	struct inet_sock inet;
	int pending;
	unsigned int corkflag;
	__u8 encap_type;
	unsigned char no_check6_tx: 1;
	unsigned char no_check6_rx: 1;
	unsigned char encap_enabled: 1;
	unsigned char gro_enabled: 1;
	unsigned char accept_udp_l4: 1;
	unsigned char accept_udp_fraglist: 1;
	__u16 len;
	__u16 gso_size;
	__u16 pcslen;
	__u16 pcrlen;
	__u8 pcflag;
	__u8 unused[3];
	int (*encap_rcv)(struct sock *, struct sk_buff *);
	int (*encap_err_lookup)(struct sock *, struct sk_buff *);
	void (*encap_destroy)(struct sock *);
	struct sk_buff * (*gro_receive)(struct sock *, struct list_head *, struct sk_buff *);
	int (*gro_complete)(struct sock *, struct sk_buff *, int);
	long: 64;
	long: 64;
	long: 64;
	struct sk_buff_head reader_queue;
	int forward_deficit;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct udp6_sock {
	struct udp_sock udp;
	struct ipv6_pinfo inet6;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct tcp6_sock {
	struct tcp_sock tcp;
	struct ipv6_pinfo inet6;
};

struct fib6_result;

struct fib6_config;

struct ipv6_stub {
	int (*ipv6_sock_mc_join)(struct sock *, int, const struct in6_addr *);
	int (*ipv6_sock_mc_drop)(struct sock *, int, const struct in6_addr *);
	struct dst_entry * (*ipv6_dst_lookup_flow)(struct net *, const struct sock *, struct flowi6 *, const struct in6_addr *);
	int (*ipv6_route_input)(struct sk_buff *);
	struct fib6_table * (*fib6_get_table)(struct net *, u32);
	int (*fib6_lookup)(struct net *, int, struct flowi6 *, struct fib6_result *, int);
	int (*fib6_table_lookup)(struct net *, struct fib6_table *, int, struct flowi6 *, struct fib6_result *, int);
	void (*fib6_select_path)(const struct net *, struct fib6_result *, struct flowi6 *, int, bool, const struct sk_buff *, int);
	u32 (*ip6_mtu_from_fib6)(const struct fib6_result *, const struct in6_addr *, const struct in6_addr *);
	int (*fib6_nh_init)(struct net *, struct fib6_nh *, struct fib6_config *, gfp_t, struct netlink_ext_ack *);
	void (*fib6_nh_release)(struct fib6_nh *);
	void (*fib6_update_sernum)(struct net *, struct fib6_info *);
	int (*ip6_del_rt)(struct net *, struct fib6_info *, bool);
	void (*fib6_rt_update)(struct net *, struct fib6_info *, struct nl_info *);
	void (*udpv6_encap_enable)();
	void (*ndisc_send_na)(struct net_device *, const struct in6_addr *, const struct in6_addr *, bool, bool, bool, bool);
	struct neigh_table *nd_tbl;
	int (*ipv6_fragment)(struct net *, struct sock *, struct sk_buff *, int (*)(struct net *, struct sock *, struct sk_buff *));
};

struct fib6_result {
	struct fib6_nh *nh;
	struct fib6_info *f6i;
	u32 fib6_flags;
	u8 fib6_type;
	struct rt6_info *rt6;
};

struct fib6_config {
	u32 fc_table;
	u32 fc_metric;
	int fc_dst_len;
	int fc_src_len;
	int fc_ifindex;
	u32 fc_flags;
	u32 fc_protocol;
	u16 fc_type;
	u16 fc_delete_all_nh: 1;
	u16 fc_ignore_dev_down: 1;
	u16 __unused: 14;
	u32 fc_nh_id;
	struct in6_addr fc_dst;
	struct in6_addr fc_src;
	struct in6_addr fc_prefsrc;
	struct in6_addr fc_gateway;
	long unsigned int fc_expires;
	struct nlattr *fc_mx;
	int fc_mx_len;
	int fc_mp_len;
	struct nlattr *fc_mp;
	struct nl_info fc_nlinfo;
	struct nlattr *fc_encap;
	u16 fc_encap_type;
	bool fc_is_fdb;
};

struct ipv6_bpf_stub {
	int (*inet6_bind)(struct sock *, struct sockaddr *, int, u32);
	struct sock * (*udp6_lib_lookup)(struct net *, const struct in6_addr *, __be16, const struct in6_addr *, __be16, int, int, struct udp_table *, struct sk_buff *);
};

struct fib_table;

struct fib_result {
	__be32 prefix;
	unsigned char prefixlen;
	unsigned char nh_sel;
	unsigned char type;
	unsigned char scope;
	u32 tclassid;
	struct fib_nh_common *nhc;
	struct fib_info *fi;
	struct fib_table *table;
	struct hlist_head *fa_head;
};

struct fib_table {
	struct hlist_node tb_hlist;
	u32 tb_id;
	int tb_num_default;
	struct callback_head rcu;
	long unsigned int *tb_data;
	long unsigned int __data[0];
};

enum {
	INET_ECN_NOT_ECT = 0,
	INET_ECN_ECT_1 = 1,
	INET_ECN_ECT_0 = 2,
	INET_ECN_CE = 3,
	INET_ECN_MASK = 3,
};

struct tcp_skb_cb {
	__u32 seq;
	__u32 end_seq;
	union {
		__u32 tcp_tw_isn;
		struct {
			u16 tcp_gso_segs;
			u16 tcp_gso_size;
		};
	};
	__u8 tcp_flags;
	__u8 sacked;
	__u8 ip_dsfield;
	__u8 txstamp_ack: 1;
	__u8 eor: 1;
	__u8 has_rxtstamp: 1;
	__u8 unused: 5;
	__u32 ack_seq;
	union {
		struct {
			__u32 in_flight: 30;
			__u32 is_app_limited: 1;
			__u32 unused: 1;
			__u32 delivered;
			u64 first_tx_mstamp;
			u64 delivered_mstamp;
		} tx;
		union {
			struct inet_skb_parm h4;
			struct inet6_skb_parm h6;
		} header;
		struct {
			__u32 flags;
			struct sock *sk_redir;
			void *data_end;
		} bpf;
	};
};

struct strp_stats {
	long long unsigned int msgs;
	long long unsigned int bytes;
	unsigned int mem_fail;
	unsigned int need_more_hdr;
	unsigned int msg_too_big;
	unsigned int msg_timeouts;
	unsigned int bad_hdr_len;
};

struct strparser;

struct strp_callbacks {
	int (*parse_msg)(struct strparser *, struct sk_buff *);
	void (*rcv_msg)(struct strparser *, struct sk_buff *);
	int (*read_sock_done)(struct strparser *, int);
	void (*abort_parser)(struct strparser *, int);
	void (*lock)(struct strparser *);
	void (*unlock)(struct strparser *);
};

struct strparser {
	struct sock *sk;
	u32 stopped: 1;
	u32 paused: 1;
	u32 aborted: 1;
	u32 interrupted: 1;
	u32 unrecov_intr: 1;
	struct sk_buff **skb_nextp;
	struct sk_buff *skb_head;
	unsigned int need_bytes;
	struct delayed_work msg_timer_work;
	struct work_struct work;
	struct strp_stats stats;
	struct strp_callbacks cb;
};

struct strp_msg {
	int full_len;
	int offset;
};

struct _strp_msg {
	struct strp_msg strp;
	int accum_len;
};

struct sk_skb_cb {
	unsigned char data[20];
	struct _strp_msg strp;
};

struct xdp_umem {
	void *addrs;
	u64 size;
	u32 headroom;
	u32 chunk_size;
	u32 chunks;
	u32 npgs;
	struct user_struct *user;
	refcount_t users;
	u8 flags;
	bool zc;
	struct page **pgs;
	int id;
	struct list_head xsk_dma_list;
	struct work_struct work;
};

struct xsk_queue;

struct xdp_sock {
	struct sock sk;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct xsk_queue *rx;
	struct net_device *dev;
	struct xdp_umem *umem;
	struct list_head flush_node;
	struct xsk_buff_pool *pool;
	u16 queue_id;
	bool zc;
	enum {
		XSK_READY = 0,
		XSK_BOUND = 1,
		XSK_UNBOUND = 2,
	} state;
	long: 64;
	struct xsk_queue *tx;
	struct list_head tx_list;
	spinlock_t rx_lock;
	u64 rx_dropped;
	u64 rx_queue_full;
	struct list_head map_list;
	spinlock_t map_list_lock;
	struct mutex mutex;
	struct xsk_queue *fq_tmp;
	struct xsk_queue *cq_tmp;
	long: 64;
};

struct tls_crypto_info {
	__u16 version;
	__u16 cipher_type;
};

struct tls12_crypto_info_aes_gcm_128 {
	struct tls_crypto_info info;
	unsigned char iv[8];
	unsigned char key[16];
	unsigned char salt[4];
	unsigned char rec_seq[8];
};

struct tls12_crypto_info_aes_gcm_256 {
	struct tls_crypto_info info;
	unsigned char iv[8];
	unsigned char key[32];
	unsigned char salt[4];
	unsigned char rec_seq[8];
};

struct tls_sw_context_rx {
	struct crypto_aead *aead_recv;
	struct crypto_wait async_wait;
	struct strparser strp;
	struct sk_buff_head rx_list;
	void (*saved_data_ready)(struct sock *);
	struct sk_buff *recv_pkt;
	u8 control;
	u8 async_capable: 1;
	u8 decrypted: 1;
	atomic_t decrypt_pending;
	spinlock_t decrypt_compl_lock;
	bool async_notify;
};

struct cipher_context {
	char *iv;
	char *rec_seq;
};

union tls_crypto_context {
	struct tls_crypto_info info;
	union {
		struct tls12_crypto_info_aes_gcm_128 aes_gcm_128;
		struct tls12_crypto_info_aes_gcm_256 aes_gcm_256;
	};
};

struct tls_prot_info {
	u16 version;
	u16 cipher_type;
	u16 prepend_size;
	u16 tag_size;
	u16 overhead_size;
	u16 iv_size;
	u16 salt_size;
	u16 rec_seq_size;
	u16 aad_size;
	u16 tail_size;
};

struct tls_context {
	struct tls_prot_info prot_info;
	u8 tx_conf: 3;
	u8 rx_conf: 3;
	int (*push_pending_record)(struct sock *, int);
	void (*sk_write_space)(struct sock *);
	void *priv_ctx_tx;
	void *priv_ctx_rx;
	struct net_device *netdev;
	struct cipher_context tx;
	struct cipher_context rx;
	struct scatterlist *partially_sent_record;
	u16 partially_sent_offset;
	bool in_tcp_sendpages;
	bool pending_open_record_frags;
	struct mutex tx_lock;
	long unsigned int flags;
	struct proto *sk_proto;
	struct sock *sk;
	void (*sk_destruct)(struct sock *);
	union tls_crypto_context crypto_send;
	union tls_crypto_context crypto_recv;
	struct list_head list;
	refcount_t refcount;
	struct callback_head rcu;
};

typedef u64 (*btf_bpf_skb_get_pay_offset)(struct sk_buff *);

typedef u64 (*btf_bpf_skb_get_nlattr)(struct sk_buff *, u32, u32);

typedef u64 (*btf_bpf_skb_get_nlattr_nest)(struct sk_buff *, u32, u32);

typedef u64 (*btf_bpf_skb_load_helper_8)(const struct sk_buff *, const void *, int, int);

typedef u64 (*btf_bpf_skb_load_helper_8_no_cache)(const struct sk_buff *, int);

typedef u64 (*btf_bpf_skb_load_helper_16)(const struct sk_buff *, const void *, int, int);

typedef u64 (*btf_bpf_skb_load_helper_16_no_cache)(const struct sk_buff *, int);

typedef u64 (*btf_bpf_skb_load_helper_32)(const struct sk_buff *, const void *, int, int);

typedef u64 (*btf_bpf_skb_load_helper_32_no_cache)(const struct sk_buff *, int);

struct bpf_scratchpad {
	union {
		__be32 diff[128];
		u8 buff[512];
	};
};

typedef u64 (*btf_bpf_skb_store_bytes)(struct sk_buff *, u32, const void *, u32, u64);

typedef u64 (*btf_bpf_skb_load_bytes)(const struct sk_buff *, u32, void *, u32);

typedef u64 (*btf_bpf_flow_dissector_load_bytes)(const struct bpf_flow_dissector *, u32, void *, u32);

typedef u64 (*btf_bpf_skb_load_bytes_relative)(const struct sk_buff *, u32, void *, u32, u32);

typedef u64 (*btf_bpf_skb_pull_data)(struct sk_buff *, u32);

typedef u64 (*btf_bpf_sk_fullsock)(struct sock *);

typedef u64 (*btf_sk_skb_pull_data)(struct sk_buff *, u32);

typedef u64 (*btf_bpf_l3_csum_replace)(struct sk_buff *, u32, u64, u64, u64);

typedef u64 (*btf_bpf_l4_csum_replace)(struct sk_buff *, u32, u64, u64, u64);

typedef u64 (*btf_bpf_csum_diff)(__be32 *, u32, __be32 *, u32, __wsum);

typedef u64 (*btf_bpf_csum_update)(struct sk_buff *, __wsum);

typedef u64 (*btf_bpf_csum_level)(struct sk_buff *, u64);

enum {
	BPF_F_NEIGH = 2,
	BPF_F_PEER = 4,
	BPF_F_NEXTHOP = 8,
};

typedef u64 (*btf_bpf_clone_redirect)(struct sk_buff *, u32, u64);

typedef u64 (*btf_bpf_redirect)(u32, u64);

typedef u64 (*btf_bpf_redirect_peer)(u32, u64);

typedef u64 (*btf_bpf_redirect_neigh)(u32, struct bpf_redir_neigh *, int, u64);

typedef u64 (*btf_bpf_msg_apply_bytes)(struct sk_msg *, u32);

typedef u64 (*btf_bpf_msg_cork_bytes)(struct sk_msg *, u32);

typedef u64 (*btf_bpf_msg_pull_data)(struct sk_msg *, u32, u32, u64);

typedef u64 (*btf_bpf_msg_push_data)(struct sk_msg *, u32, u32, u64);

typedef u64 (*btf_bpf_msg_pop_data)(struct sk_msg *, u32, u32, u64);

typedef u64 (*btf_bpf_get_cgroup_classid)(const struct sk_buff *);

typedef u64 (*btf_bpf_get_route_realm)(const struct sk_buff *);

typedef u64 (*btf_bpf_get_hash_recalc)(struct sk_buff *);

typedef u64 (*btf_bpf_set_hash_invalid)(struct sk_buff *);

typedef u64 (*btf_bpf_set_hash)(struct sk_buff *, u32);

typedef u64 (*btf_bpf_skb_vlan_push)(struct sk_buff *, __be16, u16);

typedef u64 (*btf_bpf_skb_vlan_pop)(struct sk_buff *);

typedef u64 (*btf_bpf_skb_change_proto)(struct sk_buff *, __be16, u64);

typedef u64 (*btf_bpf_skb_change_type)(struct sk_buff *, u32);

typedef u64 (*btf_sk_skb_adjust_room)(struct sk_buff *, s32, u32, u64);

typedef u64 (*btf_bpf_skb_adjust_room)(struct sk_buff *, s32, u32, u64);

typedef u64 (*btf_bpf_skb_change_tail)(struct sk_buff *, u32, u64);

typedef u64 (*btf_sk_skb_change_tail)(struct sk_buff *, u32, u64);

typedef u64 (*btf_bpf_skb_change_head)(struct sk_buff *, u32, u64);

typedef u64 (*btf_sk_skb_change_head)(struct sk_buff *, u32, u64);

typedef u64 (*btf_bpf_xdp_adjust_head)(struct xdp_buff *, int);

typedef u64 (*btf_bpf_xdp_adjust_tail)(struct xdp_buff *, int);

typedef u64 (*btf_bpf_xdp_adjust_meta)(struct xdp_buff *, int);

typedef u64 (*btf_bpf_xdp_redirect)(u32, u64);

typedef u64 (*btf_bpf_xdp_redirect_map)(struct bpf_map *, u32, u64);

typedef u64 (*btf_bpf_skb_event_output)(struct sk_buff *, struct bpf_map *, u64, void *, u64);

typedef u64 (*btf_bpf_skb_get_tunnel_key)(struct sk_buff *, struct bpf_tunnel_key *, u32, u64);

typedef u64 (*btf_bpf_skb_get_tunnel_opt)(struct sk_buff *, u8 *, u32);

typedef u64 (*btf_bpf_skb_set_tunnel_key)(struct sk_buff *, const struct bpf_tunnel_key *, u32, u64);

typedef u64 (*btf_bpf_skb_set_tunnel_opt)(struct sk_buff *, const u8 *, u32);

typedef u64 (*btf_bpf_skb_under_cgroup)(struct sk_buff *, struct bpf_map *, u32);

typedef u64 (*btf_bpf_xdp_event_output)(struct xdp_buff *, struct bpf_map *, u64, void *, u64);

typedef u64 (*btf_bpf_get_socket_cookie)(struct sk_buff *);

typedef u64 (*btf_bpf_get_socket_cookie_sock_addr)(struct bpf_sock_addr_kern *);

typedef u64 (*btf_bpf_get_socket_cookie_sock)(struct sock *);

typedef u64 (*btf_bpf_get_socket_cookie_sock_ops)(struct bpf_sock_ops_kern *);

typedef u64 (*btf_bpf_get_netns_cookie_sock)(struct sock *);

typedef u64 (*btf_bpf_get_netns_cookie_sock_addr)(struct bpf_sock_addr_kern *);

typedef u64 (*btf_bpf_get_socket_uid)(struct sk_buff *);

typedef u64 (*btf_bpf_sock_addr_setsockopt)(struct bpf_sock_addr_kern *, int, int, char *, int);

typedef u64 (*btf_bpf_sock_addr_getsockopt)(struct bpf_sock_addr_kern *, int, int, char *, int);

typedef u64 (*btf_bpf_sock_ops_setsockopt)(struct bpf_sock_ops_kern *, int, int, char *, int);

typedef u64 (*btf_bpf_sock_ops_getsockopt)(struct bpf_sock_ops_kern *, int, int, char *, int);

typedef u64 (*btf_bpf_sock_ops_cb_flags_set)(struct bpf_sock_ops_kern *, int);

typedef u64 (*btf_bpf_bind)(struct bpf_sock_addr_kern *, struct sockaddr *, int);

typedef u64 (*btf_bpf_xdp_fib_lookup)(struct xdp_buff *, struct bpf_fib_lookup *, int, u32);

typedef u64 (*btf_bpf_skb_fib_lookup)(struct sk_buff *, struct bpf_fib_lookup *, int, u32);

typedef u64 (*btf_bpf_lwt_in_push_encap)(struct sk_buff *, u32, void *, u32);

typedef u64 (*btf_bpf_lwt_xmit_push_encap)(struct sk_buff *, u32, void *, u32);

typedef u64 (*btf_bpf_skc_lookup_tcp)(struct sk_buff *, struct bpf_sock_tuple *, u32, u64, u64);

typedef u64 (*btf_bpf_sk_lookup_tcp)(struct sk_buff *, struct bpf_sock_tuple *, u32, u64, u64);

typedef u64 (*btf_bpf_sk_lookup_udp)(struct sk_buff *, struct bpf_sock_tuple *, u32, u64, u64);

typedef u64 (*btf_bpf_sk_release)(struct sock *);

typedef u64 (*btf_bpf_xdp_sk_lookup_udp)(struct xdp_buff *, struct bpf_sock_tuple *, u32, u32, u64);

typedef u64 (*btf_bpf_xdp_skc_lookup_tcp)(struct xdp_buff *, struct bpf_sock_tuple *, u32, u32, u64);

typedef u64 (*btf_bpf_xdp_sk_lookup_tcp)(struct xdp_buff *, struct bpf_sock_tuple *, u32, u32, u64);

typedef u64 (*btf_bpf_sock_addr_skc_lookup_tcp)(struct bpf_sock_addr_kern *, struct bpf_sock_tuple *, u32, u64, u64);

typedef u64 (*btf_bpf_sock_addr_sk_lookup_tcp)(struct bpf_sock_addr_kern *, struct bpf_sock_tuple *, u32, u64, u64);

typedef u64 (*btf_bpf_sock_addr_sk_lookup_udp)(struct bpf_sock_addr_kern *, struct bpf_sock_tuple *, u32, u64, u64);

typedef u64 (*btf_bpf_tcp_sock)(struct sock *);

typedef u64 (*btf_bpf_get_listener_sock)(struct sock *);

typedef u64 (*btf_bpf_skb_ecn_set_ce)(struct sk_buff *);

typedef u64 (*btf_bpf_tcp_check_syncookie)(struct sock *, void *, u32, struct tcphdr *, u32);

typedef u64 (*btf_bpf_tcp_gen_syncookie)(struct sock *, void *, u32, struct tcphdr *, u32);

typedef u64 (*btf_bpf_sk_assign)(struct sk_buff *, struct sock *, u64);

typedef u64 (*btf_bpf_sock_ops_load_hdr_opt)(struct bpf_sock_ops_kern *, void *, u32, u64);

typedef u64 (*btf_bpf_sock_ops_store_hdr_opt)(struct bpf_sock_ops_kern *, const void *, u32, u64);

typedef u64 (*btf_bpf_sock_ops_reserve_hdr_opt)(struct bpf_sock_ops_kern *, u32, u64);

typedef u64 (*btf_sk_select_reuseport)(struct sk_reuseport_kern *, struct bpf_map *, void *, u32);

typedef u64 (*btf_sk_reuseport_load_bytes)(const struct sk_reuseport_kern *, u32, void *, u32);

typedef u64 (*btf_sk_reuseport_load_bytes_relative)(const struct sk_reuseport_kern *, u32, void *, u32, u32);

typedef u64 (*btf_bpf_sk_lookup_assign)(struct bpf_sk_lookup_kern *, struct sock *, u64);

typedef u64 (*btf_bpf_skc_to_tcp6_sock)(struct sock *);

typedef u64 (*btf_bpf_skc_to_tcp_sock)(struct sock *);

typedef u64 (*btf_bpf_skc_to_tcp_timewait_sock)(struct sock *);

typedef u64 (*btf_bpf_skc_to_tcp_request_sock)(struct sock *);

typedef u64 (*btf_bpf_skc_to_udp6_sock)(struct sock *);

struct bpf_dtab_netdev;

enum {
	INET_DIAG_REQ_NONE = 0,
	INET_DIAG_REQ_BYTECODE = 1,
	INET_DIAG_REQ_SK_BPF_STORAGES = 2,
	INET_DIAG_REQ_PROTOCOL = 3,
	__INET_DIAG_REQ_MAX = 4,
};

struct sock_diag_req {
	__u8 sdiag_family;
	__u8 sdiag_protocol;
};

struct sock_diag_handler {
	__u8 family;
	int (*dump)(struct sk_buff *, struct nlmsghdr *);
	int (*get_info)(struct sk_buff *, struct sock *);
	int (*destroy)(struct sk_buff *, struct nlmsghdr *);
};

struct broadcast_sk {
	struct sock *sk;
	struct work_struct work;
};

typedef int gifconf_func_t(struct net_device *, char *, int, int);

struct tso_t {
	int next_frag_idx;
	int size;
	void *data;
	u16 ip_id;
	u8 tlen;
	bool ipv6;
	u32 tcp_seq;
};

struct fib_notifier_info {
	int family;
	struct netlink_ext_ack *extack;
};

enum fib_event_type {
	FIB_EVENT_ENTRY_REPLACE = 0,
	FIB_EVENT_ENTRY_APPEND = 1,
	FIB_EVENT_ENTRY_ADD = 2,
	FIB_EVENT_ENTRY_DEL = 3,
	FIB_EVENT_RULE_ADD = 4,
	FIB_EVENT_RULE_DEL = 5,
	FIB_EVENT_NH_ADD = 6,
	FIB_EVENT_NH_DEL = 7,
	FIB_EVENT_VIF_ADD = 8,
	FIB_EVENT_VIF_DEL = 9,
};

struct fib_notifier_net {
	struct list_head fib_notifier_ops;
	struct atomic_notifier_head fib_chain;
};

struct xdp_attachment_info {
	struct bpf_prog *prog;
	u32 flags;
};

struct xdp_buff_xsk;

struct xsk_buff_pool {
	struct device *dev;
	struct net_device *netdev;
	struct list_head xsk_tx_list;
	spinlock_t xsk_tx_list_lock;
	refcount_t users;
	struct xdp_umem *umem;
	struct work_struct work;
	struct list_head free_list;
	u32 heads_cnt;
	u16 queue_id;
	long: 16;
	long: 64;
	long: 64;
	long: 64;
	struct xsk_queue *fq;
	struct xsk_queue *cq;
	dma_addr_t *dma_pages;
	struct xdp_buff_xsk *heads;
	u64 chunk_mask;
	u64 addrs_cnt;
	u32 free_list_cnt;
	u32 dma_pages_cnt;
	u32 free_heads_cnt;
	u32 headroom;
	u32 chunk_size;
	u32 frame_len;
	u8 cached_need_wakeup;
	bool uses_need_wakeup;
	bool dma_need_sync;
	bool unaligned;
	void *addrs;
	spinlock_t cq_lock;
	struct xdp_buff_xsk *free_heads[0];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct xdp_buff_xsk {
	struct xdp_buff xdp;
	dma_addr_t dma;
	dma_addr_t frame_dma;
	struct xsk_buff_pool *pool;
	bool unaligned;
	u64 orig_addr;
	struct list_head free_list_node;
};

struct flow_dissector_key_ct {
	u16 ct_state;
	u16 ct_zone;
	u32 ct_mark;
	u32 ct_labels[4];
};

struct flow_match_meta {
	struct flow_dissector_key_meta *key;
	struct flow_dissector_key_meta *mask;
};

struct flow_match_control {
	struct flow_dissector_key_control *key;
	struct flow_dissector_key_control *mask;
};

struct flow_match_eth_addrs {
	struct flow_dissector_key_eth_addrs *key;
	struct flow_dissector_key_eth_addrs *mask;
};

struct flow_match_vlan {
	struct flow_dissector_key_vlan *key;
	struct flow_dissector_key_vlan *mask;
};

struct flow_match_ipv6_addrs {
	struct flow_dissector_key_ipv6_addrs *key;
	struct flow_dissector_key_ipv6_addrs *mask;
};

struct flow_match_ip {
	struct flow_dissector_key_ip *key;
	struct flow_dissector_key_ip *mask;
};

struct flow_match_icmp {
	struct flow_dissector_key_icmp *key;
	struct flow_dissector_key_icmp *mask;
};

struct flow_match_tcp {
	struct flow_dissector_key_tcp *key;
	struct flow_dissector_key_tcp *mask;
};

struct flow_match_mpls {
	struct flow_dissector_key_mpls *key;
	struct flow_dissector_key_mpls *mask;
};

struct flow_match_enc_keyid {
	struct flow_dissector_key_keyid *key;
	struct flow_dissector_key_keyid *mask;
};

struct flow_match_enc_opts {
	struct flow_dissector_key_enc_opts *key;
	struct flow_dissector_key_enc_opts *mask;
};

struct flow_match_ct {
	struct flow_dissector_key_ct *key;
	struct flow_dissector_key_ct *mask;
};

enum flow_block_command {
	FLOW_BLOCK_BIND = 0,
	FLOW_BLOCK_UNBIND = 1,
};

enum flow_block_binder_type {
	FLOW_BLOCK_BINDER_TYPE_UNSPEC = 0,
	FLOW_BLOCK_BINDER_TYPE_CLSACT_INGRESS = 1,
	FLOW_BLOCK_BINDER_TYPE_CLSACT_EGRESS = 2,
	FLOW_BLOCK_BINDER_TYPE_RED_EARLY_DROP = 3,
	FLOW_BLOCK_BINDER_TYPE_RED_MARK = 4,
};

struct flow_block_offload {
	enum flow_block_command command;
	enum flow_block_binder_type binder_type;
	bool block_shared;
	bool unlocked_driver_cb;
	struct net *net;
	struct flow_block *block;
	struct list_head cb_list;
	struct list_head *driver_block_list;
	struct netlink_ext_ack *extack;
	struct Qdisc *sch;
	struct list_head *cb_list_head;
};

struct flow_block_cb;

struct flow_block_indr {
	struct list_head list;
	struct net_device *dev;
	struct Qdisc *sch;
	enum flow_block_binder_type binder_type;
	void *data;
	void *cb_priv;
	void (*cleanup)(struct flow_block_cb *);
};

struct flow_block_cb {
	struct list_head driver_list;
	struct list_head list;
	flow_setup_cb_t *cb;
	void *cb_ident;
	void *cb_priv;
	void (*release)(void *);
	struct flow_block_indr indr;
	unsigned int refcnt;
};

typedef int flow_indr_block_bind_cb_t(struct net_device *, struct Qdisc *, void *, enum tc_setup_type, void *, void *, void (*)(struct flow_block_cb *));

struct flow_indr_dev {
	struct list_head list;
	flow_indr_block_bind_cb_t *cb;
	void *cb_priv;
	refcount_t refcnt;
	struct callback_head rcu;
};

struct flow_indir_dev_info {
	void *data;
	struct net_device *dev;
	struct Qdisc *sch;
	enum tc_setup_type type;
	void (*cleanup)(struct flow_block_cb *);
	struct list_head list;
	enum flow_block_command command;
	enum flow_block_binder_type binder_type;
	struct list_head *cb_list;
};

struct netdev_queue_attribute {
	struct attribute attr;
	ssize_t (*show)(struct netdev_queue *, char *);
	ssize_t (*store)(struct netdev_queue *, const char *, size_t);
};

struct trace_event_raw_kfree_skb {
	struct trace_entry ent;
	void *skbaddr;
	void *location;
	short unsigned int protocol;
	char __data[0];
};

struct trace_event_raw_consume_skb {
	struct trace_entry ent;
	void *skbaddr;
	char __data[0];
};

struct trace_event_raw_skb_copy_datagram_iovec {
	struct trace_entry ent;
	const void *skbaddr;
	int len;
	char __data[0];
};

struct trace_event_data_offsets_kfree_skb {};

struct trace_event_data_offsets_consume_skb {};

struct trace_event_data_offsets_skb_copy_datagram_iovec {};

typedef void (*btf_trace_kfree_skb)(void *, struct sk_buff *, void *);

typedef void (*btf_trace_consume_skb)(void *, struct sk_buff *);

typedef void (*btf_trace_skb_copy_datagram_iovec)(void *, const struct sk_buff *, int);

struct trace_event_raw_net_dev_start_xmit {
	struct trace_entry ent;
	u32 __data_loc_name;
	u16 queue_mapping;
	const void *skbaddr;
	bool vlan_tagged;
	u16 vlan_proto;
	u16 vlan_tci;
	u16 protocol;
	u8 ip_summed;
	unsigned int len;
	unsigned int data_len;
	int network_offset;
	bool transport_offset_valid;
	int transport_offset;
	u8 tx_flags;
	u16 gso_size;
	u16 gso_segs;
	u16 gso_type;
	char __data[0];
};

struct trace_event_raw_net_dev_xmit {
	struct trace_entry ent;
	void *skbaddr;
	unsigned int len;
	int rc;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_net_dev_xmit_timeout {
	struct trace_entry ent;
	u32 __data_loc_name;
	u32 __data_loc_driver;
	int queue_index;
	char __data[0];
};

struct trace_event_raw_net_dev_template {
	struct trace_entry ent;
	void *skbaddr;
	unsigned int len;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_net_dev_rx_verbose_template {
	struct trace_entry ent;
	u32 __data_loc_name;
	unsigned int napi_id;
	u16 queue_mapping;
	const void *skbaddr;
	bool vlan_tagged;
	u16 vlan_proto;
	u16 vlan_tci;
	u16 protocol;
	u8 ip_summed;
	u32 hash;
	bool l4_hash;
	unsigned int len;
	unsigned int data_len;
	unsigned int truesize;
	bool mac_header_valid;
	int mac_header;
	unsigned char nr_frags;
	u16 gso_size;
	u16 gso_type;
	char __data[0];
};

struct trace_event_raw_net_dev_rx_exit_template {
	struct trace_entry ent;
	int ret;
	char __data[0];
};

struct trace_event_data_offsets_net_dev_start_xmit {
	u32 name;
};

struct trace_event_data_offsets_net_dev_xmit {
	u32 name;
};

struct trace_event_data_offsets_net_dev_xmit_timeout {
	u32 name;
	u32 driver;
};

struct trace_event_data_offsets_net_dev_template {
	u32 name;
};

struct trace_event_data_offsets_net_dev_rx_verbose_template {
	u32 name;
};

struct trace_event_data_offsets_net_dev_rx_exit_template {};

typedef void (*btf_trace_net_dev_start_xmit)(void *, const struct sk_buff *, const struct net_device *);

typedef void (*btf_trace_net_dev_xmit)(void *, struct sk_buff *, int, struct net_device *, unsigned int);

typedef void (*btf_trace_net_dev_xmit_timeout)(void *, struct net_device *, int);

typedef void (*btf_trace_net_dev_queue)(void *, struct sk_buff *);

typedef void (*btf_trace_netif_receive_skb)(void *, struct sk_buff *);

typedef void (*btf_trace_netif_rx)(void *, struct sk_buff *);

typedef void (*btf_trace_napi_gro_frags_entry)(void *, const struct sk_buff *);

typedef void (*btf_trace_napi_gro_receive_entry)(void *, const struct sk_buff *);

typedef void (*btf_trace_netif_receive_skb_entry)(void *, const struct sk_buff *);

typedef void (*btf_trace_netif_receive_skb_list_entry)(void *, const struct sk_buff *);

typedef void (*btf_trace_netif_rx_entry)(void *, const struct sk_buff *);

typedef void (*btf_trace_netif_rx_ni_entry)(void *, const struct sk_buff *);

typedef void (*btf_trace_napi_gro_frags_exit)(void *, int);

typedef void (*btf_trace_napi_gro_receive_exit)(void *, int);

typedef void (*btf_trace_netif_receive_skb_exit)(void *, int);

typedef void (*btf_trace_netif_rx_exit)(void *, int);

typedef void (*btf_trace_netif_rx_ni_exit)(void *, int);

typedef void (*btf_trace_netif_receive_skb_list_exit)(void *, int);

struct trace_event_raw_napi_poll {
	struct trace_entry ent;
	struct napi_struct *napi;
	u32 __data_loc_dev_name;
	int work;
	int budget;
	char __data[0];
};

struct trace_event_data_offsets_napi_poll {
	u32 dev_name;
};

typedef void (*btf_trace_napi_poll)(void *, struct napi_struct *, int, int);

enum tcp_ca_state {
	TCP_CA_Open = 0,
	TCP_CA_Disorder = 1,
	TCP_CA_CWR = 2,
	TCP_CA_Recovery = 3,
	TCP_CA_Loss = 4,
};

struct trace_event_raw_sock_rcvqueue_full {
	struct trace_entry ent;
	int rmem_alloc;
	unsigned int truesize;
	int sk_rcvbuf;
	char __data[0];
};

struct trace_event_raw_sock_exceed_buf_limit {
	struct trace_entry ent;
	char name[32];
	long int *sysctl_mem;
	long int allocated;
	int sysctl_rmem;
	int rmem_alloc;
	int sysctl_wmem;
	int wmem_alloc;
	int wmem_queued;
	int kind;
	char __data[0];
};

struct trace_event_raw_inet_sock_set_state {
	struct trace_entry ent;
	const void *skaddr;
	int oldstate;
	int newstate;
	__u16 sport;
	__u16 dport;
	__u16 family;
	__u16 protocol;
	__u8 saddr[4];
	__u8 daddr[4];
	__u8 saddr_v6[16];
	__u8 daddr_v6[16];
	char __data[0];
};

struct trace_event_data_offsets_sock_rcvqueue_full {};

struct trace_event_data_offsets_sock_exceed_buf_limit {};

struct trace_event_data_offsets_inet_sock_set_state {};

typedef void (*btf_trace_sock_rcvqueue_full)(void *, struct sock *, struct sk_buff *);

typedef void (*btf_trace_sock_exceed_buf_limit)(void *, struct sock *, struct proto *, long int, int);

typedef void (*btf_trace_inet_sock_set_state)(void *, const struct sock *, const int, const int);

struct trace_event_raw_udp_fail_queue_rcv_skb {
	struct trace_entry ent;
	int rc;
	__u16 lport;
	char __data[0];
};

struct trace_event_data_offsets_udp_fail_queue_rcv_skb {};

typedef void (*btf_trace_udp_fail_queue_rcv_skb)(void *, int, struct sock *);

struct trace_event_raw_tcp_event_sk_skb {
	struct trace_entry ent;
	const void *skbaddr;
	const void *skaddr;
	int state;
	__u16 sport;
	__u16 dport;
	__u8 saddr[4];
	__u8 daddr[4];
	__u8 saddr_v6[16];
	__u8 daddr_v6[16];
	char __data[0];
};

struct trace_event_raw_tcp_event_sk {
	struct trace_entry ent;
	const void *skaddr;
	__u16 sport;
	__u16 dport;
	__u8 saddr[4];
	__u8 daddr[4];
	__u8 saddr_v6[16];
	__u8 daddr_v6[16];
	__u64 sock_cookie;
	char __data[0];
};

struct trace_event_raw_tcp_retransmit_synack {
	struct trace_entry ent;
	const void *skaddr;
	const void *req;
	__u16 sport;
	__u16 dport;
	__u8 saddr[4];
	__u8 daddr[4];
	__u8 saddr_v6[16];
	__u8 daddr_v6[16];
	char __data[0];
};

struct trace_event_raw_tcp_probe {
	struct trace_entry ent;
	__u8 saddr[28];
	__u8 daddr[28];
	__u16 sport;
	__u16 dport;
	__u32 mark;
	__u16 data_len;
	__u32 snd_nxt;
	__u32 snd_una;
	__u32 snd_cwnd;
	__u32 ssthresh;
	__u32 snd_wnd;
	__u32 srtt;
	__u32 rcv_wnd;
	__u64 sock_cookie;
	char __data[0];
};

struct trace_event_data_offsets_tcp_event_sk_skb {};

struct trace_event_data_offsets_tcp_event_sk {};

struct trace_event_data_offsets_tcp_retransmit_synack {};

struct trace_event_data_offsets_tcp_probe {};

typedef void (*btf_trace_tcp_retransmit_skb)(void *, const struct sock *, const struct sk_buff *);

typedef void (*btf_trace_tcp_send_reset)(void *, const struct sock *, const struct sk_buff *);

typedef void (*btf_trace_tcp_receive_reset)(void *, struct sock *);

typedef void (*btf_trace_tcp_destroy_sock)(void *, struct sock *);

typedef void (*btf_trace_tcp_rcv_space_adjust)(void *, struct sock *);

typedef void (*btf_trace_tcp_retransmit_synack)(void *, const struct sock *, const struct request_sock *);

typedef void (*btf_trace_tcp_probe)(void *, struct sock *, struct sk_buff *);

struct trace_event_raw_fib_table_lookup {
	struct trace_entry ent;
	u32 tb_id;
	int err;
	int oif;
	int iif;
	u8 proto;
	__u8 tos;
	__u8 scope;
	__u8 flags;
	__u8 src[4];
	__u8 dst[4];
	__u8 gw4[4];
	__u8 gw6[16];
	u16 sport;
	u16 dport;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_data_offsets_fib_table_lookup {
	u32 name;
};

typedef void (*btf_trace_fib_table_lookup)(void *, u32, const struct flowi4 *, const struct fib_nh_common *, int);

struct trace_event_raw_qdisc_dequeue {
	struct trace_entry ent;
	struct Qdisc *qdisc;
	const struct netdev_queue *txq;
	int packets;
	void *skbaddr;
	int ifindex;
	u32 handle;
	u32 parent;
	long unsigned int txq_state;
	char __data[0];
};

struct trace_event_raw_qdisc_reset {
	struct trace_entry ent;
	u32 __data_loc_dev;
	u32 __data_loc_kind;
	u32 parent;
	u32 handle;
	char __data[0];
};

struct trace_event_raw_qdisc_destroy {
	struct trace_entry ent;
	u32 __data_loc_dev;
	u32 __data_loc_kind;
	u32 parent;
	u32 handle;
	char __data[0];
};

struct trace_event_raw_qdisc_create {
	struct trace_entry ent;
	u32 __data_loc_dev;
	u32 __data_loc_kind;
	u32 parent;
	char __data[0];
};

struct trace_event_data_offsets_qdisc_dequeue {};

struct trace_event_data_offsets_qdisc_reset {
	u32 dev;
	u32 kind;
};

struct trace_event_data_offsets_qdisc_destroy {
	u32 dev;
	u32 kind;
};

struct trace_event_data_offsets_qdisc_create {
	u32 dev;
	u32 kind;
};

typedef void (*btf_trace_qdisc_dequeue)(void *, struct Qdisc *, const struct netdev_queue *, int, struct sk_buff *);

typedef void (*btf_trace_qdisc_reset)(void *, struct Qdisc *);

typedef void (*btf_trace_qdisc_destroy)(void *, struct Qdisc *);

typedef void (*btf_trace_qdisc_create)(void *, const struct Qdisc_ops *, struct net_device *, u32);

struct bridge_stp_xstats {
	__u64 transition_blk;
	__u64 transition_fwd;
	__u64 rx_bpdu;
	__u64 tx_bpdu;
	__u64 rx_tcn;
	__u64 tx_tcn;
};

struct br_mcast_stats {
	__u64 igmp_v1queries[2];
	__u64 igmp_v2queries[2];
	__u64 igmp_v3queries[2];
	__u64 igmp_leaves[2];
	__u64 igmp_v1reports[2];
	__u64 igmp_v2reports[2];
	__u64 igmp_v3reports[2];
	__u64 igmp_parse_errors;
	__u64 mld_v1queries[2];
	__u64 mld_v2queries[2];
	__u64 mld_leaves[2];
	__u64 mld_v1reports[2];
	__u64 mld_v2reports[2];
	__u64 mld_parse_errors;
	__u64 mcast_bytes[2];
	__u64 mcast_packets[2];
};

struct br_ip {
	union {
		__be32 ip4;
		struct in6_addr ip6;
	} src;
	union {
		__be32 ip4;
		struct in6_addr ip6;
	} dst;
	__be16 proto;
	__u16 vid;
};

struct bridge_id {
	unsigned char prio[2];
	unsigned char addr[6];
};

typedef struct bridge_id bridge_id;

struct mac_addr {
	unsigned char addr[6];
};

typedef struct mac_addr mac_addr;

typedef __u16 port_id;

struct bridge_mcast_own_query {
	struct timer_list timer;
	u32 startup_sent;
};

struct bridge_mcast_other_query {
	struct timer_list timer;
	long unsigned int delay_time;
};

struct net_bridge_port;

struct bridge_mcast_querier {
	struct br_ip addr;
	struct net_bridge_port *port;
};

struct net_bridge;

struct bridge_mcast_stats;

struct net_bridge_port {
	struct net_bridge *br;
	struct net_device *dev;
	struct list_head list;
	long unsigned int flags;
	struct net_bridge_port *backup_port;
	u8 priority;
	u8 state;
	u16 port_no;
	unsigned char topology_change_ack;
	unsigned char config_pending;
	port_id port_id;
	port_id designated_port;
	bridge_id designated_root;
	bridge_id designated_bridge;
	u32 path_cost;
	u32 designated_cost;
	long unsigned int designated_age;
	struct timer_list forward_delay_timer;
	struct timer_list hold_timer;
	struct timer_list message_age_timer;
	struct kobject kobj;
	struct callback_head rcu;
	struct bridge_mcast_own_query ip4_own_query;
	struct bridge_mcast_own_query ip6_own_query;
	unsigned char multicast_router;
	struct bridge_mcast_stats *mcast_stats;
	struct timer_list multicast_router_timer;
	struct hlist_head mglist;
	struct hlist_node rlist;
	char sysfs_name[16];
	u16 group_fwd_mask;
	u16 backup_redirected_cnt;
	struct bridge_stp_xstats stp_xstats;
};

struct bridge_mcast_stats {
	struct br_mcast_stats mstats;
	struct u64_stats_sync syncp;
};

struct net_bridge {
	spinlock_t lock;
	spinlock_t hash_lock;
	struct list_head port_list;
	struct net_device *dev;
	struct pcpu_sw_netstats *stats;
	long unsigned int options;
	struct rhashtable fdb_hash_tbl;
	u16 group_fwd_mask;
	u16 group_fwd_mask_required;
	bridge_id designated_root;
	bridge_id bridge_id;
	unsigned char topology_change;
	unsigned char topology_change_detected;
	u16 root_port;
	long unsigned int max_age;
	long unsigned int hello_time;
	long unsigned int forward_delay;
	long unsigned int ageing_time;
	long unsigned int bridge_max_age;
	long unsigned int bridge_hello_time;
	long unsigned int bridge_forward_delay;
	long unsigned int bridge_ageing_time;
	u32 root_path_cost;
	u8 group_addr[6];
	enum {
		BR_NO_STP = 0,
		BR_KERNEL_STP = 1,
		BR_USER_STP = 2,
	} stp_enabled;
	u32 hash_max;
	u32 multicast_last_member_count;
	u32 multicast_startup_query_count;
	u8 multicast_igmp_version;
	u8 multicast_router;
	u8 multicast_mld_version;
	spinlock_t multicast_lock;
	long unsigned int multicast_last_member_interval;
	long unsigned int multicast_membership_interval;
	long unsigned int multicast_querier_interval;
	long unsigned int multicast_query_interval;
	long unsigned int multicast_query_response_interval;
	long unsigned int multicast_startup_query_interval;
	struct rhashtable mdb_hash_tbl;
	struct rhashtable sg_port_tbl;
	struct hlist_head mcast_gc_list;
	struct hlist_head mdb_list;
	struct hlist_head router_list;
	struct timer_list multicast_router_timer;
	struct bridge_mcast_other_query ip4_other_query;
	struct bridge_mcast_own_query ip4_own_query;
	struct bridge_mcast_querier ip4_querier;
	struct bridge_mcast_stats *mcast_stats;
	struct bridge_mcast_other_query ip6_other_query;
	struct bridge_mcast_own_query ip6_own_query;
	struct bridge_mcast_querier ip6_querier;
	struct work_struct mcast_gc_work;
	struct timer_list hello_timer;
	struct timer_list tcn_timer;
	struct timer_list topology_change_timer;
	struct delayed_work gc_work;
	struct kobject *ifobj;
	u32 auto_cnt;
	struct hlist_head fdb_list;
};

struct net_bridge_fdb_key {
	mac_addr addr;
	u16 vlan_id;
};

struct net_bridge_fdb_entry {
	struct rhash_head rhnode;
	struct net_bridge_port *dst;
	struct net_bridge_fdb_key key;
	struct hlist_node fdb_node;
	long unsigned int flags;
	long: 64;
	long: 64;
	long unsigned int updated;
	long unsigned int used;
	struct callback_head rcu;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct trace_event_raw_br_fdb_add {
	struct trace_entry ent;
	u8 ndm_flags;
	u32 __data_loc_dev;
	unsigned char addr[6];
	u16 vid;
	u16 nlh_flags;
	char __data[0];
};

struct trace_event_raw_br_fdb_external_learn_add {
	struct trace_entry ent;
	u32 __data_loc_br_dev;
	u32 __data_loc_dev;
	unsigned char addr[6];
	u16 vid;
	char __data[0];
};

struct trace_event_raw_fdb_delete {
	struct trace_entry ent;
	u32 __data_loc_br_dev;
	u32 __data_loc_dev;
	unsigned char addr[6];
	u16 vid;
	char __data[0];
};

struct trace_event_raw_br_fdb_update {
	struct trace_entry ent;
	u32 __data_loc_br_dev;
	u32 __data_loc_dev;
	unsigned char addr[6];
	u16 vid;
	long unsigned int flags;
	char __data[0];
};

struct trace_event_data_offsets_br_fdb_add {
	u32 dev;
};

struct trace_event_data_offsets_br_fdb_external_learn_add {
	u32 br_dev;
	u32 dev;
};

struct trace_event_data_offsets_fdb_delete {
	u32 br_dev;
	u32 dev;
};

struct trace_event_data_offsets_br_fdb_update {
	u32 br_dev;
	u32 dev;
};

typedef void (*btf_trace_br_fdb_add)(void *, struct ndmsg *, struct net_device *, const unsigned char *, u16, u16);

typedef void (*btf_trace_br_fdb_external_learn_add)(void *, struct net_bridge *, struct net_bridge_port *, const unsigned char *, u16);

typedef void (*btf_trace_fdb_delete)(void *, struct net_bridge *, struct net_bridge_fdb_entry *);

typedef void (*btf_trace_br_fdb_update)(void *, struct net_bridge *, struct net_bridge_port *, const unsigned char *, u16, long unsigned int);

struct trace_event_raw_page_pool_release {
	struct trace_entry ent;
	const struct page_pool *pool;
	s32 inflight;
	u32 hold;
	u32 release;
	u64 cnt;
	char __data[0];
};

struct trace_event_raw_page_pool_state_release {
	struct trace_entry ent;
	const struct page_pool *pool;
	const struct page *page;
	u32 release;
	long unsigned int pfn;
	char __data[0];
};

struct trace_event_raw_page_pool_state_hold {
	struct trace_entry ent;
	const struct page_pool *pool;
	const struct page *page;
	u32 hold;
	long unsigned int pfn;
	char __data[0];
};

struct trace_event_raw_page_pool_update_nid {
	struct trace_entry ent;
	const struct page_pool *pool;
	int pool_nid;
	int new_nid;
	char __data[0];
};

struct trace_event_data_offsets_page_pool_release {};

struct trace_event_data_offsets_page_pool_state_release {};

struct trace_event_data_offsets_page_pool_state_hold {};

struct trace_event_data_offsets_page_pool_update_nid {};

typedef void (*btf_trace_page_pool_release)(void *, const struct page_pool *, s32, u32, u32);

typedef void (*btf_trace_page_pool_state_release)(void *, const struct page_pool *, const struct page *, u32);

typedef void (*btf_trace_page_pool_state_hold)(void *, const struct page_pool *, const struct page *, u32);

typedef void (*btf_trace_page_pool_update_nid)(void *, const struct page_pool *, int);

struct trace_event_raw_neigh_create {
	struct trace_entry ent;
	u32 family;
	u32 __data_loc_dev;
	int entries;
	u8 created;
	u8 gc_exempt;
	u8 primary_key4[4];
	u8 primary_key6[16];
	char __data[0];
};

struct trace_event_raw_neigh_update {
	struct trace_entry ent;
	u32 family;
	u32 __data_loc_dev;
	u8 lladdr[32];
	u8 lladdr_len;
	u8 flags;
	u8 nud_state;
	u8 type;
	u8 dead;
	int refcnt;
	__u8 primary_key4[4];
	__u8 primary_key6[16];
	long unsigned int confirmed;
	long unsigned int updated;
	long unsigned int used;
	u8 new_lladdr[32];
	u8 new_state;
	u32 update_flags;
	u32 pid;
	char __data[0];
};

struct trace_event_raw_neigh__update {
	struct trace_entry ent;
	u32 family;
	u32 __data_loc_dev;
	u8 lladdr[32];
	u8 lladdr_len;
	u8 flags;
	u8 nud_state;
	u8 type;
	u8 dead;
	int refcnt;
	__u8 primary_key4[4];
	__u8 primary_key6[16];
	long unsigned int confirmed;
	long unsigned int updated;
	long unsigned int used;
	u32 err;
	char __data[0];
};

struct trace_event_data_offsets_neigh_create {
	u32 dev;
};

struct trace_event_data_offsets_neigh_update {
	u32 dev;
};

struct trace_event_data_offsets_neigh__update {
	u32 dev;
};

typedef void (*btf_trace_neigh_create)(void *, struct neigh_table *, struct net_device *, const void *, const struct neighbour *, bool);

typedef void (*btf_trace_neigh_update)(void *, struct neighbour *, const u8 *, u8, u32, u32);

typedef void (*btf_trace_neigh_update_done)(void *, struct neighbour *, int);

typedef void (*btf_trace_neigh_timer_handler)(void *, struct neighbour *, int);

typedef void (*btf_trace_neigh_event_send_done)(void *, struct neighbour *, int);

typedef void (*btf_trace_neigh_event_send_dead)(void *, struct neighbour *, int);

typedef void (*btf_trace_neigh_cleanup_and_release)(void *, struct neighbour *, int);

struct dst_cache_pcpu {
	long unsigned int refresh_ts;
	struct dst_entry *dst;
	u32 cookie;
	union {
		struct in_addr in_saddr;
		struct in6_addr in6_saddr;
	};
};

struct gro_cell;

struct gro_cells {
	struct gro_cell *cells;
};

struct gro_cell {
	struct sk_buff_head napi_skbs;
	struct napi_struct napi;
};

enum netdev_lag_tx_type {
	NETDEV_LAG_TX_TYPE_UNKNOWN = 0,
	NETDEV_LAG_TX_TYPE_RANDOM = 1,
	NETDEV_LAG_TX_TYPE_BROADCAST = 2,
	NETDEV_LAG_TX_TYPE_ROUNDROBIN = 3,
	NETDEV_LAG_TX_TYPE_ACTIVEBACKUP = 4,
	NETDEV_LAG_TX_TYPE_HASH = 5,
};

enum netdev_lag_hash {
	NETDEV_LAG_HASH_NONE = 0,
	NETDEV_LAG_HASH_L2 = 1,
	NETDEV_LAG_HASH_L34 = 2,
	NETDEV_LAG_HASH_L23 = 3,
	NETDEV_LAG_HASH_E23 = 4,
	NETDEV_LAG_HASH_E34 = 5,
	NETDEV_LAG_HASH_UNKNOWN = 6,
};

struct netdev_lag_upper_info {
	enum netdev_lag_tx_type tx_type;
	enum netdev_lag_hash hash_type;
};

enum {
	BPF_LOCAL_STORAGE_GET_F_CREATE = 1,
	BPF_SK_STORAGE_GET_F_CREATE = 1,
};

enum {
	SK_DIAG_BPF_STORAGE_REQ_NONE = 0,
	SK_DIAG_BPF_STORAGE_REQ_MAP_FD = 1,
	__SK_DIAG_BPF_STORAGE_REQ_MAX = 2,
};

enum {
	SK_DIAG_BPF_STORAGE_REP_NONE = 0,
	SK_DIAG_BPF_STORAGE = 1,
	__SK_DIAG_BPF_STORAGE_REP_MAX = 2,
};

enum {
	SK_DIAG_BPF_STORAGE_NONE = 0,
	SK_DIAG_BPF_STORAGE_PAD = 1,
	SK_DIAG_BPF_STORAGE_MAP_ID = 2,
	SK_DIAG_BPF_STORAGE_MAP_VALUE = 3,
	__SK_DIAG_BPF_STORAGE_MAX = 4,
};

typedef u64 (*btf_bpf_sk_storage_get)(struct bpf_map *, struct sock *, void *, u64);

typedef u64 (*btf_bpf_sk_storage_delete)(struct bpf_map *, struct sock *);

struct bpf_sk_storage_diag {
	u32 nr_maps;
	struct bpf_map *maps[0];
};

struct bpf_iter_seq_sk_storage_map_info {
	struct bpf_map *map;
	unsigned int bucket_id;
	unsigned int skip_elems;
};

struct bpf_iter__bpf_sk_storage_map {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct bpf_map *map;
	};
	union {
		struct sock *sk;
	};
	union {
		void *value;
	};
};

struct llc_addr {
	unsigned char lsap;
	unsigned char mac[6];
};

struct llc_sap {
	unsigned char state;
	unsigned char p_bit;
	unsigned char f_bit;
	refcount_t refcnt;
	int (*rcv_func)(struct sk_buff *, struct net_device *, struct packet_type *, struct net_device *);
	struct llc_addr laddr;
	struct list_head node;
	spinlock_t sk_lock;
	int sk_count;
	struct hlist_nulls_head sk_laddr_hash[64];
	struct hlist_head sk_dev_hash[64];
	struct callback_head rcu;
};

struct llc_pdu_sn {
	u8 dsap;
	u8 ssap;
	u8 ctrl_1;
	u8 ctrl_2;
};

struct llc_pdu_un {
	u8 dsap;
	u8 ssap;
	u8 ctrl_1;
};

typedef struct sk_buff * (*gro_receive_t)(struct list_head *, struct sk_buff *);

struct nvmem_cell;

struct datalink_proto {
	unsigned char type[8];
	struct llc_sap *sap;
	short unsigned int header_length;
	int (*rcvfunc)(struct sk_buff *, struct net_device *, struct packet_type *, struct net_device *);
	int (*request)(struct datalink_proto *, struct sk_buff *, unsigned char *);
	struct list_head node;
};

struct stp_proto {
	unsigned char group_address[6];
	void (*rcv)(const struct stp_proto *, struct sk_buff *, struct net_device *);
	void *data;
};

struct tc_ratespec {
	unsigned char cell_log;
	__u8 linklayer;
	short unsigned int overhead;
	short int cell_align;
	short unsigned int mpu;
	__u32 rate;
};

struct tc_prio_qopt {
	int bands;
	__u8 priomap[16];
};

enum {
	TCA_UNSPEC = 0,
	TCA_KIND = 1,
	TCA_OPTIONS = 2,
	TCA_STATS = 3,
	TCA_XSTATS = 4,
	TCA_RATE = 5,
	TCA_FCNT = 6,
	TCA_STATS2 = 7,
	TCA_STAB = 8,
	TCA_PAD = 9,
	TCA_DUMP_INVISIBLE = 10,
	TCA_CHAIN = 11,
	TCA_HW_OFFLOAD = 12,
	TCA_INGRESS_BLOCK = 13,
	TCA_EGRESS_BLOCK = 14,
	TCA_DUMP_FLAGS = 15,
	__TCA_MAX = 16,
};

struct skb_array {
	struct ptr_ring ring;
};

struct psched_ratecfg {
	u64 rate_bytes_ps;
	u32 mult;
	u16 overhead;
	u16 mpu;
	u8 linklayer;
	u8 shift;
};

struct mini_Qdisc {
	struct tcf_proto *filter_list;
	struct tcf_block *block;
	struct gnet_stats_basic_cpu *cpu_bstats;
	struct gnet_stats_queue *cpu_qstats;
	struct callback_head rcu;
};

struct mini_Qdisc_pair {
	struct mini_Qdisc miniq1;
	struct mini_Qdisc miniq2;
	struct mini_Qdisc **p_miniq;
};

struct xfrm_offload {
	struct {
		__u32 low;
		__u32 hi;
	} seq;
	__u32 flags;
	__u32 status;
	__u8 proto;
};

struct pfifo_fast_priv {
	struct skb_array q[3];
};

struct tc_qopt_offload_stats {
	struct gnet_stats_basic_packed *bstats;
	struct gnet_stats_queue *qstats;
};

enum tc_mq_command {
	TC_MQ_CREATE = 0,
	TC_MQ_DESTROY = 1,
	TC_MQ_STATS = 2,
	TC_MQ_GRAFT = 3,
};

struct tc_mq_opt_offload_graft_params {
	long unsigned int queue;
	u32 child_handle;
};

struct tc_mq_qopt_offload {
	enum tc_mq_command command;
	u32 handle;
	union {
		struct tc_qopt_offload_stats stats;
		struct tc_mq_opt_offload_graft_params graft_params;
	};
};

struct mq_sched {
	struct Qdisc **qdiscs;
};

struct sockaddr_nl {
	__kernel_sa_family_t nl_family;
	short unsigned int nl_pad;
	__u32 nl_pid;
	__u32 nl_groups;
};

struct nlmsgerr {
	int error;
	struct nlmsghdr msg;
};

enum nlmsgerr_attrs {
	NLMSGERR_ATTR_UNUSED = 0,
	NLMSGERR_ATTR_MSG = 1,
	NLMSGERR_ATTR_OFFS = 2,
	NLMSGERR_ATTR_COOKIE = 3,
	NLMSGERR_ATTR_POLICY = 4,
	__NLMSGERR_ATTR_MAX = 5,
	NLMSGERR_ATTR_MAX = 4,
};

struct nl_pktinfo {
	__u32 group;
};

enum {
	NETLINK_UNCONNECTED = 0,
	NETLINK_CONNECTED = 1,
};

enum netlink_skb_flags {
	NETLINK_SKB_DST = 8,
};

struct netlink_notify {
	struct net *net;
	u32 portid;
	int protocol;
};

struct netlink_tap {
	struct net_device *dev;
	struct module *module;
	struct list_head list;
};

struct netlink_sock {
	struct sock sk;
	u32 portid;
	u32 dst_portid;
	u32 dst_group;
	u32 flags;
	u32 subscriptions;
	u32 ngroups;
	long unsigned int *groups;
	long unsigned int state;
	size_t max_recvmsg_len;
	wait_queue_head_t wait;
	bool bound;
	bool cb_running;
	int dump_done_errno;
	struct netlink_callback cb;
	struct mutex *cb_mutex;
	struct mutex cb_def_mutex;
	void (*netlink_rcv)(struct sk_buff *);
	int (*netlink_bind)(struct net *, int);
	void (*netlink_unbind)(struct net *, int);
	struct module *module;
	struct rhash_head node;
	struct callback_head rcu;
	struct work_struct work;
};

struct listeners;

struct netlink_table {
	struct rhashtable hash;
	struct hlist_head mc_list;
	struct listeners *listeners;
	unsigned int flags;
	unsigned int groups;
	struct mutex *cb_mutex;
	struct module *module;
	int (*bind)(struct net *, int);
	void (*unbind)(struct net *, int);
	bool (*compare)(struct net *, struct sock *);
	int registered;
};

struct listeners {
	struct callback_head rcu;
	long unsigned int masks[0];
};

struct netlink_tap_net {
	struct list_head netlink_tap_all;
	struct mutex netlink_tap_lock;
};

struct netlink_compare_arg {
	possible_net_t pnet;
	u32 portid;
};

struct netlink_broadcast_data {
	struct sock *exclude_sk;
	struct net *net;
	u32 portid;
	u32 group;
	int failure;
	int delivery_failure;
	int congested;
	int delivered;
	gfp_t allocation;
	struct sk_buff *skb;
	struct sk_buff *skb2;
	int (*tx_filter)(struct sock *, struct sk_buff *, void *);
	void *tx_data;
};

struct netlink_set_err_data {
	struct sock *exclude_sk;
	u32 portid;
	u32 group;
	int code;
};

struct nl_seq_iter {
	struct seq_net_private p;
	struct rhashtable_iter hti;
	int link;
};

struct bpf_iter__netlink {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct netlink_sock *sk;
	};
};

struct genlmsghdr {
	__u8 cmd;
	__u8 version;
	__u16 reserved;
};

enum {
	CTRL_CMD_UNSPEC = 0,
	CTRL_CMD_NEWFAMILY = 1,
	CTRL_CMD_DELFAMILY = 2,
	CTRL_CMD_GETFAMILY = 3,
	CTRL_CMD_NEWOPS = 4,
	CTRL_CMD_DELOPS = 5,
	CTRL_CMD_GETOPS = 6,
	CTRL_CMD_NEWMCAST_GRP = 7,
	CTRL_CMD_DELMCAST_GRP = 8,
	CTRL_CMD_GETMCAST_GRP = 9,
	CTRL_CMD_GETPOLICY = 10,
	__CTRL_CMD_MAX = 11,
};

enum {
	CTRL_ATTR_UNSPEC = 0,
	CTRL_ATTR_FAMILY_ID = 1,
	CTRL_ATTR_FAMILY_NAME = 2,
	CTRL_ATTR_VERSION = 3,
	CTRL_ATTR_HDRSIZE = 4,
	CTRL_ATTR_MAXATTR = 5,
	CTRL_ATTR_OPS = 6,
	CTRL_ATTR_MCAST_GROUPS = 7,
	CTRL_ATTR_POLICY = 8,
	CTRL_ATTR_OP_POLICY = 9,
	CTRL_ATTR_OP = 10,
	__CTRL_ATTR_MAX = 11,
};

enum {
	CTRL_ATTR_OP_UNSPEC = 0,
	CTRL_ATTR_OP_ID = 1,
	CTRL_ATTR_OP_FLAGS = 2,
	__CTRL_ATTR_OP_MAX = 3,
};

enum {
	CTRL_ATTR_MCAST_GRP_UNSPEC = 0,
	CTRL_ATTR_MCAST_GRP_NAME = 1,
	CTRL_ATTR_MCAST_GRP_ID = 2,
	__CTRL_ATTR_MCAST_GRP_MAX = 3,
};

enum {
	CTRL_ATTR_POLICY_UNSPEC = 0,
	CTRL_ATTR_POLICY_DO = 1,
	CTRL_ATTR_POLICY_DUMP = 2,
	__CTRL_ATTR_POLICY_DUMP_MAX = 3,
	CTRL_ATTR_POLICY_DUMP_MAX = 2,
};

struct genl_multicast_group {
	char name[16];
};

struct genl_ops;

struct genl_info;

struct genl_small_ops;

struct genl_family {
	int id;
	unsigned int hdrsize;
	char name[16];
	unsigned int version;
	unsigned int maxattr;
	unsigned int mcgrp_offset;
	u8 netnsok: 1;
	u8 parallel_ops: 1;
	u8 n_ops;
	u8 n_small_ops;
	u8 n_mcgrps;
	const struct nla_policy *policy;
	int (*pre_doit)(const struct genl_ops *, struct sk_buff *, struct genl_info *);
	void (*post_doit)(const struct genl_ops *, struct sk_buff *, struct genl_info *);
	const struct genl_ops *ops;
	const struct genl_small_ops *small_ops;
	const struct genl_multicast_group *mcgrps;
	struct module *module;
};

struct genl_ops {
	int (*doit)(struct sk_buff *, struct genl_info *);
	int (*start)(struct netlink_callback *);
	int (*dumpit)(struct sk_buff *, struct netlink_callback *);
	int (*done)(struct netlink_callback *);
	const struct nla_policy *policy;
	unsigned int maxattr;
	u8 cmd;
	u8 internal_flags;
	u8 flags;
	u8 validate;
};

struct genl_info {
	u32 snd_seq;
	u32 snd_portid;
	struct nlmsghdr *nlhdr;
	struct genlmsghdr *genlhdr;
	void *userhdr;
	struct nlattr **attrs;
	possible_net_t _net;
	void *user_ptr[2];
	struct netlink_ext_ack *extack;
};

struct genl_small_ops {
	int (*doit)(struct sk_buff *, struct genl_info *);
	int (*dumpit)(struct sk_buff *, struct netlink_callback *);
	u8 cmd;
	u8 internal_flags;
	u8 flags;
	u8 validate;
};

enum genl_validate_flags {
	GENL_DONT_VALIDATE_STRICT = 1,
	GENL_DONT_VALIDATE_DUMP = 2,
	GENL_DONT_VALIDATE_DUMP_STRICT = 4,
};

struct genl_dumpit_info {
	const struct genl_family *family;
	struct genl_ops op;
	struct nlattr **attrs;
};

struct genl_start_context {
	const struct genl_family *family;
	struct nlmsghdr *nlh;
	struct netlink_ext_ack *extack;
	const struct genl_ops *ops;
	int hdrlen;
};

struct netlink_policy_dump_state;

struct ctrl_dump_policy_ctx {
	struct netlink_policy_dump_state *state;
	const struct genl_family *rt;
	unsigned int opidx;
	u32 op;
	u16 fam_id;
	u8 policies: 1;
	u8 single_op: 1;
};

enum netlink_attribute_type {
	NL_ATTR_TYPE_INVALID = 0,
	NL_ATTR_TYPE_FLAG = 1,
	NL_ATTR_TYPE_U8 = 2,
	NL_ATTR_TYPE_U16 = 3,
	NL_ATTR_TYPE_U32 = 4,
	NL_ATTR_TYPE_U64 = 5,
	NL_ATTR_TYPE_S8 = 6,
	NL_ATTR_TYPE_S16 = 7,
	NL_ATTR_TYPE_S32 = 8,
	NL_ATTR_TYPE_S64 = 9,
	NL_ATTR_TYPE_BINARY = 10,
	NL_ATTR_TYPE_STRING = 11,
	NL_ATTR_TYPE_NUL_STRING = 12,
	NL_ATTR_TYPE_NESTED = 13,
	NL_ATTR_TYPE_NESTED_ARRAY = 14,
	NL_ATTR_TYPE_BITFIELD32 = 15,
};

enum netlink_policy_type_attr {
	NL_POLICY_TYPE_ATTR_UNSPEC = 0,
	NL_POLICY_TYPE_ATTR_TYPE = 1,
	NL_POLICY_TYPE_ATTR_MIN_VALUE_S = 2,
	NL_POLICY_TYPE_ATTR_MAX_VALUE_S = 3,
	NL_POLICY_TYPE_ATTR_MIN_VALUE_U = 4,
	NL_POLICY_TYPE_ATTR_MAX_VALUE_U = 5,
	NL_POLICY_TYPE_ATTR_MIN_LENGTH = 6,
	NL_POLICY_TYPE_ATTR_MAX_LENGTH = 7,
	NL_POLICY_TYPE_ATTR_POLICY_IDX = 8,
	NL_POLICY_TYPE_ATTR_POLICY_MAXTYPE = 9,
	NL_POLICY_TYPE_ATTR_BITFIELD32_MASK = 10,
	NL_POLICY_TYPE_ATTR_PAD = 11,
	NL_POLICY_TYPE_ATTR_MASK = 12,
	__NL_POLICY_TYPE_ATTR_MAX = 13,
	NL_POLICY_TYPE_ATTR_MAX = 12,
};

struct netlink_policy_dump_state {
	unsigned int policy_idx;
	unsigned int attr_idx;
	unsigned int n_alloc;
	struct {
		const struct nla_policy *policy;
		unsigned int maxtype;
	} policies[0];
};

struct netlink_diag_req {
	__u8 sdiag_family;
	__u8 sdiag_protocol;
	__u16 pad;
	__u32 ndiag_ino;
	__u32 ndiag_show;
	__u32 ndiag_cookie[2];
};

struct netlink_diag_msg {
	__u8 ndiag_family;
	__u8 ndiag_type;
	__u8 ndiag_protocol;
	__u8 ndiag_state;
	__u32 ndiag_portid;
	__u32 ndiag_dst_portid;
	__u32 ndiag_dst_group;
	__u32 ndiag_ino;
	__u32 ndiag_cookie[2];
};

enum {
	NETLINK_DIAG_MEMINFO = 0,
	NETLINK_DIAG_GROUPS = 1,
	NETLINK_DIAG_RX_RING = 2,
	NETLINK_DIAG_TX_RING = 3,
	NETLINK_DIAG_FLAGS = 4,
	__NETLINK_DIAG_MAX = 5,
};

struct trace_event_raw_bpf_test_finish {
	struct trace_entry ent;
	int err;
	char __data[0];
};

struct trace_event_data_offsets_bpf_test_finish {};

typedef void (*btf_trace_bpf_test_finish)(void *, int *);

struct bpf_fentry_test_t {
	struct bpf_fentry_test_t *a;
};

struct bpf_raw_tp_test_run_info {
	struct bpf_prog *prog;
	void *ctx;
	u32 retval;
};

struct ethtool_value {
	__u32 cmd;
	__u32 data;
};

enum tunable_type_id {
	ETHTOOL_TUNABLE_UNSPEC = 0,
	ETHTOOL_TUNABLE_U8 = 1,
	ETHTOOL_TUNABLE_U16 = 2,
	ETHTOOL_TUNABLE_U32 = 3,
	ETHTOOL_TUNABLE_U64 = 4,
	ETHTOOL_TUNABLE_STRING = 5,
	ETHTOOL_TUNABLE_S8 = 6,
	ETHTOOL_TUNABLE_S16 = 7,
	ETHTOOL_TUNABLE_S32 = 8,
	ETHTOOL_TUNABLE_S64 = 9,
};

struct ethtool_gstrings {
	__u32 cmd;
	__u32 string_set;
	__u32 len;
	__u8 data[0];
};

struct ethtool_sset_info {
	__u32 cmd;
	__u32 reserved;
	__u64 sset_mask;
	__u32 data[0];
};

struct ethtool_perm_addr {
	__u32 cmd;
	__u32 size;
	__u8 data[0];
};

enum ethtool_flags {
	ETH_FLAG_TXVLAN = 128,
	ETH_FLAG_RXVLAN = 256,
	ETH_FLAG_LRO = 32768,
	ETH_FLAG_NTUPLE = 134217728,
	ETH_FLAG_RXHASH = 268435456,
};

struct ethtool_rxfh {
	__u32 cmd;
	__u32 rss_context;
	__u32 indir_size;
	__u32 key_size;
	__u8 hfunc;
	__u8 rsvd8[3];
	__u32 rsvd32;
	__u32 rss_config[0];
};

struct ethtool_get_features_block {
	__u32 available;
	__u32 requested;
	__u32 active;
	__u32 never_changed;
};

struct ethtool_gfeatures {
	__u32 cmd;
	__u32 size;
	struct ethtool_get_features_block features[0];
};

struct ethtool_set_features_block {
	__u32 valid;
	__u32 requested;
};

struct ethtool_sfeatures {
	__u32 cmd;
	__u32 size;
	struct ethtool_set_features_block features[0];
};

enum ethtool_sfeatures_retval_bits {
	ETHTOOL_F_UNSUPPORTED__BIT = 0,
	ETHTOOL_F_WISH__BIT = 1,
	ETHTOOL_F_COMPAT__BIT = 2,
};

struct ethtool_per_queue_op {
	__u32 cmd;
	__u32 sub_command;
	__u32 queue_mask[128];
	char data[0];
};

struct ethtool_rx_flow_rule {
	struct flow_rule *rule;
	long unsigned int priv[0];
};

struct ethtool_rx_flow_spec_input {
	const struct ethtool_rx_flow_spec *fs;
	u32 rss_ctx;
};

struct ethtool_link_usettings {
	struct ethtool_link_settings base;
	struct {
		__u32 supported[3];
		__u32 advertising[3];
		__u32 lp_advertising[3];
	} link_modes;
};

struct ethtool_rx_flow_key {
	struct flow_dissector_key_basic basic;
	union {
		struct flow_dissector_key_ipv4_addrs ipv4;
		struct flow_dissector_key_ipv6_addrs ipv6;
	};
	struct flow_dissector_key_ports tp;
	struct flow_dissector_key_ip ip;
	struct flow_dissector_key_vlan vlan;
	struct flow_dissector_key_eth_addrs eth_addrs;
};

struct ethtool_rx_flow_match {
	struct flow_dissector dissector;
	int: 32;
	struct ethtool_rx_flow_key key;
	struct ethtool_rx_flow_key mask;
};

enum {
	ETHTOOL_UDP_TUNNEL_TYPE_VXLAN = 0,
	ETHTOOL_UDP_TUNNEL_TYPE_GENEVE = 1,
	ETHTOOL_UDP_TUNNEL_TYPE_VXLAN_GPE = 2,
	__ETHTOOL_UDP_TUNNEL_TYPE_CNT = 3,
};

enum {
	ETHTOOL_MSG_USER_NONE = 0,
	ETHTOOL_MSG_STRSET_GET = 1,
	ETHTOOL_MSG_LINKINFO_GET = 2,
	ETHTOOL_MSG_LINKINFO_SET = 3,
	ETHTOOL_MSG_LINKMODES_GET = 4,
	ETHTOOL_MSG_LINKMODES_SET = 5,
	ETHTOOL_MSG_LINKSTATE_GET = 6,
	ETHTOOL_MSG_DEBUG_GET = 7,
	ETHTOOL_MSG_DEBUG_SET = 8,
	ETHTOOL_MSG_WOL_GET = 9,
	ETHTOOL_MSG_WOL_SET = 10,
	ETHTOOL_MSG_FEATURES_GET = 11,
	ETHTOOL_MSG_FEATURES_SET = 12,
	ETHTOOL_MSG_PRIVFLAGS_GET = 13,
	ETHTOOL_MSG_PRIVFLAGS_SET = 14,
	ETHTOOL_MSG_RINGS_GET = 15,
	ETHTOOL_MSG_RINGS_SET = 16,
	ETHTOOL_MSG_CHANNELS_GET = 17,
	ETHTOOL_MSG_CHANNELS_SET = 18,
	ETHTOOL_MSG_COALESCE_GET = 19,
	ETHTOOL_MSG_COALESCE_SET = 20,
	ETHTOOL_MSG_PAUSE_GET = 21,
	ETHTOOL_MSG_PAUSE_SET = 22,
	ETHTOOL_MSG_EEE_GET = 23,
	ETHTOOL_MSG_EEE_SET = 24,
	ETHTOOL_MSG_TSINFO_GET = 25,
	ETHTOOL_MSG_CABLE_TEST_ACT = 26,
	ETHTOOL_MSG_CABLE_TEST_TDR_ACT = 27,
	ETHTOOL_MSG_TUNNEL_INFO_GET = 28,
	__ETHTOOL_MSG_USER_CNT = 29,
	ETHTOOL_MSG_USER_MAX = 28,
};

enum {
	ETHTOOL_A_HEADER_UNSPEC = 0,
	ETHTOOL_A_HEADER_DEV_INDEX = 1,
	ETHTOOL_A_HEADER_DEV_NAME = 2,
	ETHTOOL_A_HEADER_FLAGS = 3,
	__ETHTOOL_A_HEADER_CNT = 4,
	ETHTOOL_A_HEADER_MAX = 3,
};

enum {
	ETHTOOL_A_STRSET_UNSPEC = 0,
	ETHTOOL_A_STRSET_HEADER = 1,
	ETHTOOL_A_STRSET_STRINGSETS = 2,
	ETHTOOL_A_STRSET_COUNTS_ONLY = 3,
	__ETHTOOL_A_STRSET_CNT = 4,
	ETHTOOL_A_STRSET_MAX = 3,
};

enum {
	ETHTOOL_A_LINKINFO_UNSPEC = 0,
	ETHTOOL_A_LINKINFO_HEADER = 1,
	ETHTOOL_A_LINKINFO_PORT = 2,
	ETHTOOL_A_LINKINFO_PHYADDR = 3,
	ETHTOOL_A_LINKINFO_TP_MDIX = 4,
	ETHTOOL_A_LINKINFO_TP_MDIX_CTRL = 5,
	ETHTOOL_A_LINKINFO_TRANSCEIVER = 6,
	__ETHTOOL_A_LINKINFO_CNT = 7,
	ETHTOOL_A_LINKINFO_MAX = 6,
};

enum {
	ETHTOOL_A_LINKMODES_UNSPEC = 0,
	ETHTOOL_A_LINKMODES_HEADER = 1,
	ETHTOOL_A_LINKMODES_AUTONEG = 2,
	ETHTOOL_A_LINKMODES_OURS = 3,
	ETHTOOL_A_LINKMODES_PEER = 4,
	ETHTOOL_A_LINKMODES_SPEED = 5,
	ETHTOOL_A_LINKMODES_DUPLEX = 6,
	ETHTOOL_A_LINKMODES_MASTER_SLAVE_CFG = 7,
	ETHTOOL_A_LINKMODES_MASTER_SLAVE_STATE = 8,
	__ETHTOOL_A_LINKMODES_CNT = 9,
	ETHTOOL_A_LINKMODES_MAX = 8,
};

enum {
	ETHTOOL_A_LINKSTATE_UNSPEC = 0,
	ETHTOOL_A_LINKSTATE_HEADER = 1,
	ETHTOOL_A_LINKSTATE_LINK = 2,
	ETHTOOL_A_LINKSTATE_SQI = 3,
	ETHTOOL_A_LINKSTATE_SQI_MAX = 4,
	ETHTOOL_A_LINKSTATE_EXT_STATE = 5,
	ETHTOOL_A_LINKSTATE_EXT_SUBSTATE = 6,
	__ETHTOOL_A_LINKSTATE_CNT = 7,
	ETHTOOL_A_LINKSTATE_MAX = 6,
};

enum {
	ETHTOOL_A_DEBUG_UNSPEC = 0,
	ETHTOOL_A_DEBUG_HEADER = 1,
	ETHTOOL_A_DEBUG_MSGMASK = 2,
	__ETHTOOL_A_DEBUG_CNT = 3,
	ETHTOOL_A_DEBUG_MAX = 2,
};

enum {
	ETHTOOL_A_WOL_UNSPEC = 0,
	ETHTOOL_A_WOL_HEADER = 1,
	ETHTOOL_A_WOL_MODES = 2,
	ETHTOOL_A_WOL_SOPASS = 3,
	__ETHTOOL_A_WOL_CNT = 4,
	ETHTOOL_A_WOL_MAX = 3,
};

enum {
	ETHTOOL_A_FEATURES_UNSPEC = 0,
	ETHTOOL_A_FEATURES_HEADER = 1,
	ETHTOOL_A_FEATURES_HW = 2,
	ETHTOOL_A_FEATURES_WANTED = 3,
	ETHTOOL_A_FEATURES_ACTIVE = 4,
	ETHTOOL_A_FEATURES_NOCHANGE = 5,
	__ETHTOOL_A_FEATURES_CNT = 6,
	ETHTOOL_A_FEATURES_MAX = 5,
};

enum {
	ETHTOOL_A_PRIVFLAGS_UNSPEC = 0,
	ETHTOOL_A_PRIVFLAGS_HEADER = 1,
	ETHTOOL_A_PRIVFLAGS_FLAGS = 2,
	__ETHTOOL_A_PRIVFLAGS_CNT = 3,
	ETHTOOL_A_PRIVFLAGS_MAX = 2,
};

enum {
	ETHTOOL_A_RINGS_UNSPEC = 0,
	ETHTOOL_A_RINGS_HEADER = 1,
	ETHTOOL_A_RINGS_RX_MAX = 2,
	ETHTOOL_A_RINGS_RX_MINI_MAX = 3,
	ETHTOOL_A_RINGS_RX_JUMBO_MAX = 4,
	ETHTOOL_A_RINGS_TX_MAX = 5,
	ETHTOOL_A_RINGS_RX = 6,
	ETHTOOL_A_RINGS_RX_MINI = 7,
	ETHTOOL_A_RINGS_RX_JUMBO = 8,
	ETHTOOL_A_RINGS_TX = 9,
	__ETHTOOL_A_RINGS_CNT = 10,
	ETHTOOL_A_RINGS_MAX = 9,
};

enum {
	ETHTOOL_A_CHANNELS_UNSPEC = 0,
	ETHTOOL_A_CHANNELS_HEADER = 1,
	ETHTOOL_A_CHANNELS_RX_MAX = 2,
	ETHTOOL_A_CHANNELS_TX_MAX = 3,
	ETHTOOL_A_CHANNELS_OTHER_MAX = 4,
	ETHTOOL_A_CHANNELS_COMBINED_MAX = 5,
	ETHTOOL_A_CHANNELS_RX_COUNT = 6,
	ETHTOOL_A_CHANNELS_TX_COUNT = 7,
	ETHTOOL_A_CHANNELS_OTHER_COUNT = 8,
	ETHTOOL_A_CHANNELS_COMBINED_COUNT = 9,
	__ETHTOOL_A_CHANNELS_CNT = 10,
	ETHTOOL_A_CHANNELS_MAX = 9,
};

enum {
	ETHTOOL_A_COALESCE_UNSPEC = 0,
	ETHTOOL_A_COALESCE_HEADER = 1,
	ETHTOOL_A_COALESCE_RX_USECS = 2,
	ETHTOOL_A_COALESCE_RX_MAX_FRAMES = 3,
	ETHTOOL_A_COALESCE_RX_USECS_IRQ = 4,
	ETHTOOL_A_COALESCE_RX_MAX_FRAMES_IRQ = 5,
	ETHTOOL_A_COALESCE_TX_USECS = 6,
	ETHTOOL_A_COALESCE_TX_MAX_FRAMES = 7,
	ETHTOOL_A_COALESCE_TX_USECS_IRQ = 8,
	ETHTOOL_A_COALESCE_TX_MAX_FRAMES_IRQ = 9,
	ETHTOOL_A_COALESCE_STATS_BLOCK_USECS = 10,
	ETHTOOL_A_COALESCE_USE_ADAPTIVE_RX = 11,
	ETHTOOL_A_COALESCE_USE_ADAPTIVE_TX = 12,
	ETHTOOL_A_COALESCE_PKT_RATE_LOW = 13,
	ETHTOOL_A_COALESCE_RX_USECS_LOW = 14,
	ETHTOOL_A_COALESCE_RX_MAX_FRAMES_LOW = 15,
	ETHTOOL_A_COALESCE_TX_USECS_LOW = 16,
	ETHTOOL_A_COALESCE_TX_MAX_FRAMES_LOW = 17,
	ETHTOOL_A_COALESCE_PKT_RATE_HIGH = 18,
	ETHTOOL_A_COALESCE_RX_USECS_HIGH = 19,
	ETHTOOL_A_COALESCE_RX_MAX_FRAMES_HIGH = 20,
	ETHTOOL_A_COALESCE_TX_USECS_HIGH = 21,
	ETHTOOL_A_COALESCE_TX_MAX_FRAMES_HIGH = 22,
	ETHTOOL_A_COALESCE_RATE_SAMPLE_INTERVAL = 23,
	__ETHTOOL_A_COALESCE_CNT = 24,
	ETHTOOL_A_COALESCE_MAX = 23,
};

enum {
	ETHTOOL_A_PAUSE_UNSPEC = 0,
	ETHTOOL_A_PAUSE_HEADER = 1,
	ETHTOOL_A_PAUSE_AUTONEG = 2,
	ETHTOOL_A_PAUSE_RX = 3,
	ETHTOOL_A_PAUSE_TX = 4,
	ETHTOOL_A_PAUSE_STATS = 5,
	__ETHTOOL_A_PAUSE_CNT = 6,
	ETHTOOL_A_PAUSE_MAX = 5,
};

enum {
	ETHTOOL_A_EEE_UNSPEC = 0,
	ETHTOOL_A_EEE_HEADER = 1,
	ETHTOOL_A_EEE_MODES_OURS = 2,
	ETHTOOL_A_EEE_MODES_PEER = 3,
	ETHTOOL_A_EEE_ACTIVE = 4,
	ETHTOOL_A_EEE_ENABLED = 5,
	ETHTOOL_A_EEE_TX_LPI_ENABLED = 6,
	ETHTOOL_A_EEE_TX_LPI_TIMER = 7,
	__ETHTOOL_A_EEE_CNT = 8,
	ETHTOOL_A_EEE_MAX = 7,
};

enum {
	ETHTOOL_A_TSINFO_UNSPEC = 0,
	ETHTOOL_A_TSINFO_HEADER = 1,
	ETHTOOL_A_TSINFO_TIMESTAMPING = 2,
	ETHTOOL_A_TSINFO_TX_TYPES = 3,
	ETHTOOL_A_TSINFO_RX_FILTERS = 4,
	ETHTOOL_A_TSINFO_PHC_INDEX = 5,
	__ETHTOOL_A_TSINFO_CNT = 6,
	ETHTOOL_A_TSINFO_MAX = 5,
};

enum {
	ETHTOOL_A_CABLE_TEST_UNSPEC = 0,
	ETHTOOL_A_CABLE_TEST_HEADER = 1,
	__ETHTOOL_A_CABLE_TEST_CNT = 2,
	ETHTOOL_A_CABLE_TEST_MAX = 1,
};

enum {
	ETHTOOL_A_CABLE_TEST_TDR_UNSPEC = 0,
	ETHTOOL_A_CABLE_TEST_TDR_HEADER = 1,
	ETHTOOL_A_CABLE_TEST_TDR_CFG = 2,
	__ETHTOOL_A_CABLE_TEST_TDR_CNT = 3,
	ETHTOOL_A_CABLE_TEST_TDR_MAX = 2,
};

enum {
	ETHTOOL_A_TUNNEL_INFO_UNSPEC = 0,
	ETHTOOL_A_TUNNEL_INFO_HEADER = 1,
	ETHTOOL_A_TUNNEL_INFO_UDP_PORTS = 2,
	__ETHTOOL_A_TUNNEL_INFO_CNT = 3,
	ETHTOOL_A_TUNNEL_INFO_MAX = 2,
};

enum ethtool_multicast_groups {
	ETHNL_MCGRP_MONITOR = 0,
};

struct ethnl_req_info {
	struct net_device *dev;
	u32 flags;
};

struct ethnl_reply_data {
	struct net_device *dev;
};

struct ethnl_request_ops {
	u8 request_cmd;
	u8 reply_cmd;
	u16 hdr_attr;
	unsigned int req_info_size;
	unsigned int reply_data_size;
	bool allow_nodev_do;
	int (*parse_request)(struct ethnl_req_info *, struct nlattr **, struct netlink_ext_ack *);
	int (*prepare_data)(const struct ethnl_req_info *, struct ethnl_reply_data *, struct genl_info *);
	int (*reply_size)(const struct ethnl_req_info *, const struct ethnl_reply_data *);
	int (*fill_reply)(struct sk_buff *, const struct ethnl_req_info *, const struct ethnl_reply_data *);
	void (*cleanup_data)(struct ethnl_reply_data *);
};

struct ethnl_dump_ctx {
	const struct ethnl_request_ops *ops;
	struct ethnl_req_info *req_info;
	struct ethnl_reply_data *reply_data;
	int pos_hash;
	int pos_idx;
};

typedef void (*ethnl_notify_handler_t)(struct net_device *, unsigned int, const void *);

enum {
	ETHTOOL_A_BITSET_BIT_UNSPEC = 0,
	ETHTOOL_A_BITSET_BIT_INDEX = 1,
	ETHTOOL_A_BITSET_BIT_NAME = 2,
	ETHTOOL_A_BITSET_BIT_VALUE = 3,
	__ETHTOOL_A_BITSET_BIT_CNT = 4,
	ETHTOOL_A_BITSET_BIT_MAX = 3,
};

enum {
	ETHTOOL_A_BITSET_BITS_UNSPEC = 0,
	ETHTOOL_A_BITSET_BITS_BIT = 1,
	__ETHTOOL_A_BITSET_BITS_CNT = 2,
	ETHTOOL_A_BITSET_BITS_MAX = 1,
};

enum {
	ETHTOOL_A_BITSET_UNSPEC = 0,
	ETHTOOL_A_BITSET_NOMASK = 1,
	ETHTOOL_A_BITSET_SIZE = 2,
	ETHTOOL_A_BITSET_BITS = 3,
	ETHTOOL_A_BITSET_VALUE = 4,
	ETHTOOL_A_BITSET_MASK = 5,
	__ETHTOOL_A_BITSET_CNT = 6,
	ETHTOOL_A_BITSET_MAX = 5,
};

typedef const char (* const ethnl_string_array_t)[32];

enum {
	ETHTOOL_A_STRING_UNSPEC = 0,
	ETHTOOL_A_STRING_INDEX = 1,
	ETHTOOL_A_STRING_VALUE = 2,
	__ETHTOOL_A_STRING_CNT = 3,
	ETHTOOL_A_STRING_MAX = 2,
};

enum {
	ETHTOOL_A_STRINGS_UNSPEC = 0,
	ETHTOOL_A_STRINGS_STRING = 1,
	__ETHTOOL_A_STRINGS_CNT = 2,
	ETHTOOL_A_STRINGS_MAX = 1,
};

enum {
	ETHTOOL_A_STRINGSET_UNSPEC = 0,
	ETHTOOL_A_STRINGSET_ID = 1,
	ETHTOOL_A_STRINGSET_COUNT = 2,
	ETHTOOL_A_STRINGSET_STRINGS = 3,
	__ETHTOOL_A_STRINGSET_CNT = 4,
	ETHTOOL_A_STRINGSET_MAX = 3,
};

enum {
	ETHTOOL_A_STRINGSETS_UNSPEC = 0,
	ETHTOOL_A_STRINGSETS_STRINGSET = 1,
	__ETHTOOL_A_STRINGSETS_CNT = 2,
	ETHTOOL_A_STRINGSETS_MAX = 1,
};

struct strset_info {
	bool per_dev;
	bool free_strings;
	unsigned int count;
	const char (*strings)[32];
};

struct strset_req_info {
	struct ethnl_req_info base;
	u32 req_ids;
	bool counts_only;
};

struct strset_reply_data {
	struct ethnl_reply_data base;
	struct strset_info sets[16];
};

struct linkinfo_reply_data {
	struct ethnl_reply_data base;
	struct ethtool_link_ksettings ksettings;
	struct ethtool_link_settings *lsettings;
};

struct linkmodes_reply_data {
	struct ethnl_reply_data base;
	struct ethtool_link_ksettings ksettings;
	struct ethtool_link_settings *lsettings;
	bool peer_empty;
};

struct link_mode_info {
	int speed;
	u8 duplex;
};

struct linkstate_reply_data {
	struct ethnl_reply_data base;
	int link;
	int sqi;
	int sqi_max;
	bool link_ext_state_provided;
	struct ethtool_link_ext_state_info ethtool_link_ext_state_info;
};

struct debug_reply_data {
	struct ethnl_reply_data base;
	u32 msg_mask;
};

struct wol_reply_data {
	struct ethnl_reply_data base;
	struct ethtool_wolinfo wol;
	bool show_sopass;
};

struct features_reply_data {
	struct ethnl_reply_data base;
	u32 hw[2];
	u32 wanted[2];
	u32 active[2];
	u32 nochange[2];
	u32 all[2];
};

struct privflags_reply_data {
	struct ethnl_reply_data base;
	const char (*priv_flag_names)[32];
	unsigned int n_priv_flags;
	u32 priv_flags;
};

struct rings_reply_data {
	struct ethnl_reply_data base;
	struct ethtool_ringparam ringparam;
};

struct channels_reply_data {
	struct ethnl_reply_data base;
	struct ethtool_channels channels;
};

struct coalesce_reply_data {
	struct ethnl_reply_data base;
	struct ethtool_coalesce coalesce;
	u32 supported_params;
};

enum {
	ETHTOOL_A_PAUSE_STAT_UNSPEC = 0,
	ETHTOOL_A_PAUSE_STAT_PAD = 1,
	ETHTOOL_A_PAUSE_STAT_TX_FRAMES = 2,
	ETHTOOL_A_PAUSE_STAT_RX_FRAMES = 3,
	__ETHTOOL_A_PAUSE_STAT_CNT = 4,
	ETHTOOL_A_PAUSE_STAT_MAX = 3,
};

struct pause_reply_data {
	struct ethnl_reply_data base;
	struct ethtool_pauseparam pauseparam;
	struct ethtool_pause_stats pausestat;
};

struct eee_reply_data {
	struct ethnl_reply_data base;
	struct ethtool_eee eee;
};

struct tsinfo_reply_data {
	struct ethnl_reply_data base;
	struct ethtool_ts_info ts_info;
};

enum {
	ETHTOOL_A_CABLE_PAIR_A = 0,
	ETHTOOL_A_CABLE_PAIR_B = 1,
	ETHTOOL_A_CABLE_PAIR_C = 2,
	ETHTOOL_A_CABLE_PAIR_D = 3,
};

enum {
	ETHTOOL_A_CABLE_RESULT_UNSPEC = 0,
	ETHTOOL_A_CABLE_RESULT_PAIR = 1,
	ETHTOOL_A_CABLE_RESULT_CODE = 2,
	__ETHTOOL_A_CABLE_RESULT_CNT = 3,
	ETHTOOL_A_CABLE_RESULT_MAX = 2,
};

enum {
	ETHTOOL_A_CABLE_FAULT_LENGTH_UNSPEC = 0,
	ETHTOOL_A_CABLE_FAULT_LENGTH_PAIR = 1,
	ETHTOOL_A_CABLE_FAULT_LENGTH_CM = 2,
	__ETHTOOL_A_CABLE_FAULT_LENGTH_CNT = 3,
	ETHTOOL_A_CABLE_FAULT_LENGTH_MAX = 2,
};

enum {
	ETHTOOL_A_CABLE_TEST_NTF_STATUS_UNSPEC = 0,
	ETHTOOL_A_CABLE_TEST_NTF_STATUS_STARTED = 1,
	ETHTOOL_A_CABLE_TEST_NTF_STATUS_COMPLETED = 2,
};

enum {
	ETHTOOL_A_CABLE_NEST_UNSPEC = 0,
	ETHTOOL_A_CABLE_NEST_RESULT = 1,
	ETHTOOL_A_CABLE_NEST_FAULT_LENGTH = 2,
	__ETHTOOL_A_CABLE_NEST_CNT = 3,
	ETHTOOL_A_CABLE_NEST_MAX = 2,
};

enum {
	ETHTOOL_A_CABLE_TEST_NTF_UNSPEC = 0,
	ETHTOOL_A_CABLE_TEST_NTF_HEADER = 1,
	ETHTOOL_A_CABLE_TEST_NTF_STATUS = 2,
	ETHTOOL_A_CABLE_TEST_NTF_NEST = 3,
	__ETHTOOL_A_CABLE_TEST_NTF_CNT = 4,
	ETHTOOL_A_CABLE_TEST_NTF_MAX = 3,
};

enum {
	ETHTOOL_A_CABLE_TEST_TDR_CFG_UNSPEC = 0,
	ETHTOOL_A_CABLE_TEST_TDR_CFG_FIRST = 1,
	ETHTOOL_A_CABLE_TEST_TDR_CFG_LAST = 2,
	ETHTOOL_A_CABLE_TEST_TDR_CFG_STEP = 3,
	ETHTOOL_A_CABLE_TEST_TDR_CFG_PAIR = 4,
	__ETHTOOL_A_CABLE_TEST_TDR_CFG_CNT = 5,
	ETHTOOL_A_CABLE_TEST_TDR_CFG_MAX = 4,
};

enum {
	ETHTOOL_A_CABLE_AMPLITUDE_UNSPEC = 0,
	ETHTOOL_A_CABLE_AMPLITUDE_PAIR = 1,
	ETHTOOL_A_CABLE_AMPLITUDE_mV = 2,
	__ETHTOOL_A_CABLE_AMPLITUDE_CNT = 3,
	ETHTOOL_A_CABLE_AMPLITUDE_MAX = 2,
};

enum {
	ETHTOOL_A_CABLE_PULSE_UNSPEC = 0,
	ETHTOOL_A_CABLE_PULSE_mV = 1,
	__ETHTOOL_A_CABLE_PULSE_CNT = 2,
	ETHTOOL_A_CABLE_PULSE_MAX = 1,
};

enum {
	ETHTOOL_A_CABLE_STEP_UNSPEC = 0,
	ETHTOOL_A_CABLE_STEP_FIRST_DISTANCE = 1,
	ETHTOOL_A_CABLE_STEP_LAST_DISTANCE = 2,
	ETHTOOL_A_CABLE_STEP_STEP_DISTANCE = 3,
	__ETHTOOL_A_CABLE_STEP_CNT = 4,
	ETHTOOL_A_CABLE_STEP_MAX = 3,
};

enum {
	ETHTOOL_A_CABLE_TDR_NEST_UNSPEC = 0,
	ETHTOOL_A_CABLE_TDR_NEST_STEP = 1,
	ETHTOOL_A_CABLE_TDR_NEST_AMPLITUDE = 2,
	ETHTOOL_A_CABLE_TDR_NEST_PULSE = 3,
	__ETHTOOL_A_CABLE_TDR_NEST_CNT = 4,
	ETHTOOL_A_CABLE_TDR_NEST_MAX = 3,
};

enum {
	ETHTOOL_A_TUNNEL_UDP_ENTRY_UNSPEC = 0,
	ETHTOOL_A_TUNNEL_UDP_ENTRY_PORT = 1,
	ETHTOOL_A_TUNNEL_UDP_ENTRY_TYPE = 2,
	__ETHTOOL_A_TUNNEL_UDP_ENTRY_CNT = 3,
	ETHTOOL_A_TUNNEL_UDP_ENTRY_MAX = 2,
};

enum {
	ETHTOOL_A_TUNNEL_UDP_TABLE_UNSPEC = 0,
	ETHTOOL_A_TUNNEL_UDP_TABLE_SIZE = 1,
	ETHTOOL_A_TUNNEL_UDP_TABLE_TYPES = 2,
	ETHTOOL_A_TUNNEL_UDP_TABLE_ENTRY = 3,
	__ETHTOOL_A_TUNNEL_UDP_TABLE_CNT = 4,
	ETHTOOL_A_TUNNEL_UDP_TABLE_MAX = 3,
};

enum {
	ETHTOOL_A_TUNNEL_UDP_UNSPEC = 0,
	ETHTOOL_A_TUNNEL_UDP_TABLE = 1,
	__ETHTOOL_A_TUNNEL_UDP_CNT = 2,
	ETHTOOL_A_TUNNEL_UDP_MAX = 1,
};

enum udp_parsable_tunnel_type {
	UDP_TUNNEL_TYPE_VXLAN = 1,
	UDP_TUNNEL_TYPE_GENEVE = 2,
	UDP_TUNNEL_TYPE_VXLAN_GPE = 4,
};

enum udp_tunnel_nic_info_flags {
	UDP_TUNNEL_NIC_INFO_MAY_SLEEP = 1,
	UDP_TUNNEL_NIC_INFO_OPEN_ONLY = 2,
	UDP_TUNNEL_NIC_INFO_IPV4_ONLY = 4,
	UDP_TUNNEL_NIC_INFO_STATIC_IANA_VXLAN = 8,
};

struct udp_tunnel_nic_ops {
	void (*get_port)(struct net_device *, unsigned int, unsigned int, struct udp_tunnel_info *);
	void (*set_port_priv)(struct net_device *, unsigned int, unsigned int, u8);
	void (*add_port)(struct net_device *, struct udp_tunnel_info *);
	void (*del_port)(struct net_device *, struct udp_tunnel_info *);
	void (*reset_ntf)(struct net_device *);
	size_t (*dump_size)(struct net_device *, unsigned int);
	int (*dump_write)(struct net_device *, unsigned int, struct sk_buff *);
};

struct ethnl_tunnel_info_dump_ctx {
	struct ethnl_req_info req_info;
	int pos_hash;
	int pos_idx;
};

struct ip_mreqn {
	struct in_addr imr_multiaddr;
	struct in_addr imr_address;
	int imr_ifindex;
};

struct rtmsg {
	unsigned char rtm_family;
	unsigned char rtm_dst_len;
	unsigned char rtm_src_len;
	unsigned char rtm_tos;
	unsigned char rtm_table;
	unsigned char rtm_protocol;
	unsigned char rtm_scope;
	unsigned char rtm_type;
	unsigned int rtm_flags;
};

struct rtvia {
	__kernel_sa_family_t rtvia_family;
	__u8 rtvia_addr[0];
};

struct ip_sf_list;

struct ip_mc_list {
	struct in_device *interface;
	__be32 multiaddr;
	unsigned int sfmode;
	struct ip_sf_list *sources;
	struct ip_sf_list *tomb;
	long unsigned int sfcount[2];
	union {
		struct ip_mc_list *next;
		struct ip_mc_list *next_rcu;
	};
	struct ip_mc_list *next_hash;
	struct timer_list timer;
	int users;
	refcount_t refcnt;
	spinlock_t lock;
	char tm_running;
	char reporter;
	char unsolicit_count;
	char loaded;
	unsigned char gsquery;
	unsigned char crcount;
	struct callback_head rcu;
};

struct ip_sf_socklist {
	unsigned int sl_max;
	unsigned int sl_count;
	struct callback_head rcu;
	__be32 sl_addr[0];
};

struct ip_mc_socklist {
	struct ip_mc_socklist *next_rcu;
	struct ip_mreqn multi;
	unsigned int sfmode;
	struct ip_sf_socklist *sflist;
	struct callback_head rcu;
};

struct ip_sf_list {
	struct ip_sf_list *sf_next;
	long unsigned int sf_count[2];
	__be32 sf_inaddr;
	unsigned char sf_gsresp;
	unsigned char sf_oldin;
	unsigned char sf_crcount;
};

struct ipv4_addr_key {
	__be32 addr;
	int vif;
};

struct inetpeer_addr {
	union {
		struct ipv4_addr_key a4;
		struct in6_addr a6;
		u32 key[4];
	};
	__u16 family;
};

struct inet_peer {
	struct rb_node rb_node;
	struct inetpeer_addr daddr;
	u32 metrics[17];
	u32 rate_tokens;
	u32 n_redirects;
	long unsigned int rate_last;
	union {
		struct {
			atomic_t rid;
		};
		struct callback_head rcu;
	};
	__u32 dtime;
	refcount_t refcnt;
};

struct fib_rt_info {
	struct fib_info *fi;
	u32 tb_id;
	__be32 dst;
	int dst_len;
	u8 tos;
	u8 type;
	u8 offload: 1;
	u8 trap: 1;
	u8 unused: 6;
};

struct uncached_list {
	spinlock_t lock;
	struct list_head head;
};

struct rt_cache_stat {
	unsigned int in_slow_tot;
	unsigned int in_slow_mc;
	unsigned int in_no_route;
	unsigned int in_brd;
	unsigned int in_martian_dst;
	unsigned int in_martian_src;
	unsigned int out_slow_tot;
	unsigned int out_slow_mc;
};

struct fib_alias {
	struct hlist_node fa_list;
	struct fib_info *fa_info;
	u8 fa_tos;
	u8 fa_type;
	u8 fa_state;
	u8 fa_slen;
	u32 tb_id;
	s16 fa_default;
	u8 offload: 1;
	u8 trap: 1;
	u8 unused: 6;
	struct callback_head rcu;
};

struct fib_prop {
	int error;
	u8 scope;
};

struct net_offload {
	struct offload_callbacks callbacks;
	unsigned int flags;
};

struct raw_hashinfo {
	rwlock_t lock;
	struct hlist_head ht[256];
};

enum ip_defrag_users {
	IP_DEFRAG_LOCAL_DELIVER = 0,
	IP_DEFRAG_CALL_RA_CHAIN = 1,
	IP_DEFRAG_CONNTRACK_IN = 2,
	__IP_DEFRAG_CONNTRACK_IN_END = 65537,
	IP_DEFRAG_CONNTRACK_OUT = 65538,
	__IP_DEFRAG_CONNTRACK_OUT_END = 131073,
	IP_DEFRAG_CONNTRACK_BRIDGE_IN = 131074,
	__IP_DEFRAG_CONNTRACK_BRIDGE_IN = 196609,
	IP_DEFRAG_VS_IN = 196610,
	IP_DEFRAG_VS_OUT = 196611,
	IP_DEFRAG_VS_FWD = 196612,
	IP_DEFRAG_AF_PACKET = 196613,
	IP_DEFRAG_MACVLAN = 196614,
};

enum {
	INET_FRAG_FIRST_IN = 1,
	INET_FRAG_LAST_IN = 2,
	INET_FRAG_COMPLETE = 4,
	INET_FRAG_HASH_DEAD = 8,
};

struct ipq {
	struct inet_frag_queue q;
	u8 ecn;
	u16 max_df_size;
	int iif;
	unsigned int rid;
	struct inet_peer *peer;
};

typedef union {
	__be32 a4;
	__be32 a6[4];
	struct in6_addr in6;
} xfrm_address_t;

struct xfrm_id {
	xfrm_address_t daddr;
	__be32 spi;
	__u8 proto;
};

struct xfrm_sec_ctx {
	__u8 ctx_doi;
	__u8 ctx_alg;
	__u16 ctx_len;
	__u32 ctx_sid;
	char ctx_str[0];
};

struct xfrm_selector {
	xfrm_address_t daddr;
	xfrm_address_t saddr;
	__be16 dport;
	__be16 dport_mask;
	__be16 sport;
	__be16 sport_mask;
	__u16 family;
	__u8 prefixlen_d;
	__u8 prefixlen_s;
	__u8 proto;
	int ifindex;
	__kernel_uid32_t user;
};

struct xfrm_lifetime_cfg {
	__u64 soft_byte_limit;
	__u64 hard_byte_limit;
	__u64 soft_packet_limit;
	__u64 hard_packet_limit;
	__u64 soft_add_expires_seconds;
	__u64 hard_add_expires_seconds;
	__u64 soft_use_expires_seconds;
	__u64 hard_use_expires_seconds;
};

struct xfrm_lifetime_cur {
	__u64 bytes;
	__u64 packets;
	__u64 add_time;
	__u64 use_time;
};

struct xfrm_replay_state {
	__u32 oseq;
	__u32 seq;
	__u32 bitmap;
};

struct xfrm_replay_state_esn {
	unsigned int bmp_len;
	__u32 oseq;
	__u32 seq;
	__u32 oseq_hi;
	__u32 seq_hi;
	__u32 replay_window;
	__u32 bmp[0];
};

struct xfrm_algo {
	char alg_name[64];
	unsigned int alg_key_len;
	char alg_key[0];
};

struct xfrm_algo_auth {
	char alg_name[64];
	unsigned int alg_key_len;
	unsigned int alg_trunc_len;
	char alg_key[0];
};

struct xfrm_algo_aead {
	char alg_name[64];
	unsigned int alg_key_len;
	unsigned int alg_icv_len;
	char alg_key[0];
};

struct xfrm_stats {
	__u32 replay_window;
	__u32 replay;
	__u32 integrity_failed;
};

struct xfrm_encap_tmpl {
	__u16 encap_type;
	__be16 encap_sport;
	__be16 encap_dport;
	xfrm_address_t encap_oa;
};

struct xfrm_mark {
	__u32 v;
	__u32 m;
};

struct xfrm_address_filter {
	xfrm_address_t saddr;
	xfrm_address_t daddr;
	__u16 family;
	__u8 splen;
	__u8 dplen;
};

struct xfrm_state_walk {
	struct list_head all;
	u8 state;
	u8 dying;
	u8 proto;
	u32 seq;
	struct xfrm_address_filter *filter;
};

struct xfrm_state_offload {
	struct net_device *dev;
	struct net_device *real_dev;
	long unsigned int offload_handle;
	unsigned int num_exthdrs;
	u8 flags;
};

struct xfrm_mode {
	u8 encap;
	u8 family;
	u8 flags;
};

struct xfrm_replay;

struct xfrm_type;

struct xfrm_type_offload;

struct xfrm_state {
	possible_net_t xs_net;
	union {
		struct hlist_node gclist;
		struct hlist_node bydst;
	};
	struct hlist_node bysrc;
	struct hlist_node byspi;
	refcount_t refcnt;
	spinlock_t lock;
	struct xfrm_id id;
	struct xfrm_selector sel;
	struct xfrm_mark mark;
	u32 if_id;
	u32 tfcpad;
	u32 genid;
	struct xfrm_state_walk km;
	struct {
		u32 reqid;
		u8 mode;
		u8 replay_window;
		u8 aalgo;
		u8 ealgo;
		u8 calgo;
		u8 flags;
		u16 family;
		xfrm_address_t saddr;
		int header_len;
		int trailer_len;
		u32 extra_flags;
		struct xfrm_mark smark;
	} props;
	struct xfrm_lifetime_cfg lft;
	struct xfrm_algo_auth *aalg;
	struct xfrm_algo *ealg;
	struct xfrm_algo *calg;
	struct xfrm_algo_aead *aead;
	const char *geniv;
	struct xfrm_encap_tmpl *encap;
	struct sock *encap_sk;
	xfrm_address_t *coaddr;
	struct xfrm_state *tunnel;
	atomic_t tunnel_users;
	struct xfrm_replay_state replay;
	struct xfrm_replay_state_esn *replay_esn;
	struct xfrm_replay_state preplay;
	struct xfrm_replay_state_esn *preplay_esn;
	const struct xfrm_replay *repl;
	u32 xflags;
	u32 replay_maxage;
	u32 replay_maxdiff;
	struct timer_list rtimer;
	struct xfrm_stats stats;
	struct xfrm_lifetime_cur curlft;
	struct hrtimer mtimer;
	struct xfrm_state_offload xso;
	long int saved_tmo;
	time64_t lastused;
	struct page_frag xfrag;
	const struct xfrm_type *type;
	struct xfrm_mode inner_mode;
	struct xfrm_mode inner_mode_iaf;
	struct xfrm_mode outer_mode;
	const struct xfrm_type_offload *type_offload;
	struct xfrm_sec_ctx *security;
	void *data;
};

struct xfrm_replay {
	void (*advance)(struct xfrm_state *, __be32);
	int (*check)(struct xfrm_state *, struct sk_buff *, __be32);
	int (*recheck)(struct xfrm_state *, struct sk_buff *, __be32);
	void (*notify)(struct xfrm_state *, int);
	int (*overflow)(struct xfrm_state *, struct sk_buff *);
};

struct xfrm_type {
	char *description;
	struct module *owner;
	u8 proto;
	u8 flags;
	int (*init_state)(struct xfrm_state *);
	void (*destructor)(struct xfrm_state *);
	int (*input)(struct xfrm_state *, struct sk_buff *);
	int (*output)(struct xfrm_state *, struct sk_buff *);
	int (*reject)(struct xfrm_state *, struct sk_buff *, const struct flowi *);
	int (*hdr_offset)(struct xfrm_state *, struct sk_buff *, u8 **);
};

struct xfrm_type_offload {
	char *description;
	struct module *owner;
	u8 proto;
	void (*encap)(struct xfrm_state *, struct sk_buff *);
	int (*input_tail)(struct xfrm_state *, struct sk_buff *);
	int (*xmit)(struct xfrm_state *, struct sk_buff *, netdev_features_t);
};

struct sec_path {
	int len;
	int olen;
	struct xfrm_state *xvec[6];
	struct xfrm_offload ovec[1];
};

struct ip_options_data {
	struct ip_options_rcu opt;
	char data[40];
};

enum {
	LWTUNNEL_XMIT_DONE = 0,
	LWTUNNEL_XMIT_CONTINUE = 1,
};

struct ipcm_cookie {
	struct sockcm_cookie sockc;
	__be32 addr;
	int oif;
	struct ip_options_rcu *opt;
	__u8 ttl;
	__s16 tos;
	char priority;
	__u16 gso_size;
};

struct ip_fraglist_iter {
	struct sk_buff *frag;
	struct iphdr *iph;
	int offset;
	unsigned int hlen;
};

struct ip_frag_state {
	bool DF;
	unsigned int hlen;
	unsigned int ll_rs;
	unsigned int mtu;
	unsigned int left;
	int offset;
	int ptr;
	__be16 not_last_frag;
};

struct ip_reply_arg {
	struct kvec iov[1];
	int flags;
	__wsum csum;
	int csumoffset;
	int bound_dev_if;
	u8 tos;
	kuid_t uid;
};

struct ip_mreq_source {
	__be32 imr_multiaddr;
	__be32 imr_interface;
	__be32 imr_sourceaddr;
};

struct ip_msfilter {
	__be32 imsf_multiaddr;
	__be32 imsf_interface;
	__u32 imsf_fmode;
	__u32 imsf_numsrc;
	__be32 imsf_slist[1];
};

struct group_req {
	__u32 gr_interface;
	struct __kernel_sockaddr_storage gr_group;
};

struct group_source_req {
	__u32 gsr_interface;
	struct __kernel_sockaddr_storage gsr_group;
	struct __kernel_sockaddr_storage gsr_source;
};

struct group_filter {
	__u32 gf_interface;
	struct __kernel_sockaddr_storage gf_group;
	__u32 gf_fmode;
	__u32 gf_numsrc;
	struct __kernel_sockaddr_storage gf_slist[1];
};

struct in_pktinfo {
	int ipi_ifindex;
	struct in_addr ipi_spec_dst;
	struct in_addr ipi_addr;
};

struct compat_group_req {
	__u32 gr_interface;
	struct __kernel_sockaddr_storage gr_group;
} __attribute__((packed));

struct compat_group_source_req {
	__u32 gsr_interface;
	struct __kernel_sockaddr_storage gsr_group;
	struct __kernel_sockaddr_storage gsr_source;
} __attribute__((packed));

struct compat_group_filter {
	__u32 gf_interface;
	struct __kernel_sockaddr_storage gf_group;
	__u32 gf_fmode;
	__u32 gf_numsrc;
	struct __kernel_sockaddr_storage gf_slist[1];
} __attribute__((packed));

struct tcpvegas_info {
	__u32 tcpv_enabled;
	__u32 tcpv_rttcnt;
	__u32 tcpv_rtt;
	__u32 tcpv_minrtt;
};

struct tcp_dctcp_info {
	__u16 dctcp_enabled;
	__u16 dctcp_ce_state;
	__u32 dctcp_alpha;
	__u32 dctcp_ab_ecn;
	__u32 dctcp_ab_tot;
};

struct tcp_bbr_info {
	__u32 bbr_bw_lo;
	__u32 bbr_bw_hi;
	__u32 bbr_min_rtt;
	__u32 bbr_pacing_gain;
	__u32 bbr_cwnd_gain;
};

union tcp_cc_info {
	struct tcpvegas_info vegas;
	struct tcp_dctcp_info dctcp;
	struct tcp_bbr_info bbr;
};

enum {
	BPF_TCP_ESTABLISHED = 1,
	BPF_TCP_SYN_SENT = 2,
	BPF_TCP_SYN_RECV = 3,
	BPF_TCP_FIN_WAIT1 = 4,
	BPF_TCP_FIN_WAIT2 = 5,
	BPF_TCP_TIME_WAIT = 6,
	BPF_TCP_CLOSE = 7,
	BPF_TCP_CLOSE_WAIT = 8,
	BPF_TCP_LAST_ACK = 9,
	BPF_TCP_LISTEN = 10,
	BPF_TCP_CLOSING = 11,
	BPF_TCP_NEW_SYN_RECV = 12,
	BPF_TCP_MAX_STATES = 13,
};

enum inet_csk_ack_state_t {
	ICSK_ACK_SCHED = 1,
	ICSK_ACK_TIMER = 2,
	ICSK_ACK_PUSHED = 4,
	ICSK_ACK_PUSHED2 = 8,
	ICSK_ACK_NOW = 16,
};

enum {
	TCP_FLAG_CWR = 32768,
	TCP_FLAG_ECE = 16384,
	TCP_FLAG_URG = 8192,
	TCP_FLAG_ACK = 4096,
	TCP_FLAG_PSH = 2048,
	TCP_FLAG_RST = 1024,
	TCP_FLAG_SYN = 512,
	TCP_FLAG_FIN = 256,
	TCP_RESERVED_BITS = 15,
	TCP_DATA_OFFSET = 240,
};

struct tcp_repair_opt {
	__u32 opt_code;
	__u32 opt_val;
};

struct tcp_repair_window {
	__u32 snd_wl1;
	__u32 snd_wnd;
	__u32 max_window;
	__u32 rcv_wnd;
	__u32 rcv_wup;
};

enum {
	TCP_NO_QUEUE = 0,
	TCP_RECV_QUEUE = 1,
	TCP_SEND_QUEUE = 2,
	TCP_QUEUES_NR = 3,
};

struct tcp_info {
	__u8 tcpi_state;
	__u8 tcpi_ca_state;
	__u8 tcpi_retransmits;
	__u8 tcpi_probes;
	__u8 tcpi_backoff;
	__u8 tcpi_options;
	__u8 tcpi_snd_wscale: 4;
	__u8 tcpi_rcv_wscale: 4;
	__u8 tcpi_delivery_rate_app_limited: 1;
	__u8 tcpi_fastopen_client_fail: 2;
	__u32 tcpi_rto;
	__u32 tcpi_ato;
	__u32 tcpi_snd_mss;
	__u32 tcpi_rcv_mss;
	__u32 tcpi_unacked;
	__u32 tcpi_sacked;
	__u32 tcpi_lost;
	__u32 tcpi_retrans;
	__u32 tcpi_fackets;
	__u32 tcpi_last_data_sent;
	__u32 tcpi_last_ack_sent;
	__u32 tcpi_last_data_recv;
	__u32 tcpi_last_ack_recv;
	__u32 tcpi_pmtu;
	__u32 tcpi_rcv_ssthresh;
	__u32 tcpi_rtt;
	__u32 tcpi_rttvar;
	__u32 tcpi_snd_ssthresh;
	__u32 tcpi_snd_cwnd;
	__u32 tcpi_advmss;
	__u32 tcpi_reordering;
	__u32 tcpi_rcv_rtt;
	__u32 tcpi_rcv_space;
	__u32 tcpi_total_retrans;
	__u64 tcpi_pacing_rate;
	__u64 tcpi_max_pacing_rate;
	__u64 tcpi_bytes_acked;
	__u64 tcpi_bytes_received;
	__u32 tcpi_segs_out;
	__u32 tcpi_segs_in;
	__u32 tcpi_notsent_bytes;
	__u32 tcpi_min_rtt;
	__u32 tcpi_data_segs_in;
	__u32 tcpi_data_segs_out;
	__u64 tcpi_delivery_rate;
	__u64 tcpi_busy_time;
	__u64 tcpi_rwnd_limited;
	__u64 tcpi_sndbuf_limited;
	__u32 tcpi_delivered;
	__u32 tcpi_delivered_ce;
	__u64 tcpi_bytes_sent;
	__u64 tcpi_bytes_retrans;
	__u32 tcpi_dsack_dups;
	__u32 tcpi_reord_seen;
	__u32 tcpi_rcv_ooopack;
	__u32 tcpi_snd_wnd;
};

enum {
	TCP_NLA_PAD = 0,
	TCP_NLA_BUSY = 1,
	TCP_NLA_RWND_LIMITED = 2,
	TCP_NLA_SNDBUF_LIMITED = 3,
	TCP_NLA_DATA_SEGS_OUT = 4,
	TCP_NLA_TOTAL_RETRANS = 5,
	TCP_NLA_PACING_RATE = 6,
	TCP_NLA_DELIVERY_RATE = 7,
	TCP_NLA_SND_CWND = 8,
	TCP_NLA_REORDERING = 9,
	TCP_NLA_MIN_RTT = 10,
	TCP_NLA_RECUR_RETRANS = 11,
	TCP_NLA_DELIVERY_RATE_APP_LMT = 12,
	TCP_NLA_SNDQ_SIZE = 13,
	TCP_NLA_CA_STATE = 14,
	TCP_NLA_SND_SSTHRESH = 15,
	TCP_NLA_DELIVERED = 16,
	TCP_NLA_DELIVERED_CE = 17,
	TCP_NLA_BYTES_SENT = 18,
	TCP_NLA_BYTES_RETRANS = 19,
	TCP_NLA_DSACK_DUPS = 20,
	TCP_NLA_REORD_SEEN = 21,
	TCP_NLA_SRTT = 22,
	TCP_NLA_TIMEOUT_REHASH = 23,
	TCP_NLA_BYTES_NOTSENT = 24,
	TCP_NLA_EDT = 25,
};

struct tcp_zerocopy_receive {
	__u64 address;
	__u32 length;
	__u32 recv_skip_hint;
	__u32 inq;
	__s32 err;
	__u64 copybuf_address;
	__s32 copybuf_len;
};

enum tcp_chrono {
	TCP_CHRONO_UNSPEC = 0,
	TCP_CHRONO_BUSY = 1,
	TCP_CHRONO_RWND_LIMITED = 2,
	TCP_CHRONO_SNDBUF_LIMITED = 3,
	__TCP_CHRONO_MAX = 4,
};

struct tcp_splice_state {
	struct pipe_inode_info *pipe;
	size_t len;
	unsigned int flags;
};

enum tcp_fastopen_client_fail {
	TFO_STATUS_UNSPEC = 0,
	TFO_COOKIE_UNAVAILABLE = 1,
	TFO_DATA_NOT_ACKED = 2,
	TFO_SYN_RETRANSMITTED = 3,
};

struct tcp_sack_block_wire {
	__be32 start_seq;
	__be32 end_seq;
};

enum tcp_queue {
	TCP_FRAG_IN_WRITE_QUEUE = 0,
	TCP_FRAG_IN_RTX_QUEUE = 1,
};

enum tcp_ca_ack_event_flags {
	CA_ACK_SLOWPATH = 1,
	CA_ACK_WIN_UPDATE = 2,
	CA_ACK_ECE = 4,
};

struct tcp_sacktag_state {
	u64 first_sackt;
	u64 last_sackt;
	u32 reord;
	u32 sack_delivered;
	int flag;
	unsigned int mss_now;
	struct rate_sample *rate;
};

enum tsq_flags {
	TSQF_THROTTLED = 1,
	TSQF_QUEUED = 2,
	TCPF_TSQ_DEFERRED = 4,
	TCPF_WRITE_TIMER_DEFERRED = 8,
	TCPF_DELACK_TIMER_DEFERRED = 16,
	TCPF_MTU_REDUCED_DEFERRED = 32,
};

struct mptcp_out_options {};

union tcp_md5_addr {
	struct in_addr a4;
	struct in6_addr a6;
};

struct tcp_md5sig_key {
	struct hlist_node node;
	u8 keylen;
	u8 family;
	u8 prefixlen;
	union tcp_md5_addr addr;
	int l3index;
	u8 key[80];
	struct callback_head rcu;
};

struct tcp_out_options {
	u16 options;
	u16 mss;
	u8 ws;
	u8 num_sack_blocks;
	u8 hash_size;
	u8 bpf_opt_len;
	__u8 *hash_location;
	__u32 tsval;
	__u32 tsecr;
	struct tcp_fastopen_cookie *fastopen_cookie;
	struct mptcp_out_options mptcp;
};

struct tsq_tasklet {
	struct tasklet_struct tasklet;
	struct list_head head;
};

struct icmp_err {
	int errno;
	unsigned int fatal: 1;
};

enum tcp_tw_status {
	TCP_TW_SUCCESS = 0,
	TCP_TW_RST = 1,
	TCP_TW_ACK = 2,
	TCP_TW_SYN = 3,
};

enum tcp_seq_states {
	TCP_SEQ_STATE_LISTENING = 0,
	TCP_SEQ_STATE_ESTABLISHED = 1,
};

struct tcp_seq_afinfo {
	sa_family_t family;
};

struct tcp_iter_state {
	struct seq_net_private p;
	enum tcp_seq_states state;
	struct sock *syn_wait_sk;
	struct tcp_seq_afinfo *bpf_seq_afinfo;
	int bucket;
	int offset;
	int sbucket;
	int num;
	loff_t last_pos;
};

struct bpf_iter__tcp {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct sock_common *sk_common;
	};
	uid_t uid;
};

enum tcp_metric_index {
	TCP_METRIC_RTT = 0,
	TCP_METRIC_RTTVAR = 1,
	TCP_METRIC_SSTHRESH = 2,
	TCP_METRIC_CWND = 3,
	TCP_METRIC_REORDERING = 4,
	TCP_METRIC_RTT_US = 5,
	TCP_METRIC_RTTVAR_US = 6,
	__TCP_METRIC_MAX = 7,
};

enum {
	TCP_METRICS_ATTR_UNSPEC = 0,
	TCP_METRICS_ATTR_ADDR_IPV4 = 1,
	TCP_METRICS_ATTR_ADDR_IPV6 = 2,
	TCP_METRICS_ATTR_AGE = 3,
	TCP_METRICS_ATTR_TW_TSVAL = 4,
	TCP_METRICS_ATTR_TW_TS_STAMP = 5,
	TCP_METRICS_ATTR_VALS = 6,
	TCP_METRICS_ATTR_FOPEN_MSS = 7,
	TCP_METRICS_ATTR_FOPEN_SYN_DROPS = 8,
	TCP_METRICS_ATTR_FOPEN_SYN_DROP_TS = 9,
	TCP_METRICS_ATTR_FOPEN_COOKIE = 10,
	TCP_METRICS_ATTR_SADDR_IPV4 = 11,
	TCP_METRICS_ATTR_SADDR_IPV6 = 12,
	TCP_METRICS_ATTR_PAD = 13,
	__TCP_METRICS_ATTR_MAX = 14,
};

enum {
	TCP_METRICS_CMD_UNSPEC = 0,
	TCP_METRICS_CMD_GET = 1,
	TCP_METRICS_CMD_DEL = 2,
	__TCP_METRICS_CMD_MAX = 3,
};

struct tcp_fastopen_metrics {
	u16 mss;
	u16 syn_loss: 10;
	u16 try_exp: 2;
	long unsigned int last_syn_loss;
	struct tcp_fastopen_cookie cookie;
};

struct tcp_metrics_block {
	struct tcp_metrics_block *tcpm_next;
	possible_net_t tcpm_net;
	struct inetpeer_addr tcpm_saddr;
	struct inetpeer_addr tcpm_daddr;
	long unsigned int tcpm_stamp;
	u32 tcpm_lock;
	u32 tcpm_vals[5];
	struct tcp_fastopen_metrics tcpm_fastopen;
	struct callback_head callback_head;
};

struct tcpm_hash_bucket {
	struct tcp_metrics_block *chain;
};

struct icmp_filter {
	__u32 data;
};

struct raw_iter_state {
	struct seq_net_private p;
	int bucket;
};

struct raw_sock {
	struct inet_sock inet;
	struct icmp_filter filter;
	u32 ipmr_table;
};

struct raw_frag_vec {
	struct msghdr *msg;
	union {
		struct icmphdr icmph;
		char c[1];
	} hdr;
	int hlen;
};

struct ip_tunnel_encap {
	u16 type;
	u16 flags;
	__be16 sport;
	__be16 dport;
};

struct ip_tunnel_encap_ops {
	size_t (*encap_hlen)(struct ip_tunnel_encap *);
	int (*build_header)(struct sk_buff *, struct ip_tunnel_encap *, u8 *, struct flowi4 *);
	int (*err_handler)(struct sk_buff *, u32);
};

struct udp_skb_cb {
	union {
		struct inet_skb_parm h4;
		struct inet6_skb_parm h6;
	} header;
	__u16 cscov;
	__u8 partial_cov;
};

struct udp_dev_scratch {
	u32 _tsize_state;
	u16 len;
	bool is_linear;
	bool csum_unnecessary;
};

struct udp_seq_afinfo {
	sa_family_t family;
	struct udp_table *udp_table;
};

struct udp_iter_state {
	struct seq_net_private p;
	int bucket;
	struct udp_seq_afinfo *bpf_seq_afinfo;
};

struct bpf_iter__udp {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct udp_sock *udp_sk;
	};
	uid_t uid;
	int: 32;
	int bucket;
};

struct inet_protosw {
	struct list_head list;
	short unsigned int type;
	short unsigned int protocol;
	struct proto *prot;
	const struct proto_ops *ops;
	unsigned char flags;
};

typedef struct sk_buff * (*gro_receive_sk_t)(struct sock *, struct list_head *, struct sk_buff *);

typedef struct sock * (*udp_lookup_t)(struct sk_buff *, __be16, __be16);

struct xfrm_state;

struct arpreq {
	struct sockaddr arp_pa;
	struct sockaddr arp_ha;
	int arp_flags;
	struct sockaddr arp_netmask;
	char arp_dev[16];
};

enum {
	XFRM_LOOKUP_ICMP = 1,
	XFRM_LOOKUP_QUEUE = 2,
	XFRM_LOOKUP_KEEP_DST_REF = 4,
};

struct icmp_ext_hdr {
	__u8 reserved1: 4;
	__u8 version: 4;
	__u8 reserved2;
	__sum16 checksum;
};

struct icmp_extobj_hdr {
	__be16 length;
	__u8 class_num;
	__u8 class_type;
};

struct icmp_bxm {
	struct sk_buff *skb;
	int offset;
	int data_len;
	struct {
		struct icmphdr icmph;
		__be32 times[3];
	} data;
	int head_len;
	struct ip_options_data replyopts;
};

struct icmp_control {
	bool (*handler)(struct sk_buff *);
	short int error;
};

struct ifaddrmsg {
	__u8 ifa_family;
	__u8 ifa_prefixlen;
	__u8 ifa_flags;
	__u8 ifa_scope;
	__u32 ifa_index;
};

enum {
	IFA_UNSPEC = 0,
	IFA_ADDRESS = 1,
	IFA_LOCAL = 2,
	IFA_LABEL = 3,
	IFA_BROADCAST = 4,
	IFA_ANYCAST = 5,
	IFA_CACHEINFO = 6,
	IFA_MULTICAST = 7,
	IFA_FLAGS = 8,
	IFA_RT_PRIORITY = 9,
	IFA_TARGET_NETNSID = 10,
	__IFA_MAX = 11,
};

struct ifa_cacheinfo {
	__u32 ifa_prefered;
	__u32 ifa_valid;
	__u32 cstamp;
	__u32 tstamp;
};

enum {
	IFLA_INET_UNSPEC = 0,
	IFLA_INET_CONF = 1,
	__IFLA_INET_MAX = 2,
};

struct in_validator_info {
	__be32 ivi_addr;
	struct in_device *ivi_dev;
	struct netlink_ext_ack *extack;
};

struct netconfmsg {
	__u8 ncm_family;
};

enum {
	NETCONFA_UNSPEC = 0,
	NETCONFA_IFINDEX = 1,
	NETCONFA_FORWARDING = 2,
	NETCONFA_RP_FILTER = 3,
	NETCONFA_MC_FORWARDING = 4,
	NETCONFA_PROXY_NEIGH = 5,
	NETCONFA_IGNORE_ROUTES_WITH_LINKDOWN = 6,
	NETCONFA_INPUT = 7,
	NETCONFA_BC_FORWARDING = 8,
	__NETCONFA_MAX = 9,
};

struct inet_fill_args {
	u32 portid;
	u32 seq;
	int event;
	unsigned int flags;
	int netnsid;
	int ifindex;
};

struct devinet_sysctl_table {
	struct ctl_table_header *sysctl_header;
	struct ctl_table devinet_vars[33];
};

struct rtentry {
	long unsigned int rt_pad1;
	struct sockaddr rt_dst;
	struct sockaddr rt_gateway;
	struct sockaddr rt_genmask;
	short unsigned int rt_flags;
	short int rt_pad2;
	long unsigned int rt_pad3;
	void *rt_pad4;
	short int rt_metric;
	char *rt_dev;
	long unsigned int rt_mtu;
	long unsigned int rt_window;
	short unsigned int rt_irtt;
};

struct pingv6_ops {
	int (*ipv6_recv_error)(struct sock *, struct msghdr *, int, int *);
	void (*ip6_datagram_recv_common_ctl)(struct sock *, struct msghdr *, struct sk_buff *);
	void (*ip6_datagram_recv_specific_ctl)(struct sock *, struct msghdr *, struct sk_buff *);
	int (*icmpv6_err_convert)(u8, u8, int *);
	void (*ipv6_icmp_error)(struct sock *, struct sk_buff *, int, __be16, u32, u8 *);
	int (*ipv6_chk_addr)(struct net *, const struct in6_addr *, const struct net_device *, int);
};

struct igmphdr {
	__u8 type;
	__u8 code;
	__sum16 csum;
	__be32 group;
};

struct igmpv3_grec {
	__u8 grec_type;
	__u8 grec_auxwords;
	__be16 grec_nsrcs;
	__be32 grec_mca;
	__be32 grec_src[0];
};

struct igmpv3_report {
	__u8 type;
	__u8 resv1;
	__sum16 csum;
	__be16 resv2;
	__be16 ngrec;
	struct igmpv3_grec grec[0];
};

struct igmpv3_query {
	__u8 type;
	__u8 code;
	__sum16 csum;
	__be32 group;
	__u8 qrv: 3;
	__u8 suppress: 1;
	__u8 resv: 4;
	__u8 qqic;
	__be16 nsrcs;
	__be32 srcs[0];
};

struct igmp_mc_iter_state {
	struct seq_net_private p;
	struct net_device *dev;
	struct in_device *in_dev;
};

struct igmp_mcf_iter_state {
	struct seq_net_private p;
	struct net_device *dev;
	struct in_device *idev;
	struct ip_mc_list *im;
};

struct rtnexthop {
	short unsigned int rtnh_len;
	unsigned char rtnh_flags;
	unsigned char rtnh_hops;
	int rtnh_ifindex;
};

struct fib_config {
	u8 fc_dst_len;
	u8 fc_tos;
	u8 fc_protocol;
	u8 fc_scope;
	u8 fc_type;
	u8 fc_gw_family;
	u32 fc_table;
	__be32 fc_dst;
	union {
		__be32 fc_gw4;
		struct in6_addr fc_gw6;
	};
	int fc_oif;
	u32 fc_flags;
	u32 fc_priority;
	__be32 fc_prefsrc;
	u32 fc_nh_id;
	struct nlattr *fc_mx;
	struct rtnexthop *fc_mp;
	int fc_mx_len;
	int fc_mp_len;
	u32 fc_flow;
	u32 fc_nlflags;
	struct nl_info fc_nlinfo;
	struct nlattr *fc_encap;
	u16 fc_encap_type;
};

struct fib_result_nl {
	__be32 fl_addr;
	u32 fl_mark;
	unsigned char fl_tos;
	unsigned char fl_scope;
	unsigned char tb_id_in;
	unsigned char tb_id;
	unsigned char prefixlen;
	unsigned char nh_sel;
	unsigned char type;
	unsigned char scope;
	int err;
};

struct fib_dump_filter {
	u32 table_id;
	bool filter_set;
	bool dump_routes;
	bool dump_exceptions;
	unsigned char protocol;
	unsigned char rt_type;
	unsigned int flags;
	struct net_device *dev;
};

struct fib_nh_notifier_info {
	struct fib_notifier_info info;
	struct fib_nh *fib_nh;
};

struct fib_entry_notifier_info {
	struct fib_notifier_info info;
	u32 dst;
	int dst_len;
	struct fib_info *fi;
	u8 tos;
	u8 type;
	u32 tb_id;
};

typedef unsigned int t_key;

struct key_vector {
	t_key key;
	unsigned char pos;
	unsigned char bits;
	unsigned char slen;
	union {
		struct hlist_head leaf;
		struct key_vector *tnode[0];
	};
};

struct tnode {
	struct callback_head rcu;
	t_key empty_children;
	t_key full_children;
	struct key_vector *parent;
	struct key_vector kv[1];
};

struct trie_stat {
	unsigned int totdepth;
	unsigned int maxdepth;
	unsigned int tnodes;
	unsigned int leaves;
	unsigned int nullpointers;
	unsigned int prefixes;
	unsigned int nodesizes[32];
};

struct trie {
	struct key_vector kv[1];
};

struct fib_trie_iter {
	struct seq_net_private p;
	struct fib_table *tb;
	struct key_vector *tnode;
	unsigned int index;
	unsigned int depth;
};

struct fib_route_iter {
	struct seq_net_private p;
	struct fib_table *main_tb;
	struct key_vector *tnode;
	loff_t pos;
	t_key key;
};

struct ipfrag_skb_cb {
	union {
		struct inet_skb_parm h4;
		struct inet6_skb_parm h6;
	};
	struct sk_buff *next_frag;
	int frag_run_len;
};

struct ping_iter_state {
	struct seq_net_private p;
	int bucket;
	sa_family_t family;
};

struct pingfakehdr {
	struct icmphdr icmph;
	struct msghdr *msg;
	sa_family_t family;
	__wsum wcheck;
};

struct ping_table {
	struct hlist_nulls_head hash[64];
	rwlock_t lock;
};

enum lwtunnel_ip_t {
	LWTUNNEL_IP_UNSPEC = 0,
	LWTUNNEL_IP_ID = 1,
	LWTUNNEL_IP_DST = 2,
	LWTUNNEL_IP_SRC = 3,
	LWTUNNEL_IP_TTL = 4,
	LWTUNNEL_IP_TOS = 5,
	LWTUNNEL_IP_FLAGS = 6,
	LWTUNNEL_IP_PAD = 7,
	LWTUNNEL_IP_OPTS = 8,
	__LWTUNNEL_IP_MAX = 9,
};

enum lwtunnel_ip6_t {
	LWTUNNEL_IP6_UNSPEC = 0,
	LWTUNNEL_IP6_ID = 1,
	LWTUNNEL_IP6_DST = 2,
	LWTUNNEL_IP6_SRC = 3,
	LWTUNNEL_IP6_HOPLIMIT = 4,
	LWTUNNEL_IP6_TC = 5,
	LWTUNNEL_IP6_FLAGS = 6,
	LWTUNNEL_IP6_PAD = 7,
	LWTUNNEL_IP6_OPTS = 8,
	__LWTUNNEL_IP6_MAX = 9,
};

enum {
	LWTUNNEL_IP_OPTS_UNSPEC = 0,
	LWTUNNEL_IP_OPTS_GENEVE = 1,
	LWTUNNEL_IP_OPTS_VXLAN = 2,
	LWTUNNEL_IP_OPTS_ERSPAN = 3,
	__LWTUNNEL_IP_OPTS_MAX = 4,
};

enum {
	LWTUNNEL_IP_OPT_GENEVE_UNSPEC = 0,
	LWTUNNEL_IP_OPT_GENEVE_CLASS = 1,
	LWTUNNEL_IP_OPT_GENEVE_TYPE = 2,
	LWTUNNEL_IP_OPT_GENEVE_DATA = 3,
	__LWTUNNEL_IP_OPT_GENEVE_MAX = 4,
};

enum {
	LWTUNNEL_IP_OPT_VXLAN_UNSPEC = 0,
	LWTUNNEL_IP_OPT_VXLAN_GBP = 1,
	__LWTUNNEL_IP_OPT_VXLAN_MAX = 2,
};

enum {
	LWTUNNEL_IP_OPT_ERSPAN_UNSPEC = 0,
	LWTUNNEL_IP_OPT_ERSPAN_VER = 1,
	LWTUNNEL_IP_OPT_ERSPAN_INDEX = 2,
	LWTUNNEL_IP_OPT_ERSPAN_DIR = 3,
	LWTUNNEL_IP_OPT_ERSPAN_HWID = 4,
	__LWTUNNEL_IP_OPT_ERSPAN_MAX = 5,
};

struct lwtunnel_encap_ops {
	int (*build_state)(struct net *, struct nlattr *, unsigned int, const void *, struct lwtunnel_state **, struct netlink_ext_ack *);
	void (*destroy_state)(struct lwtunnel_state *);
	int (*output)(struct net *, struct sock *, struct sk_buff *);
	int (*input)(struct sk_buff *);
	int (*fill_encap)(struct sk_buff *, struct lwtunnel_state *);
	int (*get_encap_size)(struct lwtunnel_state *);
	int (*cmp_encap)(struct lwtunnel_state *, struct lwtunnel_state *);
	int (*xmit)(struct sk_buff *);
	struct module *owner;
};

struct ip6_tnl_encap_ops {
	size_t (*encap_hlen)(struct ip_tunnel_encap *);
	int (*build_header)(struct sk_buff *, struct ip_tunnel_encap *, u8 *, struct flowi6 *);
	int (*err_handler)(struct sk_buff *, struct inet6_skb_parm *, u8, u8, int, __be32);
};

struct geneve_opt {
	__be16 opt_class;
	u8 type;
	u8 length: 5;
	u8 r3: 1;
	u8 r2: 1;
	u8 r1: 1;
	u8 opt_data[0];
};

struct vxlan_metadata {
	u32 gbp;
};

struct erspan_md2 {
	__be32 timestamp;
	__be16 sgt;
	__u8 hwid_upper: 2;
	__u8 ft: 5;
	__u8 p: 1;
	__u8 o: 1;
	__u8 gra: 2;
	__u8 dir: 1;
	__u8 hwid: 4;
};

struct erspan_metadata {
	int version;
	union {
		__be32 index;
		struct erspan_md2 md2;
	} u;
};

struct nhmsg {
	unsigned char nh_family;
	unsigned char nh_scope;
	unsigned char nh_protocol;
	unsigned char resvd;
	unsigned int nh_flags;
};

struct nexthop_grp {
	__u32 id;
	__u8 weight;
	__u8 resvd1;
	__u16 resvd2;
};

enum {
	NEXTHOP_GRP_TYPE_MPATH = 0,
	__NEXTHOP_GRP_TYPE_MAX = 1,
};

enum {
	NHA_UNSPEC = 0,
	NHA_ID = 1,
	NHA_GROUP = 2,
	NHA_GROUP_TYPE = 3,
	NHA_BLACKHOLE = 4,
	NHA_OIF = 5,
	NHA_GATEWAY = 6,
	NHA_ENCAP_TYPE = 7,
	NHA_ENCAP = 8,
	NHA_GROUPS = 9,
	NHA_MASTER = 10,
	NHA_FDB = 11,
	__NHA_MAX = 12,
};

struct nh_config {
	u32 nh_id;
	u8 nh_family;
	u8 nh_protocol;
	u8 nh_blackhole;
	u8 nh_fdb;
	u32 nh_flags;
	int nh_ifindex;
	struct net_device *dev;
	union {
		__be32 ipv4;
		struct in6_addr ipv6;
	} gw;
	struct nlattr *nh_grp;
	u16 nh_grp_type;
	struct nlattr *nh_encap;
	u16 nh_encap_type;
	u32 nlflags;
	struct nl_info nlinfo;
};

enum nexthop_event_type {
	NEXTHOP_EVENT_DEL = 0,
};

enum tunnel_encap_types {
	TUNNEL_ENCAP_NONE = 0,
	TUNNEL_ENCAP_FOU = 1,
	TUNNEL_ENCAP_GUE = 2,
	TUNNEL_ENCAP_MPLS = 3,
};

struct ip_tunnel_prl_entry {
	struct ip_tunnel_prl_entry *next;
	__be32 addr;
	u16 flags;
	struct callback_head callback_head;
};

struct ip_tunnel {
	struct ip_tunnel *next;
	struct hlist_node hash_node;
	struct net_device *dev;
	struct net *net;
	long unsigned int err_time;
	int err_count;
	u32 i_seqno;
	u32 o_seqno;
	int tun_hlen;
	u32 index;
	u8 erspan_ver;
	u8 dir;
	u16 hwid;
	struct dst_cache dst_cache;
	struct ip_tunnel_parm parms;
	int mlink;
	int encap_hlen;
	int hlen;
	struct ip_tunnel_encap encap;
	struct ip_tunnel_prl_entry *prl;
	unsigned int prl_count;
	unsigned int ip_tnl_net_id;
	struct gro_cells gro_cells;
	__u32 fwmark;
	bool collect_md;
	bool ignore_df;
};

struct tnl_ptk_info {
	__be16 flags;
	__be16 proto;
	__be32 key;
	__be32 seq;
	int hdr_len;
};

struct ip_tunnel_net {
	struct net_device *fb_tunnel_dev;
	struct rtnl_link_ops *rtnl_link_ops;
	struct hlist_head tunnels[128];
	struct ip_tunnel *collect_md_tun;
	int type;
};

struct inet6_protocol {
	void (*early_demux)(struct sk_buff *);
	void (*early_demux_handler)(struct sk_buff *);
	int (*handler)(struct sk_buff *);
	int (*err_handler)(struct sk_buff *, struct inet6_skb_parm *, u8, u8, int, __be32);
	unsigned int flags;
};

struct snmp_mib {
	const char *name;
	int entry;
};

struct xfrm_tunnel {
	int (*handler)(struct sk_buff *);
	int (*cb_handler)(struct sk_buff *, int);
	int (*err_handler)(struct sk_buff *, u32);
	struct xfrm_tunnel *next;
	int priority;
};

struct ic_device {
	struct ic_device *next;
	struct net_device *dev;
	short unsigned int flags;
	short int able;
	__be32 xid;
};

struct bootp_pkt {
	struct iphdr iph;
	struct udphdr udph;
	u8 op;
	u8 htype;
	u8 hlen;
	u8 hops;
	__be32 xid;
	__be16 secs;
	__be16 flags;
	__be32 client_ip;
	__be32 your_ip;
	__be32 server_ip;
	__be32 relay_ip;
	u8 hw_addr[16];
	u8 serv_name[64];
	u8 boot_file[128];
	u8 exten[312];
};

struct inet_diag_sockid {
	__be16 idiag_sport;
	__be16 idiag_dport;
	__be32 idiag_src[4];
	__be32 idiag_dst[4];
	__u32 idiag_if;
	__u32 idiag_cookie[2];
};

struct inet_diag_req {
	__u8 idiag_family;
	__u8 idiag_src_len;
	__u8 idiag_dst_len;
	__u8 idiag_ext;
	struct inet_diag_sockid id;
	__u32 idiag_states;
	__u32 idiag_dbs;
};

struct inet_diag_req_v2 {
	__u8 sdiag_family;
	__u8 sdiag_protocol;
	__u8 idiag_ext;
	__u8 pad;
	__u32 idiag_states;
	struct inet_diag_sockid id;
};

struct inet_diag_bc_op {
	unsigned char code;
	unsigned char yes;
	short unsigned int no;
};

enum {
	INET_DIAG_BC_NOP = 0,
	INET_DIAG_BC_JMP = 1,
	INET_DIAG_BC_S_GE = 2,
	INET_DIAG_BC_S_LE = 3,
	INET_DIAG_BC_D_GE = 4,
	INET_DIAG_BC_D_LE = 5,
	INET_DIAG_BC_AUTO = 6,
	INET_DIAG_BC_S_COND = 7,
	INET_DIAG_BC_D_COND = 8,
	INET_DIAG_BC_DEV_COND = 9,
	INET_DIAG_BC_MARK_COND = 10,
	INET_DIAG_BC_S_EQ = 11,
	INET_DIAG_BC_D_EQ = 12,
	INET_DIAG_BC_CGROUP_COND = 13,
};

struct inet_diag_hostcond {
	__u8 family;
	__u8 prefix_len;
	int port;
	__be32 addr[0];
};

struct inet_diag_markcond {
	__u32 mark;
	__u32 mask;
};

struct inet_diag_msg {
	__u8 idiag_family;
	__u8 idiag_state;
	__u8 idiag_timer;
	__u8 idiag_retrans;
	struct inet_diag_sockid id;
	__u32 idiag_expires;
	__u32 idiag_rqueue;
	__u32 idiag_wqueue;
	__u32 idiag_uid;
	__u32 idiag_inode;
};

enum {
	INET_DIAG_NONE = 0,
	INET_DIAG_MEMINFO = 1,
	INET_DIAG_INFO = 2,
	INET_DIAG_VEGASINFO = 3,
	INET_DIAG_CONG = 4,
	INET_DIAG_TOS = 5,
	INET_DIAG_TCLASS = 6,
	INET_DIAG_SKMEMINFO = 7,
	INET_DIAG_SHUTDOWN = 8,
	INET_DIAG_DCTCPINFO = 9,
	INET_DIAG_PROTOCOL = 10,
	INET_DIAG_SKV6ONLY = 11,
	INET_DIAG_LOCALS = 12,
	INET_DIAG_PEERS = 13,
	INET_DIAG_PAD = 14,
	INET_DIAG_MARK = 15,
	INET_DIAG_BBRINFO = 16,
	INET_DIAG_CLASS_ID = 17,
	INET_DIAG_MD5SIG = 18,
	INET_DIAG_ULP_INFO = 19,
	INET_DIAG_SK_BPF_STORAGES = 20,
	INET_DIAG_CGROUP_ID = 21,
	INET_DIAG_SOCKOPT = 22,
	__INET_DIAG_MAX = 23,
};

struct inet_diag_meminfo {
	__u32 idiag_rmem;
	__u32 idiag_wmem;
	__u32 idiag_fmem;
	__u32 idiag_tmem;
};

struct inet_diag_sockopt {
	__u8 recverr: 1;
	__u8 is_icsk: 1;
	__u8 freebind: 1;
	__u8 hdrincl: 1;
	__u8 mc_loop: 1;
	__u8 transparent: 1;
	__u8 mc_all: 1;
	__u8 nodefrag: 1;
	__u8 bind_address_no_port: 1;
	__u8 recverr_rfc4884: 1;
	__u8 defer_connect: 1;
	__u8 unused: 5;
};

struct inet_diag_handler {
	void (*dump)(struct sk_buff *, struct netlink_callback *, const struct inet_diag_req_v2 *);
	int (*dump_one)(struct netlink_callback *, const struct inet_diag_req_v2 *);
	void (*idiag_get_info)(struct sock *, struct inet_diag_msg *, void *);
	int (*idiag_get_aux)(struct sock *, bool, struct sk_buff *);
	size_t (*idiag_get_aux_size)(struct sock *, bool);
	int (*destroy)(struct sk_buff *, const struct inet_diag_req_v2 *);
	__u16 idiag_type;
	__u16 idiag_info_size;
};

struct bpf_sk_storage_diag;

struct inet_diag_dump_data {
	struct nlattr *req_nlas[4];
	struct bpf_sk_storage_diag *bpf_stg_diag;
};

struct inet_diag_entry {
	const __be32 *saddr;
	const __be32 *daddr;
	u16 sport;
	u16 dport;
	u16 family;
	u16 userlocks;
	u32 ifindex;
	u32 mark;
};

enum {
	INET_ULP_INFO_UNSPEC = 0,
	INET_ULP_INFO_NAME = 1,
	INET_ULP_INFO_TLS = 2,
	INET_ULP_INFO_MPTCP = 3,
	__INET_ULP_INFO_MAX = 4,
};

struct bictcp {
	u32 cnt;
	u32 last_max_cwnd;
	u32 last_cwnd;
	u32 last_time;
	u32 bic_origin_point;
	u32 bic_K;
	u32 delay_min;
	u32 epoch_start;
	u32 ack_cnt;
	u32 tcp_cwnd;
	u16 unused;
	u8 sample_cnt;
	u8 found;
	u32 round_start;
	u32 end_seq;
	u32 last_ack;
	u32 curr_rtt;
};

typedef u64 (*btf_bpf_tcp_send_ack)(struct tcp_sock *, u32);

struct sockaddr_un {
	__kernel_sa_family_t sun_family;
	char sun_path[108];
};

struct unix_address {
	refcount_t refcnt;
	int len;
	unsigned int hash;
	struct sockaddr_un name[0];
};

struct scm_stat {
	atomic_t nr_fds;
};

struct unix_sock {
	struct sock sk;
	struct unix_address *addr;
	struct path path;
	struct mutex iolock;
	struct mutex bindlock;
	struct sock *peer;
	struct list_head link;
	atomic_long_t inflight;
	spinlock_t lock;
	long unsigned int gc_flags;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct socket_wq peer_wq;
	wait_queue_entry_t peer_wake;
	struct scm_stat scm_stat;
	long: 32;
	long: 64;
	long: 64;
};

struct unix_stream_read_state {
	int (*recv_actor)(struct sk_buff *, int, int, struct unix_stream_read_state *);
	struct socket *socket;
	struct msghdr *msg;
	struct pipe_inode_info *pipe;
	size_t size;
	int flags;
	unsigned int splice_flags;
};

struct ipv6_params {
	__s32 disable_ipv6;
	__s32 autoconf;
};

enum flowlabel_reflect {
	FLOWLABEL_REFLECT_ESTABLISHED = 1,
	FLOWLABEL_REFLECT_TCP_RESET = 2,
	FLOWLABEL_REFLECT_ICMPV6_ECHO_REPLIES = 4,
};

struct in6_rtmsg {
	struct in6_addr rtmsg_dst;
	struct in6_addr rtmsg_src;
	struct in6_addr rtmsg_gateway;
	__u32 rtmsg_type;
	__u16 rtmsg_dst_len;
	__u16 rtmsg_src_len;
	__u32 rtmsg_metric;
	long unsigned int rtmsg_info;
	__u32 rtmsg_flags;
	int rtmsg_ifindex;
};

struct ac6_iter_state {
	struct seq_net_private p;
	struct net_device *dev;
	struct inet6_dev *idev;
};

struct ip6_fraglist_iter {
	struct ipv6hdr *tmp_hdr;
	struct sk_buff *frag;
	int offset;
	unsigned int hlen;
	__be32 frag_id;
	u8 nexthdr;
};

struct ip6_frag_state {
	u8 *prevhdr;
	unsigned int hlen;
	unsigned int mtu;
	unsigned int left;
	int offset;
	int ptr;
	int hroom;
	int troom;
	__be32 frag_id;
	u8 nexthdr;
};

struct ip6_ra_chain {
	struct ip6_ra_chain *next;
	struct sock *sk;
	int sel;
	void (*destructor)(struct sock *);
};

struct ipcm6_cookie {
	struct sockcm_cookie sockc;
	__s16 hlimit;
	__s16 tclass;
	__s8 dontfrag;
	struct ipv6_txoptions *opt;
	__u16 gso_size;
};

enum {
	IFLA_INET6_UNSPEC = 0,
	IFLA_INET6_FLAGS = 1,
	IFLA_INET6_CONF = 2,
	IFLA_INET6_STATS = 3,
	IFLA_INET6_MCAST = 4,
	IFLA_INET6_CACHEINFO = 5,
	IFLA_INET6_ICMP6STATS = 6,
	IFLA_INET6_TOKEN = 7,
	IFLA_INET6_ADDR_GEN_MODE = 8,
	__IFLA_INET6_MAX = 9,
};

enum in6_addr_gen_mode {
	IN6_ADDR_GEN_MODE_EUI64 = 0,
	IN6_ADDR_GEN_MODE_NONE = 1,
	IN6_ADDR_GEN_MODE_STABLE_PRIVACY = 2,
	IN6_ADDR_GEN_MODE_RANDOM = 3,
};

struct ifla_cacheinfo {
	__u32 max_reasm_len;
	__u32 tstamp;
	__u32 reachable_time;
	__u32 retrans_time;
};

struct prefixmsg {
	unsigned char prefix_family;
	unsigned char prefix_pad1;
	short unsigned int prefix_pad2;
	int prefix_ifindex;
	unsigned char prefix_type;
	unsigned char prefix_len;
	unsigned char prefix_flags;
	unsigned char prefix_pad3;
};

enum {
	PREFIX_UNSPEC = 0,
	PREFIX_ADDRESS = 1,
	PREFIX_CACHEINFO = 2,
	__PREFIX_MAX = 3,
};

struct prefix_cacheinfo {
	__u32 preferred_time;
	__u32 valid_time;
};

struct in6_ifreq {
	struct in6_addr ifr6_addr;
	__u32 ifr6_prefixlen;
	int ifr6_ifindex;
};

enum {
	DEVCONF_FORWARDING = 0,
	DEVCONF_HOPLIMIT = 1,
	DEVCONF_MTU6 = 2,
	DEVCONF_ACCEPT_RA = 3,
	DEVCONF_ACCEPT_REDIRECTS = 4,
	DEVCONF_AUTOCONF = 5,
	DEVCONF_DAD_TRANSMITS = 6,
	DEVCONF_RTR_SOLICITS = 7,
	DEVCONF_RTR_SOLICIT_INTERVAL = 8,
	DEVCONF_RTR_SOLICIT_DELAY = 9,
	DEVCONF_USE_TEMPADDR = 10,
	DEVCONF_TEMP_VALID_LFT = 11,
	DEVCONF_TEMP_PREFERED_LFT = 12,
	DEVCONF_REGEN_MAX_RETRY = 13,
	DEVCONF_MAX_DESYNC_FACTOR = 14,
	DEVCONF_MAX_ADDRESSES = 15,
	DEVCONF_FORCE_MLD_VERSION = 16,
	DEVCONF_ACCEPT_RA_DEFRTR = 17,
	DEVCONF_ACCEPT_RA_PINFO = 18,
	DEVCONF_ACCEPT_RA_RTR_PREF = 19,
	DEVCONF_RTR_PROBE_INTERVAL = 20,
	DEVCONF_ACCEPT_RA_RT_INFO_MAX_PLEN = 21,
	DEVCONF_PROXY_NDP = 22,
	DEVCONF_OPTIMISTIC_DAD = 23,
	DEVCONF_ACCEPT_SOURCE_ROUTE = 24,
	DEVCONF_MC_FORWARDING = 25,
	DEVCONF_DISABLE_IPV6 = 26,
	DEVCONF_ACCEPT_DAD = 27,
	DEVCONF_FORCE_TLLAO = 28,
	DEVCONF_NDISC_NOTIFY = 29,
	DEVCONF_MLDV1_UNSOLICITED_REPORT_INTERVAL = 30,
	DEVCONF_MLDV2_UNSOLICITED_REPORT_INTERVAL = 31,
	DEVCONF_SUPPRESS_FRAG_NDISC = 32,
	DEVCONF_ACCEPT_RA_FROM_LOCAL = 33,
	DEVCONF_USE_OPTIMISTIC = 34,
	DEVCONF_ACCEPT_RA_MTU = 35,
	DEVCONF_STABLE_SECRET = 36,
	DEVCONF_USE_OIF_ADDRS_ONLY = 37,
	DEVCONF_ACCEPT_RA_MIN_HOP_LIMIT = 38,
	DEVCONF_IGNORE_ROUTES_WITH_LINKDOWN = 39,
	DEVCONF_DROP_UNICAST_IN_L2_MULTICAST = 40,
	DEVCONF_DROP_UNSOLICITED_NA = 41,
	DEVCONF_KEEP_ADDR_ON_DOWN = 42,
	DEVCONF_RTR_SOLICIT_MAX_INTERVAL = 43,
	DEVCONF_SEG6_ENABLED = 44,
	DEVCONF_SEG6_REQUIRE_HMAC = 45,
	DEVCONF_ENHANCED_DAD = 46,
	DEVCONF_ADDR_GEN_MODE = 47,
	DEVCONF_DISABLE_POLICY = 48,
	DEVCONF_ACCEPT_RA_RT_INFO_MIN_PLEN = 49,
	DEVCONF_NDISC_TCLASS = 50,
	DEVCONF_RPL_SEG_ENABLED = 51,
	DEVCONF_MAX = 52,
};

enum {
	INET6_IFADDR_STATE_PREDAD = 0,
	INET6_IFADDR_STATE_DAD = 1,
	INET6_IFADDR_STATE_POSTDAD = 2,
	INET6_IFADDR_STATE_ERRDAD = 3,
	INET6_IFADDR_STATE_DEAD = 4,
};

union fwnet_hwaddr {
	u8 u[16];
	struct {
		__be64 uniq_id;
		u8 max_rec;
		u8 sspd;
		__be16 fifo_hi;
		__be32 fifo_lo;
	} uc;
};

struct in6_validator_info {
	struct in6_addr i6vi_addr;
	struct inet6_dev *i6vi_dev;
	struct netlink_ext_ack *extack;
};

struct ifa6_config {
	const struct in6_addr *pfx;
	unsigned int plen;
	const struct in6_addr *peer_pfx;
	u32 rt_priority;
	u32 ifa_flags;
	u32 preferred_lft;
	u32 valid_lft;
	u16 scope;
};

enum cleanup_prefix_rt_t {
	CLEANUP_PREFIX_RT_NOP = 0,
	CLEANUP_PREFIX_RT_DEL = 1,
	CLEANUP_PREFIX_RT_EXPIRE = 2,
};

enum {
	IPV6_SADDR_RULE_INIT = 0,
	IPV6_SADDR_RULE_LOCAL = 1,
	IPV6_SADDR_RULE_SCOPE = 2,
	IPV6_SADDR_RULE_PREFERRED = 3,
	IPV6_SADDR_RULE_OIF = 4,
	IPV6_SADDR_RULE_LABEL = 5,
	IPV6_SADDR_RULE_PRIVACY = 6,
	IPV6_SADDR_RULE_ORCHID = 7,
	IPV6_SADDR_RULE_PREFIX = 8,
	IPV6_SADDR_RULE_MAX = 9,
};

struct ipv6_saddr_score {
	int rule;
	int addr_type;
	struct inet6_ifaddr *ifa;
	long unsigned int scorebits[1];
	int scopedist;
	int matchlen;
};

struct ipv6_saddr_dst {
	const struct in6_addr *addr;
	int ifindex;
	int scope;
	int label;
	unsigned int prefs;
};

struct if6_iter_state {
	struct seq_net_private p;
	int bucket;
	int offset;
};

enum addr_type_t {
	UNICAST_ADDR = 0,
	MULTICAST_ADDR = 1,
	ANYCAST_ADDR = 2,
};

struct inet6_fill_args {
	u32 portid;
	u32 seq;
	int event;
	unsigned int flags;
	int netnsid;
	int ifindex;
	enum addr_type_t type;
};

enum {
	DAD_PROCESS = 0,
	DAD_BEGIN = 1,
	DAD_ABORT = 2,
};

struct ifaddrlblmsg {
	__u8 ifal_family;
	__u8 __ifal_reserved;
	__u8 ifal_prefixlen;
	__u8 ifal_flags;
	__u32 ifal_index;
	__u32 ifal_seq;
};

enum {
	IFAL_ADDRESS = 1,
	IFAL_LABEL = 2,
	__IFAL_MAX = 3,
};

struct ip6addrlbl_entry {
	struct in6_addr prefix;
	int prefixlen;
	int ifindex;
	int addrtype;
	u32 label;
	struct hlist_node list;
	struct callback_head rcu;
};

struct ip6addrlbl_init_table {
	const struct in6_addr *prefix;
	int prefixlen;
	u32 label;
};

struct rd_msg {
	struct icmp6hdr icmph;
	struct in6_addr target;
	struct in6_addr dest;
	__u8 opt[0];
};

struct fib6_gc_args {
	int timeout;
	int more;
};

struct rt6_exception {
	struct hlist_node hlist;
	struct rt6_info *rt6i;
	long unsigned int stamp;
	struct callback_head rcu;
};

struct rt6_rtnl_dump_arg {
	struct sk_buff *skb;
	struct netlink_callback *cb;
	struct net *net;
	struct fib_dump_filter filter;
};

struct netevent_redirect {
	struct dst_entry *old;
	struct dst_entry *new;
	struct neighbour *neigh;
	const void *daddr;
};

struct trace_event_raw_fib6_table_lookup {
	struct trace_entry ent;
	u32 tb_id;
	int err;
	int oif;
	int iif;
	__u8 tos;
	__u8 scope;
	__u8 flags;
	__u8 src[16];
	__u8 dst[16];
	u16 sport;
	u16 dport;
	u8 proto;
	u8 rt_type;
	u32 __data_loc_name;
	__u8 gw[16];
	char __data[0];
};

struct trace_event_data_offsets_fib6_table_lookup {
	u32 name;
};

typedef void (*btf_trace_fib6_table_lookup)(void *, const struct net *, const struct fib6_result *, struct fib6_table *, const struct flowi6 *);

enum rt6_nud_state {
	RT6_NUD_FAIL_HARD = 4294967293,
	RT6_NUD_FAIL_PROBE = 4294967294,
	RT6_NUD_FAIL_DO_RR = 4294967295,
	RT6_NUD_SUCCEED = 1,
};

struct fib6_nh_dm_arg {
	struct net *net;
	const struct in6_addr *saddr;
	int oif;
	int flags;
	struct fib6_nh *nh;
};

struct fib6_nh_frl_arg {
	u32 flags;
	int oif;
	int strict;
	int *mpri;
	bool *do_rr;
	struct fib6_nh *nh;
};

struct fib6_nh_excptn_arg {
	struct rt6_info *rt;
	int plen;
};

struct fib6_nh_match_arg {
	const struct net_device *dev;
	const struct in6_addr *gw;
	struct fib6_nh *match;
};

struct fib6_nh_age_excptn_arg {
	struct fib6_gc_args *gc_args;
	long unsigned int now;
};

struct fib6_nh_rd_arg {
	struct fib6_result *res;
	struct flowi6 *fl6;
	const struct in6_addr *gw;
	struct rt6_info **ret;
};

struct ip6rd_flowi {
	struct flowi6 fl6;
	struct in6_addr gateway;
};

struct fib6_nh_del_cached_rt_arg {
	struct fib6_config *cfg;
	struct fib6_info *f6i;
};

struct arg_dev_net_ip {
	struct net_device *dev;
	struct net *net;
	struct in6_addr *addr;
};

struct arg_netdev_event {
	const struct net_device *dev;
	union {
		unsigned char nh_flags;
		long unsigned int event;
	};
};

struct rt6_mtu_change_arg {
	struct net_device *dev;
	unsigned int mtu;
	struct fib6_info *f6i;
};

struct rt6_nh {
	struct fib6_info *fib6_info;
	struct fib6_config r_cfg;
	struct list_head next;
};

struct fib6_nh_exception_dump_walker {
	struct rt6_rtnl_dump_arg *dump;
	struct fib6_info *rt;
	unsigned int flags;
	unsigned int skip;
	unsigned int count;
};

enum fib6_walk_state {
	FWS_L = 0,
	FWS_R = 1,
	FWS_C = 2,
	FWS_U = 3,
};

struct fib6_walker {
	struct list_head lh;
	struct fib6_node *root;
	struct fib6_node *node;
	struct fib6_info *leaf;
	enum fib6_walk_state state;
	unsigned int skip;
	unsigned int count;
	unsigned int skip_in_node;
	int (*func)(struct fib6_walker *);
	void *args;
};

typedef struct rt6_info * (*pol_lookup_t)(struct net *, struct fib6_table *, struct flowi6 *, const struct sk_buff *, int);

struct fib6_entry_notifier_info {
	struct fib_notifier_info info;
	struct fib6_info *rt;
	unsigned int nsiblings;
};

struct ipv6_route_iter {
	struct seq_net_private p;
	struct fib6_walker w;
	loff_t skip;
	struct fib6_table *tbl;
	int sernum;
};

struct bpf_iter__ipv6_route {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct fib6_info *rt;
	};
};

struct fib6_cleaner {
	struct fib6_walker w;
	struct net *net;
	int (*func)(struct fib6_info *, void *);
	int sernum;
	void *arg;
	bool skip_notify;
};

enum {
	FIB6_NO_SERNUM_CHANGE = 0,
};

struct fib6_dump_arg {
	struct net *net;
	struct notifier_block *nb;
	struct netlink_ext_ack *extack;
};

struct fib6_nh_pcpu_arg {
	struct fib6_info *from;
	const struct fib6_table *table;
};

struct lookup_args {
	int offset;
	const struct in6_addr *addr;
};

struct ipv6_mreq {
	struct in6_addr ipv6mr_multiaddr;
	int ipv6mr_ifindex;
};

struct in6_flowlabel_req {
	struct in6_addr flr_dst;
	__be32 flr_label;
	__u8 flr_action;
	__u8 flr_share;
	__u16 flr_flags;
	__u16 flr_expires;
	__u16 flr_linger;
	__u32 __flr_pad;
};

struct ip6_mtuinfo {
	struct sockaddr_in6 ip6m_addr;
	__u32 ip6m_mtu;
};

struct ipv6_sr_hdr {
	__u8 nexthdr;
	__u8 hdrlen;
	__u8 type;
	__u8 segments_left;
	__u8 first_segment;
	__u8 flags;
	__u16 tag;
	struct in6_addr segments[0];
};

struct nduseroptmsg {
	unsigned char nduseropt_family;
	unsigned char nduseropt_pad1;
	short unsigned int nduseropt_opts_len;
	int nduseropt_ifindex;
	__u8 nduseropt_icmp_type;
	__u8 nduseropt_icmp_code;
	short unsigned int nduseropt_pad2;
	unsigned int nduseropt_pad3;
};

enum {
	NDUSEROPT_UNSPEC = 0,
	NDUSEROPT_SRCADDR = 1,
	__NDUSEROPT_MAX = 2,
};

struct nd_msg {
	struct icmp6hdr icmph;
	struct in6_addr target;
	__u8 opt[0];
};

struct rs_msg {
	struct icmp6hdr icmph;
	__u8 opt[0];
};

struct ra_msg {
	struct icmp6hdr icmph;
	__be32 reachable_time;
	__be32 retrans_timer;
};

struct static_key_false_deferred {
	struct static_key_false key;
};

struct icmp6_filter {
	__u32 data[8];
};

struct raw6_sock {
	struct inet_sock inet;
	__u32 checksum;
	__u32 offset;
	struct icmp6_filter filter;
	__u32 ip6mr_table;
	struct ipv6_pinfo inet6;
};

struct raw6_frag_vec {
	struct msghdr *msg;
	int hlen;
	char c[4];
};

typedef void ip6_icmp_send_t(struct sk_buff *, u8, u8, __u32, const struct in6_addr *, const struct inet6_skb_parm *);

struct icmpv6_msg {
	struct sk_buff *skb;
	int offset;
	uint8_t type;
};

struct icmp6_err {
	int err;
	int fatal;
};

struct mld_msg {
	struct icmp6hdr mld_hdr;
	struct in6_addr mld_mca;
};

struct mld2_grec {
	__u8 grec_type;
	__u8 grec_auxwords;
	__be16 grec_nsrcs;
	struct in6_addr grec_mca;
	struct in6_addr grec_src[0];
};

struct mld2_report {
	struct icmp6hdr mld2r_hdr;
	struct mld2_grec mld2r_grec[0];
};

struct mld2_query {
	struct icmp6hdr mld2q_hdr;
	struct in6_addr mld2q_mca;
	__u8 mld2q_qrv: 3;
	__u8 mld2q_suppress: 1;
	__u8 mld2q_resv2: 4;
	__u8 mld2q_qqic;
	__be16 mld2q_nsrcs;
	struct in6_addr mld2q_srcs[0];
};

struct igmp6_mc_iter_state {
	struct seq_net_private p;
	struct net_device *dev;
	struct inet6_dev *idev;
};

struct igmp6_mcf_iter_state {
	struct seq_net_private p;
	struct net_device *dev;
	struct inet6_dev *idev;
	struct ifmcaddr6 *im;
};

enum ip6_defrag_users {
	IP6_DEFRAG_LOCAL_DELIVER = 0,
	IP6_DEFRAG_CONNTRACK_IN = 1,
	__IP6_DEFRAG_CONNTRACK_IN = 65536,
	IP6_DEFRAG_CONNTRACK_OUT = 65537,
	__IP6_DEFRAG_CONNTRACK_OUT = 131072,
	IP6_DEFRAG_CONNTRACK_BRIDGE_IN = 131073,
	__IP6_DEFRAG_CONNTRACK_BRIDGE_IN = 196608,
};

struct frag_queue {
	struct inet_frag_queue q;
	int iif;
	__u16 nhoffset;
	u8 ecn;
};

struct rt0_hdr {
	struct ipv6_rt_hdr rt_hdr;
	__u32 reserved;
	struct in6_addr addr[0];
};

struct ipv6_rpl_sr_hdr {
	__u8 nexthdr;
	__u8 hdrlen;
	__u8 type;
	__u8 segments_left;
	__u32 cmpre: 4;
	__u32 cmpri: 4;
	__u32 reserved: 4;
	__u32 pad: 4;
	__u32 reserved1: 16;
	union {
		struct in6_addr addr[0];
		__u8 data[0];
	} segments;
};

struct tlvtype_proc {
	int type;
	bool (*func)(struct sk_buff *, int);
};

struct ip6fl_iter_state {
	struct seq_net_private p;
	struct pid_namespace *pid_ns;
	int bucket;
};

struct sr6_tlv {
	__u8 type;
	__u8 len;
	__u8 data[0];
};

enum {
	SEG6_ATTR_UNSPEC = 0,
	SEG6_ATTR_DST = 1,
	SEG6_ATTR_DSTLEN = 2,
	SEG6_ATTR_HMACKEYID = 3,
	SEG6_ATTR_SECRET = 4,
	SEG6_ATTR_SECRETLEN = 5,
	SEG6_ATTR_ALGID = 6,
	SEG6_ATTR_HMACINFO = 7,
	__SEG6_ATTR_MAX = 8,
};

enum {
	SEG6_CMD_UNSPEC = 0,
	SEG6_CMD_SETHMAC = 1,
	SEG6_CMD_DUMPHMAC = 2,
	SEG6_CMD_SET_TUNSRC = 3,
	SEG6_CMD_GET_TUNSRC = 4,
	__SEG6_CMD_MAX = 5,
};

enum {
	IFLA_IPTUN_UNSPEC = 0,
	IFLA_IPTUN_LINK = 1,
	IFLA_IPTUN_LOCAL = 2,
	IFLA_IPTUN_REMOTE = 3,
	IFLA_IPTUN_TTL = 4,
	IFLA_IPTUN_TOS = 5,
	IFLA_IPTUN_ENCAP_LIMIT = 6,
	IFLA_IPTUN_FLOWINFO = 7,
	IFLA_IPTUN_FLAGS = 8,
	IFLA_IPTUN_PROTO = 9,
	IFLA_IPTUN_PMTUDISC = 10,
	IFLA_IPTUN_6RD_PREFIX = 11,
	IFLA_IPTUN_6RD_RELAY_PREFIX = 12,
	IFLA_IPTUN_6RD_PREFIXLEN = 13,
	IFLA_IPTUN_6RD_RELAY_PREFIXLEN = 14,
	IFLA_IPTUN_ENCAP_TYPE = 15,
	IFLA_IPTUN_ENCAP_FLAGS = 16,
	IFLA_IPTUN_ENCAP_SPORT = 17,
	IFLA_IPTUN_ENCAP_DPORT = 18,
	IFLA_IPTUN_COLLECT_METADATA = 19,
	IFLA_IPTUN_FWMARK = 20,
	__IFLA_IPTUN_MAX = 21,
};

struct ip_tunnel_prl {
	__be32 addr;
	__u16 flags;
	__u16 __reserved;
	__u32 datalen;
	__u32 __reserved2;
};

struct sit_net {
	struct ip_tunnel *tunnels_r_l[16];
	struct ip_tunnel *tunnels_r[16];
	struct ip_tunnel *tunnels_l[16];
	struct ip_tunnel *tunnels_wc[1];
	struct ip_tunnel **tunnels[4];
	struct net_device *fb_tunnel_dev;
};

enum {
	IP6_FH_F_FRAG = 1,
	IP6_FH_F_AUTH = 2,
	IP6_FH_F_SKIP_RH = 4,
};

struct sockaddr_pkt {
	short unsigned int spkt_family;
	unsigned char spkt_device[14];
	__be16 spkt_protocol;
};

struct sockaddr_ll {
	short unsigned int sll_family;
	__be16 sll_protocol;
	int sll_ifindex;
	short unsigned int sll_hatype;
	unsigned char sll_pkttype;
	unsigned char sll_halen;
	unsigned char sll_addr[8];
};

struct tpacket_stats {
	unsigned int tp_packets;
	unsigned int tp_drops;
};

struct tpacket_stats_v3 {
	unsigned int tp_packets;
	unsigned int tp_drops;
	unsigned int tp_freeze_q_cnt;
};

struct tpacket_rollover_stats {
	__u64 tp_all;
	__u64 tp_huge;
	__u64 tp_failed;
};

union tpacket_stats_u {
	struct tpacket_stats stats1;
	struct tpacket_stats_v3 stats3;
};

struct tpacket_auxdata {
	__u32 tp_status;
	__u32 tp_len;
	__u32 tp_snaplen;
	__u16 tp_mac;
	__u16 tp_net;
	__u16 tp_vlan_tci;
	__u16 tp_vlan_tpid;
};

struct tpacket_hdr {
	long unsigned int tp_status;
	unsigned int tp_len;
	unsigned int tp_snaplen;
	short unsigned int tp_mac;
	short unsigned int tp_net;
	unsigned int tp_sec;
	unsigned int tp_usec;
};

struct tpacket2_hdr {
	__u32 tp_status;
	__u32 tp_len;
	__u32 tp_snaplen;
	__u16 tp_mac;
	__u16 tp_net;
	__u32 tp_sec;
	__u32 tp_nsec;
	__u16 tp_vlan_tci;
	__u16 tp_vlan_tpid;
	__u8 tp_padding[4];
};

struct tpacket_hdr_variant1 {
	__u32 tp_rxhash;
	__u32 tp_vlan_tci;
	__u16 tp_vlan_tpid;
	__u16 tp_padding;
};

struct tpacket3_hdr {
	__u32 tp_next_offset;
	__u32 tp_sec;
	__u32 tp_nsec;
	__u32 tp_snaplen;
	__u32 tp_len;
	__u32 tp_status;
	__u16 tp_mac;
	__u16 tp_net;
	union {
		struct tpacket_hdr_variant1 hv1;
	};
	__u8 tp_padding[8];
};

struct tpacket_bd_ts {
	unsigned int ts_sec;
	union {
		unsigned int ts_usec;
		unsigned int ts_nsec;
	};
};

struct tpacket_hdr_v1 {
	__u32 block_status;
	__u32 num_pkts;
	__u32 offset_to_first_pkt;
	__u32 blk_len;
	__u64 seq_num;
	struct tpacket_bd_ts ts_first_pkt;
	struct tpacket_bd_ts ts_last_pkt;
};

union tpacket_bd_header_u {
	struct tpacket_hdr_v1 bh1;
};

struct tpacket_block_desc {
	__u32 version;
	__u32 offset_to_priv;
	union tpacket_bd_header_u hdr;
};

enum tpacket_versions {
	TPACKET_V1 = 0,
	TPACKET_V2 = 1,
	TPACKET_V3 = 2,
};

struct tpacket_req {
	unsigned int tp_block_size;
	unsigned int tp_block_nr;
	unsigned int tp_frame_size;
	unsigned int tp_frame_nr;
};

struct tpacket_req3 {
	unsigned int tp_block_size;
	unsigned int tp_block_nr;
	unsigned int tp_frame_size;
	unsigned int tp_frame_nr;
	unsigned int tp_retire_blk_tov;
	unsigned int tp_sizeof_priv;
	unsigned int tp_feature_req_word;
};

union tpacket_req_u {
	struct tpacket_req req;
	struct tpacket_req3 req3;
};

struct fanout_args {
	__u16 id;
	__u16 type_flags;
	__u32 max_num_members;
};

struct packet_mclist {
	struct packet_mclist *next;
	int ifindex;
	int count;
	short unsigned int type;
	short unsigned int alen;
	unsigned char addr[32];
};

struct pgv;

struct tpacket_kbdq_core {
	struct pgv *pkbdq;
	unsigned int feature_req_word;
	unsigned int hdrlen;
	unsigned char reset_pending_on_curr_blk;
	unsigned char delete_blk_timer;
	short unsigned int kactive_blk_num;
	short unsigned int blk_sizeof_priv;
	short unsigned int last_kactive_blk_num;
	char *pkblk_start;
	char *pkblk_end;
	int kblk_size;
	unsigned int max_frame_len;
	unsigned int knum_blocks;
	uint64_t knxt_seq_num;
	char *prev;
	char *nxt_offset;
	struct sk_buff *skb;
	rwlock_t blk_fill_in_prog_lock;
	short unsigned int retire_blk_tov;
	short unsigned int version;
	long unsigned int tov_in_jiffies;
	struct timer_list retire_blk_timer;
};

struct pgv {
	char *buffer;
};

struct packet_ring_buffer {
	struct pgv *pg_vec;
	unsigned int head;
	unsigned int frames_per_block;
	unsigned int frame_size;
	unsigned int frame_max;
	unsigned int pg_vec_order;
	unsigned int pg_vec_pages;
	unsigned int pg_vec_len;
	unsigned int *pending_refcnt;
	union {
		long unsigned int *rx_owner_map;
		struct tpacket_kbdq_core prb_bdqc;
	};
};

struct packet_fanout {
	possible_net_t net;
	unsigned int num_members;
	u32 max_num_members;
	u16 id;
	u8 type;
	u8 flags;
	union {
		atomic_t rr_cur;
		struct bpf_prog *bpf_prog;
	};
	struct list_head list;
	spinlock_t lock;
	refcount_t sk_ref;
	long: 64;
	struct packet_type prot_hook;
	struct sock *arr[0];
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct packet_rollover {
	int sock;
	atomic_long_t num;
	atomic_long_t num_huge;
	atomic_long_t num_failed;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	u32 history[16];
};

struct packet_sock {
	struct sock sk;
	struct packet_fanout *fanout;
	union tpacket_stats_u stats;
	struct packet_ring_buffer rx_ring;
	struct packet_ring_buffer tx_ring;
	int copy_thresh;
	spinlock_t bind_lock;
	struct mutex pg_vec_lock;
	unsigned int running;
	unsigned int auxdata: 1;
	unsigned int origdev: 1;
	unsigned int has_vnet_hdr: 1;
	unsigned int tp_loss: 1;
	unsigned int tp_tx_has_off: 1;
	int pressure;
	int ifindex;
	__be16 num;
	struct packet_rollover *rollover;
	struct packet_mclist *mclist;
	atomic_t mapped;
	enum tpacket_versions tp_version;
	unsigned int tp_hdrlen;
	unsigned int tp_reserve;
	unsigned int tp_tstamp;
	struct completion skb_completion;
	struct net_device *cached_dev;
	int (*xmit)(struct sk_buff *);
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	struct packet_type prot_hook;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	atomic_t tp_drops;
	long: 32;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
	long: 64;
};

struct packet_mreq_max {
	int mr_ifindex;
	short unsigned int mr_type;
	short unsigned int mr_alen;
	unsigned char mr_address[32];
};

union tpacket_uhdr {
	struct tpacket_hdr *h1;
	struct tpacket2_hdr *h2;
	struct tpacket3_hdr *h3;
	void *raw;
};

struct packet_skb_cb {
	union {
		struct sockaddr_pkt pkt;
		union {
			unsigned int origlen;
			struct sockaddr_ll ll;
		};
	} sa;
};

enum switchdev_notifier_type {
	SWITCHDEV_FDB_ADD_TO_BRIDGE = 1,
	SWITCHDEV_FDB_DEL_TO_BRIDGE = 2,
	SWITCHDEV_FDB_ADD_TO_DEVICE = 3,
	SWITCHDEV_FDB_DEL_TO_DEVICE = 4,
	SWITCHDEV_FDB_OFFLOADED = 5,
	SWITCHDEV_FDB_FLUSH_TO_BRIDGE = 6,
	SWITCHDEV_PORT_OBJ_ADD = 7,
	SWITCHDEV_PORT_OBJ_DEL = 8,
	SWITCHDEV_PORT_ATTR_SET = 9,
	SWITCHDEV_VXLAN_FDB_ADD_TO_BRIDGE = 10,
	SWITCHDEV_VXLAN_FDB_DEL_TO_BRIDGE = 11,
	SWITCHDEV_VXLAN_FDB_ADD_TO_DEVICE = 12,
	SWITCHDEV_VXLAN_FDB_DEL_TO_DEVICE = 13,
	SWITCHDEV_VXLAN_FDB_OFFLOADED = 14,
};

struct switchdev_notifier_info {
	struct net_device *dev;
	struct netlink_ext_ack *extack;
};

struct switchdev_notifier_fdb_info {
	struct switchdev_notifier_info info;
	const unsigned char *addr;
	u16 vid;
	u8 added_by_user: 1;
	u8 offloaded: 1;
};

enum br_boolopt_id {
	BR_BOOLOPT_NO_LL_LEARN = 0,
	BR_BOOLOPT_MAX = 1,
};

struct br_boolopt_multi {
	__u32 optval;
	__u32 optmask;
};

enum net_bridge_opts {
	BROPT_VLAN_ENABLED = 0,
	BROPT_VLAN_STATS_ENABLED = 1,
	BROPT_NF_CALL_IPTABLES = 2,
	BROPT_NF_CALL_IP6TABLES = 3,
	BROPT_NF_CALL_ARPTABLES = 4,
	BROPT_GROUP_ADDR_SET = 5,
	BROPT_MULTICAST_ENABLED = 6,
	BROPT_MULTICAST_QUERIER = 7,
	BROPT_MULTICAST_QUERY_USE_IFADDR = 8,
	BROPT_MULTICAST_STATS_ENABLED = 9,
	BROPT_HAS_IPV6_ADDR = 10,
	BROPT_NEIGH_SUPPRESS_ENABLED = 11,
	BROPT_MTU_SET_BY_USER = 12,
	BROPT_VLAN_STATS_PER_PORT = 13,
	BROPT_NO_LL_LEARN = 14,
	BROPT_VLAN_BRIDGE_BINDING = 15,
};

struct net_bridge_vlan_group {
	struct rhashtable vlan_hash;
	struct rhashtable tunnel_hash;
	struct list_head vlan_list;
	u16 num_vlans;
	u16 pvid;
	u8 pvid_state;
};

struct net_bridge_mcast_gc {
	struct hlist_node gc_node;
	void (*destroy)(struct net_bridge_mcast_gc *);
};

struct net_bridge_port_group_sg_key {
	struct net_bridge_port *port;
	struct br_ip addr;
};

struct net_bridge_port_group {
	struct net_bridge_port_group *next;
	struct net_bridge_port_group_sg_key key;
	unsigned char eth_addr[6];
	unsigned char flags;
	unsigned char filter_mode;
	unsigned char grp_query_rexmit_cnt;
	unsigned char rt_protocol;
	struct hlist_head src_list;
	unsigned int src_ents;
	struct timer_list timer;
	struct timer_list rexmit_timer;
	struct hlist_node mglist;
	struct rhash_head rhnode;
	struct net_bridge_mcast_gc mcast_gc;
	struct callback_head rcu;
};

struct net_bridge_mdb_entry {
	struct rhash_head rhnode;
	struct net_bridge *br;
	struct net_bridge_port_group *ports;
	struct br_ip addr;
	bool host_joined;
	struct timer_list timer;
	struct hlist_node mdb_node;
	struct net_bridge_mcast_gc mcast_gc;
	struct callback_head rcu;
};

struct br_input_skb_cb {
	struct net_device *brdev;
	u16 frag_max_size;
	u8 igmp;
	u8 mrouters_only: 1;
	u8 proxyarp_replied: 1;
	u8 src_port_isolated: 1;
};

enum br_pkt_type {
	BR_PKT_UNICAST = 0,
	BR_PKT_MULTICAST = 1,
	BR_PKT_BROADCAST = 2,
};

struct nf_br_ops {
	int (*br_dev_xmit_hook)(struct sk_buff *);
};

enum {
	FDB_NOTIFY_BIT = 1,
	FDB_NOTIFY_INACTIVE_BIT = 2,
};

enum {
	NFEA_UNSPEC = 0,
	NFEA_ACTIVITY_NOTIFY = 1,
	NFEA_DONT_REFRESH = 2,
	__NFEA_MAX = 3,
};

struct __fdb_entry {
	__u8 mac_addr[6];
	__u8 port_no;
	__u8 is_local;
	__u32 ageing_timer_value;
	__u8 port_hi;
	__u8 pad0;
	__u16 unused;
};

struct br_vlan_stats {
	u64 rx_bytes;
	u64 rx_packets;
	u64 tx_bytes;
	u64 tx_packets;
	struct u64_stats_sync syncp;
};

struct br_tunnel_info {
	__be64 tunnel_id;
	struct metadata_dst *tunnel_dst;
};

struct net_bridge_vlan {
	struct rhash_head vnode;
	struct rhash_head tnode;
	u16 vid;
	u16 flags;
	u16 priv_flags;
	u8 state;
	struct br_vlan_stats *stats;
	union {
		struct net_bridge *br;
		struct net_bridge_port *port;
	};
	union {
		refcount_t refcnt;
		struct net_bridge_vlan *brvlan;
	};
	struct br_tunnel_info tinfo;
	struct list_head vlist;
	struct callback_head rcu;
};

enum {
	BR_FDB_LOCAL = 0,
	BR_FDB_STATIC = 1,
	BR_FDB_STICKY = 2,
	BR_FDB_ADDED_BY_USER = 3,
	BR_FDB_ADDED_BY_EXT_LEARN = 4,
	BR_FDB_OFFLOADED = 5,
	BR_FDB_NOTIFY = 6,
	BR_FDB_NOTIFY_INACTIVE = 7,
};

struct __bridge_info {
	__u64 designated_root;
	__u64 bridge_id;
	__u32 root_path_cost;
	__u32 max_age;
	__u32 hello_time;
	__u32 forward_delay;
	__u32 bridge_max_age;
	__u32 bridge_hello_time;
	__u32 bridge_forward_delay;
	__u8 topology_change;
	__u8 topology_change_detected;
	__u8 root_port;
	__u8 stp_enabled;
	__u32 ageing_time;
	__u32 gc_interval;
	__u32 hello_timer_value;
	__u32 tcn_timer_value;
	__u32 topology_change_timer_value;
	__u32 gc_timer_value;
};

struct __port_info {
	__u64 designated_root;
	__u64 designated_bridge;
	__u16 port_id;
	__u16 designated_port;
	__u32 path_cost;
	__u32 designated_cost;
	__u8 state;
	__u8 top_change_ack;
	__u8 config_pending;
	__u8 unused0;
	__u32 message_age_timer_value;
	__u32 forward_delay_timer_value;
	__u32 hold_timer_value;
};

enum switchdev_attr_id {
	SWITCHDEV_ATTR_ID_UNDEFINED = 0,
	SWITCHDEV_ATTR_ID_PORT_STP_STATE = 1,
	SWITCHDEV_ATTR_ID_PORT_BRIDGE_FLAGS = 2,
	SWITCHDEV_ATTR_ID_PORT_PRE_BRIDGE_FLAGS = 3,
	SWITCHDEV_ATTR_ID_PORT_MROUTER = 4,
	SWITCHDEV_ATTR_ID_BRIDGE_AGEING_TIME = 5,
	SWITCHDEV_ATTR_ID_BRIDGE_VLAN_FILTERING = 6,
	SWITCHDEV_ATTR_ID_BRIDGE_MC_DISABLED = 7,
	SWITCHDEV_ATTR_ID_BRIDGE_MROUTER = 8,
};

struct switchdev_attr {
	struct net_device *orig_dev;
	enum switchdev_attr_id id;
	u32 flags;
	void *complete_priv;
	void (*complete)(struct net_device *, int, void *);
	union {
		u8 stp_state;
		long unsigned int brport_flags;
		bool mrouter;
		clock_t ageing_time;
		bool vlan_filtering;
		bool mc_disabled;
	} u;
};

struct br_config_bpdu {
	unsigned int topology_change: 1;
	unsigned int topology_change_ack: 1;
	bridge_id root;
	int root_path_cost;
	bridge_id bridge_id;
	port_id port_id;
	int message_age;
	int max_age;
	int hello_time;
	int forward_delay;
};

enum {
	IFLA_BR_UNSPEC = 0,
	IFLA_BR_FORWARD_DELAY = 1,
	IFLA_BR_HELLO_TIME = 2,
	IFLA_BR_MAX_AGE = 3,
	IFLA_BR_AGEING_TIME = 4,
	IFLA_BR_STP_STATE = 5,
	IFLA_BR_PRIORITY = 6,
	IFLA_BR_VLAN_FILTERING = 7,
	IFLA_BR_VLAN_PROTOCOL = 8,
	IFLA_BR_GROUP_FWD_MASK = 9,
	IFLA_BR_ROOT_ID = 10,
	IFLA_BR_BRIDGE_ID = 11,
	IFLA_BR_ROOT_PORT = 12,
	IFLA_BR_ROOT_PATH_COST = 13,
	IFLA_BR_TOPOLOGY_CHANGE = 14,
	IFLA_BR_TOPOLOGY_CHANGE_DETECTED = 15,
	IFLA_BR_HELLO_TIMER = 16,
	IFLA_BR_TCN_TIMER = 17,
	IFLA_BR_TOPOLOGY_CHANGE_TIMER = 18,
	IFLA_BR_GC_TIMER = 19,
	IFLA_BR_GROUP_ADDR = 20,
	IFLA_BR_FDB_FLUSH = 21,
	IFLA_BR_MCAST_ROUTER = 22,
	IFLA_BR_MCAST_SNOOPING = 23,
	IFLA_BR_MCAST_QUERY_USE_IFADDR = 24,
	IFLA_BR_MCAST_QUERIER = 25,
	IFLA_BR_MCAST_HASH_ELASTICITY = 26,
	IFLA_BR_MCAST_HASH_MAX = 27,
	IFLA_BR_MCAST_LAST_MEMBER_CNT = 28,
	IFLA_BR_MCAST_STARTUP_QUERY_CNT = 29,
	IFLA_BR_MCAST_LAST_MEMBER_INTVL = 30,
	IFLA_BR_MCAST_MEMBERSHIP_INTVL = 31,
	IFLA_BR_MCAST_QUERIER_INTVL = 32,
	IFLA_BR_MCAST_QUERY_INTVL = 33,
	IFLA_BR_MCAST_QUERY_RESPONSE_INTVL = 34,
	IFLA_BR_MCAST_STARTUP_QUERY_INTVL = 35,
	IFLA_BR_NF_CALL_IPTABLES = 36,
	IFLA_BR_NF_CALL_IP6TABLES = 37,
	IFLA_BR_NF_CALL_ARPTABLES = 38,
	IFLA_BR_VLAN_DEFAULT_PVID = 39,
	IFLA_BR_PAD = 40,
	IFLA_BR_VLAN_STATS_ENABLED = 41,
	IFLA_BR_MCAST_STATS_ENABLED = 42,
	IFLA_BR_MCAST_IGMP_VERSION = 43,
	IFLA_BR_MCAST_MLD_VERSION = 44,
	IFLA_BR_VLAN_STATS_PER_PORT = 45,
	IFLA_BR_MULTI_BOOLOPT = 46,
	__IFLA_BR_MAX = 47,
};

enum {
	LINK_XSTATS_TYPE_UNSPEC = 0,
	LINK_XSTATS_TYPE_BRIDGE = 1,
	LINK_XSTATS_TYPE_BOND = 2,
	__LINK_XSTATS_TYPE_MAX = 3,
};

struct bridge_vlan_info {
	__u16 flags;
	__u16 vid;
};

struct bridge_vlan_xstats {
	__u64 rx_bytes;
	__u64 rx_packets;
	__u64 tx_bytes;
	__u64 tx_packets;
	__u16 vid;
	__u16 flags;
	__u32 pad2;
};

enum {
	BRIDGE_XSTATS_UNSPEC = 0,
	BRIDGE_XSTATS_VLAN = 1,
	BRIDGE_XSTATS_MCAST = 2,
	BRIDGE_XSTATS_PAD = 3,
	BRIDGE_XSTATS_STP = 4,
	__BRIDGE_XSTATS_MAX = 5,
};

enum {
	BR_GROUPFWD_STP = 1,
	BR_GROUPFWD_MACPAUSE = 2,
	BR_GROUPFWD_LACP = 4,
};

struct vtunnel_info {
	u32 tunid;
	u16 vid;
	u16 flags;
};

enum {
	IFLA_BRIDGE_VLAN_TUNNEL_UNSPEC = 0,
	IFLA_BRIDGE_VLAN_TUNNEL_ID = 1,
	IFLA_BRIDGE_VLAN_TUNNEL_VID = 2,
	IFLA_BRIDGE_VLAN_TUNNEL_FLAGS = 3,
	__IFLA_BRIDGE_VLAN_TUNNEL_MAX = 4,
};

struct brport_attribute {
	struct attribute attr;
	ssize_t (*show)(struct net_bridge_port *, char *);
	int (*store)(struct net_bridge_port *, long unsigned int);
	int (*store_raw)(struct net_bridge_port *, char *);
};

enum {
	PIM_TYPE_HELLO = 0,
	PIM_TYPE_REGISTER = 1,
	PIM_TYPE_REGISTER_STOP = 2,
	PIM_TYPE_JOIN_PRUNE = 3,
	PIM_TYPE_BOOTSTRAP = 4,
	PIM_TYPE_ASSERT = 5,
	PIM_TYPE_GRAFT = 6,
	PIM_TYPE_GRAFT_ACK = 7,
	PIM_TYPE_CANDIDATE_RP_ADV = 8,
};

struct pimhdr {
	__u8 type;
	__u8 reserved;
	__be16 csum;
};

enum {
	MDB_RTR_TYPE_DISABLED = 0,
	MDB_RTR_TYPE_TEMP_QUERY = 1,
	MDB_RTR_TYPE_PERM = 2,
	MDB_RTR_TYPE_TEMP = 3,
};

struct br_ip_list {
	struct list_head list;
	struct br_ip addr;
};

struct net_bridge_group_src {
	struct hlist_node node;
	struct br_ip addr;
	struct net_bridge_port_group *pg;
	u8 flags;
	u8 src_query_rexmit_cnt;
	struct timer_list timer;
	struct net_bridge *br;
	struct net_bridge_mcast_gc mcast_gc;
	struct callback_head rcu;
};

enum switchdev_obj_id {
	SWITCHDEV_OBJ_ID_UNDEFINED = 0,
	SWITCHDEV_OBJ_ID_PORT_VLAN = 1,
	SWITCHDEV_OBJ_ID_PORT_MDB = 2,
	SWITCHDEV_OBJ_ID_HOST_MDB = 3,
};

struct switchdev_obj {
	struct net_device *orig_dev;
	enum switchdev_obj_id id;
	u32 flags;
	void *complete_priv;
	void (*complete)(struct net_device *, int, void *);
};

struct switchdev_obj_port_mdb {
	struct switchdev_obj obj;
	unsigned char addr[6];
	u16 vid;
};

enum {
	MDBA_UNSPEC = 0,
	MDBA_MDB = 1,
	MDBA_ROUTER = 2,
	__MDBA_MAX = 3,
};

enum {
	MDBA_MDB_UNSPEC = 0,
	MDBA_MDB_ENTRY = 1,
	__MDBA_MDB_MAX = 2,
};

enum {
	MDBA_MDB_ENTRY_UNSPEC = 0,
	MDBA_MDB_ENTRY_INFO = 1,
	__MDBA_MDB_ENTRY_MAX = 2,
};

enum {
	MDBA_MDB_EATTR_UNSPEC = 0,
	MDBA_MDB_EATTR_TIMER = 1,
	MDBA_MDB_EATTR_SRC_LIST = 2,
	MDBA_MDB_EATTR_GROUP_MODE = 3,
	MDBA_MDB_EATTR_SOURCE = 4,
	MDBA_MDB_EATTR_RTPROT = 5,
	__MDBA_MDB_EATTR_MAX = 6,
};

enum {
	MDBA_MDB_SRCLIST_UNSPEC = 0,
	MDBA_MDB_SRCLIST_ENTRY = 1,
	__MDBA_MDB_SRCLIST_MAX = 2,
};

enum {
	MDBA_MDB_SRCATTR_UNSPEC = 0,
	MDBA_MDB_SRCATTR_ADDRESS = 1,
	MDBA_MDB_SRCATTR_TIMER = 2,
	__MDBA_MDB_SRCATTR_MAX = 3,
};

enum {
	MDBA_ROUTER_UNSPEC = 0,
	MDBA_ROUTER_PORT = 1,
	__MDBA_ROUTER_MAX = 2,
};

enum {
	MDBA_ROUTER_PATTR_UNSPEC = 0,
	MDBA_ROUTER_PATTR_TIMER = 1,
	MDBA_ROUTER_PATTR_TYPE = 2,
	__MDBA_ROUTER_PATTR_MAX = 3,
};

struct br_port_msg {
	__u8 family;
	__u32 ifindex;
};

struct br_mdb_entry {
	__u32 ifindex;
	__u8 state;
	__u8 flags;
	__u16 vid;
	struct {
		union {
			__be32 ip4;
			struct in6_addr ip6;
		} u;
		__be16 proto;
	} addr;
};

enum {
	MDBA_SET_ENTRY_UNSPEC = 0,
	MDBA_SET_ENTRY = 1,
	MDBA_SET_ENTRY_ATTRS = 2,
	__MDBA_SET_ENTRY_MAX = 3,
};

enum {
	MDBE_ATTR_UNSPEC = 0,
	MDBE_ATTR_SOURCE = 1,
	__MDBE_ATTR_MAX = 2,
};

struct br_mdb_complete_info {
	struct net_bridge_port *port;
	struct br_ip ip;
};

enum {
	BT_CONNECTED = 1,
	BT_OPEN = 2,
	BT_BOUND = 3,
	BT_LISTEN = 4,
	BT_CONNECT = 5,
	BT_CONNECT2 = 6,
	BT_CONFIG = 7,
	BT_DISCONN = 8,
	BT_CLOSED = 9,
};

struct bt_sock {
	struct sock sk;
	struct list_head accept_q;
	struct sock *parent;
	long unsigned int flags;
	void (*skb_msg_name)(struct sk_buff *, void *, int *);
	void (*skb_put_cmsg)(struct sk_buff *, struct msghdr *, struct sock *);
};

enum {
	BT_SK_DEFER_SETUP = 0,
	BT_SK_SUSPEND = 1,
};

struct bt_sock_list {
	struct hlist_head head;
	rwlock_t lock;
	int (*custom_seq_show)(struct seq_file *, void *);
};

enum rfkill_type {
	RFKILL_TYPE_ALL = 0,
	RFKILL_TYPE_WLAN = 1,
	RFKILL_TYPE_BLUETOOTH = 2,
	RFKILL_TYPE_UWB = 3,
	RFKILL_TYPE_WIMAX = 4,
	RFKILL_TYPE_WWAN = 5,
	RFKILL_TYPE_GPS = 6,
	RFKILL_TYPE_FM = 7,
	RFKILL_TYPE_NFC = 8,
	NUM_RFKILL_TYPES = 9,
};

struct rfkill_ops {
	void (*poll)(struct rfkill *, void *);
	void (*query)(struct rfkill *, void *);
	int (*set_block)(void *, bool);
};

struct hci_cp_inquiry {
	__u8 lap[3];
	__u8 length;
	__u8 num_rsp;
};

struct hci_cp_write_def_link_policy {
	__le16 policy;
};

struct hci_cp_read_stored_link_key {
	bdaddr_t bdaddr;
	__u8 read_all;
};

struct hci_cp_delete_stored_link_key {
	bdaddr_t bdaddr;
	__u8 delete_all;
};

struct hci_cp_write_eir {
	__u8 fec;
	__u8 data[240];
};

struct hci_cp_write_def_err_data_reporting {
	__u8 err_data_reporting;
};

struct hci_cp_write_le_host_supported {
	__u8 le;
	__u8 simul;
};

struct hci_cp_read_local_ext_features {
	__u8 page;
};

struct hci_cp_le_write_def_data_len {
	__le16 tx_len;
	__le16 tx_time;
};

struct hci_cp_le_set_default_phy {
	__u8 all_phys;
	__u8 tx_phys;
	__u8 rx_phys;
};

struct inquiry_info {
	bdaddr_t bdaddr;
	__u8 pscan_rep_mode;
	__u8 pscan_period_mode;
	__u8 pscan_mode;
	__u8 dev_class[3];
	__le16 clock_offset;
};

struct hci_command_hdr {
	__le16 opcode;
	__u8 plen;
} __attribute__((packed));

struct hci_dev_info {
	__u16 dev_id;
	char name[8];
	bdaddr_t bdaddr;
	__u32 flags;
	__u8 type;
	__u8 features[8];
	__u32 pkt_type;
	__u32 link_policy;
	__u32 link_mode;
	__u16 acl_mtu;
	__u16 acl_pkts;
	__u16 sco_mtu;
	__u16 sco_pkts;
	struct hci_dev_stats stat;
};

struct hci_dev_req {
	__u16 dev_id;
	__u32 dev_opt;
};

struct hci_dev_list_req {
	__u16 dev_num;
	struct hci_dev_req dev_req[0];
};

struct hci_inquiry_req {
	__u16 dev_id;
	__u16 flags;
	__u8 lap[3];
	__u8 length;
	__u8 num_rsp;
};

struct inquiry_data {
	bdaddr_t bdaddr;
	__u8 pscan_rep_mode;
	__u8 pscan_period_mode;
	__u8 pscan_mode;
	__u8 dev_class[3];
	__le16 clock_offset;
	__s8 rssi;
	__u8 ssp_mode;
};

struct inquiry_entry {
	struct list_head all;
	struct list_head list;
	enum {
		NAME_NOT_KNOWN = 0,
		NAME_NEEDED = 1,
		NAME_PENDING = 2,
		NAME_KNOWN = 3,
	} name_state;
	__u32 timestamp;
	struct inquiry_data data;
};

struct bdaddr_list {
	struct list_head list;
	bdaddr_t bdaddr;
	u8 bdaddr_type;
};

struct bdaddr_list_with_irk {
	struct list_head list;
	bdaddr_t bdaddr;
	u8 bdaddr_type;
	u8 peer_irk[16];
	u8 local_irk[16];
};

struct bdaddr_list_with_flags {
	struct list_head list;
	bdaddr_t bdaddr;
	u8 bdaddr_type;
	u32 current_flags;
};

struct bt_uuid {
	struct list_head list;
	u8 uuid[16];
	u8 size;
	u8 svc_hint;
};

struct blocked_key {
	struct list_head list;
	struct callback_head rcu;
	u8 type;
	u8 val[16];
};

struct smp_ltk {
	struct list_head list;
	struct callback_head rcu;
	bdaddr_t bdaddr;
	u8 bdaddr_type;
	u8 authenticated;
	u8 type;
	u8 enc_size;
	__le16 ediv;
	__le64 rand;
	u8 val[16];
};

struct smp_irk {
	struct list_head list;
	struct callback_head rcu;
	bdaddr_t rpa;
	bdaddr_t bdaddr;
	u8 addr_type;
	u8 val[16];
};

struct link_key {
	struct list_head list;
	struct callback_head rcu;
	bdaddr_t bdaddr;
	u8 type;
	u8 val[16];
	u8 pin_len;
};

struct oob_data {
	struct list_head list;
	bdaddr_t bdaddr;
	u8 bdaddr_type;
	u8 present;
	u8 hash192[16];
	u8 rand192[16];
	u8 hash256[16];
	u8 rand256[16];
};

struct adv_info {
	struct list_head list;
	bool pending;
	__u8 instance;
	__u32 flags;
	__u16 timeout;
	__u16 remaining_time;
	__u16 duration;
	__u16 adv_data_len;
	__u8 adv_data[31];
	__u16 scan_rsp_len;
	__u8 scan_rsp_data[31];
	__s8 tx_power;
	bdaddr_t random_addr;
	bool rpa_expired;
	struct delayed_work rpa_expired_cb;
};

struct adv_pattern {
	struct list_head list;
	__u8 ad_type;
	__u8 offset;
	__u8 length;
	__u8 value[31];
};

struct adv_monitor {
	struct list_head patterns;
	bool active;
	__u16 handle;
};

struct hci_conn_params {
	struct list_head list;
	struct list_head action;
	bdaddr_t addr;
	u8 addr_type;
	u16 conn_min_interval;
	u16 conn_max_interval;
	u16 conn_latency;
	u16 supervision_timeout;
	enum {
		HCI_AUTO_CONN_DISABLED = 0,
		HCI_AUTO_CONN_REPORT = 1,
		HCI_AUTO_CONN_DIRECT = 2,
		HCI_AUTO_CONN_ALWAYS = 3,
		HCI_AUTO_CONN_LINK_LOSS = 4,
		HCI_AUTO_CONN_EXPLICIT = 5,
	} auto_connect;
	struct hci_conn *conn;
	bool explicit_connect;
	u32 current_flags;
};

struct hci_cb {
	struct list_head list;
	char *name;
	void (*connect_cfm)(struct hci_conn *, __u8);
	void (*disconn_cfm)(struct hci_conn *, __u8);
	void (*security_cfm)(struct hci_conn *, __u8, __u8);
	void (*key_change_cfm)(struct hci_conn *, __u8);
	void (*role_switch_cfm)(struct hci_conn *, __u8, __u8);
};

struct hci_request {
	struct hci_dev *hdev;
	struct sk_buff_head cmd_q;
	int err;
};

enum {
	SMP_STK = 0,
	SMP_LTK = 1,
	SMP_LTK_SLAVE = 2,
	SMP_LTK_P256 = 3,
	SMP_LTK_P256_DEBUG = 4,
};

struct hci_cp_create_conn {
	bdaddr_t bdaddr;
	__le16 pkt_type;
	__u8 pscan_rep_mode;
	__u8 pscan_mode;
	__le16 clock_offset;
	__u8 role_switch;
} __attribute__((packed));

struct hci_cp_add_sco {
	__le16 handle;
	__le16 pkt_type;
};

struct hci_cp_auth_requested {
	__le16 handle;
};

struct hci_cp_set_conn_encrypt {
	__le16 handle;
	__u8 encrypt;
} __attribute__((packed));

struct hci_cp_read_clock_offset {
	__le16 handle;
};

struct hci_cp_setup_sync_conn {
	__le16 handle;
	__le32 tx_bandwidth;
	__le32 rx_bandwidth;
	__le16 max_latency;
	__le16 voice_setting;
	__u8 retrans_effort;
	__le16 pkt_type;
} __attribute__((packed));

struct hci_cp_sniff_mode {
	__le16 handle;
	__le16 max_interval;
	__le16 min_interval;
	__le16 attempt;
	__le16 timeout;
};

struct hci_cp_exit_sniff_mode {
	__le16 handle;
};

struct hci_cp_switch_role {
	bdaddr_t bdaddr;
	__u8 role;
};

struct hci_cp_sniff_subrate {
	__le16 handle;
	__le16 max_latency;
	__le16 min_remote_timeout;
	__le16 min_local_timeout;
};

struct hci_cp_le_set_adv_param {
	__le16 min_interval;
	__le16 max_interval;
	__u8 type;
	__u8 own_address_type;
	__u8 direct_addr_type;
	bdaddr_t direct_addr;
	__u8 channel_map;
	__u8 filter_policy;
} __attribute__((packed));

struct hci_cp_le_create_conn {
	__le16 scan_interval;
	__le16 scan_window;
	__u8 filter_policy;
	__u8 peer_addr_type;
	bdaddr_t peer_addr;
	__u8 own_address_type;
	__le16 conn_interval_min;
	__le16 conn_interval_max;
	__le16 conn_latency;
	__le16 supervision_timeout;
	__le16 min_ce_len;
	__le16 max_ce_len;
} __attribute__((packed));

struct hci_cp_le_conn_update {
	__le16 handle;
	__le16 conn_interval_min;
	__le16 conn_interval_max;
	__le16 conn_latency;
	__le16 supervision_timeout;
	__le16 min_ce_len;
	__le16 max_ce_len;
};

struct hci_cp_le_start_enc {
	__le16 handle;
	__le64 rand;
	__le16 ediv;
	__u8 ltk[16];
} __attribute__((packed));

struct hci_cp_le_ext_create_conn {
	__u8 filter_policy;
	__u8 own_addr_type;
	__u8 peer_addr_type;
	bdaddr_t peer_addr;
	__u8 phys;
	__u8 data[0];
};

struct hci_cp_le_ext_conn_param {
	__le16 scan_interval;
	__le16 scan_window;
	__le16 conn_interval_min;
	__le16 conn_interval_max;
	__le16 conn_latency;
	__le16 supervision_timeout;
	__le16 min_ce_len;
	__le16 max_ce_len;
};

struct hci_cp_le_set_ext_adv_params {
	__u8 handle;
	__le16 evt_properties;
	__u8 min_interval[3];
	__u8 max_interval[3];
	__u8 channel_map;
	__u8 own_addr_type;
	__u8 peer_addr_type;
	bdaddr_t peer_addr;
	__u8 filter_policy;
	__u8 tx_power;
	__u8 primary_phy;
	__u8 secondary_max_skip;
	__u8 secondary_phy;
	__u8 sid;
	__u8 notif_enable;
} __attribute__((packed));

struct hci_cp_le_set_ext_adv_enable {
	__u8 enable;
	__u8 num_of_sets;
	__u8 data[0];
};

struct hci_cp_le_set_adv_set_rand_addr {
	__u8 handle;
	bdaddr_t bdaddr;
};

struct hci_conn_info {
	__u16 handle;
	bdaddr_t bdaddr;
	__u8 type;
	__u8 out;
	__u16 state;
	__u32 link_mode;
};

struct hci_conn_list_req {
	__u16 dev_id;
	__u16 conn_num;
	struct hci_conn_info conn_info[0];
};

struct hci_conn_info_req {
	bdaddr_t bdaddr;
	__u8 type;
	struct hci_conn_info conn_info[0];
};

struct hci_auth_info_req {
	bdaddr_t bdaddr;
	__u8 type;
};

struct amp_mgr {
	struct list_head list;
	struct l2cap_conn *l2cap_conn;
	struct l2cap_chan *a2mp_chan;
	struct l2cap_chan *bredr_chan;
	struct kref kref;
	__u8 ident;
	__u8 handle;
	long unsigned int state;
	long unsigned int flags;
	struct list_head amp_ctrls;
	struct mutex amp_ctrls_lock;
};

enum {
	HCI_CONN_AUTH_PEND = 0,
	HCI_CONN_REAUTH_PEND = 1,
	HCI_CONN_ENCRYPT_PEND = 2,
	HCI_CONN_RSWITCH_PEND = 3,
	HCI_CONN_MODE_CHANGE_PEND = 4,
	HCI_CONN_SCO_SETUP_PEND = 5,
	HCI_CONN_MGMT_CONNECTED = 6,
	HCI_CONN_SSP_ENABLED = 7,
	HCI_CONN_SC_ENABLED = 8,
	HCI_CONN_AES_CCM = 9,
	HCI_CONN_POWER_SAVE = 10,
	HCI_CONN_FLUSH_KEY = 11,
	HCI_CONN_ENCRYPT = 12,
	HCI_CONN_AUTH = 13,
	HCI_CONN_SECURE = 14,
	HCI_CONN_FIPS = 15,
	HCI_CONN_STK_ENCRYPT = 16,
	HCI_CONN_AUTH_INITIATOR = 17,
	HCI_CONN_DROP = 18,
	HCI_CONN_PARAM_REMOVAL_PEND = 19,
	HCI_CONN_NEW_LINK_KEY = 20,
	HCI_CONN_SCANNING = 21,
	HCI_CONN_AUTH_FAILURE = 22,
};

struct sco_param {
	u16 pkt_type;
	u16 max_latency;
	u8 retrans_effort;
};

struct hci_cp_disconnect {
	__le16 handle;
	__u8 reason;
} __attribute__((packed));

struct hci_cp_accept_conn_req {
	bdaddr_t bdaddr;
	__u8 role;
};

struct hci_cp_reject_conn_req {
	bdaddr_t bdaddr;
	__u8 reason;
};

struct hci_cp_link_key_reply {
	bdaddr_t bdaddr;
	__u8 link_key[16];
};

struct hci_cp_pin_code_reply {
	bdaddr_t bdaddr;
	__u8 pin_len;
	__u8 pin_code[16];
};

struct hci_rp_pin_code_reply {
	__u8 status;
	bdaddr_t bdaddr;
};

struct hci_rp_pin_code_neg_reply {
	__u8 status;
	bdaddr_t bdaddr;
};

struct hci_cp_change_conn_ptype {
	__le16 handle;
	__le16 pkt_type;
};

struct hci_cp_remote_name_req {
	bdaddr_t bdaddr;
	__u8 pscan_rep_mode;
	__u8 pscan_mode;
	__le16 clock_offset;
};

struct hci_cp_read_remote_features {
	__le16 handle;
};

struct hci_cp_read_remote_ext_features {
	__le16 handle;
	__u8 page;
} __attribute__((packed));

struct hci_cp_accept_sync_conn_req {
	bdaddr_t bdaddr;
	__le32 tx_bandwidth;
	__le32 rx_bandwidth;
	__le16 max_latency;
	__le16 content_format;
	__u8 retrans_effort;
	__le16 pkt_type;
} __attribute__((packed));

struct hci_cp_io_capability_reply {
	bdaddr_t bdaddr;
	__u8 capability;
	__u8 oob_data;
	__u8 authentication;
};

struct hci_rp_user_confirm_reply {
	__u8 status;
	bdaddr_t bdaddr;
};

struct hci_cp_remote_oob_data_reply {
	bdaddr_t bdaddr;
	__u8 hash[16];
	__u8 rand[16];
};

struct hci_cp_remote_oob_data_neg_reply {
	bdaddr_t bdaddr;
};

struct hci_cp_io_capability_neg_reply {
	bdaddr_t bdaddr;
	__u8 reason;
};

struct hci_cp_remote_oob_ext_data_reply {
	bdaddr_t bdaddr;
	__u8 hash192[16];
	__u8 rand192[16];
	__u8 hash256[16];
	__u8 rand256[16];
};

struct hci_rp_role_discovery {
	__u8 status;
	__le16 handle;
	__u8 role;
} __attribute__((packed));

struct hci_rp_read_link_policy {
	__u8 status;
	__le16 handle;
	__le16 policy;
} __attribute__((packed));

struct hci_rp_write_link_policy {
	__u8 status;
	__le16 handle;
} __attribute__((packed));

struct hci_rp_read_def_link_policy {
	__u8 status;
	__le16 policy;
} __attribute__((packed));

struct hci_rp_read_stored_link_key {
	__u8 status;
	__u8 max_keys;
	__u8 num_keys;
};

struct hci_rp_delete_stored_link_key {
	__u8 status;
	__u8 num_keys;
};

struct hci_rp_read_local_name {
	__u8 status;
	__u8 name[248];
};

struct hci_rp_read_class_of_dev {
	__u8 status;
	__u8 dev_class[3];
};

struct hci_rp_read_voice_setting {
	__u8 status;
	__le16 voice_setting;
} __attribute__((packed));

struct hci_rp_read_num_supported_iac {
	__u8 status;
	__u8 num_iac;
};

struct hci_cp_write_ssp_mode {
	__u8 mode;
};

struct hci_rp_read_local_oob_data {
	__u8 status;
	__u8 hash[16];
	__u8 rand[16];
};

struct hci_rp_read_inq_rsp_tx_power {
	__u8 status;
	__s8 tx_power;
};

struct hci_rp_read_def_err_data_reporting {
	__u8 status;
	__u8 err_data_reporting;
};

struct hci_rp_read_flow_control_mode {
	__u8 status;
	__u8 mode;
};

struct hci_cp_write_sc_support {
	__u8 support;
};

struct hci_rp_read_auth_payload_to {
	__u8 status;
	__le16 handle;
	__le16 timeout;
} __attribute__((packed));

struct hci_cp_write_auth_payload_to {
	__le16 handle;
	__le16 timeout;
};

struct hci_rp_write_auth_payload_to {
	__u8 status;
	__le16 handle;
} __attribute__((packed));

struct hci_rp_read_local_oob_ext_data {
	__u8 status;
	__u8 hash192[16];
	__u8 rand192[16];
	__u8 hash256[16];
	__u8 rand256[16];
};

struct hci_rp_read_local_version {
	__u8 status;
	__u8 hci_ver;
	__le16 hci_rev;
	__u8 lmp_ver;
	__le16 manufacturer;
	__le16 lmp_subver;
} __attribute__((packed));

struct hci_rp_read_local_commands {
	__u8 status;
	__u8 commands[64];
};

struct hci_rp_read_local_features {
	__u8 status;
	__u8 features[8];
};

struct hci_rp_read_local_ext_features {
	__u8 status;
	__u8 page;
	__u8 max_page;
	__u8 features[8];
};

struct hci_rp_read_buffer_size {
	__u8 status;
	__le16 acl_mtu;
	__u8 sco_mtu;
	__le16 acl_max_pkt;
	__le16 sco_max_pkt;
} __attribute__((packed));

struct hci_rp_read_bd_addr {
	__u8 status;
	bdaddr_t bdaddr;
};

struct hci_rp_read_data_block_size {
	__u8 status;
	__le16 max_acl_len;
	__le16 block_len;
	__le16 num_blocks;
} __attribute__((packed));

struct hci_rp_read_local_pairing_opts {
	__u8 status;
	__u8 pairing_opts;
	__u8 max_key_size;
};

struct hci_rp_read_page_scan_activity {
	__u8 status;
	__le16 interval;
	__le16 window;
} __attribute__((packed));

struct hci_cp_write_page_scan_activity {
	__le16 interval;
	__le16 window;
};

struct hci_cp_read_tx_power {
	__le16 handle;
	__u8 type;
} __attribute__((packed));

struct hci_rp_read_tx_power {
	__u8 status;
	__le16 handle;
	__s8 tx_power;
} __attribute__((packed));

struct hci_rp_read_page_scan_type {
	__u8 status;
	__u8 type;
};

struct hci_rp_read_rssi {
	__u8 status;
	__le16 handle;
	__s8 rssi;
} __attribute__((packed));

struct hci_cp_read_clock {
	__le16 handle;
	__u8 which;
} __attribute__((packed));

struct hci_rp_read_clock {
	__u8 status;
	__le16 handle;
	__le32 clock;
	__le16 accuracy;
} __attribute__((packed));

struct hci_cp_read_enc_key_size {
	__le16 handle;
};

struct hci_rp_read_enc_key_size {
	__u8 status;
	__le16 handle;
	__u8 key_size;
} __attribute__((packed));

struct hci_rp_read_local_amp_info {
	__u8 status;
	__u8 amp_status;
	__le32 total_bw;
	__le32 max_bw;
	__le32 min_latency;
	__le32 max_pdu;
	__u8 amp_type;
	__le16 pal_cap;
	__le16 max_assoc_size;
	__le32 max_flush_to;
	__le32 be_flush_to;
} __attribute__((packed));

struct hci_rp_le_read_buffer_size {
	__u8 status;
	__le16 le_mtu;
	__u8 le_max_pkt;
} __attribute__((packed));

struct hci_rp_le_read_local_features {
	__u8 status;
	__u8 features[8];
};

struct hci_rp_le_read_adv_tx_power {
	__u8 status;
	__s8 tx_power;
};

struct hci_cp_le_set_scan_param {
	__u8 type;
	__le16 interval;
	__le16 window;
	__u8 own_address_type;
	__u8 filter_policy;
} __attribute__((packed));

struct hci_cp_le_set_scan_enable {
	__u8 enable;
	__u8 filter_dup;
};

struct hci_rp_le_read_white_list_size {
	__u8 status;
	__u8 size;
};

struct hci_cp_le_add_to_white_list {
	__u8 bdaddr_type;
	bdaddr_t bdaddr;
};

struct hci_cp_le_del_from_white_list {
	__u8 bdaddr_type;
	bdaddr_t bdaddr;
};

struct hci_cp_le_read_remote_features {
	__le16 handle;
};

struct hci_cp_le_ltk_reply {
	__le16 handle;
	__u8 ltk[16];
};

struct hci_cp_le_ltk_neg_reply {
	__le16 handle;
};

struct hci_rp_le_read_supported_states {
	__u8 status;
	__u8 le_states[8];
};

struct hci_cp_le_conn_param_req_reply {
	__le16 handle;
	__le16 interval_min;
	__le16 interval_max;
	__le16 latency;
	__le16 timeout;
	__le16 min_ce_len;
	__le16 max_ce_len;
};

struct hci_cp_le_conn_param_req_neg_reply {
	__le16 handle;
	__u8 reason;
} __attribute__((packed));

struct hci_rp_le_read_def_data_len {
	__u8 status;
	__le16 tx_len;
	__le16 tx_time;
} __attribute__((packed));

struct hci_cp_le_add_to_resolv_list {
	__u8 bdaddr_type;
	bdaddr_t bdaddr;
	__u8 peer_irk[16];
	__u8 local_irk[16];
};

struct hci_cp_le_del_from_resolv_list {
	__u8 bdaddr_type;
	bdaddr_t bdaddr;
};

struct hci_rp_le_read_resolv_list_size {
	__u8 status;
	__u8 size;
};

struct hci_rp_le_read_max_data_len {
	__u8 status;
	__le16 tx_len;
	__le16 tx_time;
	__le16 rx_len;
	__le16 rx_time;
} __attribute__((packed));

struct hci_cp_le_set_ext_scan_params {
	__u8 own_addr_type;
	__u8 filter_policy;
	__u8 scanning_phys;
	__u8 data[0];
};

struct hci_cp_le_scan_phy_params {
	__u8 type;
	__le16 interval;
	__le16 window;
} __attribute__((packed));

struct hci_cp_le_set_ext_scan_enable {
	__u8 enable;
	__u8 filter_dup;
	__le16 duration;
	__le16 period;
};

struct hci_rp_le_read_num_supported_adv_sets {
	__u8 status;
	__u8 num_of_sets;
};

struct hci_rp_le_set_ext_adv_params {
	__u8 status;
	__u8 tx_power;
};

struct hci_ev_conn_complete {
	__u8 status;
	__le16 handle;
	bdaddr_t bdaddr;
	__u8 link_type;
	__u8 encr_mode;
} __attribute__((packed));

struct hci_ev_conn_request {
	bdaddr_t bdaddr;
	__u8 dev_class[3];
	__u8 link_type;
};

struct hci_ev_disconn_complete {
	__u8 status;
	__le16 handle;
	__u8 reason;
} __attribute__((packed));

struct hci_ev_auth_complete {
	__u8 status;
	__le16 handle;
} __attribute__((packed));

struct hci_ev_remote_name {
	__u8 status;
	bdaddr_t bdaddr;
	__u8 name[248];
};

struct hci_ev_encrypt_change {
	__u8 status;
	__le16 handle;
	__u8 encrypt;
} __attribute__((packed));

struct hci_ev_change_link_key_complete {
	__u8 status;
	__le16 handle;
} __attribute__((packed));

struct hci_ev_remote_features {
	__u8 status;
	__le16 handle;
	__u8 features[8];
} __attribute__((packed));

struct hci_ev_cmd_complete {
	__u8 ncmd;
	__le16 opcode;
} __attribute__((packed));

struct hci_ev_cmd_status {
	__u8 status;
	__u8 ncmd;
	__le16 opcode;
};

struct hci_ev_hardware_error {
	__u8 code;
};

struct hci_ev_role_change {
	__u8 status;
	bdaddr_t bdaddr;
	__u8 role;
};

struct hci_comp_pkts_info {
	__le16 handle;
	__le16 count;
};

struct hci_ev_num_comp_pkts {
	__u8 num_hndl;
	struct hci_comp_pkts_info handles[0];
} __attribute__((packed));

struct hci_ev_mode_change {
	__u8 status;
	__le16 handle;
	__u8 mode;
	__le16 interval;
} __attribute__((packed));

struct hci_ev_pin_code_req {
	bdaddr_t bdaddr;
};

struct hci_ev_link_key_req {
	bdaddr_t bdaddr;
};

struct hci_ev_link_key_notify {
	bdaddr_t bdaddr;
	__u8 link_key[16];
	__u8 key_type;
};

struct hci_ev_clock_offset {
	__u8 status;
	__le16 handle;
	__le16 clock_offset;
} __attribute__((packed));

struct hci_ev_pkt_type_change {
	__u8 status;
	__le16 handle;
	__le16 pkt_type;
} __attribute__((packed));

struct hci_ev_pscan_rep_mode {
	bdaddr_t bdaddr;
	__u8 pscan_rep_mode;
};

struct inquiry_info_with_rssi {
	bdaddr_t bdaddr;
	__u8 pscan_rep_mode;
	__u8 pscan_period_mode;
	__u8 dev_class[3];
	__le16 clock_offset;
	__s8 rssi;
} __attribute__((packed));

struct inquiry_info_with_rssi_and_pscan_mode {
	bdaddr_t bdaddr;
	__u8 pscan_rep_mode;
	__u8 pscan_period_mode;
	__u8 pscan_mode;
	__u8 dev_class[3];
	__le16 clock_offset;
	__s8 rssi;
} __attribute__((packed));

struct hci_ev_remote_ext_features {
	__u8 status;
	__le16 handle;
	__u8 page;
	__u8 max_page;
	__u8 features[8];
} __attribute__((packed));

struct hci_ev_sync_conn_complete {
	__u8 status;
	__le16 handle;
	bdaddr_t bdaddr;
	__u8 link_type;
	__u8 tx_interval;
	__u8 retrans_window;
	__le16 rx_pkt_len;
	__le16 tx_pkt_len;
	__u8 air_mode;
} __attribute__((packed));

struct extended_inquiry_info {
	bdaddr_t bdaddr;
	__u8 pscan_rep_mode;
	__u8 pscan_period_mode;
	__u8 dev_class[3];
	__le16 clock_offset;
	__s8 rssi;
	__u8 data[240];
} __attribute__((packed));

struct hci_ev_key_refresh_complete {
	__u8 status;
	__le16 handle;
} __attribute__((packed));

struct hci_ev_io_capa_request {
	bdaddr_t bdaddr;
};

struct hci_ev_io_capa_reply {
	bdaddr_t bdaddr;
	__u8 capability;
	__u8 oob_data;
	__u8 authentication;
};

struct hci_ev_user_confirm_req {
	bdaddr_t bdaddr;
	__le32 passkey;
} __attribute__((packed));

struct hci_ev_user_passkey_req {
	bdaddr_t bdaddr;
};

struct hci_ev_remote_oob_data_request {
	bdaddr_t bdaddr;
};

struct hci_ev_simple_pair_complete {
	__u8 status;
	bdaddr_t bdaddr;
};

struct hci_ev_user_passkey_notify {
	bdaddr_t bdaddr;
	__le32 passkey;
} __attribute__((packed));

struct hci_ev_keypress_notify {
	bdaddr_t bdaddr;
	__u8 type;
};

struct hci_ev_remote_host_features {
	bdaddr_t bdaddr;
	__u8 features[8];
};

struct hci_ev_le_meta {
	__u8 subevent;
};

struct hci_comp_blocks_info {
	__le16 handle;
	__le16 pkts;
	__le16 blocks;
};

struct hci_ev_num_comp_blocks {
	__le16 num_blocks;
	__u8 num_hndl;
	struct hci_comp_blocks_info handles[0];
} __attribute__((packed));

struct hci_ev_le_conn_complete {
	__u8 status;
	__le16 handle;
	__u8 role;
	__u8 bdaddr_type;
	bdaddr_t bdaddr;
	__le16 interval;
	__le16 latency;
	__le16 supervision_timeout;
	__u8 clk_accurancy;
} __attribute__((packed));

struct hci_ev_le_advertising_info {
	__u8 evt_type;
	__u8 bdaddr_type;
	bdaddr_t bdaddr;
	__u8 length;
	__u8 data[0];
};

struct hci_ev_le_conn_update_complete {
	__u8 status;
	__le16 handle;
	__le16 interval;
	__le16 latency;
	__le16 supervision_timeout;
} __attribute__((packed));

struct hci_ev_le_remote_feat_complete {
	__u8 status;
	__le16 handle;
	__u8 features[8];
} __attribute__((packed));

struct hci_ev_le_ltk_req {
	__le16 handle;
	__le64 rand;
	__le16 ediv;
} __attribute__((packed));

struct hci_ev_le_remote_conn_param_req {
	__le16 handle;
	__le16 interval_min;
	__le16 interval_max;
	__le16 latency;
	__le16 timeout;
};

struct hci_ev_le_direct_adv_info {
	__u8 evt_type;
	__u8 bdaddr_type;
	bdaddr_t bdaddr;
	__u8 direct_addr_type;
	bdaddr_t direct_addr;
	__s8 rssi;
};

struct hci_ev_le_phy_update_complete {
	__u8 status;
	__le16 handle;
	__u8 tx_phy;
	__u8 rx_phy;
} __attribute__((packed));

struct hci_ev_le_ext_adv_report {
	__le16 evt_type;
	__u8 bdaddr_type;
	bdaddr_t bdaddr;
	__u8 primary_phy;
	__u8 secondary_phy;
	__u8 sid;
	__u8 tx_power;
	__s8 rssi;
	__le16 interval;
	__u8 direct_addr_type;
	bdaddr_t direct_addr;
	__u8 length;
	__u8 data[0];
};

struct hci_ev_le_enh_conn_complete {
	__u8 status;
	__le16 handle;
	__u8 role;
	__u8 bdaddr_type;
	bdaddr_t bdaddr;
	bdaddr_t local_rpa;
	bdaddr_t peer_rpa;
	__le16 interval;
	__le16 latency;
	__le16 supervision_timeout;
	__u8 clk_accurancy;
} __attribute__((packed));

struct hci_evt_le_ext_adv_set_term {
	__u8 status;
	__u8 handle;
	__le16 conn_handle;
	__u8 num_evts;
} __attribute__((packed));

enum {
	HCI_SOCK_TRUSTED = 0,
	HCI_MGMT_INDEX_EVENTS = 1,
	HCI_MGMT_UNCONF_INDEX_EVENTS = 2,
	HCI_MGMT_EXT_INDEX_EVENTS = 3,
	HCI_MGMT_EXT_INFO_EVENTS = 4,
	HCI_MGMT_OPTION_EVENTS = 5,
	HCI_MGMT_SETTING_EVENTS = 6,
	HCI_MGMT_DEV_CLASS_EVENTS = 7,
	HCI_MGMT_LOCAL_NAME_EVENTS = 8,
	HCI_MGMT_OOB_DATA_EVENTS = 9,
	HCI_MGMT_EXP_FEATURE_EVENTS = 10,
};

struct hci_cp_user_passkey_reply {
	bdaddr_t bdaddr;
	__le32 passkey;
} __attribute__((packed));

struct hci_cp_read_rssi {
	__le16 handle;
};

struct smp_csrk {
	bdaddr_t bdaddr;
	u8 bdaddr_type;
	u8 type;
	u8 val[16];
};

struct hci_mgmt_handler {
	int (*func)(struct sock *, struct hci_dev *, void *, u16);
	size_t data_len;
	long unsigned int flags;
};

struct hci_mgmt_chan {
	struct list_head list;
	short unsigned int channel;
	size_t handler_count;
	const struct hci_mgmt_handler *handlers;
	void (*hdev_init)(struct sock *, struct hci_dev *);
};

struct mgmt_addr_info {
	bdaddr_t bdaddr;
	__u8 type;
};

struct mgmt_rp_read_version {
	__u8 version;
	__le16 revision;
} __attribute__((packed));

struct mgmt_rp_read_commands {
	__le16 num_commands;
	__le16 num_events;
	__le16 opcodes[0];
};

struct mgmt_rp_read_index_list {
	__le16 num_controllers;
	__le16 index[0];
};

struct mgmt_rp_read_info {
	bdaddr_t bdaddr;
	__u8 version;
	__le16 manufacturer;
	__le32 supported_settings;
	__le32 current_settings;
	__u8 dev_class[3];
	__u8 name[249];
	__u8 short_name[11];
} __attribute__((packed));

struct mgmt_mode {
	__u8 val;
};

struct mgmt_cp_set_discoverable {
	__u8 val;
	__le16 timeout;
} __attribute__((packed));

struct mgmt_cp_set_dev_class {
	__u8 major;
	__u8 minor;
};

struct mgmt_cp_set_local_name {
	__u8 name[249];
	__u8 short_name[11];
};

struct mgmt_cp_add_uuid {
	__u8 uuid[16];
	__u8 svc_hint;
};

struct mgmt_cp_remove_uuid {
	__u8 uuid[16];
};

struct mgmt_link_key_info {
	struct mgmt_addr_info addr;
	__u8 type;
	__u8 val[16];
	__u8 pin_len;
};

struct mgmt_cp_load_link_keys {
	__u8 debug_keys;
	__le16 key_count;
	struct mgmt_link_key_info keys[0];
} __attribute__((packed));

struct mgmt_ltk_info {
	struct mgmt_addr_info addr;
	__u8 type;
	__u8 master;
	__u8 enc_size;
	__le16 ediv;
	__le64 rand;
	__u8 val[16];
} __attribute__((packed));

struct mgmt_cp_load_long_term_keys {
	__le16 key_count;
	struct mgmt_ltk_info keys[0];
} __attribute__((packed));

struct mgmt_cp_disconnect {
	struct mgmt_addr_info addr;
};

struct mgmt_rp_disconnect {
	struct mgmt_addr_info addr;
};

struct mgmt_rp_get_connections {
	__le16 conn_count;
	struct mgmt_addr_info addr[0];
};

struct mgmt_cp_pin_code_reply {
	struct mgmt_addr_info addr;
	__u8 pin_len;
	__u8 pin_code[16];
};

struct mgmt_cp_pin_code_neg_reply {
	struct mgmt_addr_info addr;
};

struct mgmt_cp_set_io_capability {
	__u8 io_capability;
};

struct mgmt_cp_pair_device {
	struct mgmt_addr_info addr;
	__u8 io_cap;
};

struct mgmt_rp_pair_device {
	struct mgmt_addr_info addr;
};

struct mgmt_cp_unpair_device {
	struct mgmt_addr_info addr;
	__u8 disconnect;
};

struct mgmt_rp_unpair_device {
	struct mgmt_addr_info addr;
};

struct mgmt_cp_user_confirm_reply {
	struct mgmt_addr_info addr;
};

struct mgmt_cp_user_confirm_neg_reply {
	struct mgmt_addr_info addr;
};

struct mgmt_cp_user_passkey_reply {
	struct mgmt_addr_info addr;
	__le32 passkey;
} __attribute__((packed));

struct mgmt_cp_user_passkey_neg_reply {
	struct mgmt_addr_info addr;
};

struct mgmt_rp_read_local_oob_data {
	__u8 hash192[16];
	__u8 rand192[16];
	__u8 hash256[16];
	__u8 rand256[16];
};

struct mgmt_cp_add_remote_oob_data {
	struct mgmt_addr_info addr;
	__u8 hash[16];
	__u8 rand[16];
};

struct mgmt_cp_add_remote_oob_ext_data {
	struct mgmt_addr_info addr;
	__u8 hash192[16];
	__u8 rand192[16];
	__u8 hash256[16];
	__u8 rand256[16];
};

struct mgmt_cp_remove_remote_oob_data {
	struct mgmt_addr_info addr;
};

struct mgmt_cp_start_discovery {
	__u8 type;
};

struct mgmt_cp_stop_discovery {
	__u8 type;
};

struct mgmt_cp_confirm_name {
	struct mgmt_addr_info addr;
	__u8 name_known;
};

struct mgmt_cp_block_device {
	struct mgmt_addr_info addr;
};

struct mgmt_cp_unblock_device {
	struct mgmt_addr_info addr;
};

struct mgmt_cp_set_device_id {
	__le16 source;
	__le16 vendor;
	__le16 product;
	__le16 version;
};

struct mgmt_cp_set_static_address {
	bdaddr_t bdaddr;
};

struct mgmt_cp_set_scan_params {
	__le16 interval;
	__le16 window;
};

struct mgmt_cp_set_privacy {
	__u8 privacy;
	__u8 irk[16];
};

struct mgmt_irk_info {
	struct mgmt_addr_info addr;
	__u8 val[16];
};

struct mgmt_cp_load_irks {
	__le16 irk_count;
	struct mgmt_irk_info irks[0];
};

struct mgmt_cp_get_conn_info {
	struct mgmt_addr_info addr;
};

struct mgmt_rp_get_conn_info {
	struct mgmt_addr_info addr;
	__s8 rssi;
	__s8 tx_power;
	__s8 max_tx_power;
};

struct mgmt_cp_get_clock_info {
	struct mgmt_addr_info addr;
};

struct mgmt_rp_get_clock_info {
	struct mgmt_addr_info addr;
	__le32 local_clock;
	__le32 piconet_clock;
	__le16 accuracy;
} __attribute__((packed));

struct mgmt_cp_add_device {
	struct mgmt_addr_info addr;
	__u8 action;
};

struct mgmt_cp_remove_device {
	struct mgmt_addr_info addr;
};

struct mgmt_conn_param {
	struct mgmt_addr_info addr;
	__le16 min_interval;
	__le16 max_interval;
	__le16 latency;
	__le16 timeout;
} __attribute__((packed));

struct mgmt_cp_load_conn_param {
	__le16 param_count;
	struct mgmt_conn_param params[0];
};

struct mgmt_rp_read_unconf_index_list {
	__le16 num_controllers;
	__le16 index[0];
};

struct mgmt_rp_read_config_info {
	__le16 manufacturer;
	__le32 supported_options;
	__le32 missing_options;
} __attribute__((packed));

struct mgmt_cp_set_external_config {
	__u8 config;
};

struct mgmt_cp_set_public_address {
	bdaddr_t bdaddr;
};

struct mgmt_cp_start_service_discovery {
	__u8 type;
	__s8 rssi;
	__le16 uuid_count;
	__u8 uuids[0];
};

struct mgmt_cp_read_local_oob_ext_data {
	__u8 type;
};

struct mgmt_rp_read_local_oob_ext_data {
	__u8 type;
	__le16 eir_len;
	__u8 eir[0];
} __attribute__((packed));

struct mgmt_rp_read_ext_index_list {
	__le16 num_controllers;
	struct {
		__le16 index;
		__u8 type;
		__u8 bus;
	} entry[0];
};

struct mgmt_rp_read_adv_features {
	__le32 supported_flags;
	__u8 max_adv_data_len;
	__u8 max_scan_rsp_len;
	__u8 max_instances;
	__u8 num_instances;
	__u8 instance[0];
};

struct mgmt_cp_add_advertising {
	__u8 instance;
	__le32 flags;
	__le16 duration;
	__le16 timeout;
	__u8 adv_data_len;
	__u8 scan_rsp_len;
	__u8 data[0];
} __attribute__((packed));

struct mgmt_rp_add_advertising {
	__u8 instance;
};

struct mgmt_cp_remove_advertising {
	__u8 instance;
};

struct mgmt_rp_remove_advertising {
	__u8 instance;
};

struct mgmt_cp_get_adv_size_info {
	__u8 instance;
	__le32 flags;
} __attribute__((packed));

struct mgmt_rp_get_adv_size_info {
	__u8 instance;
	__le32 flags;
	__u8 max_adv_data_len;
	__u8 max_scan_rsp_len;
} __attribute__((packed));

struct mgmt_rp_read_ext_info {
	bdaddr_t bdaddr;
	__u8 version;
	__le16 manufacturer;
	__le32 supported_settings;
	__le32 current_settings;
	__le16 eir_len;
	__u8 eir[0];
} __attribute__((packed));

struct mgmt_cp_set_appearance {
	__le16 appearance;
};

struct mgmt_rp_get_phy_confguration {
	__le32 supported_phys;
	__le32 configurable_phys;
	__le32 selected_phys;
};

struct mgmt_cp_set_phy_confguration {
	__le32 selected_phys;
};

struct mgmt_blocked_key_info {
	__u8 type;
	__u8 val[16];
};

struct mgmt_cp_set_blocked_keys {
	__le16 key_count;
	struct mgmt_blocked_key_info keys[0];
};

struct mgmt_rp_read_security_info {
	__le16 sec_len;
	__u8 sec[0];
};

struct mgmt_rp_read_exp_features_info {
	__le16 feature_count;
	struct {
		__u8 uuid[16];
		__le32 flags;
	} features[0];
} __attribute__((packed));

struct mgmt_cp_set_exp_feature {
	__u8 uuid[16];
	__u8 param[0];
};

struct mgmt_rp_set_exp_feature {
	__u8 uuid[16];
	__le32 flags;
};

struct mgmt_cp_get_device_flags {
	struct mgmt_addr_info addr;
};

struct mgmt_rp_get_device_flags {
	struct mgmt_addr_info addr;
	__le32 supported_flags;
	__le32 current_flags;
} __attribute__((packed));

struct mgmt_cp_set_device_flags {
	struct mgmt_addr_info addr;
	__le32 current_flags;
} __attribute__((packed));

struct mgmt_rp_read_adv_monitor_features {
	__le32 supported_features;
	__le32 enabled_features;
	__le16 max_num_handles;
	__u8 max_num_patterns;
	__le16 num_handles;
	__le16 handles[0];
} __attribute__((packed));

struct mgmt_adv_pattern {
	__u8 ad_type;
	__u8 offset;
	__u8 length;
	__u8 value[31];
};

struct mgmt_cp_add_adv_patterns_monitor {
	__u8 pattern_count;
	struct mgmt_adv_pattern patterns[0];
};

struct mgmt_rp_add_adv_patterns_monitor {
	__le16 monitor_handle;
};

struct mgmt_cp_remove_adv_monitor {
	__le16 monitor_handle;
};

struct mgmt_rp_remove_adv_monitor {
	__le16 monitor_handle;
};

struct mgmt_ev_new_link_key {
	__u8 store_hint;
	struct mgmt_link_key_info key;
};

struct mgmt_ev_new_long_term_key {
	__u8 store_hint;
	struct mgmt_ltk_info key;
} __attribute__((packed));

struct mgmt_ev_device_connected {
	struct mgmt_addr_info addr;
	__le32 flags;
	__le16 eir_len;
	__u8 eir[0];
} __attribute__((packed));

struct mgmt_ev_device_disconnected {
	struct mgmt_addr_info addr;
	__u8 reason;
};

struct mgmt_ev_connect_failed {
	struct mgmt_addr_info addr;
	__u8 status;
};

struct mgmt_ev_pin_code_request {
	struct mgmt_addr_info addr;
	__u8 secure;
};

struct mgmt_ev_user_confirm_request {
	struct mgmt_addr_info addr;
	__u8 confirm_hint;
	__le32 value;
};

struct mgmt_ev_user_passkey_request {
	struct mgmt_addr_info addr;
};

struct mgmt_ev_auth_failed {
	struct mgmt_addr_info addr;
	__u8 status;
};

struct mgmt_ev_device_found {
	struct mgmt_addr_info addr;
	__s8 rssi;
	__le32 flags;
	__le16 eir_len;
	__u8 eir[0];
} __attribute__((packed));

struct mgmt_ev_discovering {
	__u8 type;
	__u8 discovering;
};

struct mgmt_ev_device_unpaired {
	struct mgmt_addr_info addr;
};

struct mgmt_ev_passkey_notify {
	struct mgmt_addr_info addr;
	__le32 passkey;
	__u8 entered;
} __attribute__((packed));

struct mgmt_ev_new_irk {
	__u8 store_hint;
	bdaddr_t rpa;
	struct mgmt_irk_info irk;
};

struct mgmt_csrk_info {
	struct mgmt_addr_info addr;
	__u8 type;
	__u8 val[16];
};

struct mgmt_ev_new_csrk {
	__u8 store_hint;
	struct mgmt_csrk_info key;
};

struct mgmt_ev_device_added {
	struct mgmt_addr_info addr;
	__u8 action;
};

struct mgmt_ev_device_removed {
	struct mgmt_addr_info addr;
};

struct mgmt_ev_new_conn_param {
	struct mgmt_addr_info addr;
	__u8 store_hint;
	__le16 min_interval;
	__le16 max_interval;
	__le16 latency;
	__le16 timeout;
};

struct mgmt_ev_ext_index {
	__u8 type;
	__u8 bus;
};

struct mgmt_ev_advertising_added {
	__u8 instance;
};

struct mgmt_ev_advertising_removed {
	__u8 instance;
};

struct mgmt_ev_ext_info_changed {
	__le16 eir_len;
	__u8 eir[0];
};

struct mgmt_ev_phy_configuration_changed {
	__le32 selected_phys;
};

struct mgmt_ev_exp_feature_changed {
	__u8 uuid[16];
	__le32 flags;
};

struct mgmt_ev_device_flags_changed {
	struct mgmt_addr_info addr;
	__le32 supported_flags;
	__le32 current_flags;
} __attribute__((packed));

struct mgmt_ev_adv_monitor_added {
	__le16 monitor_handle;
};

struct mgmt_ev_controller_suspend {
	__u8 suspend_state;
};

struct mgmt_ev_controller_resume {
	__u8 wake_reason;
	struct mgmt_addr_info addr;
};

struct mgmt_pending_cmd {
	struct list_head list;
	u16 opcode;
	int index;
	void *param;
	size_t param_len;
	struct sock *sk;
	void *user_data;
	int (*cmd_complete)(struct mgmt_pending_cmd *, u8);
};

struct cmd_lookup {
	struct sock *sk;
	struct hci_dev *hdev;
	u8 mgmt_status;
};

struct hci_ev_stack_internal {
	__u16 type;
	__u8 data[0];
};

struct hci_ev_si_device {
	__u16 event;
	__u16 dev_id;
};

struct sockaddr_hci {
	sa_family_t hci_family;
	short unsigned int hci_dev;
	short unsigned int hci_channel;
};

struct hci_filter {
	long unsigned int type_mask;
	long unsigned int event_mask[2];
	__le16 opcode;
};

struct hci_ufilter {
	__u32 type_mask;
	__u32 event_mask[2];
	__le16 opcode;
};

struct hci_mon_hdr {
	__le16 opcode;
	__le16 index;
	__le16 len;
};

struct hci_mon_new_index {
	__u8 type;
	__u8 bus;
	bdaddr_t bdaddr;
	char name[8];
};

struct hci_mon_index_info {
	bdaddr_t bdaddr;
	__le16 manufacturer;
};

struct mgmt_hdr {
	__le16 opcode;
	__le16 index;
	__le16 len;
};

struct hci_pinfo {
	struct bt_sock bt;
	struct hci_dev *hdev;
	struct hci_filter filter;
	__u8 cmsg_mask;
	short unsigned int channel;
	long unsigned int flags;
	__u32 cookie;
	char comm[16];
};

struct hci_sec_filter {
	__u32 type_mask;
	__u32 event_mask[2];
	__u32 ocf_mask[24];
};

struct l2cap_hdr {
	__le16 len;
	__le16 cid;
};

struct l2cap_cmd_hdr {
	__u8 code;
	__u8 ident;
	__le16 len;
};

struct l2cap_cmd_rej_unk {
	__le16 reason;
};

struct l2cap_cmd_rej_cid {
	__le16 reason;
	__le16 scid;
	__le16 dcid;
};

struct l2cap_conn_req {
	__le16 psm;
	__le16 scid;
};

struct l2cap_conn_rsp {
	__le16 dcid;
	__le16 scid;
	__le16 result;
	__le16 status;
};

struct l2cap_conf_req {
	__le16 dcid;
	__le16 flags;
	__u8 data[0];
};

struct l2cap_conf_rsp {
	__le16 scid;
	__le16 flags;
	__le16 result;
	__u8 data[0];
};

struct l2cap_conf_opt {
	__u8 type;
	__u8 len;
	__u8 val[0];
};

struct l2cap_conf_rfc {
	__u8 mode;
	__u8 txwin_size;
	__u8 max_transmit;
	__le16 retrans_timeout;
	__le16 monitor_timeout;
	__le16 max_pdu_size;
} __attribute__((packed));

struct l2cap_conf_efs {
	__u8 id;
	__u8 stype;
	__le16 msdu;
	__le32 sdu_itime;
	__le32 acc_lat;
	__le32 flush_to;
};

struct l2cap_disconn_req {
	__le16 dcid;
	__le16 scid;
};

struct l2cap_disconn_rsp {
	__le16 dcid;
	__le16 scid;
};

struct l2cap_info_req {
	__le16 type;
};

struct l2cap_info_rsp {
	__le16 type;
	__le16 result;
	__u8 data[0];
};

struct l2cap_create_chan_req {
	__le16 psm;
	__le16 scid;
	__u8 amp_id;
} __attribute__((packed));

struct l2cap_create_chan_rsp {
	__le16 dcid;
	__le16 scid;
	__le16 result;
	__le16 status;
};

struct l2cap_move_chan_req {
	__le16 icid;
	__u8 dest_amp_id;
} __attribute__((packed));

struct l2cap_move_chan_rsp {
	__le16 icid;
	__le16 result;
};

struct l2cap_move_chan_cfm {
	__le16 icid;
	__le16 result;
};

struct l2cap_move_chan_cfm_rsp {
	__le16 icid;
};

struct l2cap_conn_param_update_req {
	__le16 min;
	__le16 max;
	__le16 latency;
	__le16 to_multiplier;
};

struct l2cap_conn_param_update_rsp {
	__le16 result;
};

struct l2cap_le_conn_req {
	__le16 psm;
	__le16 scid;
	__le16 mtu;
	__le16 mps;
	__le16 credits;
};

struct l2cap_le_conn_rsp {
	__le16 dcid;
	__le16 mtu;
	__le16 mps;
	__le16 credits;
	__le16 result;
};

struct l2cap_le_credits {
	__le16 cid;
	__le16 credits;
};

struct l2cap_ecred_conn_req {
	__le16 psm;
	__le16 mtu;
	__le16 mps;
	__le16 credits;
	__le16 scid[0];
};

struct l2cap_ecred_conn_rsp {
	__le16 mtu;
	__le16 mps;
	__le16 credits;
	__le16 result;
	__le16 dcid[0];
};

struct l2cap_ecred_reconf_req {
	__le16 mtu;
	__le16 mps;
	__le16 scid[0];
};

struct l2cap_ecred_reconf_rsp {
	__le16 result;
};

struct l2cap_user {
	struct list_head list;
	int (*probe)(struct l2cap_conn *, struct l2cap_user *);
	void (*remove)(struct l2cap_conn *, struct l2cap_user *);
};

enum {
	CONF_REQ_SENT = 0,
	CONF_INPUT_DONE = 1,
	CONF_OUTPUT_DONE = 2,
	CONF_MTU_DONE = 3,
	CONF_MODE_DONE = 4,
	CONF_CONNECT_PEND = 5,
	CONF_RECV_NO_FCS = 6,
	CONF_STATE2_DEVICE = 7,
	CONF_EWS_RECV = 8,
	CONF_LOC_CONF_PEND = 9,
	CONF_REM_CONF_PEND = 10,
	CONF_NOT_COMPLETE = 11,
};

enum {
	CONN_SREJ_SENT = 0,
	CONN_WAIT_F = 1,
	CONN_SREJ_ACT = 2,
	CONN_SEND_PBIT = 3,
	CONN_REMOTE_BUSY = 4,
	CONN_LOCAL_BUSY = 5,
	CONN_REJ_ACT = 6,
	CONN_SEND_FBIT = 7,
	CONN_RNR_SENT = 8,
};

enum {
	FLAG_ROLE_SWITCH = 0,
	FLAG_FORCE_ACTIVE = 1,
	FLAG_FORCE_RELIABLE = 2,
	FLAG_FLUSHABLE = 3,
	FLAG_EXT_CTRL = 4,
	FLAG_EFS_ENABLE = 5,
	FLAG_DEFER_SETUP = 6,
	FLAG_LE_CONN_REQ_SENT = 7,
	FLAG_ECRED_CONN_REQ_SENT = 8,
	FLAG_PENDING_SECURITY = 9,
	FLAG_HOLD_HCI_CONN = 10,
};

enum {
	L2CAP_NESTING_SMP = 0,
	L2CAP_NESTING_NORMAL = 1,
	L2CAP_NESTING_PARENT = 2,
};

enum {
	L2CAP_TX_STATE_XMIT = 0,
	L2CAP_TX_STATE_WAIT_F = 1,
};

enum {
	L2CAP_RX_STATE_RECV = 0,
	L2CAP_RX_STATE_SREJ_SENT = 1,
	L2CAP_RX_STATE_MOVE = 2,
	L2CAP_RX_STATE_WAIT_P = 3,
	L2CAP_RX_STATE_WAIT_F = 4,
};

enum {
	L2CAP_TXSEQ_EXPECTED = 0,
	L2CAP_TXSEQ_EXPECTED_SREJ = 1,
	L2CAP_TXSEQ_UNEXPECTED = 2,
	L2CAP_TXSEQ_UNEXPECTED_SREJ = 3,
	L2CAP_TXSEQ_DUPLICATE = 4,
	L2CAP_TXSEQ_DUPLICATE_SREJ = 5,
	L2CAP_TXSEQ_INVALID = 6,
	L2CAP_TXSEQ_INVALID_IGNORE = 7,
};

enum {
	L2CAP_EV_DATA_REQUEST = 0,
	L2CAP_EV_LOCAL_BUSY_DETECTED = 1,
	L2CAP_EV_LOCAL_BUSY_CLEAR = 2,
	L2CAP_EV_RECV_REQSEQ_AND_FBIT = 3,
	L2CAP_EV_RECV_FBIT = 4,
	L2CAP_EV_RETRANS_TO = 5,
	L2CAP_EV_MONITOR_TO = 6,
	L2CAP_EV_EXPLICIT_POLL = 7,
	L2CAP_EV_RECV_IFRAME = 8,
	L2CAP_EV_RECV_RR = 9,
	L2CAP_EV_RECV_REJ = 10,
	L2CAP_EV_RECV_RNR = 11,
	L2CAP_EV_RECV_SREJ = 12,
	L2CAP_EV_RECV_FRAME = 13,
};

enum {
	L2CAP_MOVE_ROLE_NONE = 0,
	L2CAP_MOVE_ROLE_INITIATOR = 1,
	L2CAP_MOVE_ROLE_RESPONDER = 2,
};

enum {
	L2CAP_MOVE_STABLE = 0,
	L2CAP_MOVE_WAIT_REQ = 1,
	L2CAP_MOVE_WAIT_RSP = 2,
	L2CAP_MOVE_WAIT_RSP_SUCCESS = 3,
	L2CAP_MOVE_WAIT_CONFIRM = 4,
	L2CAP_MOVE_WAIT_CONFIRM_RSP = 5,
	L2CAP_MOVE_WAIT_LOGICAL_COMP = 6,
	L2CAP_MOVE_WAIT_LOGICAL_CFM = 7,
	L2CAP_MOVE_WAIT_LOCAL_BUSY = 8,
	L2CAP_MOVE_WAIT_PREPARE = 9,
};

typedef void (*l2cap_chan_func_t)(struct l2cap_chan *, void *);

enum smp_key_pref {
	SMP_ALLOW_STK = 0,
	SMP_USE_LTK = 1,
};

struct l2cap_ecred_conn_data {
	struct {
		struct l2cap_ecred_conn_req req;
		__le16 scid[5];
	} pdu;
	struct l2cap_chan *chan;
	struct pid *pid;
	int count;
};

struct l2cap_chan_data {
	struct l2cap_chan *chan;
	struct pid *pid;
	int count;
};

struct bt_security {
	__u8 level;
	__u8 key_size;
};

struct bt_power {
	__u8 force_active;
};

struct sockaddr_l2 {
	sa_family_t l2_family;
	__le16 l2_psm;
	bdaddr_t l2_bdaddr;
	__le16 l2_cid;
	__u8 l2_bdaddr_type;
};

struct l2cap_options {
	__u16 omtu;
	__u16 imtu;
	__u16 flush_to;
	__u8 mode;
	__u8 fcs;
	__u8 max_tx;
	__u16 txwin_size;
};

struct l2cap_conninfo {
	__u16 hci_handle;
	__u8 dev_class[3];
};

struct l2cap_pinfo {
	struct bt_sock bt;
	struct l2cap_chan *chan;
	struct sk_buff *rx_busy_skb;
};

typedef struct {
	u64 a;
	u64 b;
} u128___2;

struct smp_cmd_pairing {
	__u8 io_capability;
	__u8 oob_flag;
	__u8 auth_req;
	__u8 max_key_size;
	__u8 init_key_dist;
	__u8 resp_key_dist;
};

struct smp_cmd_pairing_confirm {
	__u8 confirm_val[16];
};

struct smp_cmd_encrypt_info {
	__u8 ltk[16];
};

struct smp_cmd_master_ident {
	__le16 ediv;
	__le64 rand;
} __attribute__((packed));

struct smp_cmd_ident_info {
	__u8 irk[16];
};

struct smp_cmd_ident_addr_info {
	__u8 addr_type;
	bdaddr_t bdaddr;
};

struct smp_cmd_sign_info {
	__u8 csrk[16];
};

struct smp_cmd_security_req {
	__u8 auth_req;
};

struct smp_cmd_public_key {
	__u8 x[32];
	__u8 y[32];
};

struct smp_cmd_dhkey_check {
	__u8 e[16];
};

struct smp_cmd_keypress_notify {
	__u8 value;
};

enum {
	SMP_FLAG_TK_VALID = 0,
	SMP_FLAG_CFM_PENDING = 1,
	SMP_FLAG_MITM_AUTH = 2,
	SMP_FLAG_COMPLETE = 3,
	SMP_FLAG_INITIATOR = 4,
	SMP_FLAG_SC = 5,
	SMP_FLAG_REMOTE_PK = 6,
	SMP_FLAG_DEBUG_KEY = 7,
	SMP_FLAG_WAIT_USER = 8,
	SMP_FLAG_DHKEY_PENDING = 9,
	SMP_FLAG_REMOTE_OOB = 10,
	SMP_FLAG_LOCAL_OOB = 11,
	SMP_FLAG_CT2 = 12,
};

struct smp_dev {
	bool local_oob;
	u8 local_pk[64];
	u8 local_rand[16];
	bool debug_key;
	struct crypto_shash *tfm_cmac;
	struct crypto_kpp *tfm_ecdh;
};

struct smp_chan {
	struct l2cap_conn *conn;
	struct delayed_work security_timer;
	long unsigned int allow_cmd;
	u8 preq[7];
	u8 prsp[7];
	u8 prnd[16];
	u8 rrnd[16];
	u8 pcnf[16];
	u8 tk[16];
	u8 rr[16];
	u8 lr[16];
	u8 enc_key_size;
	u8 remote_key_dist;
	bdaddr_t id_addr;
	u8 id_addr_type;
	u8 irk[16];
	struct smp_csrk *csrk;
	struct smp_csrk *slave_csrk;
	struct smp_ltk *ltk;
	struct smp_ltk *slave_ltk;
	struct smp_irk *remote_irk;
	u8 *link_key;
	long unsigned int flags;
	u8 method;
	u8 passkey_round;
	u8 local_pk[64];
	u8 remote_pk[64];
	u8 dhkey[32];
	u8 mackey[16];
	struct crypto_shash *tfm_cmac;
	struct crypto_kpp *tfm_ecdh;
};

struct ecdh_completion {
	struct completion completion;
	int err;
};

struct hci_cp_remote_name_req_cancel {
	bdaddr_t bdaddr;
};

struct hci_cp_reject_sync_conn_req {
	bdaddr_t bdaddr;
	__u8 reason;
};

struct hci_cp_disconn_phy_link {
	__u8 phy_handle;
	__u8 reason;
};

struct hci_cp_set_event_filter {
	__u8 flt_type;
	__u8 cond_type;
	struct {
		bdaddr_t bdaddr;
		__u8 auto_accept;
	} addr_conn_flt;
};

struct hci_cp_write_local_name {
	__u8 name[248];
};

struct hci_cp_write_current_iac_lap {
	__u8 num_iac;
	__u8 iac_lap[6];
};

struct hci_cp_le_set_adv_data {
	__u8 length;
	__u8 data[31];
};

struct hci_cp_le_set_scan_rsp_data {
	__u8 length;
	__u8 data[31];
};

struct hci_cp_ext_adv_set {
	__u8 handle;
	__le16 duration;
	__u8 max_events;
} __attribute__((packed));

struct hci_cp_le_set_ext_adv_data {
	__u8 handle;
	__u8 operation;
	__u8 frag_pref;
	__u8 length;
	__u8 data[31];
};

struct hci_cp_le_set_ext_scan_rsp_data {
	__u8 handle;
	__u8 operation;
	__u8 frag_pref;
	__u8 length;
	__u8 data[31];
};

struct mgmt_ev_cmd_complete {
	__le16 opcode;
	__u8 status;
	__u8 data[0];
} __attribute__((packed));

struct mgmt_ev_cmd_status {
	__le16 opcode;
	__u8 status;
} __attribute__((packed));

struct mgmt_tlv {
	__le16 type;
	__u8 length;
	__u8 value[0];
} __attribute__((packed));

struct mgmt_rp_read_def_system_config;

struct bt_voice {
	__u16 setting;
};

struct sockaddr_sco {
	sa_family_t sco_family;
	bdaddr_t sco_bdaddr;
};

struct sco_options {
	__u16 mtu;
};

struct sco_conninfo {
	__u16 hci_handle;
	__u8 dev_class[3];
};

struct sco_conn {
	struct hci_conn *hcon;
	spinlock_t lock;
	struct sock *sk;
	struct delayed_work timeout_work;
	unsigned int mtu;
};

struct sco_pinfo {
	struct bt_sock bt;
	bdaddr_t src;
	bdaddr_t dst;
	__u32 flags;
	__u16 setting;
	__u8 cmsg_mask;
	struct sco_conn *conn;
};

struct rfcomm_hdr {
	u8 addr;
	u8 ctrl;
	u8 len;
};

struct rfcomm_cmd {
	u8 addr;
	u8 ctrl;
	u8 len;
	u8 fcs;
};

struct rfcomm_mcc {
	u8 type;
	u8 len;
};

struct rfcomm_pn {
	u8 dlci;
	u8 flow_ctrl;
	u8 priority;
	u8 ack_timer;
	__le16 mtu;
	u8 max_retrans;
	u8 credits;
};

struct rfcomm_rpn {
	u8 dlci;
	u8 bit_rate;
	u8 line_settings;
	u8 flow_ctrl;
	u8 xon_char;
	u8 xoff_char;
	__le16 param_mask;
};

struct rfcomm_rls {
	u8 dlci;
	u8 status;
};

struct rfcomm_msc {
	u8 dlci;
	u8 v24_sig;
};

struct rfcomm_session {
	struct list_head list;
	struct socket *sock;
	struct timer_list timer;
	long unsigned int state;
	long unsigned int flags;
	int initiator;
	int cfc;
	uint mtu;
	struct list_head dlcs;
};

struct rfcomm_dlc {
	struct list_head list;
	struct rfcomm_session *session;
	struct sk_buff_head tx_queue;
	struct timer_list timer;
	struct mutex lock;
	long unsigned int state;
	long unsigned int flags;
	refcount_t refcnt;
	u8 dlci;
	u8 addr;
	u8 priority;
	u8 v24_sig;
	u8 remote_v24_sig;
	u8 mscex;
	u8 out;
	u8 sec_level;
	u8 role_switch;
	u32 defer_setup;
	uint mtu;
	uint cfc;
	uint rx_credits;
	uint tx_credits;
	void *owner;
	void (*data_ready)(struct rfcomm_dlc *, struct sk_buff *);
	void (*state_change)(struct rfcomm_dlc *, int);
	void (*modem_status)(struct rfcomm_dlc *, u8);
};

struct sockaddr_rc {
	sa_family_t rc_family;
	bdaddr_t rc_bdaddr;
	u8 rc_channel;
};

struct rfcomm_conninfo {
	__u16 hci_handle;
	__u8 dev_class[3];
};

struct rfcomm_pinfo {
	struct bt_sock bt;
	bdaddr_t src;
	bdaddr_t dst;
	struct rfcomm_dlc *dlc;
	u8 channel;
	u8 sec_level;
	u8 role_switch;
};

struct rfcomm_dev_req {
	s16 dev_id;
	u32 flags;
	bdaddr_t src;
	bdaddr_t dst;
	u8 channel;
};

struct rfcomm_dev_info {
	s16 id;
	u32 flags;
	u16 state;
	bdaddr_t src;
	bdaddr_t dst;
	u8 channel;
};

struct rfcomm_dev_list_req {
	u16 dev_num;
	struct rfcomm_dev_info dev_info[0];
};

struct rfcomm_dev {
	struct tty_port port;
	struct list_head list;
	char name[12];
	int id;
	long unsigned int flags;
	int err;
	long unsigned int status;
	bdaddr_t src;
	bdaddr_t dst;
	u8 channel;
	uint modem_status;
	struct rfcomm_dlc *dlc;
	struct device *tty_dev;
	atomic_t wmem_alloc;
	struct sk_buff_head pending;
};

struct bnep_control_rsp {
	__u8 type;
	__u8 ctrl;
	__be16 resp;
};

struct bnep_ext_hdr {
	__u8 type;
	__u8 len;
	__u8 data[0];
};

struct bnep_connadd_req {
	int sock;
	__u32 flags;
	__u16 role;
	char device[16];
};

struct bnep_conndel_req {
	__u32 flags;
	__u8 dst[6];
};

struct bnep_conninfo {
	__u32 flags;
	__u16 role;
	__u16 state;
	__u8 dst[6];
	char device[16];
};

struct bnep_connlist_req {
	__u32 cnum;
	struct bnep_conninfo *ci;
};

struct bnep_proto_filter {
	__u16 start;
	__u16 end;
};

struct bnep_session {
	struct list_head list;
	unsigned int role;
	long unsigned int state;
	long unsigned int flags;
	atomic_t terminate;
	struct task_struct *task;
	struct ethhdr eh;
	struct msghdr msg;
	struct bnep_proto_filter proto_filter[5];
	long long unsigned int mc_filter;
	struct socket *sock;
	struct net_device *dev;
};

struct hidp_connadd_req {
	int ctrl_sock;
	int intr_sock;
	__u16 parser;
	__u16 rd_size;
	__u8 *rd_data;
	__u8 country;
	__u8 subclass;
	__u16 vendor;
	__u16 product;
	__u16 version;
	__u32 flags;
	__u32 idle_to;
	char name[128];
};

struct hidp_conndel_req {
	bdaddr_t bdaddr;
	__u32 flags;
};

struct hidp_conninfo {
	bdaddr_t bdaddr;
	__u32 flags;
	__u16 state;
	__u16 vendor;
	__u16 product;
	__u16 version;
	char name[128];
};

struct hidp_connlist_req {
	__u32 cnum;
	struct hidp_conninfo *ci;
};

enum hidp_session_state {
	HIDP_SESSION_IDLING = 0,
	HIDP_SESSION_PREPARING = 1,
	HIDP_SESSION_RUNNING = 2,
};

struct hidp_session {
	struct list_head list;
	struct kref ref;
	atomic_t state;
	wait_queue_head_t state_queue;
	atomic_t terminate;
	struct task_struct *task;
	long unsigned int flags;
	bdaddr_t bdaddr;
	struct l2cap_conn *conn;
	struct l2cap_user user;
	struct socket *ctrl_sock;
	struct socket *intr_sock;
	struct sk_buff_head ctrl_transmit;
	struct sk_buff_head intr_transmit;
	uint ctrl_mtu;
	uint intr_mtu;
	long unsigned int idle_to;
	struct work_struct dev_init;
	struct input_dev *input;
	struct hid_device *hid;
	struct timer_list timer;
	__u8 *rd_data;
	uint rd_size;
	unsigned char keys[8];
	unsigned char leds;
	int waiting_report_type;
	int waiting_report_number;
	struct mutex report_mutex;
	struct sk_buff *report_return;
	wait_queue_head_t report_queue;
	int output_report_success;
	u8 input_buf[8192];
};

enum rpc_msg_type {
	RPC_CALL = 0,
	RPC_REPLY = 1,
};

enum rpc_reply_stat {
	RPC_MSG_ACCEPTED = 0,
	RPC_MSG_DENIED = 1,
};

enum rpc_reject_stat {
	RPC_MISMATCH = 0,
	RPC_AUTH_ERROR = 1,
};

enum {
	SUNRPC_PIPEFS_NFS_PRIO = 0,
	SUNRPC_PIPEFS_RPC_PRIO = 1,
};

enum {
	RPC_PIPEFS_MOUNT = 0,
	RPC_PIPEFS_UMOUNT = 1,
};

struct sunrpc_net {
	struct proc_dir_entry *proc_net_rpc;
	struct cache_detail *ip_map_cache;
	struct cache_detail *unix_gid_cache;
	struct cache_detail *rsc_cache;
	struct cache_detail *rsi_cache;
	struct super_block *pipefs_sb;
	struct rpc_pipe *gssd_dummy;
	struct mutex pipefs_sb_lock;
	struct list_head all_clients;
	spinlock_t rpc_client_lock;
	struct rpc_clnt *rpcb_local_clnt;
	struct rpc_clnt *rpcb_local_clnt4;
	spinlock_t rpcb_clnt_lock;
	unsigned int rpcb_users;
	unsigned int rpcb_is_af_local: 1;
	struct mutex gssp_lock;
	struct rpc_clnt *gssp_clnt;
	int use_gss_proxy;
	int pipe_version;
	atomic_t pipe_users;
	struct proc_dir_entry *use_gssp_proc;
};

struct rpc_cb_add_xprt_calldata {
	struct rpc_xprt_switch *xps;
	struct rpc_xprt *xprt;
};

struct connect_timeout_data {
	long unsigned int connect_timeout;
	long unsigned int reconnect_timeout;
};

struct xprt_class {
	struct list_head list;
	int ident;
	struct rpc_xprt * (*setup)(struct xprt_create *);
	struct module *owner;
	char name[32];
	const char *netid[0];
};

enum xprt_xid_rb_cmp {
	XID_RB_EQUAL = 0,
	XID_RB_LEFT = 1,
	XID_RB_RIGHT = 2,
};

typedef __be32 rpc_fraghdr;

struct xdr_skb_reader {
	struct sk_buff *skb;
	unsigned int offset;
	size_t count;
	__wsum csum;
};

typedef size_t (*xdr_skb_read_actor)(struct xdr_skb_reader *, void *, size_t);

struct svc_sock {
	struct svc_xprt sk_xprt;
	struct socket *sk_sock;
	struct sock *sk_sk;
	void (*sk_ostate)(struct sock *);
	void (*sk_odata)(struct sock *);
	void (*sk_owspace)(struct sock *);
	__be32 sk_marker;
	u32 sk_tcplen;
	u32 sk_datalen;
	struct page *sk_pages[259];
};

struct sock_xprt {
	struct rpc_xprt xprt;
	struct socket *sock;
	struct sock *inet;
	struct file *file;
	struct {
		struct {
			__be32 fraghdr;
			__be32 xid;
			__be32 calldir;
		};
		u32 offset;
		u32 len;
		long unsigned int copied;
	} recv;
	struct {
		u32 offset;
	} xmit;
	long unsigned int sock_state;
	struct delayed_work connect_worker;
	struct work_struct error_worker;
	struct work_struct recv_worker;
	struct mutex recv_mutex;
	struct __kernel_sockaddr_storage srcaddr;
	short unsigned int srcport;
	int xprt_err;
	size_t rcvsize;
	size_t sndsize;
	struct rpc_timeout tcp_timeout;
	void (*old_data_ready)(struct sock *);
	void (*old_state_change)(struct sock *);
	void (*old_write_space)(struct sock *);
	void (*old_error_report)(struct sock *);
};

struct rpc_buffer {
	size_t len;
	char data[0];
};

typedef void (*rpc_action)(struct rpc_task *);

struct trace_event_raw_rpc_xdr_buf_class {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	const void *head_base;
	size_t head_len;
	const void *tail_base;
	size_t tail_len;
	unsigned int page_len;
	unsigned int msg_len;
	char __data[0];
};

struct trace_event_raw_rpc_clnt_class {
	struct trace_entry ent;
	unsigned int client_id;
	char __data[0];
};

struct trace_event_raw_rpc_clnt_new {
	struct trace_entry ent;
	unsigned int client_id;
	u32 __data_loc_addr;
	u32 __data_loc_port;
	u32 __data_loc_program;
	u32 __data_loc_server;
	char __data[0];
};

struct trace_event_raw_rpc_clnt_new_err {
	struct trace_entry ent;
	int error;
	u32 __data_loc_program;
	u32 __data_loc_server;
	char __data[0];
};

struct trace_event_raw_rpc_clnt_clone_err {
	struct trace_entry ent;
	unsigned int client_id;
	int error;
	char __data[0];
};

struct trace_event_raw_rpc_task_status {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	int status;
	char __data[0];
};

struct trace_event_raw_rpc_request {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	int version;
	bool async;
	u32 __data_loc_progname;
	u32 __data_loc_procname;
	char __data[0];
};

struct trace_event_raw_rpc_task_running {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	const void *action;
	long unsigned int runstate;
	int status;
	short unsigned int flags;
	char __data[0];
};

struct trace_event_raw_rpc_task_queued {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	long unsigned int timeout;
	long unsigned int runstate;
	int status;
	short unsigned int flags;
	u32 __data_loc_q_name;
	char __data[0];
};

struct trace_event_raw_rpc_failure {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	char __data[0];
};

struct trace_event_raw_rpc_reply_event {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	u32 xid;
	u32 __data_loc_progname;
	u32 version;
	u32 __data_loc_procname;
	u32 __data_loc_servername;
	char __data[0];
};

struct trace_event_raw_rpc_buf_alloc {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	size_t callsize;
	size_t recvsize;
	int status;
	char __data[0];
};

struct trace_event_raw_rpc_call_rpcerror {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	int tk_status;
	int rpc_status;
	char __data[0];
};

struct trace_event_raw_rpc_stats_latency {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	u32 xid;
	int version;
	u32 __data_loc_progname;
	u32 __data_loc_procname;
	long unsigned int backlog;
	long unsigned int rtt;
	long unsigned int execute;
	char __data[0];
};

struct trace_event_raw_rpc_xdr_overflow {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	int version;
	size_t requested;
	const void *end;
	const void *p;
	const void *head_base;
	size_t head_len;
	const void *tail_base;
	size_t tail_len;
	unsigned int page_len;
	unsigned int len;
	u32 __data_loc_progname;
	u32 __data_loc_procedure;
	char __data[0];
};

struct trace_event_raw_rpc_xdr_alignment {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	int version;
	size_t offset;
	unsigned int copied;
	const void *head_base;
	size_t head_len;
	const void *tail_base;
	size_t tail_len;
	unsigned int page_len;
	unsigned int len;
	u32 __data_loc_progname;
	u32 __data_loc_procedure;
	char __data[0];
};

struct trace_event_raw_xs_socket_event {
	struct trace_entry ent;
	unsigned int socket_state;
	unsigned int sock_state;
	long long unsigned int ino;
	u32 __data_loc_dstaddr;
	u32 __data_loc_dstport;
	char __data[0];
};

struct trace_event_raw_xs_socket_event_done {
	struct trace_entry ent;
	int error;
	unsigned int socket_state;
	unsigned int sock_state;
	long long unsigned int ino;
	u32 __data_loc_dstaddr;
	u32 __data_loc_dstport;
	char __data[0];
};

struct trace_event_raw_rpc_socket_nospace {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	unsigned int total;
	unsigned int remaining;
	char __data[0];
};

struct trace_event_raw_rpc_xprt_lifetime_class {
	struct trace_entry ent;
	long unsigned int state;
	u32 __data_loc_addr;
	u32 __data_loc_port;
	char __data[0];
};

struct trace_event_raw_rpc_xprt_event {
	struct trace_entry ent;
	u32 xid;
	int status;
	u32 __data_loc_addr;
	u32 __data_loc_port;
	char __data[0];
};

struct trace_event_raw_xprt_transmit {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	u32 xid;
	u32 seqno;
	int status;
	char __data[0];
};

struct trace_event_raw_xprt_ping {
	struct trace_entry ent;
	int status;
	u32 __data_loc_addr;
	u32 __data_loc_port;
	char __data[0];
};

struct trace_event_raw_xprt_writelock_event {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	unsigned int snd_task_id;
	char __data[0];
};

struct trace_event_raw_xprt_cong_event {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	unsigned int snd_task_id;
	long unsigned int cong;
	long unsigned int cwnd;
	bool wait;
	char __data[0];
};

struct trace_event_raw_xprt_reserve {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	u32 xid;
	char __data[0];
};

struct trace_event_raw_xs_stream_read_data {
	struct trace_entry ent;
	ssize_t err;
	size_t total;
	u32 __data_loc_addr;
	u32 __data_loc_port;
	char __data[0];
};

struct trace_event_raw_xs_stream_read_request {
	struct trace_entry ent;
	u32 __data_loc_addr;
	u32 __data_loc_port;
	u32 xid;
	long unsigned int copied;
	unsigned int reclen;
	unsigned int offset;
	char __data[0];
};

struct trace_event_raw_rpcb_getport {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	unsigned int program;
	unsigned int version;
	int protocol;
	unsigned int bind_version;
	u32 __data_loc_servername;
	char __data[0];
};

struct trace_event_raw_rpcb_setport {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	int status;
	short unsigned int port;
	char __data[0];
};

struct trace_event_raw_pmap_register {
	struct trace_entry ent;
	unsigned int program;
	unsigned int version;
	int protocol;
	unsigned int port;
	char __data[0];
};

struct trace_event_raw_rpcb_register {
	struct trace_entry ent;
	unsigned int program;
	unsigned int version;
	u32 __data_loc_addr;
	u32 __data_loc_netid;
	char __data[0];
};

struct trace_event_raw_rpcb_unregister {
	struct trace_entry ent;
	unsigned int program;
	unsigned int version;
	u32 __data_loc_netid;
	char __data[0];
};

struct trace_event_raw_svc_xdr_buf_class {
	struct trace_entry ent;
	u32 xid;
	const void *head_base;
	size_t head_len;
	const void *tail_base;
	size_t tail_len;
	unsigned int page_len;
	unsigned int msg_len;
	char __data[0];
};

struct trace_event_raw_svc_recv {
	struct trace_entry ent;
	u32 xid;
	int len;
	long unsigned int flags;
	u32 __data_loc_addr;
	char __data[0];
};

struct trace_event_raw_svc_authenticate {
	struct trace_entry ent;
	u32 xid;
	long unsigned int svc_status;
	long unsigned int auth_stat;
	char __data[0];
};

struct trace_event_raw_svc_process {
	struct trace_entry ent;
	u32 xid;
	u32 vers;
	u32 proc;
	u32 __data_loc_service;
	u32 __data_loc_addr;
	char __data[0];
};

struct trace_event_raw_svc_rqst_event {
	struct trace_entry ent;
	u32 xid;
	long unsigned int flags;
	u32 __data_loc_addr;
	char __data[0];
};

struct trace_event_raw_svc_rqst_status {
	struct trace_entry ent;
	u32 xid;
	int status;
	long unsigned int flags;
	u32 __data_loc_addr;
	char __data[0];
};

struct trace_event_raw_svc_xprt_create_err {
	struct trace_entry ent;
	long int error;
	u32 __data_loc_program;
	u32 __data_loc_protocol;
	unsigned char addr[28];
	char __data[0];
};

struct trace_event_raw_svc_xprt_do_enqueue {
	struct trace_entry ent;
	int pid;
	long unsigned int flags;
	u32 __data_loc_addr;
	char __data[0];
};

struct trace_event_raw_svc_xprt_event {
	struct trace_entry ent;
	long unsigned int flags;
	u32 __data_loc_addr;
	char __data[0];
};

struct trace_event_raw_svc_xprt_accept {
	struct trace_entry ent;
	u32 __data_loc_addr;
	u32 __data_loc_protocol;
	u32 __data_loc_service;
	char __data[0];
};

struct trace_event_raw_svc_xprt_dequeue {
	struct trace_entry ent;
	long unsigned int flags;
	long unsigned int wakeup;
	u32 __data_loc_addr;
	char __data[0];
};

struct trace_event_raw_svc_wake_up {
	struct trace_entry ent;
	int pid;
	char __data[0];
};

struct trace_event_raw_svc_handle_xprt {
	struct trace_entry ent;
	int len;
	long unsigned int flags;
	u32 __data_loc_addr;
	char __data[0];
};

struct trace_event_raw_svc_stats_latency {
	struct trace_entry ent;
	u32 xid;
	long unsigned int execute;
	u32 __data_loc_addr;
	char __data[0];
};

struct trace_event_raw_svc_deferred_event {
	struct trace_entry ent;
	const void *dr;
	u32 xid;
	__u8 addr[58];
	char __data[0];
};

struct trace_event_raw_svcsock_new_socket {
	struct trace_entry ent;
	long unsigned int type;
	long unsigned int family;
	bool listener;
	char __data[0];
};

struct trace_event_raw_svcsock_marker {
	struct trace_entry ent;
	unsigned int length;
	bool last;
	u32 __data_loc_addr;
	char __data[0];
};

struct trace_event_raw_svcsock_class {
	struct trace_entry ent;
	ssize_t result;
	long unsigned int flags;
	u32 __data_loc_addr;
	char __data[0];
};

struct trace_event_raw_svcsock_tcp_recv_short {
	struct trace_entry ent;
	u32 expected;
	u32 received;
	long unsigned int flags;
	u32 __data_loc_addr;
	char __data[0];
};

struct trace_event_raw_svcsock_tcp_state {
	struct trace_entry ent;
	long unsigned int socket_state;
	long unsigned int sock_state;
	long unsigned int flags;
	u32 __data_loc_addr;
	char __data[0];
};

struct trace_event_raw_svcsock_accept_class {
	struct trace_entry ent;
	long int status;
	u32 __data_loc_service;
	unsigned char addr[28];
	char __data[0];
};

struct trace_event_raw_cache_event {
	struct trace_entry ent;
	const struct cache_head *h;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_register_class {
	struct trace_entry ent;
	u32 version;
	long unsigned int family;
	short unsigned int protocol;
	short unsigned int port;
	int error;
	u32 __data_loc_program;
	char __data[0];
};

struct trace_event_raw_svc_unregister {
	struct trace_entry ent;
	u32 version;
	int error;
	u32 __data_loc_program;
	char __data[0];
};

struct trace_event_data_offsets_rpc_xdr_buf_class {};

struct trace_event_data_offsets_rpc_clnt_class {};

struct trace_event_data_offsets_rpc_clnt_new {
	u32 addr;
	u32 port;
	u32 program;
	u32 server;
};

struct trace_event_data_offsets_rpc_clnt_new_err {
	u32 program;
	u32 server;
};

struct trace_event_data_offsets_rpc_clnt_clone_err {};

struct trace_event_data_offsets_rpc_task_status {};

struct trace_event_data_offsets_rpc_request {
	u32 progname;
	u32 procname;
};

struct trace_event_data_offsets_rpc_task_running {};

struct trace_event_data_offsets_rpc_task_queued {
	u32 q_name;
};

struct trace_event_data_offsets_rpc_failure {};

struct trace_event_data_offsets_rpc_reply_event {
	u32 progname;
	u32 procname;
	u32 servername;
};

struct trace_event_data_offsets_rpc_buf_alloc {};

struct trace_event_data_offsets_rpc_call_rpcerror {};

struct trace_event_data_offsets_rpc_stats_latency {
	u32 progname;
	u32 procname;
};

struct trace_event_data_offsets_rpc_xdr_overflow {
	u32 progname;
	u32 procedure;
};

struct trace_event_data_offsets_rpc_xdr_alignment {
	u32 progname;
	u32 procedure;
};

struct trace_event_data_offsets_xs_socket_event {
	u32 dstaddr;
	u32 dstport;
};

struct trace_event_data_offsets_xs_socket_event_done {
	u32 dstaddr;
	u32 dstport;
};

struct trace_event_data_offsets_rpc_socket_nospace {};

struct trace_event_data_offsets_rpc_xprt_lifetime_class {
	u32 addr;
	u32 port;
};

struct trace_event_data_offsets_rpc_xprt_event {
	u32 addr;
	u32 port;
};

struct trace_event_data_offsets_xprt_transmit {};

struct trace_event_data_offsets_xprt_ping {
	u32 addr;
	u32 port;
};

struct trace_event_data_offsets_xprt_writelock_event {};

struct trace_event_data_offsets_xprt_cong_event {};

struct trace_event_data_offsets_xprt_reserve {};

struct trace_event_data_offsets_xs_stream_read_data {
	u32 addr;
	u32 port;
};

struct trace_event_data_offsets_xs_stream_read_request {
	u32 addr;
	u32 port;
};

struct trace_event_data_offsets_rpcb_getport {
	u32 servername;
};

struct trace_event_data_offsets_rpcb_setport {};

struct trace_event_data_offsets_pmap_register {};

struct trace_event_data_offsets_rpcb_register {
	u32 addr;
	u32 netid;
};

struct trace_event_data_offsets_rpcb_unregister {
	u32 netid;
};

struct trace_event_data_offsets_svc_xdr_buf_class {};

struct trace_event_data_offsets_svc_recv {
	u32 addr;
};

struct trace_event_data_offsets_svc_authenticate {};

struct trace_event_data_offsets_svc_process {
	u32 service;
	u32 addr;
};

struct trace_event_data_offsets_svc_rqst_event {
	u32 addr;
};

struct trace_event_data_offsets_svc_rqst_status {
	u32 addr;
};

struct trace_event_data_offsets_svc_xprt_create_err {
	u32 program;
	u32 protocol;
};

struct trace_event_data_offsets_svc_xprt_do_enqueue {
	u32 addr;
};

struct trace_event_data_offsets_svc_xprt_event {
	u32 addr;
};

struct trace_event_data_offsets_svc_xprt_accept {
	u32 addr;
	u32 protocol;
	u32 service;
};

struct trace_event_data_offsets_svc_xprt_dequeue {
	u32 addr;
};

struct trace_event_data_offsets_svc_wake_up {};

struct trace_event_data_offsets_svc_handle_xprt {
	u32 addr;
};

struct trace_event_data_offsets_svc_stats_latency {
	u32 addr;
};

struct trace_event_data_offsets_svc_deferred_event {};

struct trace_event_data_offsets_svcsock_new_socket {};

struct trace_event_data_offsets_svcsock_marker {
	u32 addr;
};

struct trace_event_data_offsets_svcsock_class {
	u32 addr;
};

struct trace_event_data_offsets_svcsock_tcp_recv_short {
	u32 addr;
};

struct trace_event_data_offsets_svcsock_tcp_state {
	u32 addr;
};

struct trace_event_data_offsets_svcsock_accept_class {
	u32 service;
};

struct trace_event_data_offsets_cache_event {
	u32 name;
};

struct trace_event_data_offsets_register_class {
	u32 program;
};

struct trace_event_data_offsets_svc_unregister {
	u32 program;
};

typedef void (*btf_trace_rpc_xdr_sendto)(void *, const struct rpc_task *, const struct xdr_buf *);

typedef void (*btf_trace_rpc_xdr_recvfrom)(void *, const struct rpc_task *, const struct xdr_buf *);

typedef void (*btf_trace_rpc_xdr_reply_pages)(void *, const struct rpc_task *, const struct xdr_buf *);

typedef void (*btf_trace_rpc_clnt_free)(void *, const struct rpc_clnt *);

typedef void (*btf_trace_rpc_clnt_killall)(void *, const struct rpc_clnt *);

typedef void (*btf_trace_rpc_clnt_shutdown)(void *, const struct rpc_clnt *);

typedef void (*btf_trace_rpc_clnt_release)(void *, const struct rpc_clnt *);

typedef void (*btf_trace_rpc_clnt_replace_xprt)(void *, const struct rpc_clnt *);

typedef void (*btf_trace_rpc_clnt_replace_xprt_err)(void *, const struct rpc_clnt *);

typedef void (*btf_trace_rpc_clnt_new)(void *, const struct rpc_clnt *, const struct rpc_xprt *, const char *, const char *);

typedef void (*btf_trace_rpc_clnt_new_err)(void *, const char *, const char *, int);

typedef void (*btf_trace_rpc_clnt_clone_err)(void *, const struct rpc_clnt *, int);

typedef void (*btf_trace_rpc_call_status)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc_connect_status)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc_timeout_status)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc_retry_refresh_status)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc_refresh_status)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc_request)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc_task_begin)(void *, const struct rpc_task *, const void *);

typedef void (*btf_trace_rpc_task_run_action)(void *, const struct rpc_task *, const void *);

typedef void (*btf_trace_rpc_task_sync_sleep)(void *, const struct rpc_task *, const void *);

typedef void (*btf_trace_rpc_task_sync_wake)(void *, const struct rpc_task *, const void *);

typedef void (*btf_trace_rpc_task_complete)(void *, const struct rpc_task *, const void *);

typedef void (*btf_trace_rpc_task_timeout)(void *, const struct rpc_task *, const void *);

typedef void (*btf_trace_rpc_task_signalled)(void *, const struct rpc_task *, const void *);

typedef void (*btf_trace_rpc_task_end)(void *, const struct rpc_task *, const void *);

typedef void (*btf_trace_rpc_task_sleep)(void *, const struct rpc_task *, const struct rpc_wait_queue *);

typedef void (*btf_trace_rpc_task_wakeup)(void *, const struct rpc_task *, const struct rpc_wait_queue *);

typedef void (*btf_trace_rpc_bad_callhdr)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc_bad_verifier)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc__prog_unavail)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc__prog_mismatch)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc__proc_unavail)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc__garbage_args)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc__unparsable)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc__mismatch)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc__stale_creds)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc__bad_creds)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc__auth_tooweak)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpcb_prog_unavail_err)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpcb_timeout_err)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpcb_bind_version_err)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpcb_unreachable_err)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpcb_unrecognized_err)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc_buf_alloc)(void *, const struct rpc_task *, int);

typedef void (*btf_trace_rpc_call_rpcerror)(void *, const struct rpc_task *, int, int);

typedef void (*btf_trace_rpc_stats_latency)(void *, const struct rpc_task *, ktime_t, ktime_t, ktime_t);

typedef void (*btf_trace_rpc_xdr_overflow)(void *, const struct xdr_stream *, size_t);

typedef void (*btf_trace_rpc_xdr_alignment)(void *, const struct xdr_stream *, size_t, unsigned int);

typedef void (*btf_trace_rpc_socket_state_change)(void *, struct rpc_xprt *, struct socket *);

typedef void (*btf_trace_rpc_socket_connect)(void *, struct rpc_xprt *, struct socket *, int);

typedef void (*btf_trace_rpc_socket_error)(void *, struct rpc_xprt *, struct socket *, int);

typedef void (*btf_trace_rpc_socket_reset_connection)(void *, struct rpc_xprt *, struct socket *, int);

typedef void (*btf_trace_rpc_socket_close)(void *, struct rpc_xprt *, struct socket *);

typedef void (*btf_trace_rpc_socket_shutdown)(void *, struct rpc_xprt *, struct socket *);

typedef void (*btf_trace_rpc_socket_nospace)(void *, const struct rpc_rqst *, const struct sock_xprt *);

typedef void (*btf_trace_xprt_create)(void *, const struct rpc_xprt *);

typedef void (*btf_trace_xprt_connect)(void *, const struct rpc_xprt *);

typedef void (*btf_trace_xprt_disconnect_auto)(void *, const struct rpc_xprt *);

typedef void (*btf_trace_xprt_disconnect_done)(void *, const struct rpc_xprt *);

typedef void (*btf_trace_xprt_disconnect_force)(void *, const struct rpc_xprt *);

typedef void (*btf_trace_xprt_disconnect_cleanup)(void *, const struct rpc_xprt *);

typedef void (*btf_trace_xprt_destroy)(void *, const struct rpc_xprt *);

typedef void (*btf_trace_xprt_timer)(void *, const struct rpc_xprt *, __be32, int);

typedef void (*btf_trace_xprt_lookup_rqst)(void *, const struct rpc_xprt *, __be32, int);

typedef void (*btf_trace_xprt_transmit)(void *, const struct rpc_rqst *, int);

typedef void (*btf_trace_xprt_ping)(void *, const struct rpc_xprt *, int);

typedef void (*btf_trace_xprt_reserve_xprt)(void *, const struct rpc_xprt *, const struct rpc_task *);

typedef void (*btf_trace_xprt_release_xprt)(void *, const struct rpc_xprt *, const struct rpc_task *);

typedef void (*btf_trace_xprt_reserve_cong)(void *, const struct rpc_xprt *, const struct rpc_task *);

typedef void (*btf_trace_xprt_release_cong)(void *, const struct rpc_xprt *, const struct rpc_task *);

typedef void (*btf_trace_xprt_get_cong)(void *, const struct rpc_xprt *, const struct rpc_task *);

typedef void (*btf_trace_xprt_put_cong)(void *, const struct rpc_xprt *, const struct rpc_task *);

typedef void (*btf_trace_xprt_reserve)(void *, const struct rpc_rqst *);

typedef void (*btf_trace_xs_stream_read_data)(void *, struct rpc_xprt *, ssize_t, size_t);

typedef void (*btf_trace_xs_stream_read_request)(void *, struct sock_xprt *);

typedef void (*btf_trace_rpcb_getport)(void *, const struct rpc_clnt *, const struct rpc_task *, unsigned int);

typedef void (*btf_trace_rpcb_setport)(void *, const struct rpc_task *, int, short unsigned int);

typedef void (*btf_trace_pmap_register)(void *, u32, u32, int, short unsigned int);

typedef void (*btf_trace_rpcb_register)(void *, u32, u32, const char *, const char *);

typedef void (*btf_trace_rpcb_unregister)(void *, u32, u32, const char *);

typedef void (*btf_trace_svc_xdr_recvfrom)(void *, const struct svc_rqst *, const struct xdr_buf *);

typedef void (*btf_trace_svc_xdr_sendto)(void *, const struct svc_rqst *, const struct xdr_buf *);

typedef void (*btf_trace_svc_recv)(void *, struct svc_rqst *, int);

typedef void (*btf_trace_svc_authenticate)(void *, const struct svc_rqst *, int, __be32);

typedef void (*btf_trace_svc_process)(void *, const struct svc_rqst *, const char *);

typedef void (*btf_trace_svc_defer)(void *, const struct svc_rqst *);

typedef void (*btf_trace_svc_drop)(void *, const struct svc_rqst *);

typedef void (*btf_trace_svc_send)(void *, struct svc_rqst *, int);

typedef void (*btf_trace_svc_xprt_create_err)(void *, const char *, const char *, struct sockaddr *, const struct svc_xprt *);

typedef void (*btf_trace_svc_xprt_do_enqueue)(void *, struct svc_xprt *, struct svc_rqst *);

typedef void (*btf_trace_svc_xprt_no_write_space)(void *, struct svc_xprt *);

typedef void (*btf_trace_svc_xprt_close)(void *, struct svc_xprt *);

typedef void (*btf_trace_svc_xprt_detach)(void *, struct svc_xprt *);

typedef void (*btf_trace_svc_xprt_free)(void *, struct svc_xprt *);

typedef void (*btf_trace_svc_xprt_accept)(void *, const struct svc_xprt *, const char *);

typedef void (*btf_trace_svc_xprt_dequeue)(void *, struct svc_rqst *);

typedef void (*btf_trace_svc_wake_up)(void *, int);

typedef void (*btf_trace_svc_handle_xprt)(void *, struct svc_xprt *, int);

typedef void (*btf_trace_svc_stats_latency)(void *, const struct svc_rqst *);

typedef void (*btf_trace_svc_defer_drop)(void *, const struct svc_deferred_req *);

typedef void (*btf_trace_svc_defer_queue)(void *, const struct svc_deferred_req *);

typedef void (*btf_trace_svc_defer_recv)(void *, const struct svc_deferred_req *);

typedef void (*btf_trace_svcsock_new_socket)(void *, const struct socket *);

typedef void (*btf_trace_svcsock_marker)(void *, const struct svc_xprt *, __be32);

typedef void (*btf_trace_svcsock_udp_send)(void *, const struct svc_xprt *, ssize_t);

typedef void (*btf_trace_svcsock_udp_recv)(void *, const struct svc_xprt *, ssize_t);

typedef void (*btf_trace_svcsock_udp_recv_err)(void *, const struct svc_xprt *, ssize_t);

typedef void (*btf_trace_svcsock_tcp_send)(void *, const struct svc_xprt *, ssize_t);

typedef void (*btf_trace_svcsock_tcp_recv)(void *, const struct svc_xprt *, ssize_t);

typedef void (*btf_trace_svcsock_tcp_recv_eagain)(void *, const struct svc_xprt *, ssize_t);

typedef void (*btf_trace_svcsock_tcp_recv_err)(void *, const struct svc_xprt *, ssize_t);

typedef void (*btf_trace_svcsock_data_ready)(void *, const struct svc_xprt *, ssize_t);

typedef void (*btf_trace_svcsock_write_space)(void *, const struct svc_xprt *, ssize_t);

typedef void (*btf_trace_svcsock_tcp_recv_short)(void *, const struct svc_xprt *, u32, u32);

typedef void (*btf_trace_svcsock_tcp_state)(void *, const struct svc_xprt *, const struct socket *);

typedef void (*btf_trace_svcsock_accept_err)(void *, const struct svc_xprt *, const char *, long int);

typedef void (*btf_trace_svcsock_getpeername_err)(void *, const struct svc_xprt *, const char *, long int);

typedef void (*btf_trace_cache_entry_expired)(void *, const struct cache_detail *, const struct cache_head *);

typedef void (*btf_trace_cache_entry_upcall)(void *, const struct cache_detail *, const struct cache_head *);

typedef void (*btf_trace_cache_entry_update)(void *, const struct cache_detail *, const struct cache_head *);

typedef void (*btf_trace_cache_entry_make_negative)(void *, const struct cache_detail *, const struct cache_head *);

typedef void (*btf_trace_cache_entry_no_listener)(void *, const struct cache_detail *, const struct cache_head *);

typedef void (*btf_trace_svc_register)(void *, const char *, const u32, const int, const short unsigned int, const short unsigned int, int);

typedef void (*btf_trace_svc_noregister)(void *, const char *, const u32, const int, const short unsigned int, const short unsigned int, int);

typedef void (*btf_trace_svc_unregister)(void *, const char *, const u32, int);

struct rpc_cred_cache {
	struct hlist_head *hashtable;
	unsigned int hashbits;
	spinlock_t lock;
};

enum {
	SVC_POOL_AUTO = 4294967295,
	SVC_POOL_GLOBAL = 0,
	SVC_POOL_PERCPU = 1,
	SVC_POOL_PERNODE = 2,
};

struct svc_pool_map {
	int count;
	int mode;
	unsigned int npools;
	unsigned int *pool_to;
	unsigned int *to_pool;
};

struct unix_domain {
	struct auth_domain h;
};

struct ip_map {
	struct cache_head h;
	char m_class[8];
	struct in6_addr m_addr;
	struct unix_domain *m_client;
	struct callback_head m_rcu;
};

struct unix_gid {
	struct cache_head h;
	kuid_t uid;
	struct group_info *gi;
	struct callback_head rcu;
};

enum {
	RPCBPROC_NULL = 0,
	RPCBPROC_SET = 1,
	RPCBPROC_UNSET = 2,
	RPCBPROC_GETPORT = 3,
	RPCBPROC_GETADDR = 3,
	RPCBPROC_DUMP = 4,
	RPCBPROC_CALLIT = 5,
	RPCBPROC_BCAST = 5,
	RPCBPROC_GETTIME = 6,
	RPCBPROC_UADDR2TADDR = 7,
	RPCBPROC_TADDR2UADDR = 8,
	RPCBPROC_GETVERSADDR = 9,
	RPCBPROC_INDIRECT = 10,
	RPCBPROC_GETADDRLIST = 11,
	RPCBPROC_GETSTAT = 12,
};

struct rpcbind_args {
	struct rpc_xprt *r_xprt;
	u32 r_prog;
	u32 r_vers;
	u32 r_prot;
	short unsigned int r_port;
	const char *r_netid;
	const char *r_addr;
	const char *r_owner;
	int r_status;
};

struct rpcb_info {
	u32 rpc_vers;
	const struct rpc_procinfo *rpc_proc;
};

struct xdr_array2_desc;

typedef int (*xdr_xcode_elem_t)(struct xdr_array2_desc *, void *);

struct xdr_array2_desc {
	unsigned int elem_size;
	unsigned int array_len;
	unsigned int array_maxlen;
	xdr_xcode_elem_t xcode;
};

struct thread_deferred_req {
	struct cache_deferred_req handle;
	struct completion completion;
};

struct cache_queue {
	struct list_head list;
	int reader;
};

struct cache_request {
	struct cache_queue q;
	struct cache_head *item;
	char *buf;
	int len;
	int readers;
};

struct cache_reader {
	struct cache_queue q;
	int offset;
};

struct rpc_filelist {
	const char *name;
	const struct file_operations *i_fop;
	umode_t mode;
};

enum {
	RPCAUTH_info = 0,
	RPCAUTH_EOF = 1,
};

enum {
	RPCAUTH_lockd = 0,
	RPCAUTH_mount = 1,
	RPCAUTH_nfs = 2,
	RPCAUTH_portmap = 3,
	RPCAUTH_statd = 4,
	RPCAUTH_nfsd4_cb = 5,
	RPCAUTH_cache = 6,
	RPCAUTH_nfsd = 7,
	RPCAUTH_gssd = 8,
	RPCAUTH_RootEOF = 9,
};

struct svc_xpt_user {
	struct list_head list;
	void (*callback)(struct svc_xpt_user *);
};

typedef struct rpc_xprt * (*xprt_switch_find_xprt_t)(struct rpc_xprt_switch *, const struct rpc_xprt *);

enum rpc_gss_proc {
	RPC_GSS_PROC_DATA = 0,
	RPC_GSS_PROC_INIT = 1,
	RPC_GSS_PROC_CONTINUE_INIT = 2,
	RPC_GSS_PROC_DESTROY = 3,
};

enum rpc_gss_svc {
	RPC_GSS_SVC_NONE = 1,
	RPC_GSS_SVC_INTEGRITY = 2,
	RPC_GSS_SVC_PRIVACY = 3,
};

struct gss_cl_ctx {
	refcount_t count;
	enum rpc_gss_proc gc_proc;
	u32 gc_seq;
	u32 gc_seq_xmit;
	spinlock_t gc_seq_lock;
	struct gss_ctx *gc_gss_ctx;
	struct xdr_netobj gc_wire_ctx;
	struct xdr_netobj gc_acceptor;
	u32 gc_win;
	long unsigned int gc_expiry;
	struct callback_head gc_rcu;
};

struct gss_upcall_msg;

struct gss_cred {
	struct rpc_cred gc_base;
	enum rpc_gss_svc gc_service;
	struct gss_cl_ctx *gc_ctx;
	struct gss_upcall_msg *gc_upcall;
	const char *gc_principal;
	long unsigned int gc_upcall_timestamp;
};

struct gss_auth;

struct gss_upcall_msg {
	refcount_t count;
	kuid_t uid;
	const char *service_name;
	struct rpc_pipe_msg msg;
	struct list_head list;
	struct gss_auth *auth;
	struct rpc_pipe *pipe;
	struct rpc_wait_queue rpc_waitqueue;
	wait_queue_head_t waitqueue;
	struct gss_cl_ctx *ctx;
	char databuf[256];
};

typedef unsigned int OM_uint32;

struct gss_pipe {
	struct rpc_pipe_dir_object pdo;
	struct rpc_pipe *pipe;
	struct rpc_clnt *clnt;
	const char *name;
	struct kref kref;
};

struct gss_auth {
	struct kref kref;
	struct hlist_node hash;
	struct rpc_auth rpc_auth;
	struct gss_api_mech *mech;
	enum rpc_gss_svc service;
	struct rpc_clnt *client;
	struct net *net;
	struct gss_pipe *gss_pipe[2];
	const char *target_name;
};

struct gss_alloc_pdo {
	struct rpc_clnt *clnt;
	const char *name;
	const struct rpc_pipe_ops *upcall_ops;
};

struct rpc_gss_wire_cred {
	u32 gc_v;
	u32 gc_proc;
	u32 gc_seq;
	u32 gc_svc;
	struct xdr_netobj gc_ctx;
};

struct gssp_in_token {
	struct page **pages;
	unsigned int page_base;
	unsigned int page_len;
};

struct gssp_upcall_data {
	struct xdr_netobj in_handle;
	struct gssp_in_token in_token;
	struct xdr_netobj out_handle;
	struct xdr_netobj out_token;
	struct rpcsec_gss_oid mech_oid;
	struct svc_cred creds;
	int found_creds;
	int major_status;
	int minor_status;
};

struct rsi {
	struct cache_head h;
	struct xdr_netobj in_handle;
	struct xdr_netobj in_token;
	struct xdr_netobj out_handle;
	struct xdr_netobj out_token;
	int major_status;
	int minor_status;
	struct callback_head callback_head;
};

struct gss_svc_seq_data {
	u32 sd_max;
	long unsigned int sd_win[2];
	spinlock_t sd_lock;
};

struct rsc {
	struct cache_head h;
	struct xdr_netobj handle;
	struct svc_cred cred;
	struct gss_svc_seq_data seqdata;
	struct gss_ctx *mechctx;
	struct callback_head callback_head;
};

struct gss_domain {
	struct auth_domain h;
	u32 pseudoflavor;
};

struct gss_svc_data {
	struct rpc_gss_wire_cred clcred;
	__be32 *verf_start;
	struct rsc *rsci;
};

typedef struct xdr_netobj gssx_buffer;

typedef struct xdr_netobj utf8string;

typedef struct xdr_netobj gssx_OID;

struct gssx_option {
	gssx_buffer option;
	gssx_buffer value;
};

struct gssx_option_array {
	u32 count;
	struct gssx_option *data;
};

struct gssx_status {
	u64 major_status;
	gssx_OID mech;
	u64 minor_status;
	utf8string major_status_string;
	utf8string minor_status_string;
	gssx_buffer server_ctx;
	struct gssx_option_array options;
};

struct gssx_call_ctx {
	utf8string locale;
	gssx_buffer server_ctx;
	struct gssx_option_array options;
};

struct gssx_name {
	gssx_buffer display_name;
};

typedef struct gssx_name gssx_name;

struct gssx_cred_element {
	gssx_name MN;
	gssx_OID mech;
	u32 cred_usage;
	u64 initiator_time_rec;
	u64 acceptor_time_rec;
	struct gssx_option_array options;
};

struct gssx_cred_element_array {
	u32 count;
	struct gssx_cred_element *data;
};

struct gssx_cred {
	gssx_name desired_name;
	struct gssx_cred_element_array elements;
	gssx_buffer cred_handle_reference;
	u32 needs_release;
};

struct gssx_ctx {
	gssx_buffer exported_context_token;
	gssx_buffer state;
	u32 need_release;
	gssx_OID mech;
	gssx_name src_name;
	gssx_name targ_name;
	u64 lifetime;
	u64 ctx_flags;
	u32 locally_initiated;
	u32 open;
	struct gssx_option_array options;
};

struct gssx_cb {
	u64 initiator_addrtype;
	gssx_buffer initiator_address;
	u64 acceptor_addrtype;
	gssx_buffer acceptor_address;
	gssx_buffer application_data;
};

struct gssx_arg_accept_sec_context {
	struct gssx_call_ctx call_ctx;
	struct gssx_ctx *context_handle;
	struct gssx_cred *cred_handle;
	struct gssp_in_token input_token;
	struct gssx_cb *input_cb;
	u32 ret_deleg_cred;
	struct gssx_option_array options;
	struct page **pages;
	unsigned int npages;
};

struct gssx_res_accept_sec_context {
	struct gssx_status status;
	struct gssx_ctx *context_handle;
	gssx_buffer *output_token;
	struct gssx_option_array options;
};

enum {
	GSSX_NULL = 0,
	GSSX_INDICATE_MECHS = 1,
	GSSX_GET_CALL_CONTEXT = 2,
	GSSX_IMPORT_AND_CANON_NAME = 3,
	GSSX_EXPORT_CRED = 4,
	GSSX_IMPORT_CRED = 5,
	GSSX_ACQUIRE_CRED = 6,
	GSSX_STORE_CRED = 7,
	GSSX_INIT_SEC_CONTEXT = 8,
	GSSX_ACCEPT_SEC_CONTEXT = 9,
	GSSX_RELEASE_HANDLE = 10,
	GSSX_GET_MIC = 11,
	GSSX_VERIFY = 12,
	GSSX_WRAP = 13,
	GSSX_UNWRAP = 14,
	GSSX_WRAP_SIZE_LIMIT = 15,
};

struct gssx_name_attr {
	gssx_buffer attr;
	gssx_buffer value;
	struct gssx_option_array extensions;
};

struct gssx_name_attr_array {
	u32 count;
	struct gssx_name_attr *data;
};

struct trace_event_raw_rpcgss_gssapi_event {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	u32 maj_stat;
	char __data[0];
};

struct trace_event_raw_rpcgss_import_ctx {
	struct trace_entry ent;
	int status;
	char __data[0];
};

struct trace_event_raw_rpcgss_ctx_class {
	struct trace_entry ent;
	const void *cred;
	long unsigned int service;
	u32 __data_loc_principal;
	char __data[0];
};

struct trace_event_raw_rpcgss_svc_gssapi_class {
	struct trace_entry ent;
	u32 xid;
	u32 maj_stat;
	u32 __data_loc_addr;
	char __data[0];
};

struct trace_event_raw_rpcgss_svc_unwrap_failed {
	struct trace_entry ent;
	u32 xid;
	u32 __data_loc_addr;
	char __data[0];
};

struct trace_event_raw_rpcgss_svc_seqno_bad {
	struct trace_entry ent;
	u32 expected;
	u32 received;
	u32 xid;
	u32 __data_loc_addr;
	char __data[0];
};

struct trace_event_raw_rpcgss_svc_accept_upcall {
	struct trace_entry ent;
	u32 minor_status;
	long unsigned int major_status;
	u32 xid;
	u32 __data_loc_addr;
	char __data[0];
};

struct trace_event_raw_rpcgss_svc_authenticate {
	struct trace_entry ent;
	u32 seqno;
	u32 xid;
	u32 __data_loc_addr;
	char __data[0];
};

struct trace_event_raw_rpcgss_unwrap_failed {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	char __data[0];
};

struct trace_event_raw_rpcgss_bad_seqno {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	u32 expected;
	u32 received;
	char __data[0];
};

struct trace_event_raw_rpcgss_seqno {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	u32 xid;
	u32 seqno;
	char __data[0];
};

struct trace_event_raw_rpcgss_need_reencode {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	u32 xid;
	u32 seq_xmit;
	u32 seqno;
	bool ret;
	char __data[0];
};

struct trace_event_raw_rpcgss_update_slack {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	u32 xid;
	const void *auth;
	unsigned int rslack;
	unsigned int ralign;
	unsigned int verfsize;
	char __data[0];
};

struct trace_event_raw_rpcgss_svc_seqno_class {
	struct trace_entry ent;
	u32 xid;
	u32 seqno;
	char __data[0];
};

struct trace_event_raw_rpcgss_svc_seqno_low {
	struct trace_entry ent;
	u32 xid;
	u32 seqno;
	u32 min;
	u32 max;
	char __data[0];
};

struct trace_event_raw_rpcgss_upcall_msg {
	struct trace_entry ent;
	u32 __data_loc_msg;
	char __data[0];
};

struct trace_event_raw_rpcgss_upcall_result {
	struct trace_entry ent;
	u32 uid;
	int result;
	char __data[0];
};

struct trace_event_raw_rpcgss_context {
	struct trace_entry ent;
	long unsigned int expiry;
	long unsigned int now;
	unsigned int timeout;
	u32 window_size;
	int len;
	u32 __data_loc_acceptor;
	char __data[0];
};

struct trace_event_raw_rpcgss_createauth {
	struct trace_entry ent;
	unsigned int flavor;
	int error;
	char __data[0];
};

struct trace_event_raw_rpcgss_oid_to_mech {
	struct trace_entry ent;
	u32 __data_loc_oid;
	char __data[0];
};

struct trace_event_data_offsets_rpcgss_gssapi_event {};

struct trace_event_data_offsets_rpcgss_import_ctx {};

struct trace_event_data_offsets_rpcgss_ctx_class {
	u32 principal;
};

struct trace_event_data_offsets_rpcgss_svc_gssapi_class {
	u32 addr;
};

struct trace_event_data_offsets_rpcgss_svc_unwrap_failed {
	u32 addr;
};

struct trace_event_data_offsets_rpcgss_svc_seqno_bad {
	u32 addr;
};

struct trace_event_data_offsets_rpcgss_svc_accept_upcall {
	u32 addr;
};

struct trace_event_data_offsets_rpcgss_svc_authenticate {
	u32 addr;
};

struct trace_event_data_offsets_rpcgss_unwrap_failed {};

struct trace_event_data_offsets_rpcgss_bad_seqno {};

struct trace_event_data_offsets_rpcgss_seqno {};

struct trace_event_data_offsets_rpcgss_need_reencode {};

struct trace_event_data_offsets_rpcgss_update_slack {};

struct trace_event_data_offsets_rpcgss_svc_seqno_class {};

struct trace_event_data_offsets_rpcgss_svc_seqno_low {};

struct trace_event_data_offsets_rpcgss_upcall_msg {
	u32 msg;
};

struct trace_event_data_offsets_rpcgss_upcall_result {};

struct trace_event_data_offsets_rpcgss_context {
	u32 acceptor;
};

struct trace_event_data_offsets_rpcgss_createauth {};

struct trace_event_data_offsets_rpcgss_oid_to_mech {
	u32 oid;
};

typedef void (*btf_trace_rpcgss_import_ctx)(void *, int);

typedef void (*btf_trace_rpcgss_get_mic)(void *, const struct rpc_task *, u32);

typedef void (*btf_trace_rpcgss_verify_mic)(void *, const struct rpc_task *, u32);

typedef void (*btf_trace_rpcgss_wrap)(void *, const struct rpc_task *, u32);

typedef void (*btf_trace_rpcgss_unwrap)(void *, const struct rpc_task *, u32);

typedef void (*btf_trace_rpcgss_ctx_init)(void *, const struct gss_cred *);

typedef void (*btf_trace_rpcgss_ctx_destroy)(void *, const struct gss_cred *);

typedef void (*btf_trace_rpcgss_svc_unwrap)(void *, const struct svc_rqst *, u32);

typedef void (*btf_trace_rpcgss_svc_mic)(void *, const struct svc_rqst *, u32);

typedef void (*btf_trace_rpcgss_svc_unwrap_failed)(void *, const struct svc_rqst *);

typedef void (*btf_trace_rpcgss_svc_seqno_bad)(void *, const struct svc_rqst *, u32, u32);

typedef void (*btf_trace_rpcgss_svc_accept_upcall)(void *, const struct svc_rqst *, u32, u32);

typedef void (*btf_trace_rpcgss_svc_authenticate)(void *, const struct svc_rqst *, const struct rpc_gss_wire_cred *);

typedef void (*btf_trace_rpcgss_unwrap_failed)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpcgss_bad_seqno)(void *, const struct rpc_task *, u32, u32);

typedef void (*btf_trace_rpcgss_seqno)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpcgss_need_reencode)(void *, const struct rpc_task *, u32, bool);

typedef void (*btf_trace_rpcgss_update_slack)(void *, const struct rpc_task *, const struct rpc_auth *);

typedef void (*btf_trace_rpcgss_svc_seqno_large)(void *, const struct svc_rqst *, u32);

typedef void (*btf_trace_rpcgss_svc_seqno_seen)(void *, const struct svc_rqst *, u32);

typedef void (*btf_trace_rpcgss_svc_seqno_low)(void *, const struct svc_rqst *, u32, u32, u32);

typedef void (*btf_trace_rpcgss_upcall_msg)(void *, const char *);

typedef void (*btf_trace_rpcgss_upcall_result)(void *, u32, int);

typedef void (*btf_trace_rpcgss_context)(void *, u32, long unsigned int, long unsigned int, unsigned int, unsigned int, const u8 *);

typedef void (*btf_trace_rpcgss_createauth)(void *, unsigned int, int);

typedef void (*btf_trace_rpcgss_oid_to_mech)(void *, const char *);

enum nl80211_radar_event {
	NL80211_RADAR_DETECTED = 0,
	NL80211_RADAR_CAC_FINISHED = 1,
	NL80211_RADAR_CAC_ABORTED = 2,
	NL80211_RADAR_NOP_FINISHED = 3,
	NL80211_RADAR_PRE_CAC_EXPIRED = 4,
	NL80211_RADAR_CAC_STARTED = 5,
};

enum ieee80211_reasoncode {
	WLAN_REASON_UNSPECIFIED = 1,
	WLAN_REASON_PREV_AUTH_NOT_VALID = 2,
	WLAN_REASON_DEAUTH_LEAVING = 3,
	WLAN_REASON_DISASSOC_DUE_TO_INACTIVITY = 4,
	WLAN_REASON_DISASSOC_AP_BUSY = 5,
	WLAN_REASON_CLASS2_FRAME_FROM_NONAUTH_STA = 6,
	WLAN_REASON_CLASS3_FRAME_FROM_NONASSOC_STA = 7,
	WLAN_REASON_DISASSOC_STA_HAS_LEFT = 8,
	WLAN_REASON_STA_REQ_ASSOC_WITHOUT_AUTH = 9,
	WLAN_REASON_DISASSOC_BAD_POWER = 10,
	WLAN_REASON_DISASSOC_BAD_SUPP_CHAN = 11,
	WLAN_REASON_INVALID_IE = 13,
	WLAN_REASON_MIC_FAILURE = 14,
	WLAN_REASON_4WAY_HANDSHAKE_TIMEOUT = 15,
	WLAN_REASON_GROUP_KEY_HANDSHAKE_TIMEOUT = 16,
	WLAN_REASON_IE_DIFFERENT = 17,
	WLAN_REASON_INVALID_GROUP_CIPHER = 18,
	WLAN_REASON_INVALID_PAIRWISE_CIPHER = 19,
	WLAN_REASON_INVALID_AKMP = 20,
	WLAN_REASON_UNSUPP_RSN_VERSION = 21,
	WLAN_REASON_INVALID_RSN_IE_CAP = 22,
	WLAN_REASON_IEEE8021X_FAILED = 23,
	WLAN_REASON_CIPHER_SUITE_REJECTED = 24,
	WLAN_REASON_TDLS_TEARDOWN_UNREACHABLE = 25,
	WLAN_REASON_TDLS_TEARDOWN_UNSPECIFIED = 26,
	WLAN_REASON_DISASSOC_UNSPECIFIED_QOS = 32,
	WLAN_REASON_DISASSOC_QAP_NO_BANDWIDTH = 33,
	WLAN_REASON_DISASSOC_LOW_ACK = 34,
	WLAN_REASON_DISASSOC_QAP_EXCEED_TXOP = 35,
	WLAN_REASON_QSTA_LEAVE_QBSS = 36,
	WLAN_REASON_QSTA_NOT_USE = 37,
	WLAN_REASON_QSTA_REQUIRE_SETUP = 38,
	WLAN_REASON_QSTA_TIMEOUT = 39,
	WLAN_REASON_QSTA_CIPHER_NOT_SUPP = 45,
	WLAN_REASON_MESH_PEER_CANCELED = 52,
	WLAN_REASON_MESH_MAX_PEERS = 53,
	WLAN_REASON_MESH_CONFIG = 54,
	WLAN_REASON_MESH_CLOSE = 55,
	WLAN_REASON_MESH_MAX_RETRIES = 56,
	WLAN_REASON_MESH_CONFIRM_TIMEOUT = 57,
	WLAN_REASON_MESH_INVALID_GTK = 58,
	WLAN_REASON_MESH_INCONSISTENT_PARAM = 59,
	WLAN_REASON_MESH_INVALID_SECURITY = 60,
	WLAN_REASON_MESH_PATH_ERROR = 61,
	WLAN_REASON_MESH_PATH_NOFORWARD = 62,
	WLAN_REASON_MESH_PATH_DEST_UNREACHABLE = 63,
	WLAN_REASON_MAC_EXISTS_IN_MBSS = 64,
	WLAN_REASON_MESH_CHAN_REGULATORY = 65,
	WLAN_REASON_MESH_CHAN = 66,
};

enum ieee80211_key_len {
	WLAN_KEY_LEN_WEP40 = 5,
	WLAN_KEY_LEN_WEP104 = 13,
	WLAN_KEY_LEN_CCMP = 16,
	WLAN_KEY_LEN_CCMP_256 = 32,
	WLAN_KEY_LEN_TKIP = 32,
	WLAN_KEY_LEN_AES_CMAC = 16,
	WLAN_KEY_LEN_SMS4 = 32,
	WLAN_KEY_LEN_GCMP = 16,
	WLAN_KEY_LEN_GCMP_256 = 32,
	WLAN_KEY_LEN_BIP_CMAC_256 = 32,
	WLAN_KEY_LEN_BIP_GMAC_128 = 16,
	WLAN_KEY_LEN_BIP_GMAC_256 = 32,
};

struct cfg80211_cached_keys {
	struct key_params params[4];
	u8 data[52];
	int def;
};

struct cfg80211_internal_bss {
	struct list_head list;
	struct list_head hidden_list;
	struct rb_node rbn;
	u64 ts_boottime;
	long unsigned int ts;
	long unsigned int refcount;
	atomic_t hold;
	u64 parent_tsf;
	u8 parent_bssid[6];
	struct cfg80211_bss pub;
};

struct cfg80211_cqm_config {
	u32 rssi_hyst;
	s32 last_rssi_event_value;
	int n_rssi_thresholds;
	s32 rssi_thresholds[0];
};

struct cfg80211_registered_device {
	const struct cfg80211_ops *ops;
	struct list_head list;
	struct rfkill_ops rfkill_ops;
	struct rfkill *rfkill;
	struct work_struct rfkill_block;
	char country_ie_alpha2[2];
	const struct ieee80211_regdomain *requested_regd;
	enum environment_cap env;
	int wiphy_idx;
	int devlist_generation;
	int wdev_id;
	int opencount;
	wait_queue_head_t dev_wait;
	struct list_head beacon_registrations;
	spinlock_t beacon_registrations_lock;
	int num_running_ifaces;
	int num_running_monitor_ifaces;
	u64 cookie_counter;
	spinlock_t bss_lock;
	struct list_head bss_list;
	struct rb_root bss_tree;
	u32 bss_generation;
	u32 bss_entries;
	struct cfg80211_scan_request *scan_req;
	struct cfg80211_scan_request *int_scan_req;
	struct sk_buff *scan_msg;
	struct list_head sched_scan_req_list;
	time64_t suspend_at;
	struct work_struct scan_done_wk;
	struct genl_info *cur_cmd_info;
	struct work_struct conn_work;
	struct work_struct event_work;
	struct delayed_work dfs_update_channels_wk;
	u32 crit_proto_nlportid;
	struct cfg80211_coalesce *coalesce;
	struct work_struct destroy_work;
	struct work_struct sched_scan_stop_wk;
	struct work_struct sched_scan_res_wk;
	struct cfg80211_chan_def radar_chandef;
	struct work_struct propagate_radar_detect_wk;
	struct cfg80211_chan_def cac_done_chandef;
	struct work_struct propagate_cac_done_wk;
	struct work_struct mgmt_registrations_update_wk;
	spinlock_t mgmt_registrations_lock;
	long: 32;
	long: 64;
	long: 64;
	struct wiphy wiphy;
};

enum cfg80211_event_type {
	EVENT_CONNECT_RESULT = 0,
	EVENT_ROAMED = 1,
	EVENT_DISCONNECTED = 2,
	EVENT_IBSS_JOINED = 3,
	EVENT_STOPPED = 4,
	EVENT_PORT_AUTHORIZED = 5,
};

struct cfg80211_event {
	struct list_head list;
	enum cfg80211_event_type type;
	union {
		struct cfg80211_connect_resp_params cr;
		struct cfg80211_roam_info rm;
		struct {
			const u8 *ie;
			size_t ie_len;
			u16 reason;
			bool locally_generated;
		} dc;
		struct {
			u8 bssid[6];
			struct ieee80211_channel *channel;
		} ij;
		struct {
			u8 bssid[6];
		} pa;
	};
};

struct cfg80211_beacon_registration {
	struct list_head list;
	u32 nlportid;
};

struct radiotap_align_size {
	uint8_t align: 4;
	uint8_t size: 4;
};

struct ieee80211_radiotap_namespace {
	const struct radiotap_align_size *align_size;
	int n_bits;
	uint32_t oui;
	uint8_t subns;
};

struct ieee80211_radiotap_vendor_namespaces {
	const struct ieee80211_radiotap_namespace *ns;
	int n_ns;
};

struct ieee80211_radiotap_iterator {
	struct ieee80211_radiotap_header *_rtheader;
	const struct ieee80211_radiotap_vendor_namespaces *_vns;
	const struct ieee80211_radiotap_namespace *current_namespace;
	unsigned char *_arg;
	unsigned char *_next_ns_data;
	__le32 *_next_bitmap;
	unsigned char *this_arg;
	int this_arg_index;
	int this_arg_size;
	int is_radiotap_ns;
	int _max_length;
	int _arg_index;
	uint32_t _bitmap_shifter;
	int _reset_on_ext;
};

enum ieee80211_radiotap_presence {
	IEEE80211_RADIOTAP_TSFT = 0,
	IEEE80211_RADIOTAP_FLAGS = 1,
	IEEE80211_RADIOTAP_RATE = 2,
	IEEE80211_RADIOTAP_CHANNEL = 3,
	IEEE80211_RADIOTAP_FHSS = 4,
	IEEE80211_RADIOTAP_DBM_ANTSIGNAL = 5,
	IEEE80211_RADIOTAP_DBM_ANTNOISE = 6,
	IEEE80211_RADIOTAP_LOCK_QUALITY = 7,
	IEEE80211_RADIOTAP_TX_ATTENUATION = 8,
	IEEE80211_RADIOTAP_DB_TX_ATTENUATION = 9,
	IEEE80211_RADIOTAP_DBM_TX_POWER = 10,
	IEEE80211_RADIOTAP_ANTENNA = 11,
	IEEE80211_RADIOTAP_DB_ANTSIGNAL = 12,
	IEEE80211_RADIOTAP_DB_ANTNOISE = 13,
	IEEE80211_RADIOTAP_RX_FLAGS = 14,
	IEEE80211_RADIOTAP_TX_FLAGS = 15,
	IEEE80211_RADIOTAP_RTS_RETRIES = 16,
	IEEE80211_RADIOTAP_DATA_RETRIES = 17,
	IEEE80211_RADIOTAP_MCS = 19,
	IEEE80211_RADIOTAP_AMPDU_STATUS = 20,
	IEEE80211_RADIOTAP_VHT = 21,
	IEEE80211_RADIOTAP_TIMESTAMP = 22,
	IEEE80211_RADIOTAP_HE = 23,
	IEEE80211_RADIOTAP_HE_MU = 24,
	IEEE80211_RADIOTAP_ZERO_LEN_PSDU = 26,
	IEEE80211_RADIOTAP_LSIG = 27,
	IEEE80211_RADIOTAP_RADIOTAP_NAMESPACE = 29,
	IEEE80211_RADIOTAP_VENDOR_NAMESPACE = 30,
	IEEE80211_RADIOTAP_EXT = 31,
};

struct ieee80211s_hdr {
	u8 flags;
	u8 ttl;
	__le32 seqnum;
	u8 eaddr1[6];
	u8 eaddr2[6];
} __attribute__((packed));

enum ieee80211_p2p_attr_id {
	IEEE80211_P2P_ATTR_STATUS = 0,
	IEEE80211_P2P_ATTR_MINOR_REASON = 1,
	IEEE80211_P2P_ATTR_CAPABILITY = 2,
	IEEE80211_P2P_ATTR_DEVICE_ID = 3,
	IEEE80211_P2P_ATTR_GO_INTENT = 4,
	IEEE80211_P2P_ATTR_GO_CONFIG_TIMEOUT = 5,
	IEEE80211_P2P_ATTR_LISTEN_CHANNEL = 6,
	IEEE80211_P2P_ATTR_GROUP_BSSID = 7,
	IEEE80211_P2P_ATTR_EXT_LISTEN_TIMING = 8,
	IEEE80211_P2P_ATTR_INTENDED_IFACE_ADDR = 9,
	IEEE80211_P2P_ATTR_MANAGABILITY = 10,
	IEEE80211_P2P_ATTR_CHANNEL_LIST = 11,
	IEEE80211_P2P_ATTR_ABSENCE_NOTICE = 12,
	IEEE80211_P2P_ATTR_DEVICE_INFO = 13,
	IEEE80211_P2P_ATTR_GROUP_INFO = 14,
	IEEE80211_P2P_ATTR_GROUP_ID = 15,
	IEEE80211_P2P_ATTR_INTERFACE = 16,
	IEEE80211_P2P_ATTR_OPER_CHANNEL = 17,
	IEEE80211_P2P_ATTR_INVITE_FLAGS = 18,
	IEEE80211_P2P_ATTR_VENDOR_SPECIFIC = 221,
	IEEE80211_P2P_ATTR_MAX = 222,
};

enum ieee80211_vht_chanwidth {
	IEEE80211_VHT_CHANWIDTH_USE_HT = 0,
	IEEE80211_VHT_CHANWIDTH_80MHZ = 1,
	IEEE80211_VHT_CHANWIDTH_160MHZ = 2,
	IEEE80211_VHT_CHANWIDTH_80P80MHZ = 3,
};

enum ieee80211_statuscode {
	WLAN_STATUS_SUCCESS = 0,
	WLAN_STATUS_UNSPECIFIED_FAILURE = 1,
	WLAN_STATUS_CAPS_UNSUPPORTED = 10,
	WLAN_STATUS_REASSOC_NO_ASSOC = 11,
	WLAN_STATUS_ASSOC_DENIED_UNSPEC = 12,
	WLAN_STATUS_NOT_SUPPORTED_AUTH_ALG = 13,
	WLAN_STATUS_UNKNOWN_AUTH_TRANSACTION = 14,
	WLAN_STATUS_CHALLENGE_FAIL = 15,
	WLAN_STATUS_AUTH_TIMEOUT = 16,
	WLAN_STATUS_AP_UNABLE_TO_HANDLE_NEW_STA = 17,
	WLAN_STATUS_ASSOC_DENIED_RATES = 18,
	WLAN_STATUS_ASSOC_DENIED_NOSHORTPREAMBLE = 19,
	WLAN_STATUS_ASSOC_DENIED_NOPBCC = 20,
	WLAN_STATUS_ASSOC_DENIED_NOAGILITY = 21,
	WLAN_STATUS_ASSOC_DENIED_NOSPECTRUM = 22,
	WLAN_STATUS_ASSOC_REJECTED_BAD_POWER = 23,
	WLAN_STATUS_ASSOC_REJECTED_BAD_SUPP_CHAN = 24,
	WLAN_STATUS_ASSOC_DENIED_NOSHORTTIME = 25,
	WLAN_STATUS_ASSOC_DENIED_NODSSSOFDM = 26,
	WLAN_STATUS_ASSOC_REJECTED_TEMPORARILY = 30,
	WLAN_STATUS_ROBUST_MGMT_FRAME_POLICY_VIOLATION = 31,
	WLAN_STATUS_INVALID_IE = 40,
	WLAN_STATUS_INVALID_GROUP_CIPHER = 41,
	WLAN_STATUS_INVALID_PAIRWISE_CIPHER = 42,
	WLAN_STATUS_INVALID_AKMP = 43,
	WLAN_STATUS_UNSUPP_RSN_VERSION = 44,
	WLAN_STATUS_INVALID_RSN_IE_CAP = 45,
	WLAN_STATUS_CIPHER_SUITE_REJECTED = 46,
	WLAN_STATUS_UNSPECIFIED_QOS = 32,
	WLAN_STATUS_ASSOC_DENIED_NOBANDWIDTH = 33,
	WLAN_STATUS_ASSOC_DENIED_LOWACK = 34,
	WLAN_STATUS_ASSOC_DENIED_UNSUPP_QOS = 35,
	WLAN_STATUS_REQUEST_DECLINED = 37,
	WLAN_STATUS_INVALID_QOS_PARAM = 38,
	WLAN_STATUS_CHANGE_TSPEC = 39,
	WLAN_STATUS_WAIT_TS_DELAY = 47,
	WLAN_STATUS_NO_DIRECT_LINK = 48,
	WLAN_STATUS_STA_NOT_PRESENT = 49,
	WLAN_STATUS_STA_NOT_QSTA = 50,
	WLAN_STATUS_ANTI_CLOG_REQUIRED = 76,
	WLAN_STATUS_FCG_NOT_SUPP = 78,
	WLAN_STATUS_STA_NO_TBTT = 78,
	WLAN_STATUS_REJECTED_WITH_SUGGESTED_CHANGES = 39,
	WLAN_STATUS_REJECTED_FOR_DELAY_PERIOD = 47,
	WLAN_STATUS_REJECT_WITH_SCHEDULE = 83,
	WLAN_STATUS_PENDING_ADMITTING_FST_SESSION = 86,
	WLAN_STATUS_PERFORMING_FST_NOW = 87,
	WLAN_STATUS_PENDING_GAP_IN_BA_WINDOW = 88,
	WLAN_STATUS_REJECT_U_PID_SETTING = 89,
	WLAN_STATUS_REJECT_DSE_BAND = 96,
	WLAN_STATUS_DENIED_WITH_SUGGESTED_BAND_AND_CHANNEL = 99,
	WLAN_STATUS_DENIED_DUE_TO_SPECTRUM_MANAGEMENT = 103,
	WLAN_STATUS_FILS_AUTHENTICATION_FAILURE = 108,
	WLAN_STATUS_UNKNOWN_AUTHENTICATION_SERVER = 109,
	WLAN_STATUS_SAE_HASH_TO_ELEMENT = 126,
	WLAN_STATUS_SAE_PK = 127,
};

enum ieee80211_eid {
	WLAN_EID_SSID = 0,
	WLAN_EID_SUPP_RATES = 1,
	WLAN_EID_FH_PARAMS = 2,
	WLAN_EID_DS_PARAMS = 3,
	WLAN_EID_CF_PARAMS = 4,
	WLAN_EID_TIM = 5,
	WLAN_EID_IBSS_PARAMS = 6,
	WLAN_EID_COUNTRY = 7,
	WLAN_EID_REQUEST = 10,
	WLAN_EID_QBSS_LOAD = 11,
	WLAN_EID_EDCA_PARAM_SET = 12,
	WLAN_EID_TSPEC = 13,
	WLAN_EID_TCLAS = 14,
	WLAN_EID_SCHEDULE = 15,
	WLAN_EID_CHALLENGE = 16,
	WLAN_EID_PWR_CONSTRAINT = 32,
	WLAN_EID_PWR_CAPABILITY = 33,
	WLAN_EID_TPC_REQUEST = 34,
	WLAN_EID_TPC_REPORT = 35,
	WLAN_EID_SUPPORTED_CHANNELS = 36,
	WLAN_EID_CHANNEL_SWITCH = 37,
	WLAN_EID_MEASURE_REQUEST = 38,
	WLAN_EID_MEASURE_REPORT = 39,
	WLAN_EID_QUIET = 40,
	WLAN_EID_IBSS_DFS = 41,
	WLAN_EID_ERP_INFO = 42,
	WLAN_EID_TS_DELAY = 43,
	WLAN_EID_TCLAS_PROCESSING = 44,
	WLAN_EID_HT_CAPABILITY = 45,
	WLAN_EID_QOS_CAPA = 46,
	WLAN_EID_RSN = 48,
	WLAN_EID_802_15_COEX = 49,
	WLAN_EID_EXT_SUPP_RATES = 50,
	WLAN_EID_AP_CHAN_REPORT = 51,
	WLAN_EID_NEIGHBOR_REPORT = 52,
	WLAN_EID_RCPI = 53,
	WLAN_EID_MOBILITY_DOMAIN = 54,
	WLAN_EID_FAST_BSS_TRANSITION = 55,
	WLAN_EID_TIMEOUT_INTERVAL = 56,
	WLAN_EID_RIC_DATA = 57,
	WLAN_EID_DSE_REGISTERED_LOCATION = 58,
	WLAN_EID_SUPPORTED_REGULATORY_CLASSES = 59,
	WLAN_EID_EXT_CHANSWITCH_ANN = 60,
	WLAN_EID_HT_OPERATION = 61,
	WLAN_EID_SECONDARY_CHANNEL_OFFSET = 62,
	WLAN_EID_BSS_AVG_ACCESS_DELAY = 63,
	WLAN_EID_ANTENNA_INFO = 64,
	WLAN_EID_RSNI = 65,
	WLAN_EID_MEASUREMENT_PILOT_TX_INFO = 66,
	WLAN_EID_BSS_AVAILABLE_CAPACITY = 67,
	WLAN_EID_BSS_AC_ACCESS_DELAY = 68,
	WLAN_EID_TIME_ADVERTISEMENT = 69,
	WLAN_EID_RRM_ENABLED_CAPABILITIES = 70,
	WLAN_EID_MULTIPLE_BSSID = 71,
	WLAN_EID_BSS_COEX_2040 = 72,
	WLAN_EID_BSS_INTOLERANT_CHL_REPORT = 73,
	WLAN_EID_OVERLAP_BSS_SCAN_PARAM = 74,
	WLAN_EID_RIC_DESCRIPTOR = 75,
	WLAN_EID_MMIE = 76,
	WLAN_EID_ASSOC_COMEBACK_TIME = 77,
	WLAN_EID_EVENT_REQUEST = 78,
	WLAN_EID_EVENT_REPORT = 79,
	WLAN_EID_DIAGNOSTIC_REQUEST = 80,
	WLAN_EID_DIAGNOSTIC_REPORT = 81,
	WLAN_EID_LOCATION_PARAMS = 82,
	WLAN_EID_NON_TX_BSSID_CAP = 83,
	WLAN_EID_SSID_LIST = 84,
	WLAN_EID_MULTI_BSSID_IDX = 85,
	WLAN_EID_FMS_DESCRIPTOR = 86,
	WLAN_EID_FMS_REQUEST = 87,
	WLAN_EID_FMS_RESPONSE = 88,
	WLAN_EID_QOS_TRAFFIC_CAPA = 89,
	WLAN_EID_BSS_MAX_IDLE_PERIOD = 90,
	WLAN_EID_TSF_REQUEST = 91,
	WLAN_EID_TSF_RESPOSNE = 92,
	WLAN_EID_WNM_SLEEP_MODE = 93,
	WLAN_EID_TIM_BCAST_REQ = 94,
	WLAN_EID_TIM_BCAST_RESP = 95,
	WLAN_EID_COLL_IF_REPORT = 96,
	WLAN_EID_CHANNEL_USAGE = 97,
	WLAN_EID_TIME_ZONE = 98,
	WLAN_EID_DMS_REQUEST = 99,
	WLAN_EID_DMS_RESPONSE = 100,
	WLAN_EID_LINK_ID = 101,
	WLAN_EID_WAKEUP_SCHEDUL = 102,
	WLAN_EID_CHAN_SWITCH_TIMING = 104,
	WLAN_EID_PTI_CONTROL = 105,
	WLAN_EID_PU_BUFFER_STATUS = 106,
	WLAN_EID_INTERWORKING = 107,
	WLAN_EID_ADVERTISEMENT_PROTOCOL = 108,
	WLAN_EID_EXPEDITED_BW_REQ = 109,
	WLAN_EID_QOS_MAP_SET = 110,
	WLAN_EID_ROAMING_CONSORTIUM = 111,
	WLAN_EID_EMERGENCY_ALERT = 112,
	WLAN_EID_MESH_CONFIG = 113,
	WLAN_EID_MESH_ID = 114,
	WLAN_EID_LINK_METRIC_REPORT = 115,
	WLAN_EID_CONGESTION_NOTIFICATION = 116,
	WLAN_EID_PEER_MGMT = 117,
	WLAN_EID_CHAN_SWITCH_PARAM = 118,
	WLAN_EID_MESH_AWAKE_WINDOW = 119,
	WLAN_EID_BEACON_TIMING = 120,
	WLAN_EID_MCCAOP_SETUP_REQ = 121,
	WLAN_EID_MCCAOP_SETUP_RESP = 122,
	WLAN_EID_MCCAOP_ADVERT = 123,
	WLAN_EID_MCCAOP_TEARDOWN = 124,
	WLAN_EID_GANN = 125,
	WLAN_EID_RANN = 126,
	WLAN_EID_EXT_CAPABILITY = 127,
	WLAN_EID_PREQ = 130,
	WLAN_EID_PREP = 131,
	WLAN_EID_PERR = 132,
	WLAN_EID_PXU = 137,
	WLAN_EID_PXUC = 138,
	WLAN_EID_AUTH_MESH_PEER_EXCH = 139,
	WLAN_EID_MIC = 140,
	WLAN_EID_DESTINATION_URI = 141,
	WLAN_EID_UAPSD_COEX = 142,
	WLAN_EID_WAKEUP_SCHEDULE = 143,
	WLAN_EID_EXT_SCHEDULE = 144,
	WLAN_EID_STA_AVAILABILITY = 145,
	WLAN_EID_DMG_TSPEC = 146,
	WLAN_EID_DMG_AT = 147,
	WLAN_EID_DMG_CAP = 148,
	WLAN_EID_CISCO_VENDOR_SPECIFIC = 150,
	WLAN_EID_DMG_OPERATION = 151,
	WLAN_EID_DMG_BSS_PARAM_CHANGE = 152,
	WLAN_EID_DMG_BEAM_REFINEMENT = 153,
	WLAN_EID_CHANNEL_MEASURE_FEEDBACK = 154,
	WLAN_EID_AWAKE_WINDOW = 157,
	WLAN_EID_MULTI_BAND = 158,
	WLAN_EID_ADDBA_EXT = 159,
	WLAN_EID_NEXT_PCP_LIST = 160,
	WLAN_EID_PCP_HANDOVER = 161,
	WLAN_EID_DMG_LINK_MARGIN = 162,
	WLAN_EID_SWITCHING_STREAM = 163,
	WLAN_EID_SESSION_TRANSITION = 164,
	WLAN_EID_DYN_TONE_PAIRING_REPORT = 165,
	WLAN_EID_CLUSTER_REPORT = 166,
	WLAN_EID_RELAY_CAP = 167,
	WLAN_EID_RELAY_XFER_PARAM_SET = 168,
	WLAN_EID_BEAM_LINK_MAINT = 169,
	WLAN_EID_MULTIPLE_MAC_ADDR = 170,
	WLAN_EID_U_PID = 171,
	WLAN_EID_DMG_LINK_ADAPT_ACK = 172,
	WLAN_EID_MCCAOP_ADV_OVERVIEW = 174,
	WLAN_EID_QUIET_PERIOD_REQ = 175,
	WLAN_EID_QUIET_PERIOD_RESP = 177,
	WLAN_EID_EPAC_POLICY = 182,
	WLAN_EID_CLISTER_TIME_OFF = 183,
	WLAN_EID_INTER_AC_PRIO = 184,
	WLAN_EID_SCS_DESCRIPTOR = 185,
	WLAN_EID_QLOAD_REPORT = 186,
	WLAN_EID_HCCA_TXOP_UPDATE_COUNT = 187,
	WLAN_EID_HL_STREAM_ID = 188,
	WLAN_EID_GCR_GROUP_ADDR = 189,
	WLAN_EID_ANTENNA_SECTOR_ID_PATTERN = 190,
	WLAN_EID_VHT_CAPABILITY = 191,
	WLAN_EID_VHT_OPERATION = 192,
	WLAN_EID_EXTENDED_BSS_LOAD = 193,
	WLAN_EID_WIDE_BW_CHANNEL_SWITCH = 194,
	WLAN_EID_VHT_TX_POWER_ENVELOPE = 195,
	WLAN_EID_CHANNEL_SWITCH_WRAPPER = 196,
	WLAN_EID_AID = 197,
	WLAN_EID_QUIET_CHANNEL = 198,
	WLAN_EID_OPMODE_NOTIF = 199,
	WLAN_EID_REDUCED_NEIGHBOR_REPORT = 201,
	WLAN_EID_AID_REQUEST = 210,
	WLAN_EID_AID_RESPONSE = 211,
	WLAN_EID_S1G_BCN_COMPAT = 213,
	WLAN_EID_S1G_SHORT_BCN_INTERVAL = 214,
	WLAN_EID_S1G_CAPABILITIES = 217,
	WLAN_EID_VENDOR_SPECIFIC = 221,
	WLAN_EID_QOS_PARAMETER = 222,
	WLAN_EID_S1G_OPERATION = 232,
	WLAN_EID_CAG_NUMBER = 237,
	WLAN_EID_AP_CSN = 239,
	WLAN_EID_FILS_INDICATION = 240,
	WLAN_EID_DILS = 241,
	WLAN_EID_FRAGMENT = 242,
	WLAN_EID_RSNX = 244,
	WLAN_EID_EXTENSION = 255,
};

struct element {
	u8 id;
	u8 datalen;
	u8 data[0];
};

enum nl80211_he_ru_alloc {
	NL80211_RATE_INFO_HE_RU_ALLOC_26 = 0,
	NL80211_RATE_INFO_HE_RU_ALLOC_52 = 1,
	NL80211_RATE_INFO_HE_RU_ALLOC_106 = 2,
	NL80211_RATE_INFO_HE_RU_ALLOC_242 = 3,
	NL80211_RATE_INFO_HE_RU_ALLOC_484 = 4,
	NL80211_RATE_INFO_HE_RU_ALLOC_996 = 5,
	NL80211_RATE_INFO_HE_RU_ALLOC_2x996 = 6,
};

enum ieee80211_rate_flags {
	IEEE80211_RATE_SHORT_PREAMBLE = 1,
	IEEE80211_RATE_MANDATORY_A = 2,
	IEEE80211_RATE_MANDATORY_B = 4,
	IEEE80211_RATE_MANDATORY_G = 8,
	IEEE80211_RATE_ERP_G = 16,
	IEEE80211_RATE_SUPPORTS_5MHZ = 32,
	IEEE80211_RATE_SUPPORTS_10MHZ = 64,
};

struct iface_combination_params {
	int num_different_channels;
	u8 radar_detect;
	int iftype_num[13];
	u32 new_beacon_int;
};

enum rate_info_flags {
	RATE_INFO_FLAGS_MCS = 1,
	RATE_INFO_FLAGS_VHT_MCS = 2,
	RATE_INFO_FLAGS_SHORT_GI = 4,
	RATE_INFO_FLAGS_DMG = 8,
	RATE_INFO_FLAGS_HE_MCS = 16,
	RATE_INFO_FLAGS_EDMG = 32,
};

enum rate_info_bw {
	RATE_INFO_BW_20 = 0,
	RATE_INFO_BW_5 = 1,
	RATE_INFO_BW_10 = 2,
	RATE_INFO_BW_40 = 3,
	RATE_INFO_BW_80 = 4,
	RATE_INFO_BW_160 = 5,
	RATE_INFO_BW_HE_RU = 6,
};

struct iapp_layer2_update {
	u8 da[6];
	u8 sa[6];
	__be16 len;
	u8 dsap;
	u8 ssap;
	u8 control;
	u8 xid_info[3];
};

enum nl80211_reg_rule_flags {
	NL80211_RRF_NO_OFDM = 1,
	NL80211_RRF_NO_CCK = 2,
	NL80211_RRF_NO_INDOOR = 4,
	NL80211_RRF_NO_OUTDOOR = 8,
	NL80211_RRF_DFS = 16,
	NL80211_RRF_PTP_ONLY = 32,
	NL80211_RRF_PTMP_ONLY = 64,
	NL80211_RRF_NO_IR = 128,
	__NL80211_RRF_NO_IBSS = 256,
	NL80211_RRF_AUTO_BW = 2048,
	NL80211_RRF_IR_CONCURRENT = 4096,
	NL80211_RRF_NO_HT40MINUS = 8192,
	NL80211_RRF_NO_HT40PLUS = 16384,
	NL80211_RRF_NO_80MHZ = 32768,
	NL80211_RRF_NO_160MHZ = 65536,
	NL80211_RRF_NO_HE = 131072,
};

enum ieee80211_regd_source {
	REGD_SOURCE_INTERNAL_DB = 0,
	REGD_SOURCE_CRDA = 1,
	REGD_SOURCE_CACHED = 2,
};

enum reg_request_treatment {
	REG_REQ_OK = 0,
	REG_REQ_IGNORE = 1,
	REG_REQ_INTERSECT = 2,
	REG_REQ_ALREADY_SET = 3,
};

struct reg_beacon {
	struct list_head list;
	struct ieee80211_channel chan;
};

struct reg_regdb_apply_request {
	struct list_head list;
	const struct ieee80211_regdomain *regdom;
};

struct fwdb_country {
	u8 alpha2[2];
	__be16 coll_ptr;
};

struct fwdb_header {
	__be32 magic;
	__be32 version;
	struct fwdb_country country[0];
};

struct fwdb_collection {
	u8 len;
	u8 n_rules;
	u8 dfs_region;
	char: 8;
};

enum fwdb_flags {
	FWDB_FLAG_NO_OFDM = 1,
	FWDB_FLAG_NO_OUTDOOR = 2,
	FWDB_FLAG_DFS = 4,
	FWDB_FLAG_NO_IR = 8,
	FWDB_FLAG_AUTO_BW = 16,
};

struct fwdb_wmm_ac {
	u8 ecw;
	u8 aifsn;
	__be16 cot;
};

struct fwdb_wmm_rule {
	struct fwdb_wmm_ac client[4];
	struct fwdb_wmm_ac ap[4];
};

struct fwdb_rule {
	u8 len;
	u8 flags;
	__be16 max_eirp;
	__be32 start;
	__be32 end;
	__be32 max_bw;
	__be16 cac_timeout;
	__be16 wmm_ptr;
};

enum nl80211_scan_flags {
	NL80211_SCAN_FLAG_LOW_PRIORITY = 1,
	NL80211_SCAN_FLAG_FLUSH = 2,
	NL80211_SCAN_FLAG_AP = 4,
	NL80211_SCAN_FLAG_RANDOM_ADDR = 8,
	NL80211_SCAN_FLAG_FILS_MAX_CHANNEL_TIME = 16,
	NL80211_SCAN_FLAG_ACCEPT_BCAST_PROBE_RESP = 32,
	NL80211_SCAN_FLAG_OCE_PROBE_REQ_HIGH_TX_RATE = 64,
	NL80211_SCAN_FLAG_OCE_PROBE_REQ_DEFERRAL_SUPPRESSION = 128,
	NL80211_SCAN_FLAG_LOW_SPAN = 256,
	NL80211_SCAN_FLAG_LOW_POWER = 512,
	NL80211_SCAN_FLAG_HIGH_ACCURACY = 1024,
	NL80211_SCAN_FLAG_RANDOM_SN = 2048,
	NL80211_SCAN_FLAG_MIN_PREQ_CONTENT = 4096,
	NL80211_SCAN_FLAG_FREQ_KHZ = 8192,
	NL80211_SCAN_FLAG_COLOCATED_6GHZ = 16384,
};

struct ieee80211_s1g_bcn_compat_ie {
	__le16 compat_info;
	__le16 beacon_int;
	__le32 tsf_completion;
};

struct ieee80211_s1g_oper_ie {
	u8 ch_width;
	u8 oper_class;
	u8 primary_ch;
	u8 oper_ch;
	__le16 basic_mcs_nss;
};

struct ieee80211_ext {
	__le16 frame_control;
	__le16 duration;
	union {
		struct {
			u8 sa[6];
			__le32 timestamp;
			u8 change_seq;
			u8 variable[0];
		} __attribute__((packed)) s1g_beacon;
		struct {
			u8 sa[6];
			__le32 timestamp;
			u8 change_seq;
			u8 next_tbtt[3];
			u8 variable[0];
		} __attribute__((packed)) s1g_short_beacon;
	} u;
} __attribute__((packed));

struct ieee80211_ht_operation {
	u8 primary_chan;
	u8 ht_param;
	__le16 operation_mode;
	__le16 stbc_param;
	u8 basic_set[16];
};

enum ieee80211_eid_ext {
	WLAN_EID_EXT_ASSOC_DELAY_INFO = 1,
	WLAN_EID_EXT_FILS_REQ_PARAMS = 2,
	WLAN_EID_EXT_FILS_KEY_CONFIRM = 3,
	WLAN_EID_EXT_FILS_SESSION = 4,
	WLAN_EID_EXT_FILS_HLP_CONTAINER = 5,
	WLAN_EID_EXT_FILS_IP_ADDR_ASSIGN = 6,
	WLAN_EID_EXT_KEY_DELIVERY = 7,
	WLAN_EID_EXT_FILS_WRAPPED_DATA = 8,
	WLAN_EID_EXT_FILS_PUBLIC_KEY = 12,
	WLAN_EID_EXT_FILS_NONCE = 13,
	WLAN_EID_EXT_FUTURE_CHAN_GUIDANCE = 14,
	WLAN_EID_EXT_HE_CAPABILITY = 35,
	WLAN_EID_EXT_HE_OPERATION = 36,
	WLAN_EID_EXT_UORA = 37,
	WLAN_EID_EXT_HE_MU_EDCA = 38,
	WLAN_EID_EXT_HE_SPR = 39,
	WLAN_EID_EXT_NDP_FEEDBACK_REPORT_PARAMSET = 41,
	WLAN_EID_EXT_BSS_COLOR_CHG_ANN = 42,
	WLAN_EID_EXT_QUIET_TIME_PERIOD_SETUP = 43,
	WLAN_EID_EXT_ESS_REPORT = 45,
	WLAN_EID_EXT_OPS = 46,
	WLAN_EID_EXT_HE_BSS_LOAD = 47,
	WLAN_EID_EXT_MAX_CHANNEL_SWITCH_TIME = 52,
	WLAN_EID_EXT_MULTIPLE_BSSID_CONFIGURATION = 55,
	WLAN_EID_EXT_NON_INHERITANCE = 56,
	WLAN_EID_EXT_KNOWN_BSSID = 57,
	WLAN_EID_EXT_SHORT_SSID_LIST = 58,
	WLAN_EID_EXT_HE_6GHZ_CAPA = 59,
	WLAN_EID_EXT_UL_MU_POWER_CAPA = 60,
};

struct ieee80211_neighbor_ap_info {
	u8 tbtt_info_hdr;
	u8 tbtt_info_len;
	u8 op_class;
	u8 channel;
};

enum cfg80211_bss_frame_type {
	CFG80211_BSS_FTYPE_UNKNOWN = 0,
	CFG80211_BSS_FTYPE_BEACON = 1,
	CFG80211_BSS_FTYPE_PRESP = 2,
};

struct cfg80211_colocated_ap {
	struct list_head list;
	u8 bssid[6];
	u8 ssid[32];
	size_t ssid_len;
	u32 short_ssid;
	u32 center_freq;
	u8 unsolicited_probe: 1;
	u8 oct_recommended: 1;
	u8 same_ssid: 1;
	u8 multi_bss: 1;
	u8 transmitted_bssid: 1;
	u8 colocated_ess: 1;
	u8 short_ssid_valid: 1;
};

enum bss_compare_mode {
	BSS_CMP_REGULAR = 0,
	BSS_CMP_HIDE_ZLEN = 1,
	BSS_CMP_HIDE_NUL = 2,
};

struct cfg80211_non_tx_bss {
	struct cfg80211_bss *tx_bss;
	u8 max_bssid_indicator;
	u8 bssid_index;
};

enum ieee80211_vht_mcs_support {
	IEEE80211_VHT_MCS_SUPPORT_0_7 = 0,
	IEEE80211_VHT_MCS_SUPPORT_0_8 = 1,
	IEEE80211_VHT_MCS_SUPPORT_0_9 = 2,
	IEEE80211_VHT_MCS_NOT_SUPPORTED = 3,
};

enum ieee80211_he_mcs_support {
	IEEE80211_HE_MCS_SUPPORT_0_7 = 0,
	IEEE80211_HE_MCS_SUPPORT_0_9 = 1,
	IEEE80211_HE_MCS_SUPPORT_0_11 = 2,
	IEEE80211_HE_MCS_NOT_SUPPORTED = 3,
};

enum ieee80211_mesh_sync_method {
	IEEE80211_SYNC_METHOD_NEIGHBOR_OFFSET = 1,
	IEEE80211_SYNC_METHOD_VENDOR = 255,
};

enum ieee80211_mesh_path_protocol {
	IEEE80211_PATH_PROTOCOL_HWMP = 1,
	IEEE80211_PATH_PROTOCOL_VENDOR = 255,
};

enum ieee80211_mesh_path_metric {
	IEEE80211_PATH_METRIC_AIRTIME = 1,
	IEEE80211_PATH_METRIC_VENDOR = 255,
};

enum nl80211_sta_flags {
	__NL80211_STA_FLAG_INVALID = 0,
	NL80211_STA_FLAG_AUTHORIZED = 1,
	NL80211_STA_FLAG_SHORT_PREAMBLE = 2,
	NL80211_STA_FLAG_WME = 3,
	NL80211_STA_FLAG_MFP = 4,
	NL80211_STA_FLAG_AUTHENTICATED = 5,
	NL80211_STA_FLAG_TDLS_PEER = 6,
	NL80211_STA_FLAG_ASSOCIATED = 7,
	__NL80211_STA_FLAG_AFTER_LAST = 8,
	NL80211_STA_FLAG_MAX = 7,
};

enum nl80211_sta_p2p_ps_status {
	NL80211_P2P_PS_UNSUPPORTED = 0,
	NL80211_P2P_PS_SUPPORTED = 1,
	NUM_NL80211_P2P_PS_STATUS = 2,
};

enum nl80211_rate_info {
	__NL80211_RATE_INFO_INVALID = 0,
	NL80211_RATE_INFO_BITRATE = 1,
	NL80211_RATE_INFO_MCS = 2,
	NL80211_RATE_INFO_40_MHZ_WIDTH = 3,
	NL80211_RATE_INFO_SHORT_GI = 4,
	NL80211_RATE_INFO_BITRATE32 = 5,
	NL80211_RATE_INFO_VHT_MCS = 6,
	NL80211_RATE_INFO_VHT_NSS = 7,
	NL80211_RATE_INFO_80_MHZ_WIDTH = 8,
	NL80211_RATE_INFO_80P80_MHZ_WIDTH = 9,
	NL80211_RATE_INFO_160_MHZ_WIDTH = 10,
	NL80211_RATE_INFO_10_MHZ_WIDTH = 11,
	NL80211_RATE_INFO_5_MHZ_WIDTH = 12,
	NL80211_RATE_INFO_HE_MCS = 13,
	NL80211_RATE_INFO_HE_NSS = 14,
	NL80211_RATE_INFO_HE_GI = 15,
	NL80211_RATE_INFO_HE_DCM = 16,
	NL80211_RATE_INFO_HE_RU_ALLOC = 17,
	__NL80211_RATE_INFO_AFTER_LAST = 18,
	NL80211_RATE_INFO_MAX = 17,
};

enum nl80211_sta_bss_param {
	__NL80211_STA_BSS_PARAM_INVALID = 0,
	NL80211_STA_BSS_PARAM_CTS_PROT = 1,
	NL80211_STA_BSS_PARAM_SHORT_PREAMBLE = 2,
	NL80211_STA_BSS_PARAM_SHORT_SLOT_TIME = 3,
	NL80211_STA_BSS_PARAM_DTIM_PERIOD = 4,
	NL80211_STA_BSS_PARAM_BEACON_INTERVAL = 5,
	__NL80211_STA_BSS_PARAM_AFTER_LAST = 6,
	NL80211_STA_BSS_PARAM_MAX = 5,
};

enum nl80211_tid_stats {
	__NL80211_TID_STATS_INVALID = 0,
	NL80211_TID_STATS_RX_MSDU = 1,
	NL80211_TID_STATS_TX_MSDU = 2,
	NL80211_TID_STATS_TX_MSDU_RETRIES = 3,
	NL80211_TID_STATS_TX_MSDU_FAILED = 4,
	NL80211_TID_STATS_PAD = 5,
	NL80211_TID_STATS_TXQ_STATS = 6,
	NUM_NL80211_TID_STATS = 7,
	NL80211_TID_STATS_MAX = 6,
};

enum nl80211_txq_stats {
	__NL80211_TXQ_STATS_INVALID = 0,
	NL80211_TXQ_STATS_BACKLOG_BYTES = 1,
	NL80211_TXQ_STATS_BACKLOG_PACKETS = 2,
	NL80211_TXQ_STATS_FLOWS = 3,
	NL80211_TXQ_STATS_DROPS = 4,
	NL80211_TXQ_STATS_ECN_MARKS = 5,
	NL80211_TXQ_STATS_OVERLIMIT = 6,
	NL80211_TXQ_STATS_OVERMEMORY = 7,
	NL80211_TXQ_STATS_COLLISIONS = 8,
	NL80211_TXQ_STATS_TX_BYTES = 9,
	NL80211_TXQ_STATS_TX_PACKETS = 10,
	NL80211_TXQ_STATS_MAX_FLOWS = 11,
	NUM_NL80211_TXQ_STATS = 12,
	NL80211_TXQ_STATS_MAX = 11,
};

enum nl80211_mpath_info {
	__NL80211_MPATH_INFO_INVALID = 0,
	NL80211_MPATH_INFO_FRAME_QLEN = 1,
	NL80211_MPATH_INFO_SN = 2,
	NL80211_MPATH_INFO_METRIC = 3,
	NL80211_MPATH_INFO_EXPTIME = 4,
	NL80211_MPATH_INFO_FLAGS = 5,
	NL80211_MPATH_INFO_DISCOVERY_TIMEOUT = 6,
	NL80211_MPATH_INFO_DISCOVERY_RETRIES = 7,
	NL80211_MPATH_INFO_HOP_COUNT = 8,
	NL80211_MPATH_INFO_PATH_CHANGE = 9,
	__NL80211_MPATH_INFO_AFTER_LAST = 10,
	NL80211_MPATH_INFO_MAX = 9,
};

enum nl80211_band_iftype_attr {
	__NL80211_BAND_IFTYPE_ATTR_INVALID = 0,
	NL80211_BAND_IFTYPE_ATTR_IFTYPES = 1,
	NL80211_BAND_IFTYPE_ATTR_HE_CAP_MAC = 2,
	NL80211_BAND_IFTYPE_ATTR_HE_CAP_PHY = 3,
	NL80211_BAND_IFTYPE_ATTR_HE_CAP_MCS_SET = 4,
	NL80211_BAND_IFTYPE_ATTR_HE_CAP_PPE = 5,
	NL80211_BAND_IFTYPE_ATTR_HE_6GHZ_CAPA = 6,
	__NL80211_BAND_IFTYPE_ATTR_AFTER_LAST = 7,
	NL80211_BAND_IFTYPE_ATTR_MAX = 6,
};

enum nl80211_band_attr {
	__NL80211_BAND_ATTR_INVALID = 0,
	NL80211_BAND_ATTR_FREQS = 1,
	NL80211_BAND_ATTR_RATES = 2,
	NL80211_BAND_ATTR_HT_MCS_SET = 3,
	NL80211_BAND_ATTR_HT_CAPA = 4,
	NL80211_BAND_ATTR_HT_AMPDU_FACTOR = 5,
	NL80211_BAND_ATTR_HT_AMPDU_DENSITY = 6,
	NL80211_BAND_ATTR_VHT_MCS_SET = 7,
	NL80211_BAND_ATTR_VHT_CAPA = 8,
	NL80211_BAND_ATTR_IFTYPE_DATA = 9,
	NL80211_BAND_ATTR_EDMG_CHANNELS = 10,
	NL80211_BAND_ATTR_EDMG_BW_CONFIG = 11,
	__NL80211_BAND_ATTR_AFTER_LAST = 12,
	NL80211_BAND_ATTR_MAX = 11,
};

enum nl80211_wmm_rule {
	__NL80211_WMMR_INVALID = 0,
	NL80211_WMMR_CW_MIN = 1,
	NL80211_WMMR_CW_MAX = 2,
	NL80211_WMMR_AIFSN = 3,
	NL80211_WMMR_TXOP = 4,
	__NL80211_WMMR_LAST = 5,
	NL80211_WMMR_MAX = 4,
};

enum nl80211_frequency_attr {
	__NL80211_FREQUENCY_ATTR_INVALID = 0,
	NL80211_FREQUENCY_ATTR_FREQ = 1,
	NL80211_FREQUENCY_ATTR_DISABLED = 2,
	NL80211_FREQUENCY_ATTR_NO_IR = 3,
	__NL80211_FREQUENCY_ATTR_NO_IBSS = 4,
	NL80211_FREQUENCY_ATTR_RADAR = 5,
	NL80211_FREQUENCY_ATTR_MAX_TX_POWER = 6,
	NL80211_FREQUENCY_ATTR_DFS_STATE = 7,
	NL80211_FREQUENCY_ATTR_DFS_TIME = 8,
	NL80211_FREQUENCY_ATTR_NO_HT40_MINUS = 9,
	NL80211_FREQUENCY_ATTR_NO_HT40_PLUS = 10,
	NL80211_FREQUENCY_ATTR_NO_80MHZ = 11,
	NL80211_FREQUENCY_ATTR_NO_160MHZ = 12,
	NL80211_FREQUENCY_ATTR_DFS_CAC_TIME = 13,
	NL80211_FREQUENCY_ATTR_INDOOR_ONLY = 14,
	NL80211_FREQUENCY_ATTR_IR_CONCURRENT = 15,
	NL80211_FREQUENCY_ATTR_NO_20MHZ = 16,
	NL80211_FREQUENCY_ATTR_NO_10MHZ = 17,
	NL80211_FREQUENCY_ATTR_WMM = 18,
	NL80211_FREQUENCY_ATTR_NO_HE = 19,
	NL80211_FREQUENCY_ATTR_OFFSET = 20,
	NL80211_FREQUENCY_ATTR_1MHZ = 21,
	NL80211_FREQUENCY_ATTR_2MHZ = 22,
	NL80211_FREQUENCY_ATTR_4MHZ = 23,
	NL80211_FREQUENCY_ATTR_8MHZ = 24,
	NL80211_FREQUENCY_ATTR_16MHZ = 25,
	__NL80211_FREQUENCY_ATTR_AFTER_LAST = 26,
	NL80211_FREQUENCY_ATTR_MAX = 25,
};

enum nl80211_bitrate_attr {
	__NL80211_BITRATE_ATTR_INVALID = 0,
	NL80211_BITRATE_ATTR_RATE = 1,
	NL80211_BITRATE_ATTR_2GHZ_SHORTPREAMBLE = 2,
	__NL80211_BITRATE_ATTR_AFTER_LAST = 3,
	NL80211_BITRATE_ATTR_MAX = 2,
};

enum nl80211_reg_type {
	NL80211_REGDOM_TYPE_COUNTRY = 0,
	NL80211_REGDOM_TYPE_WORLD = 1,
	NL80211_REGDOM_TYPE_CUSTOM_WORLD = 2,
	NL80211_REGDOM_TYPE_INTERSECTION = 3,
};

enum nl80211_reg_rule_attr {
	__NL80211_REG_RULE_ATTR_INVALID = 0,
	NL80211_ATTR_REG_RULE_FLAGS = 1,
	NL80211_ATTR_FREQ_RANGE_START = 2,
	NL80211_ATTR_FREQ_RANGE_END = 3,
	NL80211_ATTR_FREQ_RANGE_MAX_BW = 4,
	NL80211_ATTR_POWER_RULE_MAX_ANT_GAIN = 5,
	NL80211_ATTR_POWER_RULE_MAX_EIRP = 6,
	NL80211_ATTR_DFS_CAC_TIME = 7,
	__NL80211_REG_RULE_ATTR_AFTER_LAST = 8,
	NL80211_REG_RULE_ATTR_MAX = 7,
};

enum nl80211_sched_scan_match_attr {
	__NL80211_SCHED_SCAN_MATCH_ATTR_INVALID = 0,
	NL80211_SCHED_SCAN_MATCH_ATTR_SSID = 1,
	NL80211_SCHED_SCAN_MATCH_ATTR_RSSI = 2,
	NL80211_SCHED_SCAN_MATCH_ATTR_RELATIVE_RSSI = 3,
	NL80211_SCHED_SCAN_MATCH_ATTR_RSSI_ADJUST = 4,
	NL80211_SCHED_SCAN_MATCH_ATTR_BSSID = 5,
	NL80211_SCHED_SCAN_MATCH_PER_BAND_RSSI = 6,
	__NL80211_SCHED_SCAN_MATCH_ATTR_AFTER_LAST = 7,
	NL80211_SCHED_SCAN_MATCH_ATTR_MAX = 6,
};

enum nl80211_survey_info {
	__NL80211_SURVEY_INFO_INVALID = 0,
	NL80211_SURVEY_INFO_FREQUENCY = 1,
	NL80211_SURVEY_INFO_NOISE = 2,
	NL80211_SURVEY_INFO_IN_USE = 3,
	NL80211_SURVEY_INFO_TIME = 4,
	NL80211_SURVEY_INFO_TIME_BUSY = 5,
	NL80211_SURVEY_INFO_TIME_EXT_BUSY = 6,
	NL80211_SURVEY_INFO_TIME_RX = 7,
	NL80211_SURVEY_INFO_TIME_TX = 8,
	NL80211_SURVEY_INFO_TIME_SCAN = 9,
	NL80211_SURVEY_INFO_PAD = 10,
	NL80211_SURVEY_INFO_TIME_BSS_RX = 11,
	NL80211_SURVEY_INFO_FREQUENCY_OFFSET = 12,
	__NL80211_SURVEY_INFO_AFTER_LAST = 13,
	NL80211_SURVEY_INFO_MAX = 12,
};

enum nl80211_meshconf_params {
	__NL80211_MESHCONF_INVALID = 0,
	NL80211_MESHCONF_RETRY_TIMEOUT = 1,
	NL80211_MESHCONF_CONFIRM_TIMEOUT = 2,
	NL80211_MESHCONF_HOLDING_TIMEOUT = 3,
	NL80211_MESHCONF_MAX_PEER_LINKS = 4,
	NL80211_MESHCONF_MAX_RETRIES = 5,
	NL80211_MESHCONF_TTL = 6,
	NL80211_MESHCONF_AUTO_OPEN_PLINKS = 7,
	NL80211_MESHCONF_HWMP_MAX_PREQ_RETRIES = 8,
	NL80211_MESHCONF_PATH_REFRESH_TIME = 9,
	NL80211_MESHCONF_MIN_DISCOVERY_TIMEOUT = 10,
	NL80211_MESHCONF_HWMP_ACTIVE_PATH_TIMEOUT = 11,
	NL80211_MESHCONF_HWMP_PREQ_MIN_INTERVAL = 12,
	NL80211_MESHCONF_HWMP_NET_DIAM_TRVS_TIME = 13,
	NL80211_MESHCONF_HWMP_ROOTMODE = 14,
	NL80211_MESHCONF_ELEMENT_TTL = 15,
	NL80211_MESHCONF_HWMP_RANN_INTERVAL = 16,
	NL80211_MESHCONF_GATE_ANNOUNCEMENTS = 17,
	NL80211_MESHCONF_HWMP_PERR_MIN_INTERVAL = 18,
	NL80211_MESHCONF_FORWARDING = 19,
	NL80211_MESHCONF_RSSI_THRESHOLD = 20,
	NL80211_MESHCONF_SYNC_OFFSET_MAX_NEIGHBOR = 21,
	NL80211_MESHCONF_HT_OPMODE = 22,
	NL80211_MESHCONF_HWMP_PATH_TO_ROOT_TIMEOUT = 23,
	NL80211_MESHCONF_HWMP_ROOT_INTERVAL = 24,
	NL80211_MESHCONF_HWMP_CONFIRMATION_INTERVAL = 25,
	NL80211_MESHCONF_POWER_MODE = 26,
	NL80211_MESHCONF_AWAKE_WINDOW = 27,
	NL80211_MESHCONF_PLINK_TIMEOUT = 28,
	NL80211_MESHCONF_CONNECTED_TO_GATE = 29,
	NL80211_MESHCONF_NOLEARN = 30,
	NL80211_MESHCONF_CONNECTED_TO_AS = 31,
	__NL80211_MESHCONF_ATTR_AFTER_LAST = 32,
	NL80211_MESHCONF_ATTR_MAX = 31,
};

enum nl80211_mesh_setup_params {
	__NL80211_MESH_SETUP_INVALID = 0,
	NL80211_MESH_SETUP_ENABLE_VENDOR_PATH_SEL = 1,
	NL80211_MESH_SETUP_ENABLE_VENDOR_METRIC = 2,
	NL80211_MESH_SETUP_IE = 3,
	NL80211_MESH_SETUP_USERSPACE_AUTH = 4,
	NL80211_MESH_SETUP_USERSPACE_AMPE = 5,
	NL80211_MESH_SETUP_ENABLE_VENDOR_SYNC = 6,
	NL80211_MESH_SETUP_USERSPACE_MPM = 7,
	NL80211_MESH_SETUP_AUTH_PROTOCOL = 8,
	__NL80211_MESH_SETUP_ATTR_AFTER_LAST = 9,
	NL80211_MESH_SETUP_ATTR_MAX = 8,
};

enum nl80211_txq_attr {
	__NL80211_TXQ_ATTR_INVALID = 0,
	NL80211_TXQ_ATTR_AC = 1,
	NL80211_TXQ_ATTR_TXOP = 2,
	NL80211_TXQ_ATTR_CWMIN = 3,
	NL80211_TXQ_ATTR_CWMAX = 4,
	NL80211_TXQ_ATTR_AIFS = 5,
	__NL80211_TXQ_ATTR_AFTER_LAST = 6,
	NL80211_TXQ_ATTR_MAX = 5,
};

enum nl80211_bss {
	__NL80211_BSS_INVALID = 0,
	NL80211_BSS_BSSID = 1,
	NL80211_BSS_FREQUENCY = 2,
	NL80211_BSS_TSF = 3,
	NL80211_BSS_BEACON_INTERVAL = 4,
	NL80211_BSS_CAPABILITY = 5,
	NL80211_BSS_INFORMATION_ELEMENTS = 6,
	NL80211_BSS_SIGNAL_MBM = 7,
	NL80211_BSS_SIGNAL_UNSPEC = 8,
	NL80211_BSS_STATUS = 9,
	NL80211_BSS_SEEN_MS_AGO = 10,
	NL80211_BSS_BEACON_IES = 11,
	NL80211_BSS_CHAN_WIDTH = 12,
	NL80211_BSS_BEACON_TSF = 13,
	NL80211_BSS_PRESP_DATA = 14,
	NL80211_BSS_LAST_SEEN_BOOTTIME = 15,
	NL80211_BSS_PAD = 16,
	NL80211_BSS_PARENT_TSF = 17,
	NL80211_BSS_PARENT_BSSID = 18,
	NL80211_BSS_CHAIN_SIGNAL = 19,
	NL80211_BSS_FREQUENCY_OFFSET = 20,
	__NL80211_BSS_AFTER_LAST = 21,
	NL80211_BSS_MAX = 20,
};

enum nl80211_bss_status {
	NL80211_BSS_STATUS_AUTHENTICATED = 0,
	NL80211_BSS_STATUS_ASSOCIATED = 1,
	NL80211_BSS_STATUS_IBSS_JOINED = 2,
};

enum nl80211_key_default_types {
	__NL80211_KEY_DEFAULT_TYPE_INVALID = 0,
	NL80211_KEY_DEFAULT_TYPE_UNICAST = 1,
	NL80211_KEY_DEFAULT_TYPE_MULTICAST = 2,
	NUM_NL80211_KEY_DEFAULT_TYPES = 3,
};

enum nl80211_key_attributes {
	__NL80211_KEY_INVALID = 0,
	NL80211_KEY_DATA = 1,
	NL80211_KEY_IDX = 2,
	NL80211_KEY_CIPHER = 3,
	NL80211_KEY_SEQ = 4,
	NL80211_KEY_DEFAULT = 5,
	NL80211_KEY_DEFAULT_MGMT = 6,
	NL80211_KEY_TYPE = 7,
	NL80211_KEY_DEFAULT_TYPES = 8,
	NL80211_KEY_MODE = 9,
	NL80211_KEY_DEFAULT_BEACON = 10,
	__NL80211_KEY_AFTER_LAST = 11,
	NL80211_KEY_MAX = 10,
};

enum nl80211_tx_rate_attributes {
	__NL80211_TXRATE_INVALID = 0,
	NL80211_TXRATE_LEGACY = 1,
	NL80211_TXRATE_HT = 2,
	NL80211_TXRATE_VHT = 3,
	NL80211_TXRATE_GI = 4,
	NL80211_TXRATE_HE = 5,
	NL80211_TXRATE_HE_GI = 6,
	NL80211_TXRATE_HE_LTF = 7,
	__NL80211_TXRATE_AFTER_LAST = 8,
	NL80211_TXRATE_MAX = 7,
};

struct nl80211_txrate_vht {
	__u16 mcs[8];
};

struct nl80211_txrate_he {
	__u16 mcs[8];
};

enum nl80211_ps_state {
	NL80211_PS_DISABLED = 0,
	NL80211_PS_ENABLED = 1,
};

enum nl80211_attr_cqm {
	__NL80211_ATTR_CQM_INVALID = 0,
	NL80211_ATTR_CQM_RSSI_THOLD = 1,
	NL80211_ATTR_CQM_RSSI_HYST = 2,
	NL80211_ATTR_CQM_RSSI_THRESHOLD_EVENT = 3,
	NL80211_ATTR_CQM_PKT_LOSS_EVENT = 4,
	NL80211_ATTR_CQM_TXE_RATE = 5,
	NL80211_ATTR_CQM_TXE_PKTS = 6,
	NL80211_ATTR_CQM_TXE_INTVL = 7,
	NL80211_ATTR_CQM_BEACON_LOSS_EVENT = 8,
	NL80211_ATTR_CQM_RSSI_LEVEL = 9,
	__NL80211_ATTR_CQM_AFTER_LAST = 10,
	NL80211_ATTR_CQM_MAX = 9,
};

enum nl80211_cqm_rssi_threshold_event {
	NL80211_CQM_RSSI_THRESHOLD_EVENT_LOW = 0,
	NL80211_CQM_RSSI_THRESHOLD_EVENT_HIGH = 1,
	NL80211_CQM_RSSI_BEACON_LOSS_EVENT = 2,
};

enum nl80211_tid_config_attr {
	__NL80211_TID_CONFIG_ATTR_INVALID = 0,
	NL80211_TID_CONFIG_ATTR_PAD = 1,
	NL80211_TID_CONFIG_ATTR_VIF_SUPP = 2,
	NL80211_TID_CONFIG_ATTR_PEER_SUPP = 3,
	NL80211_TID_CONFIG_ATTR_OVERRIDE = 4,
	NL80211_TID_CONFIG_ATTR_TIDS = 5,
	NL80211_TID_CONFIG_ATTR_NOACK = 6,
	NL80211_TID_CONFIG_ATTR_RETRY_SHORT = 7,
	NL80211_TID_CONFIG_ATTR_RETRY_LONG = 8,
	NL80211_TID_CONFIG_ATTR_AMPDU_CTRL = 9,
	NL80211_TID_CONFIG_ATTR_RTSCTS_CTRL = 10,
	NL80211_TID_CONFIG_ATTR_AMSDU_CTRL = 11,
	NL80211_TID_CONFIG_ATTR_TX_RATE_TYPE = 12,
	NL80211_TID_CONFIG_ATTR_TX_RATE = 13,
	__NL80211_TID_CONFIG_ATTR_AFTER_LAST = 14,
	NL80211_TID_CONFIG_ATTR_MAX = 13,
};

enum nl80211_packet_pattern_attr {
	__NL80211_PKTPAT_INVALID = 0,
	NL80211_PKTPAT_MASK = 1,
	NL80211_PKTPAT_PATTERN = 2,
	NL80211_PKTPAT_OFFSET = 3,
	NUM_NL80211_PKTPAT = 4,
	MAX_NL80211_PKTPAT = 3,
};

struct nl80211_pattern_support {
	__u32 max_patterns;
	__u32 min_pattern_len;
	__u32 max_pattern_len;
	__u32 max_pkt_offset;
};

enum nl80211_wowlan_triggers {
	__NL80211_WOWLAN_TRIG_INVALID = 0,
	NL80211_WOWLAN_TRIG_ANY = 1,
	NL80211_WOWLAN_TRIG_DISCONNECT = 2,
	NL80211_WOWLAN_TRIG_MAGIC_PKT = 3,
	NL80211_WOWLAN_TRIG_PKT_PATTERN = 4,
	NL80211_WOWLAN_TRIG_GTK_REKEY_SUPPORTED = 5,
	NL80211_WOWLAN_TRIG_GTK_REKEY_FAILURE = 6,
	NL80211_WOWLAN_TRIG_EAP_IDENT_REQUEST = 7,
	NL80211_WOWLAN_TRIG_4WAY_HANDSHAKE = 8,
	NL80211_WOWLAN_TRIG_RFKILL_RELEASE = 9,
	NL80211_WOWLAN_TRIG_WAKEUP_PKT_80211 = 10,
	NL80211_WOWLAN_TRIG_WAKEUP_PKT_80211_LEN = 11,
	NL80211_WOWLAN_TRIG_WAKEUP_PKT_8023 = 12,
	NL80211_WOWLAN_TRIG_WAKEUP_PKT_8023_LEN = 13,
	NL80211_WOWLAN_TRIG_TCP_CONNECTION = 14,
	NL80211_WOWLAN_TRIG_WAKEUP_TCP_MATCH = 15,
	NL80211_WOWLAN_TRIG_WAKEUP_TCP_CONNLOST = 16,
	NL80211_WOWLAN_TRIG_WAKEUP_TCP_NOMORETOKENS = 17,
	NL80211_WOWLAN_TRIG_NET_DETECT = 18,
	NL80211_WOWLAN_TRIG_NET_DETECT_RESULTS = 19,
	NUM_NL80211_WOWLAN_TRIG = 20,
	MAX_NL80211_WOWLAN_TRIG = 19,
};

enum nl80211_wowlan_tcp_attrs {
	__NL80211_WOWLAN_TCP_INVALID = 0,
	NL80211_WOWLAN_TCP_SRC_IPV4 = 1,
	NL80211_WOWLAN_TCP_DST_IPV4 = 2,
	NL80211_WOWLAN_TCP_DST_MAC = 3,
	NL80211_WOWLAN_TCP_SRC_PORT = 4,
	NL80211_WOWLAN_TCP_DST_PORT = 5,
	NL80211_WOWLAN_TCP_DATA_PAYLOAD = 6,
	NL80211_WOWLAN_TCP_DATA_PAYLOAD_SEQ = 7,
	NL80211_WOWLAN_TCP_DATA_PAYLOAD_TOKEN = 8,
	NL80211_WOWLAN_TCP_DATA_INTERVAL = 9,
	NL80211_WOWLAN_TCP_WAKE_PAYLOAD = 10,
	NL80211_WOWLAN_TCP_WAKE_MASK = 11,
	NUM_NL80211_WOWLAN_TCP = 12,
	MAX_NL80211_WOWLAN_TCP = 11,
};

struct nl80211_coalesce_rule_support {
	__u32 max_rules;
	struct nl80211_pattern_support pat;
	__u32 max_delay;
};

enum nl80211_attr_coalesce_rule {
	__NL80211_COALESCE_RULE_INVALID = 0,
	NL80211_ATTR_COALESCE_RULE_DELAY = 1,
	NL80211_ATTR_COALESCE_RULE_CONDITION = 2,
	NL80211_ATTR_COALESCE_RULE_PKT_PATTERN = 3,
	NUM_NL80211_ATTR_COALESCE_RULE = 4,
	NL80211_ATTR_COALESCE_RULE_MAX = 3,
};

enum nl80211_iface_limit_attrs {
	NL80211_IFACE_LIMIT_UNSPEC = 0,
	NL80211_IFACE_LIMIT_MAX = 1,
	NL80211_IFACE_LIMIT_TYPES = 2,
	NUM_NL80211_IFACE_LIMIT = 3,
	MAX_NL80211_IFACE_LIMIT = 2,
};

enum nl80211_if_combination_attrs {
	NL80211_IFACE_COMB_UNSPEC = 0,
	NL80211_IFACE_COMB_LIMITS = 1,
	NL80211_IFACE_COMB_MAXNUM = 2,
	NL80211_IFACE_COMB_STA_AP_BI_MATCH = 3,
	NL80211_IFACE_COMB_NUM_CHANNELS = 4,
	NL80211_IFACE_COMB_RADAR_DETECT_WIDTHS = 5,
	NL80211_IFACE_COMB_RADAR_DETECT_REGIONS = 6,
	NL80211_IFACE_COMB_BI_MIN_GCD = 7,
	NUM_NL80211_IFACE_COMB = 8,
	MAX_NL80211_IFACE_COMB = 7,
};

enum nl80211_plink_state {
	NL80211_PLINK_LISTEN = 0,
	NL80211_PLINK_OPN_SNT = 1,
	NL80211_PLINK_OPN_RCVD = 2,
	NL80211_PLINK_CNF_RCVD = 3,
	NL80211_PLINK_ESTAB = 4,
	NL80211_PLINK_HOLDING = 5,
	NL80211_PLINK_BLOCKED = 6,
	NUM_NL80211_PLINK_STATES = 7,
	MAX_NL80211_PLINK_STATES = 6,
};

enum plink_actions {
	NL80211_PLINK_ACTION_NO_ACTION = 0,
	NL80211_PLINK_ACTION_OPEN = 1,
	NL80211_PLINK_ACTION_BLOCK = 2,
	NUM_NL80211_PLINK_ACTIONS = 3,
};

enum nl80211_rekey_data {
	__NL80211_REKEY_DATA_INVALID = 0,
	NL80211_REKEY_DATA_KEK = 1,
	NL80211_REKEY_DATA_KCK = 2,
	NL80211_REKEY_DATA_REPLAY_CTR = 3,
	NL80211_REKEY_DATA_AKM = 4,
	NUM_NL80211_REKEY_DATA = 5,
	MAX_NL80211_REKEY_DATA = 4,
};

enum nl80211_sta_wme_attr {
	__NL80211_STA_WME_INVALID = 0,
	NL80211_STA_WME_UAPSD_QUEUES = 1,
	NL80211_STA_WME_MAX_SP = 2,
	__NL80211_STA_WME_AFTER_LAST = 3,
	NL80211_STA_WME_MAX = 2,
};

enum nl80211_pmksa_candidate_attr {
	__NL80211_PMKSA_CANDIDATE_INVALID = 0,
	NL80211_PMKSA_CANDIDATE_INDEX = 1,
	NL80211_PMKSA_CANDIDATE_BSSID = 2,
	NL80211_PMKSA_CANDIDATE_PREAUTH = 3,
	NUM_NL80211_PMKSA_CANDIDATE = 4,
	MAX_NL80211_PMKSA_CANDIDATE = 3,
};

enum nl80211_connect_failed_reason {
	NL80211_CONN_FAIL_MAX_CLIENTS = 0,
	NL80211_CONN_FAIL_BLOCKED_CLIENT = 1,
};

enum nl80211_protocol_features {
	NL80211_PROTOCOL_FEATURE_SPLIT_WIPHY_DUMP = 1,
};

enum nl80211_sched_scan_plan {
	__NL80211_SCHED_SCAN_PLAN_INVALID = 0,
	NL80211_SCHED_SCAN_PLAN_INTERVAL = 1,
	NL80211_SCHED_SCAN_PLAN_ITERATIONS = 2,
	__NL80211_SCHED_SCAN_PLAN_AFTER_LAST = 3,
	NL80211_SCHED_SCAN_PLAN_MAX = 2,
};

struct nl80211_bss_select_rssi_adjust {
	__u8 band;
	__s8 delta;
};

enum nl80211_nan_publish_type {
	NL80211_NAN_SOLICITED_PUBLISH = 1,
	NL80211_NAN_UNSOLICITED_PUBLISH = 2,
};

enum nl80211_nan_func_term_reason {
	NL80211_NAN_FUNC_TERM_REASON_USER_REQUEST = 0,
	NL80211_NAN_FUNC_TERM_REASON_TTL_EXPIRED = 1,
	NL80211_NAN_FUNC_TERM_REASON_ERROR = 2,
};

enum nl80211_nan_func_attributes {
	__NL80211_NAN_FUNC_INVALID = 0,
	NL80211_NAN_FUNC_TYPE = 1,
	NL80211_NAN_FUNC_SERVICE_ID = 2,
	NL80211_NAN_FUNC_PUBLISH_TYPE = 3,
	NL80211_NAN_FUNC_PUBLISH_BCAST = 4,
	NL80211_NAN_FUNC_SUBSCRIBE_ACTIVE = 5,
	NL80211_NAN_FUNC_FOLLOW_UP_ID = 6,
	NL80211_NAN_FUNC_FOLLOW_UP_REQ_ID = 7,
	NL80211_NAN_FUNC_FOLLOW_UP_DEST = 8,
	NL80211_NAN_FUNC_CLOSE_RANGE = 9,
	NL80211_NAN_FUNC_TTL = 10,
	NL80211_NAN_FUNC_SERVICE_INFO = 11,
	NL80211_NAN_FUNC_SRF = 12,
	NL80211_NAN_FUNC_RX_MATCH_FILTER = 13,
	NL80211_NAN_FUNC_TX_MATCH_FILTER = 14,
	NL80211_NAN_FUNC_INSTANCE_ID = 15,
	NL80211_NAN_FUNC_TERM_REASON = 16,
	NUM_NL80211_NAN_FUNC_ATTR = 17,
	NL80211_NAN_FUNC_ATTR_MAX = 16,
};

enum nl80211_nan_srf_attributes {
	__NL80211_NAN_SRF_INVALID = 0,
	NL80211_NAN_SRF_INCLUDE = 1,
	NL80211_NAN_SRF_BF = 2,
	NL80211_NAN_SRF_BF_IDX = 3,
	NL80211_NAN_SRF_MAC_ADDRS = 4,
	NUM_NL80211_NAN_SRF_ATTR = 5,
	NL80211_NAN_SRF_ATTR_MAX = 4,
};

enum nl80211_nan_match_attributes {
	__NL80211_NAN_MATCH_INVALID = 0,
	NL80211_NAN_MATCH_FUNC_LOCAL = 1,
	NL80211_NAN_MATCH_FUNC_PEER = 2,
	NUM_NL80211_NAN_MATCH_ATTR = 3,
	NL80211_NAN_MATCH_ATTR_MAX = 2,
};

enum nl80211_ftm_responder_attributes {
	__NL80211_FTM_RESP_ATTR_INVALID = 0,
	NL80211_FTM_RESP_ATTR_ENABLED = 1,
	NL80211_FTM_RESP_ATTR_LCI = 2,
	NL80211_FTM_RESP_ATTR_CIVICLOC = 3,
	__NL80211_FTM_RESP_ATTR_LAST = 4,
	NL80211_FTM_RESP_ATTR_MAX = 3,
};

enum nl80211_ftm_responder_stats {
	__NL80211_FTM_STATS_INVALID = 0,
	NL80211_FTM_STATS_SUCCESS_NUM = 1,
	NL80211_FTM_STATS_PARTIAL_NUM = 2,
	NL80211_FTM_STATS_FAILED_NUM = 3,
	NL80211_FTM_STATS_ASAP_NUM = 4,
	NL80211_FTM_STATS_NON_ASAP_NUM = 5,
	NL80211_FTM_STATS_TOTAL_DURATION_MSEC = 6,
	NL80211_FTM_STATS_UNKNOWN_TRIGGERS_NUM = 7,
	NL80211_FTM_STATS_RESCHEDULE_REQUESTS_NUM = 8,
	NL80211_FTM_STATS_OUT_OF_WINDOW_TRIGGERS_NUM = 9,
	NL80211_FTM_STATS_PAD = 10,
	__NL80211_FTM_STATS_AFTER_LAST = 11,
	NL80211_FTM_STATS_MAX = 10,
};

enum nl80211_peer_measurement_type {
	NL80211_PMSR_TYPE_INVALID = 0,
	NL80211_PMSR_TYPE_FTM = 1,
	NUM_NL80211_PMSR_TYPES = 2,
	NL80211_PMSR_TYPE_MAX = 1,
};

enum nl80211_peer_measurement_req {
	__NL80211_PMSR_REQ_ATTR_INVALID = 0,
	NL80211_PMSR_REQ_ATTR_DATA = 1,
	NL80211_PMSR_REQ_ATTR_GET_AP_TSF = 2,
	NUM_NL80211_PMSR_REQ_ATTRS = 3,
	NL80211_PMSR_REQ_ATTR_MAX = 2,
};

enum nl80211_peer_measurement_peer_attrs {
	__NL80211_PMSR_PEER_ATTR_INVALID = 0,
	NL80211_PMSR_PEER_ATTR_ADDR = 1,
	NL80211_PMSR_PEER_ATTR_CHAN = 2,
	NL80211_PMSR_PEER_ATTR_REQ = 3,
	NL80211_PMSR_PEER_ATTR_RESP = 4,
	NUM_NL80211_PMSR_PEER_ATTRS = 5,
	NL80211_PMSR_PEER_ATTR_MAX = 4,
};

enum nl80211_peer_measurement_attrs {
	__NL80211_PMSR_ATTR_INVALID = 0,
	NL80211_PMSR_ATTR_MAX_PEERS = 1,
	NL80211_PMSR_ATTR_REPORT_AP_TSF = 2,
	NL80211_PMSR_ATTR_RANDOMIZE_MAC_ADDR = 3,
	NL80211_PMSR_ATTR_TYPE_CAPA = 4,
	NL80211_PMSR_ATTR_PEERS = 5,
	NUM_NL80211_PMSR_ATTR = 6,
	NL80211_PMSR_ATTR_MAX = 5,
};

enum nl80211_peer_measurement_ftm_capa {
	__NL80211_PMSR_FTM_CAPA_ATTR_INVALID = 0,
	NL80211_PMSR_FTM_CAPA_ATTR_ASAP = 1,
	NL80211_PMSR_FTM_CAPA_ATTR_NON_ASAP = 2,
	NL80211_PMSR_FTM_CAPA_ATTR_REQ_LCI = 3,
	NL80211_PMSR_FTM_CAPA_ATTR_REQ_CIVICLOC = 4,
	NL80211_PMSR_FTM_CAPA_ATTR_PREAMBLES = 5,
	NL80211_PMSR_FTM_CAPA_ATTR_BANDWIDTHS = 6,
	NL80211_PMSR_FTM_CAPA_ATTR_MAX_BURSTS_EXPONENT = 7,
	NL80211_PMSR_FTM_CAPA_ATTR_MAX_FTMS_PER_BURST = 8,
	NL80211_PMSR_FTM_CAPA_ATTR_TRIGGER_BASED = 9,
	NL80211_PMSR_FTM_CAPA_ATTR_NON_TRIGGER_BASED = 10,
	NUM_NL80211_PMSR_FTM_CAPA_ATTR = 11,
	NL80211_PMSR_FTM_CAPA_ATTR_MAX = 10,
};

enum nl80211_peer_measurement_ftm_req {
	__NL80211_PMSR_FTM_REQ_ATTR_INVALID = 0,
	NL80211_PMSR_FTM_REQ_ATTR_ASAP = 1,
	NL80211_PMSR_FTM_REQ_ATTR_PREAMBLE = 2,
	NL80211_PMSR_FTM_REQ_ATTR_NUM_BURSTS_EXP = 3,
	NL80211_PMSR_FTM_REQ_ATTR_BURST_PERIOD = 4,
	NL80211_PMSR_FTM_REQ_ATTR_BURST_DURATION = 5,
	NL80211_PMSR_FTM_REQ_ATTR_FTMS_PER_BURST = 6,
	NL80211_PMSR_FTM_REQ_ATTR_NUM_FTMR_RETRIES = 7,
	NL80211_PMSR_FTM_REQ_ATTR_REQUEST_LCI = 8,
	NL80211_PMSR_FTM_REQ_ATTR_REQUEST_CIVICLOC = 9,
	NL80211_PMSR_FTM_REQ_ATTR_TRIGGER_BASED = 10,
	NL80211_PMSR_FTM_REQ_ATTR_NON_TRIGGER_BASED = 11,
	NUM_NL80211_PMSR_FTM_REQ_ATTR = 12,
	NL80211_PMSR_FTM_REQ_ATTR_MAX = 11,
};

enum nl80211_obss_pd_attributes {
	__NL80211_HE_OBSS_PD_ATTR_INVALID = 0,
	NL80211_HE_OBSS_PD_ATTR_MIN_OFFSET = 1,
	NL80211_HE_OBSS_PD_ATTR_MAX_OFFSET = 2,
	NL80211_HE_OBSS_PD_ATTR_NON_SRG_MAX_OFFSET = 3,
	NL80211_HE_OBSS_PD_ATTR_BSS_COLOR_BITMAP = 4,
	NL80211_HE_OBSS_PD_ATTR_PARTIAL_BSSID_BITMAP = 5,
	NL80211_HE_OBSS_PD_ATTR_SR_CTRL = 6,
	__NL80211_HE_OBSS_PD_ATTR_LAST = 7,
	NL80211_HE_OBSS_PD_ATTR_MAX = 6,
};

enum nl80211_bss_color_attributes {
	__NL80211_HE_BSS_COLOR_ATTR_INVALID = 0,
	NL80211_HE_BSS_COLOR_ATTR_COLOR = 1,
	NL80211_HE_BSS_COLOR_ATTR_DISABLED = 2,
	NL80211_HE_BSS_COLOR_ATTR_PARTIAL = 3,
	__NL80211_HE_BSS_COLOR_ATTR_LAST = 4,
	NL80211_HE_BSS_COLOR_ATTR_MAX = 3,
};

enum nl80211_iftype_akm_attributes {
	__NL80211_IFTYPE_AKM_ATTR_INVALID = 0,
	NL80211_IFTYPE_AKM_ATTR_IFTYPES = 1,
	NL80211_IFTYPE_AKM_ATTR_SUITES = 2,
	__NL80211_IFTYPE_AKM_ATTR_LAST = 3,
	NL80211_IFTYPE_AKM_ATTR_MAX = 2,
};

enum nl80211_fils_discovery_attributes {
	__NL80211_FILS_DISCOVERY_ATTR_INVALID = 0,
	NL80211_FILS_DISCOVERY_ATTR_INT_MIN = 1,
	NL80211_FILS_DISCOVERY_ATTR_INT_MAX = 2,
	NL80211_FILS_DISCOVERY_ATTR_TMPL = 3,
	__NL80211_FILS_DISCOVERY_ATTR_LAST = 4,
	NL80211_FILS_DISCOVERY_ATTR_MAX = 3,
};

enum nl80211_unsol_bcast_probe_resp_attributes {
	__NL80211_UNSOL_BCAST_PROBE_RESP_ATTR_INVALID = 0,
	NL80211_UNSOL_BCAST_PROBE_RESP_ATTR_INT = 1,
	NL80211_UNSOL_BCAST_PROBE_RESP_ATTR_TMPL = 2,
	__NL80211_UNSOL_BCAST_PROBE_RESP_ATTR_LAST = 3,
	NL80211_UNSOL_BCAST_PROBE_RESP_ATTR_MAX = 2,
};

enum survey_info_flags {
	SURVEY_INFO_NOISE_DBM = 1,
	SURVEY_INFO_IN_USE = 2,
	SURVEY_INFO_TIME = 4,
	SURVEY_INFO_TIME_BUSY = 8,
	SURVEY_INFO_TIME_EXT_BUSY = 16,
	SURVEY_INFO_TIME_RX = 32,
	SURVEY_INFO_TIME_TX = 64,
	SURVEY_INFO_TIME_SCAN = 128,
	SURVEY_INFO_TIME_BSS_RX = 256,
};

enum cfg80211_ap_settings_flags {
	AP_SETTINGS_EXTERNAL_AUTH_SUPPORT = 1,
};

enum station_parameters_apply_mask {
	STATION_PARAM_APPLY_UAPSD = 1,
	STATION_PARAM_APPLY_CAPABILITY = 2,
	STATION_PARAM_APPLY_PLINK_STATE = 4,
	STATION_PARAM_APPLY_STA_TXPOWER = 8,
};

enum cfg80211_station_type {
	CFG80211_STA_AP_CLIENT = 0,
	CFG80211_STA_AP_CLIENT_UNASSOC = 1,
	CFG80211_STA_AP_MLME_CLIENT = 2,
	CFG80211_STA_AP_STA = 3,
	CFG80211_STA_IBSS = 4,
	CFG80211_STA_TDLS_PEER_SETUP = 5,
	CFG80211_STA_TDLS_PEER_ACTIVE = 6,
	CFG80211_STA_MESH_PEER_KERNEL = 7,
	CFG80211_STA_MESH_PEER_USER = 8,
};

enum bss_param_flags {
	BSS_PARAM_FLAGS_CTS_PROT = 1,
	BSS_PARAM_FLAGS_SHORT_PREAMBLE = 2,
	BSS_PARAM_FLAGS_SHORT_SLOT_TIME = 4,
};

enum monitor_flags {
	MONITOR_FLAG_CHANGED = 1,
	MONITOR_FLAG_FCSFAIL = 2,
	MONITOR_FLAG_PLCPFAIL = 4,
	MONITOR_FLAG_CONTROL = 8,
	MONITOR_FLAG_OTHER_BSS = 16,
	MONITOR_FLAG_COOK_FRAMES = 32,
	MONITOR_FLAG_ACTIVE = 64,
};

enum mpath_info_flags {
	MPATH_INFO_FRAME_QLEN = 1,
	MPATH_INFO_SN = 2,
	MPATH_INFO_METRIC = 4,
	MPATH_INFO_EXPTIME = 8,
	MPATH_INFO_DISCOVERY_TIMEOUT = 16,
	MPATH_INFO_DISCOVERY_RETRIES = 32,
	MPATH_INFO_FLAGS = 64,
	MPATH_INFO_HOP_COUNT = 128,
	MPATH_INFO_PATH_CHANGE = 256,
};

enum cfg80211_assoc_req_flags {
	ASSOC_REQ_DISABLE_HT = 1,
	ASSOC_REQ_DISABLE_VHT = 2,
	ASSOC_REQ_USE_RRM = 4,
	CONNECT_REQ_EXTERNAL_AUTH_SUPPORT = 8,
};

enum cfg80211_connect_params_changed {
	UPDATE_ASSOC_IES = 1,
	UPDATE_FILS_ERP_INFO = 2,
	UPDATE_AUTH_TYPE = 4,
};

enum wiphy_params_flags {
	WIPHY_PARAM_RETRY_SHORT = 1,
	WIPHY_PARAM_RETRY_LONG = 2,
	WIPHY_PARAM_FRAG_THRESHOLD = 4,
	WIPHY_PARAM_RTS_THRESHOLD = 8,
	WIPHY_PARAM_COVERAGE_CLASS = 16,
	WIPHY_PARAM_DYN_ACK = 32,
	WIPHY_PARAM_TXQ_LIMIT = 64,
	WIPHY_PARAM_TXQ_MEMORY_LIMIT = 128,
	WIPHY_PARAM_TXQ_QUANTUM = 256,
};

struct cfg80211_wowlan_nd_match {
	struct cfg80211_ssid ssid;
	int n_channels;
	u32 channels[0];
};

struct cfg80211_wowlan_nd_info {
	int n_matches;
	struct cfg80211_wowlan_nd_match *matches[0];
};

struct cfg80211_wowlan_wakeup {
	bool disconnect;
	bool magic_pkt;
	bool gtk_rekey_failure;
	bool eap_identity_req;
	bool four_way_handshake;
	bool rfkill_release;
	bool packet_80211;
	bool tcp_match;
	bool tcp_connlost;
	bool tcp_nomoretokens;
	s32 pattern_idx;
	u32 packet_present_len;
	u32 packet_len;
	const void *packet;
	struct cfg80211_wowlan_nd_info *net_detect;
};

enum cfg80211_nan_conf_changes {
	CFG80211_NAN_CONF_CHANGED_PREF = 1,
	CFG80211_NAN_CONF_CHANGED_BANDS = 2,
};

enum wiphy_opmode_flag {
	STA_OPMODE_MAX_BW_CHANGED = 1,
	STA_OPMODE_SMPS_MODE_CHANGED = 2,
	STA_OPMODE_N_SS_CHANGED = 4,
};

struct sta_opmode_info {
	u32 changed;
	enum nl80211_smps_mode smps_mode;
	enum nl80211_chan_width bw;
	u8 rx_nss;
};

struct cfg80211_ft_event_params {
	const u8 *ies;
	size_t ies_len;
	const u8 *target_ap;
	const u8 *ric_ies;
	size_t ric_ies_len;
};

struct cfg80211_nan_match_params {
	enum nl80211_nan_function_type type;
	u8 inst_id;
	u8 peer_inst_id;
	const u8 *addr;
	u8 info_len;
	const u8 *info;
	u64 cookie;
};

enum nl80211_multicast_groups {
	NL80211_MCGRP_CONFIG = 0,
	NL80211_MCGRP_SCAN = 1,
	NL80211_MCGRP_REGULATORY = 2,
	NL80211_MCGRP_MLME = 3,
	NL80211_MCGRP_VENDOR = 4,
	NL80211_MCGRP_NAN = 5,
	NL80211_MCGRP_TESTMODE = 6,
};

struct key_parse {
	struct key_params p;
	int idx;
	int type;
	bool def;
	bool defmgmt;
	bool defbeacon;
	bool def_uni;
	bool def_multi;
};

struct nl80211_dump_wiphy_state {
	s64 filter_wiphy;
	long int start;
	long int split_start;
	long int band_start;
	long int chan_start;
	long int capa_start;
	bool split;
};

struct get_key_cookie {
	struct sk_buff *msg;
	int error;
	int idx;
};

enum ieee80211_category {
	WLAN_CATEGORY_SPECTRUM_MGMT = 0,
	WLAN_CATEGORY_QOS = 1,
	WLAN_CATEGORY_DLS = 2,
	WLAN_CATEGORY_BACK = 3,
	WLAN_CATEGORY_PUBLIC = 4,
	WLAN_CATEGORY_RADIO_MEASUREMENT = 5,
	WLAN_CATEGORY_HT = 7,
	WLAN_CATEGORY_SA_QUERY = 8,
	WLAN_CATEGORY_PROTECTED_DUAL_OF_ACTION = 9,
	WLAN_CATEGORY_WNM = 10,
	WLAN_CATEGORY_WNM_UNPROTECTED = 11,
	WLAN_CATEGORY_TDLS = 12,
	WLAN_CATEGORY_MESH_ACTION = 13,
	WLAN_CATEGORY_MULTIHOP_ACTION = 14,
	WLAN_CATEGORY_SELF_PROTECTED = 15,
	WLAN_CATEGORY_DMG = 16,
	WLAN_CATEGORY_WMM = 17,
	WLAN_CATEGORY_FST = 18,
	WLAN_CATEGORY_UNPROT_DMG = 20,
	WLAN_CATEGORY_VHT = 21,
	WLAN_CATEGORY_VENDOR_SPECIFIC_PROTECTED = 126,
	WLAN_CATEGORY_VENDOR_SPECIFIC = 127,
};

struct cfg80211_mgmt_registration {
	struct list_head list;
	struct wireless_dev *wdev;
	u32 nlportid;
	int match_len;
	__le16 frame_type;
	bool multicast_rx;
	u8 match[0];
};

struct cfg80211_conn {
	struct cfg80211_connect_params params;
	enum {
		CFG80211_CONN_SCANNING = 0,
		CFG80211_CONN_SCAN_AGAIN = 1,
		CFG80211_CONN_AUTHENTICATE_NEXT = 2,
		CFG80211_CONN_AUTHENTICATING = 3,
		CFG80211_CONN_AUTH_FAILED_TIMEOUT = 4,
		CFG80211_CONN_ASSOCIATE_NEXT = 5,
		CFG80211_CONN_ASSOCIATING = 6,
		CFG80211_CONN_ASSOC_FAILED = 7,
		CFG80211_CONN_ASSOC_FAILED_TIMEOUT = 8,
		CFG80211_CONN_DEAUTH = 9,
		CFG80211_CONN_ABANDON = 10,
		CFG80211_CONN_CONNECTED = 11,
	} state;
	u8 bssid[6];
	u8 prev_bssid[6];
	const u8 *ie;
	size_t ie_len;
	bool auto_auth;
	bool prev_bssid_valid;
};

enum cfg80211_chan_mode {
	CHAN_MODE_UNDEFINED = 0,
	CHAN_MODE_SHARED = 1,
	CHAN_MODE_EXCLUSIVE = 2,
};

struct trace_event_raw_rdev_suspend {
	struct trace_entry ent;
	char wiphy_name[32];
	bool any;
	bool disconnect;
	bool magic_pkt;
	bool gtk_rekey_failure;
	bool eap_identity_req;
	bool four_way_handshake;
	bool rfkill_release;
	bool valid_wow;
	char __data[0];
};

struct trace_event_raw_rdev_return_int {
	struct trace_entry ent;
	char wiphy_name[32];
	int ret;
	char __data[0];
};

struct trace_event_raw_rdev_scan {
	struct trace_entry ent;
	char wiphy_name[32];
	char __data[0];
};

struct trace_event_raw_wiphy_only_evt {
	struct trace_entry ent;
	char wiphy_name[32];
	char __data[0];
};

struct trace_event_raw_wiphy_enabled_evt {
	struct trace_entry ent;
	char wiphy_name[32];
	bool enabled;
	char __data[0];
};

struct trace_event_raw_rdev_add_virtual_intf {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 __data_loc_vir_intf_name;
	enum nl80211_iftype type;
	char __data[0];
};

struct trace_event_raw_wiphy_wdev_evt {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 id;
	char __data[0];
};

struct trace_event_raw_wiphy_wdev_cookie_evt {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 id;
	u64 cookie;
	char __data[0];
};

struct trace_event_raw_rdev_change_virtual_intf {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	enum nl80211_iftype type;
	char __data[0];
};

struct trace_event_raw_key_handle {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 mac_addr[6];
	u8 key_index;
	bool pairwise;
	char __data[0];
};

struct trace_event_raw_rdev_add_key {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 mac_addr[6];
	u8 key_index;
	bool pairwise;
	u8 mode;
	char __data[0];
};

struct trace_event_raw_rdev_set_default_key {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 key_index;
	bool unicast;
	bool multicast;
	char __data[0];
};

struct trace_event_raw_rdev_set_default_mgmt_key {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 key_index;
	char __data[0];
};

struct trace_event_raw_rdev_set_default_beacon_key {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 key_index;
	char __data[0];
};

struct trace_event_raw_rdev_start_ap {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	enum nl80211_band band;
	u32 control_freq;
	u32 freq_offset;
	u32 width;
	u32 center_freq1;
	u32 freq1_offset;
	u32 center_freq2;
	int beacon_interval;
	int dtim_period;
	char ssid[33];
	enum nl80211_hidden_ssid hidden_ssid;
	u32 wpa_ver;
	bool privacy;
	enum nl80211_auth_type auth_type;
	int inactivity_timeout;
	char __data[0];
};

struct trace_event_raw_rdev_change_beacon {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u32 __data_loc_head;
	u32 __data_loc_tail;
	u32 __data_loc_beacon_ies;
	u32 __data_loc_proberesp_ies;
	u32 __data_loc_assocresp_ies;
	u32 __data_loc_probe_resp;
	char __data[0];
};

struct trace_event_raw_wiphy_netdev_evt {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	char __data[0];
};

struct trace_event_raw_station_add_change {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 sta_mac[6];
	u32 sta_flags_mask;
	u32 sta_flags_set;
	u32 sta_modify_mask;
	int listen_interval;
	u16 capability;
	u16 aid;
	u8 plink_action;
	u8 plink_state;
	u8 uapsd_queues;
	u8 max_sp;
	u8 opmode_notif;
	bool opmode_notif_used;
	u8 ht_capa[26];
	u8 vht_capa[12];
	char vlan[16];
	u32 __data_loc_supported_rates;
	u32 __data_loc_ext_capab;
	u32 __data_loc_supported_channels;
	u32 __data_loc_supported_oper_classes;
	char __data[0];
};

struct trace_event_raw_wiphy_netdev_mac_evt {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 sta_mac[6];
	char __data[0];
};

struct trace_event_raw_station_del {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 sta_mac[6];
	u8 subtype;
	u16 reason_code;
	char __data[0];
};

struct trace_event_raw_rdev_dump_station {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 sta_mac[6];
	int idx;
	char __data[0];
};

struct trace_event_raw_rdev_return_int_station_info {
	struct trace_entry ent;
	char wiphy_name[32];
	int ret;
	int generation;
	u32 connected_time;
	u32 inactive_time;
	u32 rx_bytes;
	u32 tx_bytes;
	u32 rx_packets;
	u32 tx_packets;
	u32 tx_retries;
	u32 tx_failed;
	u32 rx_dropped_misc;
	u32 beacon_loss_count;
	u16 llid;
	u16 plid;
	u8 plink_state;
	char __data[0];
};

struct trace_event_raw_mpath_evt {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 dst[6];
	u8 next_hop[6];
	char __data[0];
};

struct trace_event_raw_rdev_dump_mpath {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 dst[6];
	u8 next_hop[6];
	int idx;
	char __data[0];
};

struct trace_event_raw_rdev_get_mpp {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 dst[6];
	u8 mpp[6];
	char __data[0];
};

struct trace_event_raw_rdev_dump_mpp {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 dst[6];
	u8 mpp[6];
	int idx;
	char __data[0];
};

struct trace_event_raw_rdev_return_int_mpath_info {
	struct trace_entry ent;
	char wiphy_name[32];
	int ret;
	int generation;
	u32 filled;
	u32 frame_qlen;
	u32 sn;
	u32 metric;
	u32 exptime;
	u32 discovery_timeout;
	u8 discovery_retries;
	u8 flags;
	char __data[0];
};

struct trace_event_raw_rdev_return_int_mesh_config {
	struct trace_entry ent;
	char wiphy_name[32];
	u16 dot11MeshRetryTimeout;
	u16 dot11MeshConfirmTimeout;
	u16 dot11MeshHoldingTimeout;
	u16 dot11MeshMaxPeerLinks;
	u8 dot11MeshMaxRetries;
	u8 dot11MeshTTL;
	u8 element_ttl;
	bool auto_open_plinks;
	u32 dot11MeshNbrOffsetMaxNeighbor;
	u8 dot11MeshHWMPmaxPREQretries;
	u32 path_refresh_time;
	u32 dot11MeshHWMPactivePathTimeout;
	u16 min_discovery_timeout;
	u16 dot11MeshHWMPpreqMinInterval;
	u16 dot11MeshHWMPperrMinInterval;
	u16 dot11MeshHWMPnetDiameterTraversalTime;
	u8 dot11MeshHWMPRootMode;
	u16 dot11MeshHWMPRannInterval;
	bool dot11MeshGateAnnouncementProtocol;
	bool dot11MeshForwarding;
	s32 rssi_threshold;
	u16 ht_opmode;
	u32 dot11MeshHWMPactivePathToRootTimeout;
	u16 dot11MeshHWMProotInterval;
	u16 dot11MeshHWMPconfirmationInterval;
	bool dot11MeshNolearn;
	int ret;
	char __data[0];
};

struct trace_event_raw_rdev_update_mesh_config {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u16 dot11MeshRetryTimeout;
	u16 dot11MeshConfirmTimeout;
	u16 dot11MeshHoldingTimeout;
	u16 dot11MeshMaxPeerLinks;
	u8 dot11MeshMaxRetries;
	u8 dot11MeshTTL;
	u8 element_ttl;
	bool auto_open_plinks;
	u32 dot11MeshNbrOffsetMaxNeighbor;
	u8 dot11MeshHWMPmaxPREQretries;
	u32 path_refresh_time;
	u32 dot11MeshHWMPactivePathTimeout;
	u16 min_discovery_timeout;
	u16 dot11MeshHWMPpreqMinInterval;
	u16 dot11MeshHWMPperrMinInterval;
	u16 dot11MeshHWMPnetDiameterTraversalTime;
	u8 dot11MeshHWMPRootMode;
	u16 dot11MeshHWMPRannInterval;
	bool dot11MeshGateAnnouncementProtocol;
	bool dot11MeshForwarding;
	s32 rssi_threshold;
	u16 ht_opmode;
	u32 dot11MeshHWMPactivePathToRootTimeout;
	u16 dot11MeshHWMProotInterval;
	u16 dot11MeshHWMPconfirmationInterval;
	bool dot11MeshNolearn;
	u32 mask;
	char __data[0];
};

struct trace_event_raw_rdev_join_mesh {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u16 dot11MeshRetryTimeout;
	u16 dot11MeshConfirmTimeout;
	u16 dot11MeshHoldingTimeout;
	u16 dot11MeshMaxPeerLinks;
	u8 dot11MeshMaxRetries;
	u8 dot11MeshTTL;
	u8 element_ttl;
	bool auto_open_plinks;
	u32 dot11MeshNbrOffsetMaxNeighbor;
	u8 dot11MeshHWMPmaxPREQretries;
	u32 path_refresh_time;
	u32 dot11MeshHWMPactivePathTimeout;
	u16 min_discovery_timeout;
	u16 dot11MeshHWMPpreqMinInterval;
	u16 dot11MeshHWMPperrMinInterval;
	u16 dot11MeshHWMPnetDiameterTraversalTime;
	u8 dot11MeshHWMPRootMode;
	u16 dot11MeshHWMPRannInterval;
	bool dot11MeshGateAnnouncementProtocol;
	bool dot11MeshForwarding;
	s32 rssi_threshold;
	u16 ht_opmode;
	u32 dot11MeshHWMPactivePathToRootTimeout;
	u16 dot11MeshHWMProotInterval;
	u16 dot11MeshHWMPconfirmationInterval;
	bool dot11MeshNolearn;
	char __data[0];
};

struct trace_event_raw_rdev_change_bss {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	int use_cts_prot;
	int use_short_preamble;
	int use_short_slot_time;
	int ap_isolate;
	int ht_opmode;
	char __data[0];
};

struct trace_event_raw_rdev_set_txq_params {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	enum nl80211_ac ac;
	u16 txop;
	u16 cwmin;
	u16 cwmax;
	u8 aifs;
	char __data[0];
};

struct trace_event_raw_rdev_libertas_set_mesh_channel {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	enum nl80211_band band;
	u32 center_freq;
	u16 freq_offset;
	char __data[0];
};

struct trace_event_raw_rdev_set_monitor_channel {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_band band;
	u32 control_freq;
	u32 freq_offset;
	u32 width;
	u32 center_freq1;
	u32 freq1_offset;
	u32 center_freq2;
	char __data[0];
};

struct trace_event_raw_rdev_auth {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 bssid[6];
	enum nl80211_auth_type auth_type;
	char __data[0];
};

struct trace_event_raw_rdev_assoc {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 bssid[6];
	u8 prev_bssid[6];
	bool use_mfp;
	u32 flags;
	char __data[0];
};

struct trace_event_raw_rdev_deauth {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 bssid[6];
	u16 reason_code;
	char __data[0];
};

struct trace_event_raw_rdev_disassoc {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 bssid[6];
	u16 reason_code;
	bool local_state_change;
	char __data[0];
};

struct trace_event_raw_rdev_mgmt_tx_cancel_wait {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 id;
	u64 cookie;
	char __data[0];
};

struct trace_event_raw_rdev_set_power_mgmt {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	bool enabled;
	int timeout;
	char __data[0];
};

struct trace_event_raw_rdev_connect {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 bssid[6];
	char ssid[33];
	enum nl80211_auth_type auth_type;
	bool privacy;
	u32 wpa_versions;
	u32 flags;
	u8 prev_bssid[6];
	char __data[0];
};

struct trace_event_raw_rdev_update_connect_params {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u32 changed;
	char __data[0];
};

struct trace_event_raw_rdev_set_cqm_rssi_config {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	s32 rssi_thold;
	u32 rssi_hyst;
	char __data[0];
};

struct trace_event_raw_rdev_set_cqm_rssi_range_config {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	s32 rssi_low;
	s32 rssi_high;
	char __data[0];
};

struct trace_event_raw_rdev_set_cqm_txe_config {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u32 rate;
	u32 pkts;
	u32 intvl;
	char __data[0];
};

struct trace_event_raw_rdev_disconnect {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u16 reason_code;
	char __data[0];
};

struct trace_event_raw_rdev_join_ibss {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 bssid[6];
	char ssid[33];
	char __data[0];
};

struct trace_event_raw_rdev_join_ocb {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	char __data[0];
};

struct trace_event_raw_rdev_set_wiphy_params {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 changed;
	char __data[0];
};

struct trace_event_raw_rdev_set_tx_power {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 id;
	enum nl80211_tx_power_setting type;
	int mbm;
	char __data[0];
};

struct trace_event_raw_rdev_return_int_int {
	struct trace_entry ent;
	char wiphy_name[32];
	int func_ret;
	int func_fill;
	char __data[0];
};

struct trace_event_raw_rdev_set_bitrate_mask {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 peer[6];
	char __data[0];
};

struct trace_event_raw_rdev_update_mgmt_frame_registrations {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 id;
	u16 global_stypes;
	u16 interface_stypes;
	char __data[0];
};

struct trace_event_raw_rdev_return_int_tx_rx {
	struct trace_entry ent;
	char wiphy_name[32];
	int ret;
	u32 tx;
	u32 rx;
	char __data[0];
};

struct trace_event_raw_rdev_return_void_tx_rx {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 tx;
	u32 tx_max;
	u32 rx;
	u32 rx_max;
	char __data[0];
};

struct trace_event_raw_tx_rx_evt {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 tx;
	u32 rx;
	char __data[0];
};

struct trace_event_raw_wiphy_netdev_id_evt {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u64 id;
	char __data[0];
};

struct trace_event_raw_rdev_tdls_mgmt {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 peer[6];
	u8 action_code;
	u8 dialog_token;
	u16 status_code;
	u32 peer_capability;
	bool initiator;
	u32 __data_loc_buf;
	char __data[0];
};

struct trace_event_raw_rdev_dump_survey {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	int idx;
	char __data[0];
};

struct trace_event_raw_rdev_return_int_survey_info {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_band band;
	u32 center_freq;
	u16 freq_offset;
	int ret;
	u64 time;
	u64 time_busy;
	u64 time_ext_busy;
	u64 time_rx;
	u64 time_tx;
	u64 time_scan;
	u32 filled;
	s8 noise;
	char __data[0];
};

struct trace_event_raw_rdev_tdls_oper {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 peer[6];
	enum nl80211_tdls_operation oper;
	char __data[0];
};

struct trace_event_raw_rdev_pmksa {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 bssid[6];
	char __data[0];
};

struct trace_event_raw_rdev_probe_client {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 peer[6];
	char __data[0];
};

struct trace_event_raw_rdev_remain_on_channel {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 id;
	enum nl80211_band band;
	u32 center_freq;
	u16 freq_offset;
	unsigned int duration;
	char __data[0];
};

struct trace_event_raw_rdev_return_int_cookie {
	struct trace_entry ent;
	char wiphy_name[32];
	int ret;
	u64 cookie;
	char __data[0];
};

struct trace_event_raw_rdev_cancel_remain_on_channel {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 id;
	u64 cookie;
	char __data[0];
};

struct trace_event_raw_rdev_mgmt_tx {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 id;
	enum nl80211_band band;
	u32 center_freq;
	u16 freq_offset;
	bool offchan;
	unsigned int wait;
	bool no_cck;
	bool dont_wait_for_ack;
	char __data[0];
};

struct trace_event_raw_rdev_tx_control_port {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 dest[6];
	__be16 proto;
	bool unencrypted;
	char __data[0];
};

struct trace_event_raw_rdev_set_noack_map {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u16 noack_map;
	char __data[0];
};

struct trace_event_raw_rdev_return_chandef {
	struct trace_entry ent;
	char wiphy_name[32];
	int ret;
	enum nl80211_band band;
	u32 control_freq;
	u32 freq_offset;
	u32 width;
	u32 center_freq1;
	u32 freq1_offset;
	u32 center_freq2;
	char __data[0];
};

struct trace_event_raw_rdev_start_nan {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 id;
	u8 master_pref;
	u8 bands;
	char __data[0];
};

struct trace_event_raw_rdev_nan_change_conf {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 id;
	u8 master_pref;
	u8 bands;
	u32 changes;
	char __data[0];
};

struct trace_event_raw_rdev_add_nan_func {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 id;
	u8 func_type;
	u64 cookie;
	char __data[0];
};

struct trace_event_raw_rdev_del_nan_func {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 id;
	u64 cookie;
	char __data[0];
};

struct trace_event_raw_rdev_set_mac_acl {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u32 acl_policy;
	char __data[0];
};

struct trace_event_raw_rdev_update_ft_ies {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u16 md;
	u32 __data_loc_ie;
	char __data[0];
};

struct trace_event_raw_rdev_crit_proto_start {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 id;
	u16 proto;
	u16 duration;
	char __data[0];
};

struct trace_event_raw_rdev_crit_proto_stop {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 id;
	char __data[0];
};

struct trace_event_raw_rdev_channel_switch {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	enum nl80211_band band;
	u32 control_freq;
	u32 freq_offset;
	u32 width;
	u32 center_freq1;
	u32 freq1_offset;
	u32 center_freq2;
	bool radar_required;
	bool block_tx;
	u8 count;
	u32 __data_loc_bcn_ofs;
	u32 __data_loc_pres_ofs;
	char __data[0];
};

struct trace_event_raw_rdev_set_qos_map {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 num_des;
	u8 dscp_exception[42];
	u8 up[16];
	char __data[0];
};

struct trace_event_raw_rdev_set_ap_chanwidth {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	enum nl80211_band band;
	u32 control_freq;
	u32 freq_offset;
	u32 width;
	u32 center_freq1;
	u32 freq1_offset;
	u32 center_freq2;
	char __data[0];
};

struct trace_event_raw_rdev_add_tx_ts {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 peer[6];
	u8 tsid;
	u8 user_prio;
	u16 admitted_time;
	char __data[0];
};

struct trace_event_raw_rdev_del_tx_ts {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 peer[6];
	u8 tsid;
	char __data[0];
};

struct trace_event_raw_rdev_tdls_channel_switch {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 addr[6];
	u8 oper_class;
	enum nl80211_band band;
	u32 control_freq;
	u32 freq_offset;
	u32 width;
	u32 center_freq1;
	u32 freq1_offset;
	u32 center_freq2;
	char __data[0];
};

struct trace_event_raw_rdev_tdls_cancel_channel_switch {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 addr[6];
	char __data[0];
};

struct trace_event_raw_rdev_set_pmk {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 aa[6];
	u8 pmk_len;
	u8 pmk_r0_name_len;
	u32 __data_loc_pmk;
	u32 __data_loc_pmk_r0_name;
	char __data[0];
};

struct trace_event_raw_rdev_del_pmk {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 aa[6];
	char __data[0];
};

struct trace_event_raw_rdev_external_auth {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 bssid[6];
	u8 ssid[33];
	u16 status;
	char __data[0];
};

struct trace_event_raw_rdev_start_radar_detection {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	enum nl80211_band band;
	u32 control_freq;
	u32 freq_offset;
	u32 width;
	u32 center_freq1;
	u32 freq1_offset;
	u32 center_freq2;
	u32 cac_time_ms;
	char __data[0];
};

struct trace_event_raw_rdev_set_mcast_rate {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	int mcast_rate[5];
	char __data[0];
};

struct trace_event_raw_rdev_set_coalesce {
	struct trace_entry ent;
	char wiphy_name[32];
	int n_rules;
	char __data[0];
};

struct trace_event_raw_rdev_set_multicast_to_unicast {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	bool enabled;
	char __data[0];
};

struct trace_event_raw_rdev_get_ftm_responder_stats {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u64 timestamp;
	u32 success_num;
	u32 partial_num;
	u32 failed_num;
	u32 asap_num;
	u32 non_asap_num;
	u64 duration;
	u32 unknown_triggers;
	u32 reschedule;
	u32 out_of_window;
	char __data[0];
};

struct trace_event_raw_cfg80211_return_bool {
	struct trace_entry ent;
	bool ret;
	char __data[0];
};

struct trace_event_raw_cfg80211_netdev_mac_evt {
	struct trace_entry ent;
	char name[16];
	int ifindex;
	u8 macaddr[6];
	char __data[0];
};

struct trace_event_raw_netdev_evt_only {
	struct trace_entry ent;
	char name[16];
	int ifindex;
	char __data[0];
};

struct trace_event_raw_cfg80211_send_rx_assoc {
	struct trace_entry ent;
	char name[16];
	int ifindex;
	u8 bssid[6];
	enum nl80211_band band;
	u32 center_freq;
	u16 freq_offset;
	char __data[0];
};

struct trace_event_raw_netdev_frame_event {
	struct trace_entry ent;
	char name[16];
	int ifindex;
	u32 __data_loc_frame;
	char __data[0];
};

struct trace_event_raw_cfg80211_tx_mlme_mgmt {
	struct trace_entry ent;
	char name[16];
	int ifindex;
	u32 __data_loc_frame;
	char __data[0];
};

struct trace_event_raw_netdev_mac_evt {
	struct trace_entry ent;
	char name[16];
	int ifindex;
	u8 mac[6];
	char __data[0];
};

struct trace_event_raw_cfg80211_michael_mic_failure {
	struct trace_entry ent;
	char name[16];
	int ifindex;
	u8 addr[6];
	enum nl80211_key_type key_type;
	int key_id;
	u8 tsc[6];
	char __data[0];
};

struct trace_event_raw_cfg80211_ready_on_channel {
	struct trace_entry ent;
	u32 id;
	u64 cookie;
	enum nl80211_band band;
	u32 center_freq;
	u16 freq_offset;
	unsigned int duration;
	char __data[0];
};

struct trace_event_raw_cfg80211_ready_on_channel_expired {
	struct trace_entry ent;
	u32 id;
	u64 cookie;
	enum nl80211_band band;
	u32 center_freq;
	u16 freq_offset;
	char __data[0];
};

struct trace_event_raw_cfg80211_tx_mgmt_expired {
	struct trace_entry ent;
	u32 id;
	u64 cookie;
	enum nl80211_band band;
	u32 center_freq;
	u16 freq_offset;
	char __data[0];
};

struct trace_event_raw_cfg80211_new_sta {
	struct trace_entry ent;
	char name[16];
	int ifindex;
	u8 mac_addr[6];
	int generation;
	u32 connected_time;
	u32 inactive_time;
	u32 rx_bytes;
	u32 tx_bytes;
	u32 rx_packets;
	u32 tx_packets;
	u32 tx_retries;
	u32 tx_failed;
	u32 rx_dropped_misc;
	u32 beacon_loss_count;
	u16 llid;
	u16 plid;
	u8 plink_state;
	char __data[0];
};

struct trace_event_raw_cfg80211_rx_mgmt {
	struct trace_entry ent;
	u32 id;
	int freq;
	int sig_dbm;
	char __data[0];
};

struct trace_event_raw_cfg80211_mgmt_tx_status {
	struct trace_entry ent;
	u32 id;
	u64 cookie;
	bool ack;
	char __data[0];
};

struct trace_event_raw_cfg80211_control_port_tx_status {
	struct trace_entry ent;
	u32 id;
	u64 cookie;
	bool ack;
	char __data[0];
};

struct trace_event_raw_cfg80211_rx_control_port {
	struct trace_entry ent;
	char name[16];
	int ifindex;
	int len;
	u8 from[6];
	u16 proto;
	bool unencrypted;
	char __data[0];
};

struct trace_event_raw_cfg80211_cqm_rssi_notify {
	struct trace_entry ent;
	char name[16];
	int ifindex;
	enum nl80211_cqm_rssi_threshold_event rssi_event;
	s32 rssi_level;
	char __data[0];
};

struct trace_event_raw_cfg80211_reg_can_beacon {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_band band;
	u32 control_freq;
	u32 freq_offset;
	u32 width;
	u32 center_freq1;
	u32 freq1_offset;
	u32 center_freq2;
	enum nl80211_iftype iftype;
	bool check_no_ir;
	char __data[0];
};

struct trace_event_raw_cfg80211_chandef_dfs_required {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_band band;
	u32 control_freq;
	u32 freq_offset;
	u32 width;
	u32 center_freq1;
	u32 freq1_offset;
	u32 center_freq2;
	char __data[0];
};

struct trace_event_raw_cfg80211_ch_switch_notify {
	struct trace_entry ent;
	char name[16];
	int ifindex;
	enum nl80211_band band;
	u32 control_freq;
	u32 freq_offset;
	u32 width;
	u32 center_freq1;
	u32 freq1_offset;
	u32 center_freq2;
	char __data[0];
};

struct trace_event_raw_cfg80211_ch_switch_started_notify {
	struct trace_entry ent;
	char name[16];
	int ifindex;
	enum nl80211_band band;
	u32 control_freq;
	u32 freq_offset;
	u32 width;
	u32 center_freq1;
	u32 freq1_offset;
	u32 center_freq2;
	char __data[0];
};

struct trace_event_raw_cfg80211_radar_event {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_band band;
	u32 control_freq;
	u32 freq_offset;
	u32 width;
	u32 center_freq1;
	u32 freq1_offset;
	u32 center_freq2;
	char __data[0];
};

struct trace_event_raw_cfg80211_cac_event {
	struct trace_entry ent;
	char name[16];
	int ifindex;
	enum nl80211_radar_event evt;
	char __data[0];
};

struct trace_event_raw_cfg80211_rx_evt {
	struct trace_entry ent;
	char name[16];
	int ifindex;
	u8 addr[6];
	char __data[0];
};

struct trace_event_raw_cfg80211_ibss_joined {
	struct trace_entry ent;
	char name[16];
	int ifindex;
	u8 bssid[6];
	enum nl80211_band band;
	u32 center_freq;
	u16 freq_offset;
	char __data[0];
};

struct trace_event_raw_cfg80211_probe_status {
	struct trace_entry ent;
	char name[16];
	int ifindex;
	u8 addr[6];
	u64 cookie;
	bool acked;
	char __data[0];
};

struct trace_event_raw_cfg80211_cqm_pktloss_notify {
	struct trace_entry ent;
	char name[16];
	int ifindex;
	u8 peer[6];
	u32 num_packets;
	char __data[0];
};

struct trace_event_raw_cfg80211_pmksa_candidate_notify {
	struct trace_entry ent;
	char name[16];
	int ifindex;
	int index;
	u8 bssid[6];
	bool preauth;
	char __data[0];
};

struct trace_event_raw_cfg80211_report_obss_beacon {
	struct trace_entry ent;
	char wiphy_name[32];
	int freq;
	int sig_dbm;
	char __data[0];
};

struct trace_event_raw_cfg80211_tdls_oper_request {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 peer[6];
	enum nl80211_tdls_operation oper;
	u16 reason_code;
	char __data[0];
};

struct trace_event_raw_cfg80211_scan_done {
	struct trace_entry ent;
	u32 n_channels;
	u32 __data_loc_ie;
	u32 rates[5];
	u32 wdev_id;
	u8 wiphy_mac[6];
	bool no_cck;
	bool aborted;
	u64 scan_start_tsf;
	u8 tsf_bssid[6];
	char __data[0];
};

struct trace_event_raw_wiphy_id_evt {
	struct trace_entry ent;
	char wiphy_name[32];
	u64 id;
	char __data[0];
};

struct trace_event_raw_cfg80211_get_bss {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_band band;
	u32 center_freq;
	u16 freq_offset;
	u8 bssid[6];
	u32 __data_loc_ssid;
	enum ieee80211_bss_type bss_type;
	enum ieee80211_privacy privacy;
	char __data[0];
};

struct trace_event_raw_cfg80211_inform_bss_frame {
	struct trace_entry ent;
	char wiphy_name[32];
	enum nl80211_band band;
	u32 center_freq;
	u16 freq_offset;
	enum nl80211_bss_scan_width scan_width;
	u32 __data_loc_mgmt;
	s32 signal;
	u64 ts_boottime;
	u64 parent_tsf;
	u8 parent_bssid[6];
	char __data[0];
};

struct trace_event_raw_cfg80211_bss_evt {
	struct trace_entry ent;
	u8 bssid[6];
	enum nl80211_band band;
	u32 center_freq;
	u16 freq_offset;
	char __data[0];
};

struct trace_event_raw_cfg80211_return_uint {
	struct trace_entry ent;
	unsigned int ret;
	char __data[0];
};

struct trace_event_raw_cfg80211_return_u32 {
	struct trace_entry ent;
	u32 ret;
	char __data[0];
};

struct trace_event_raw_cfg80211_report_wowlan_wakeup {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 id;
	bool non_wireless;
	bool disconnect;
	bool magic_pkt;
	bool gtk_rekey_failure;
	bool eap_identity_req;
	bool four_way_handshake;
	bool rfkill_release;
	s32 pattern_idx;
	u32 packet_len;
	u32 __data_loc_packet;
	char __data[0];
};

struct trace_event_raw_cfg80211_ft_event {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u32 __data_loc_ies;
	u8 target_ap[6];
	u32 __data_loc_ric_ies;
	char __data[0];
};

struct trace_event_raw_cfg80211_stop_iface {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 id;
	char __data[0];
};

struct trace_event_raw_cfg80211_pmsr_report {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 id;
	u64 cookie;
	u8 addr[6];
	char __data[0];
};

struct trace_event_raw_cfg80211_pmsr_complete {
	struct trace_entry ent;
	char wiphy_name[32];
	u32 id;
	u64 cookie;
	char __data[0];
};

struct trace_event_raw_rdev_update_owe_info {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 peer[6];
	u16 status;
	u32 __data_loc_ie;
	char __data[0];
};

struct trace_event_raw_cfg80211_update_owe_info_event {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 peer[6];
	u32 __data_loc_ie;
	char __data[0];
};

struct trace_event_raw_rdev_probe_mesh_link {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 dest[6];
	char __data[0];
};

struct trace_event_raw_rdev_set_tid_config {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 peer[6];
	char __data[0];
};

struct trace_event_raw_rdev_reset_tid_config {
	struct trace_entry ent;
	char wiphy_name[32];
	char name[16];
	int ifindex;
	u8 peer[6];
	u8 tids;
	char __data[0];
};

struct trace_event_data_offsets_rdev_suspend {};

struct trace_event_data_offsets_rdev_return_int {};

struct trace_event_data_offsets_rdev_scan {};

struct trace_event_data_offsets_wiphy_only_evt {};

struct trace_event_data_offsets_wiphy_enabled_evt {};

struct trace_event_data_offsets_rdev_add_virtual_intf {
	u32 vir_intf_name;
};

struct trace_event_data_offsets_wiphy_wdev_evt {};

struct trace_event_data_offsets_wiphy_wdev_cookie_evt {};

struct trace_event_data_offsets_rdev_change_virtual_intf {};

struct trace_event_data_offsets_key_handle {};

struct trace_event_data_offsets_rdev_add_key {};

struct trace_event_data_offsets_rdev_set_default_key {};

struct trace_event_data_offsets_rdev_set_default_mgmt_key {};

struct trace_event_data_offsets_rdev_set_default_beacon_key {};

struct trace_event_data_offsets_rdev_start_ap {};

struct trace_event_data_offsets_rdev_change_beacon {
	u32 head;
	u32 tail;
	u32 beacon_ies;
	u32 proberesp_ies;
	u32 assocresp_ies;
	u32 probe_resp;
};

struct trace_event_data_offsets_wiphy_netdev_evt {};

struct trace_event_data_offsets_station_add_change {
	u32 supported_rates;
	u32 ext_capab;
	u32 supported_channels;
	u32 supported_oper_classes;
};

struct trace_event_data_offsets_wiphy_netdev_mac_evt {};

struct trace_event_data_offsets_station_del {};

struct trace_event_data_offsets_rdev_dump_station {};

struct trace_event_data_offsets_rdev_return_int_station_info {};

struct trace_event_data_offsets_mpath_evt {};

struct trace_event_data_offsets_rdev_dump_mpath {};

struct trace_event_data_offsets_rdev_get_mpp {};

struct trace_event_data_offsets_rdev_dump_mpp {};

struct trace_event_data_offsets_rdev_return_int_mpath_info {};

struct trace_event_data_offsets_rdev_return_int_mesh_config {};

struct trace_event_data_offsets_rdev_update_mesh_config {};

struct trace_event_data_offsets_rdev_join_mesh {};

struct trace_event_data_offsets_rdev_change_bss {};

struct trace_event_data_offsets_rdev_set_txq_params {};

struct trace_event_data_offsets_rdev_libertas_set_mesh_channel {};

struct trace_event_data_offsets_rdev_set_monitor_channel {};

struct trace_event_data_offsets_rdev_auth {};

struct trace_event_data_offsets_rdev_assoc {};

struct trace_event_data_offsets_rdev_deauth {};

struct trace_event_data_offsets_rdev_disassoc {};

struct trace_event_data_offsets_rdev_mgmt_tx_cancel_wait {};

struct trace_event_data_offsets_rdev_set_power_mgmt {};

struct trace_event_data_offsets_rdev_connect {};

struct trace_event_data_offsets_rdev_update_connect_params {};

struct trace_event_data_offsets_rdev_set_cqm_rssi_config {};

struct trace_event_data_offsets_rdev_set_cqm_rssi_range_config {};

struct trace_event_data_offsets_rdev_set_cqm_txe_config {};

struct trace_event_data_offsets_rdev_disconnect {};

struct trace_event_data_offsets_rdev_join_ibss {};

struct trace_event_data_offsets_rdev_join_ocb {};

struct trace_event_data_offsets_rdev_set_wiphy_params {};

struct trace_event_data_offsets_rdev_set_tx_power {};

struct trace_event_data_offsets_rdev_return_int_int {};

struct trace_event_data_offsets_rdev_set_bitrate_mask {};

struct trace_event_data_offsets_rdev_update_mgmt_frame_registrations {};

struct trace_event_data_offsets_rdev_return_int_tx_rx {};

struct trace_event_data_offsets_rdev_return_void_tx_rx {};

struct trace_event_data_offsets_tx_rx_evt {};

struct trace_event_data_offsets_wiphy_netdev_id_evt {};

struct trace_event_data_offsets_rdev_tdls_mgmt {
	u32 buf;
};

struct trace_event_data_offsets_rdev_dump_survey {};

struct trace_event_data_offsets_rdev_return_int_survey_info {};

struct trace_event_data_offsets_rdev_tdls_oper {};

struct trace_event_data_offsets_rdev_pmksa {};

struct trace_event_data_offsets_rdev_probe_client {};

struct trace_event_data_offsets_rdev_remain_on_channel {};

struct trace_event_data_offsets_rdev_return_int_cookie {};

struct trace_event_data_offsets_rdev_cancel_remain_on_channel {};

struct trace_event_data_offsets_rdev_mgmt_tx {};

struct trace_event_data_offsets_rdev_tx_control_port {};

struct trace_event_data_offsets_rdev_set_noack_map {};

struct trace_event_data_offsets_rdev_return_chandef {};

struct trace_event_data_offsets_rdev_start_nan {};

struct trace_event_data_offsets_rdev_nan_change_conf {};

struct trace_event_data_offsets_rdev_add_nan_func {};

struct trace_event_data_offsets_rdev_del_nan_func {};

struct trace_event_data_offsets_rdev_set_mac_acl {};

struct trace_event_data_offsets_rdev_update_ft_ies {
	u32 ie;
};

struct trace_event_data_offsets_rdev_crit_proto_start {};

struct trace_event_data_offsets_rdev_crit_proto_stop {};

struct trace_event_data_offsets_rdev_channel_switch {
	u32 bcn_ofs;
	u32 pres_ofs;
};

struct trace_event_data_offsets_rdev_set_qos_map {};

struct trace_event_data_offsets_rdev_set_ap_chanwidth {};

struct trace_event_data_offsets_rdev_add_tx_ts {};

struct trace_event_data_offsets_rdev_del_tx_ts {};

struct trace_event_data_offsets_rdev_tdls_channel_switch {};

struct trace_event_data_offsets_rdev_tdls_cancel_channel_switch {};

struct trace_event_data_offsets_rdev_set_pmk {
	u32 pmk;
	u32 pmk_r0_name;
};

struct trace_event_data_offsets_rdev_del_pmk {};

struct trace_event_data_offsets_rdev_external_auth {};

struct trace_event_data_offsets_rdev_start_radar_detection {};

struct trace_event_data_offsets_rdev_set_mcast_rate {};

struct trace_event_data_offsets_rdev_set_coalesce {};

struct trace_event_data_offsets_rdev_set_multicast_to_unicast {};

struct trace_event_data_offsets_rdev_get_ftm_responder_stats {};

struct trace_event_data_offsets_cfg80211_return_bool {};

struct trace_event_data_offsets_cfg80211_netdev_mac_evt {};

struct trace_event_data_offsets_netdev_evt_only {};

struct trace_event_data_offsets_cfg80211_send_rx_assoc {};

struct trace_event_data_offsets_netdev_frame_event {
	u32 frame;
};

struct trace_event_data_offsets_cfg80211_tx_mlme_mgmt {
	u32 frame;
};

struct trace_event_data_offsets_netdev_mac_evt {};

struct trace_event_data_offsets_cfg80211_michael_mic_failure {};

struct trace_event_data_offsets_cfg80211_ready_on_channel {};

struct trace_event_data_offsets_cfg80211_ready_on_channel_expired {};

struct trace_event_data_offsets_cfg80211_tx_mgmt_expired {};

struct trace_event_data_offsets_cfg80211_new_sta {};

struct trace_event_data_offsets_cfg80211_rx_mgmt {};

struct trace_event_data_offsets_cfg80211_mgmt_tx_status {};

struct trace_event_data_offsets_cfg80211_control_port_tx_status {};

struct trace_event_data_offsets_cfg80211_rx_control_port {};

struct trace_event_data_offsets_cfg80211_cqm_rssi_notify {};

struct trace_event_data_offsets_cfg80211_reg_can_beacon {};

struct trace_event_data_offsets_cfg80211_chandef_dfs_required {};

struct trace_event_data_offsets_cfg80211_ch_switch_notify {};

struct trace_event_data_offsets_cfg80211_ch_switch_started_notify {};

struct trace_event_data_offsets_cfg80211_radar_event {};

struct trace_event_data_offsets_cfg80211_cac_event {};

struct trace_event_data_offsets_cfg80211_rx_evt {};

struct trace_event_data_offsets_cfg80211_ibss_joined {};

struct trace_event_data_offsets_cfg80211_probe_status {};

struct trace_event_data_offsets_cfg80211_cqm_pktloss_notify {};

struct trace_event_data_offsets_cfg80211_pmksa_candidate_notify {};

struct trace_event_data_offsets_cfg80211_report_obss_beacon {};

struct trace_event_data_offsets_cfg80211_tdls_oper_request {};

struct trace_event_data_offsets_cfg80211_scan_done {
	u32 ie;
};

struct trace_event_data_offsets_wiphy_id_evt {};

struct trace_event_data_offsets_cfg80211_get_bss {
	u32 ssid;
};

struct trace_event_data_offsets_cfg80211_inform_bss_frame {
	u32 mgmt;
};

struct trace_event_data_offsets_cfg80211_bss_evt {};

struct trace_event_data_offsets_cfg80211_return_uint {};

struct trace_event_data_offsets_cfg80211_return_u32 {};

struct trace_event_data_offsets_cfg80211_report_wowlan_wakeup {
	u32 packet;
};

struct trace_event_data_offsets_cfg80211_ft_event {
	u32 ies;
	u32 ric_ies;
};

struct trace_event_data_offsets_cfg80211_stop_iface {};

struct trace_event_data_offsets_cfg80211_pmsr_report {};

struct trace_event_data_offsets_cfg80211_pmsr_complete {};

struct trace_event_data_offsets_rdev_update_owe_info {
	u32 ie;
};

struct trace_event_data_offsets_cfg80211_update_owe_info_event {
	u32 ie;
};

struct trace_event_data_offsets_rdev_probe_mesh_link {};

struct trace_event_data_offsets_rdev_set_tid_config {};

struct trace_event_data_offsets_rdev_reset_tid_config {};

typedef void (*btf_trace_rdev_suspend)(void *, struct wiphy *, struct cfg80211_wowlan *);

typedef void (*btf_trace_rdev_return_int)(void *, struct wiphy *, int);

typedef void (*btf_trace_rdev_scan)(void *, struct wiphy *, struct cfg80211_scan_request *);

typedef void (*btf_trace_rdev_resume)(void *, struct wiphy *);

typedef void (*btf_trace_rdev_return_void)(void *, struct wiphy *);

typedef void (*btf_trace_rdev_get_antenna)(void *, struct wiphy *);

typedef void (*btf_trace_rdev_rfkill_poll)(void *, struct wiphy *);

typedef void (*btf_trace_rdev_set_wakeup)(void *, struct wiphy *, bool);

typedef void (*btf_trace_rdev_add_virtual_intf)(void *, struct wiphy *, char *, enum nl80211_iftype);

typedef void (*btf_trace_rdev_return_wdev)(void *, struct wiphy *, struct wireless_dev *);

typedef void (*btf_trace_rdev_del_virtual_intf)(void *, struct wiphy *, struct wireless_dev *);

typedef void (*btf_trace_rdev_change_virtual_intf)(void *, struct wiphy *, struct net_device *, enum nl80211_iftype);

typedef void (*btf_trace_rdev_get_key)(void *, struct wiphy *, struct net_device *, u8, bool, const u8 *);

typedef void (*btf_trace_rdev_del_key)(void *, struct wiphy *, struct net_device *, u8, bool, const u8 *);

typedef void (*btf_trace_rdev_add_key)(void *, struct wiphy *, struct net_device *, u8, bool, const u8 *, u8);

typedef void (*btf_trace_rdev_set_default_key)(void *, struct wiphy *, struct net_device *, u8, bool, bool);

typedef void (*btf_trace_rdev_set_default_mgmt_key)(void *, struct wiphy *, struct net_device *, u8);

typedef void (*btf_trace_rdev_set_default_beacon_key)(void *, struct wiphy *, struct net_device *, u8);

typedef void (*btf_trace_rdev_start_ap)(void *, struct wiphy *, struct net_device *, struct cfg80211_ap_settings *);

typedef void (*btf_trace_rdev_change_beacon)(void *, struct wiphy *, struct net_device *, struct cfg80211_beacon_data *);

typedef void (*btf_trace_rdev_stop_ap)(void *, struct wiphy *, struct net_device *);

typedef void (*btf_trace_rdev_set_rekey_data)(void *, struct wiphy *, struct net_device *);

typedef void (*btf_trace_rdev_get_mesh_config)(void *, struct wiphy *, struct net_device *);

typedef void (*btf_trace_rdev_leave_mesh)(void *, struct wiphy *, struct net_device *);

typedef void (*btf_trace_rdev_leave_ibss)(void *, struct wiphy *, struct net_device *);

typedef void (*btf_trace_rdev_leave_ocb)(void *, struct wiphy *, struct net_device *);

typedef void (*btf_trace_rdev_flush_pmksa)(void *, struct wiphy *, struct net_device *);

typedef void (*btf_trace_rdev_end_cac)(void *, struct wiphy *, struct net_device *);

typedef void (*btf_trace_rdev_add_station)(void *, struct wiphy *, struct net_device *, u8 *, struct station_parameters *);

typedef void (*btf_trace_rdev_change_station)(void *, struct wiphy *, struct net_device *, u8 *, struct station_parameters *);

typedef void (*btf_trace_rdev_del_station)(void *, struct wiphy *, struct net_device *, struct station_del_parameters *);

typedef void (*btf_trace_rdev_get_station)(void *, struct wiphy *, struct net_device *, const u8 *);

typedef void (*btf_trace_rdev_del_mpath)(void *, struct wiphy *, struct net_device *, const u8 *);

typedef void (*btf_trace_rdev_set_wds_peer)(void *, struct wiphy *, struct net_device *, const u8 *);

typedef void (*btf_trace_rdev_dump_station)(void *, struct wiphy *, struct net_device *, int, u8 *);

typedef void (*btf_trace_rdev_return_int_station_info)(void *, struct wiphy *, int, struct station_info *);

typedef void (*btf_trace_rdev_add_mpath)(void *, struct wiphy *, struct net_device *, u8 *, u8 *);

typedef void (*btf_trace_rdev_change_mpath)(void *, struct wiphy *, struct net_device *, u8 *, u8 *);

typedef void (*btf_trace_rdev_get_mpath)(void *, struct wiphy *, struct net_device *, u8 *, u8 *);

typedef void (*btf_trace_rdev_dump_mpath)(void *, struct wiphy *, struct net_device *, int, u8 *, u8 *);

typedef void (*btf_trace_rdev_get_mpp)(void *, struct wiphy *, struct net_device *, u8 *, u8 *);

typedef void (*btf_trace_rdev_dump_mpp)(void *, struct wiphy *, struct net_device *, int, u8 *, u8 *);

typedef void (*btf_trace_rdev_return_int_mpath_info)(void *, struct wiphy *, int, struct mpath_info *);

typedef void (*btf_trace_rdev_return_int_mesh_config)(void *, struct wiphy *, int, struct mesh_config *);

typedef void (*btf_trace_rdev_update_mesh_config)(void *, struct wiphy *, struct net_device *, u32, const struct mesh_config *);

typedef void (*btf_trace_rdev_join_mesh)(void *, struct wiphy *, struct net_device *, const struct mesh_config *, const struct mesh_setup *);

typedef void (*btf_trace_rdev_change_bss)(void *, struct wiphy *, struct net_device *, struct bss_parameters *);

typedef void (*btf_trace_rdev_set_txq_params)(void *, struct wiphy *, struct net_device *, struct ieee80211_txq_params *);

typedef void (*btf_trace_rdev_libertas_set_mesh_channel)(void *, struct wiphy *, struct net_device *, struct ieee80211_channel *);

typedef void (*btf_trace_rdev_set_monitor_channel)(void *, struct wiphy *, struct cfg80211_chan_def *);

typedef void (*btf_trace_rdev_auth)(void *, struct wiphy *, struct net_device *, struct cfg80211_auth_request *);

typedef void (*btf_trace_rdev_assoc)(void *, struct wiphy *, struct net_device *, struct cfg80211_assoc_request *);

typedef void (*btf_trace_rdev_deauth)(void *, struct wiphy *, struct net_device *, struct cfg80211_deauth_request *);

typedef void (*btf_trace_rdev_disassoc)(void *, struct wiphy *, struct net_device *, struct cfg80211_disassoc_request *);

typedef void (*btf_trace_rdev_mgmt_tx_cancel_wait)(void *, struct wiphy *, struct wireless_dev *, u64);

typedef void (*btf_trace_rdev_set_power_mgmt)(void *, struct wiphy *, struct net_device *, bool, int);

typedef void (*btf_trace_rdev_connect)(void *, struct wiphy *, struct net_device *, struct cfg80211_connect_params *);

typedef void (*btf_trace_rdev_update_connect_params)(void *, struct wiphy *, struct net_device *, struct cfg80211_connect_params *, u32);

typedef void (*btf_trace_rdev_set_cqm_rssi_config)(void *, struct wiphy *, struct net_device *, s32, u32);

typedef void (*btf_trace_rdev_set_cqm_rssi_range_config)(void *, struct wiphy *, struct net_device *, s32, s32);

typedef void (*btf_trace_rdev_set_cqm_txe_config)(void *, struct wiphy *, struct net_device *, u32, u32, u32);

typedef void (*btf_trace_rdev_disconnect)(void *, struct wiphy *, struct net_device *, u16);

typedef void (*btf_trace_rdev_join_ibss)(void *, struct wiphy *, struct net_device *, struct cfg80211_ibss_params *);

typedef void (*btf_trace_rdev_join_ocb)(void *, struct wiphy *, struct net_device *, const struct ocb_setup *);

typedef void (*btf_trace_rdev_set_wiphy_params)(void *, struct wiphy *, u32);

typedef void (*btf_trace_rdev_get_tx_power)(void *, struct wiphy *, struct wireless_dev *);

typedef void (*btf_trace_rdev_set_tx_power)(void *, struct wiphy *, struct wireless_dev *, enum nl80211_tx_power_setting, int);

typedef void (*btf_trace_rdev_return_int_int)(void *, struct wiphy *, int, int);

typedef void (*btf_trace_rdev_set_bitrate_mask)(void *, struct wiphy *, struct net_device *, const u8 *, const struct cfg80211_bitrate_mask *);

typedef void (*btf_trace_rdev_update_mgmt_frame_registrations)(void *, struct wiphy *, struct wireless_dev *, struct mgmt_frame_regs *);

typedef void (*btf_trace_rdev_return_int_tx_rx)(void *, struct wiphy *, int, u32, u32);

typedef void (*btf_trace_rdev_return_void_tx_rx)(void *, struct wiphy *, u32, u32, u32, u32);

typedef void (*btf_trace_rdev_set_antenna)(void *, struct wiphy *, u32, u32);

typedef void (*btf_trace_rdev_sched_scan_start)(void *, struct wiphy *, struct net_device *, u64);

typedef void (*btf_trace_rdev_sched_scan_stop)(void *, struct wiphy *, struct net_device *, u64);

typedef void (*btf_trace_rdev_tdls_mgmt)(void *, struct wiphy *, struct net_device *, u8 *, u8, u8, u16, u32, bool, const u8 *, size_t);

typedef void (*btf_trace_rdev_dump_survey)(void *, struct wiphy *, struct net_device *, int);

typedef void (*btf_trace_rdev_return_int_survey_info)(void *, struct wiphy *, int, struct survey_info *);

typedef void (*btf_trace_rdev_tdls_oper)(void *, struct wiphy *, struct net_device *, u8 *, enum nl80211_tdls_operation);

typedef void (*btf_trace_rdev_probe_client)(void *, struct wiphy *, struct net_device *, const u8 *);

typedef void (*btf_trace_rdev_set_pmksa)(void *, struct wiphy *, struct net_device *, struct cfg80211_pmksa *);

typedef void (*btf_trace_rdev_del_pmksa)(void *, struct wiphy *, struct net_device *, struct cfg80211_pmksa *);

typedef void (*btf_trace_rdev_remain_on_channel)(void *, struct wiphy *, struct wireless_dev *, struct ieee80211_channel *, unsigned int);

typedef void (*btf_trace_rdev_return_int_cookie)(void *, struct wiphy *, int, u64);

typedef void (*btf_trace_rdev_cancel_remain_on_channel)(void *, struct wiphy *, struct wireless_dev *, u64);

typedef void (*btf_trace_rdev_mgmt_tx)(void *, struct wiphy *, struct wireless_dev *, struct cfg80211_mgmt_tx_params *);

typedef void (*btf_trace_rdev_tx_control_port)(void *, struct wiphy *, struct net_device *, const u8 *, size_t, const u8 *, __be16, bool);

typedef void (*btf_trace_rdev_set_noack_map)(void *, struct wiphy *, struct net_device *, u16);

typedef void (*btf_trace_rdev_get_channel)(void *, struct wiphy *, struct wireless_dev *);

typedef void (*btf_trace_rdev_return_chandef)(void *, struct wiphy *, int, struct cfg80211_chan_def *);

typedef void (*btf_trace_rdev_start_p2p_device)(void *, struct wiphy *, struct wireless_dev *);

typedef void (*btf_trace_rdev_stop_p2p_device)(void *, struct wiphy *, struct wireless_dev *);

typedef void (*btf_trace_rdev_start_nan)(void *, struct wiphy *, struct wireless_dev *, struct cfg80211_nan_conf *);

typedef void (*btf_trace_rdev_nan_change_conf)(void *, struct wiphy *, struct wireless_dev *, struct cfg80211_nan_conf *, u32);

typedef void (*btf_trace_rdev_stop_nan)(void *, struct wiphy *, struct wireless_dev *);

typedef void (*btf_trace_rdev_add_nan_func)(void *, struct wiphy *, struct wireless_dev *, const struct cfg80211_nan_func *);

typedef void (*btf_trace_rdev_del_nan_func)(void *, struct wiphy *, struct wireless_dev *, u64);

typedef void (*btf_trace_rdev_set_mac_acl)(void *, struct wiphy *, struct net_device *, struct cfg80211_acl_data *);

typedef void (*btf_trace_rdev_update_ft_ies)(void *, struct wiphy *, struct net_device *, struct cfg80211_update_ft_ies_params *);

typedef void (*btf_trace_rdev_crit_proto_start)(void *, struct wiphy *, struct wireless_dev *, enum nl80211_crit_proto_id, u16);

typedef void (*btf_trace_rdev_crit_proto_stop)(void *, struct wiphy *, struct wireless_dev *);

typedef void (*btf_trace_rdev_channel_switch)(void *, struct wiphy *, struct net_device *, struct cfg80211_csa_settings *);

typedef void (*btf_trace_rdev_set_qos_map)(void *, struct wiphy *, struct net_device *, struct cfg80211_qos_map *);

typedef void (*btf_trace_rdev_set_ap_chanwidth)(void *, struct wiphy *, struct net_device *, struct cfg80211_chan_def *);

typedef void (*btf_trace_rdev_add_tx_ts)(void *, struct wiphy *, struct net_device *, u8, const u8 *, u8, u16);

typedef void (*btf_trace_rdev_del_tx_ts)(void *, struct wiphy *, struct net_device *, u8, const u8 *);

typedef void (*btf_trace_rdev_tdls_channel_switch)(void *, struct wiphy *, struct net_device *, const u8 *, u8, struct cfg80211_chan_def *);

typedef void (*btf_trace_rdev_tdls_cancel_channel_switch)(void *, struct wiphy *, struct net_device *, const u8 *);

typedef void (*btf_trace_rdev_set_pmk)(void *, struct wiphy *, struct net_device *, struct cfg80211_pmk_conf *);

typedef void (*btf_trace_rdev_del_pmk)(void *, struct wiphy *, struct net_device *, const u8 *);

typedef void (*btf_trace_rdev_external_auth)(void *, struct wiphy *, struct net_device *, struct cfg80211_external_auth_params *);

typedef void (*btf_trace_rdev_start_radar_detection)(void *, struct wiphy *, struct net_device *, struct cfg80211_chan_def *, u32);

typedef void (*btf_trace_rdev_set_mcast_rate)(void *, struct wiphy *, struct net_device *, int *);

typedef void (*btf_trace_rdev_set_coalesce)(void *, struct wiphy *, struct cfg80211_coalesce *);

typedef void (*btf_trace_rdev_abort_scan)(void *, struct wiphy *, struct wireless_dev *);

typedef void (*btf_trace_rdev_set_multicast_to_unicast)(void *, struct wiphy *, struct net_device *, const bool);

typedef void (*btf_trace_rdev_get_txq_stats)(void *, struct wiphy *, struct wireless_dev *);

typedef void (*btf_trace_rdev_get_ftm_responder_stats)(void *, struct wiphy *, struct net_device *, struct cfg80211_ftm_responder_stats *);

typedef void (*btf_trace_rdev_start_pmsr)(void *, struct wiphy *, struct wireless_dev *, u64);

typedef void (*btf_trace_rdev_abort_pmsr)(void *, struct wiphy *, struct wireless_dev *, u64);

typedef void (*btf_trace_cfg80211_return_bool)(void *, bool);

typedef void (*btf_trace_cfg80211_notify_new_peer_candidate)(void *, struct net_device *, const u8 *);

typedef void (*btf_trace_cfg80211_send_rx_auth)(void *, struct net_device *);

typedef void (*btf_trace_cfg80211_send_rx_assoc)(void *, struct net_device *, struct cfg80211_bss *);

typedef void (*btf_trace_cfg80211_rx_unprot_mlme_mgmt)(void *, struct net_device *, const u8 *, int);

typedef void (*btf_trace_cfg80211_rx_mlme_mgmt)(void *, struct net_device *, const u8 *, int);

typedef void (*btf_trace_cfg80211_tx_mlme_mgmt)(void *, struct net_device *, const u8 *, int);

typedef void (*btf_trace_cfg80211_send_auth_timeout)(void *, struct net_device *, const u8 *);

typedef void (*btf_trace_cfg80211_send_assoc_timeout)(void *, struct net_device *, const u8 *);

typedef void (*btf_trace_cfg80211_michael_mic_failure)(void *, struct net_device *, const u8 *, enum nl80211_key_type, int, const u8 *);

typedef void (*btf_trace_cfg80211_ready_on_channel)(void *, struct wireless_dev *, u64, struct ieee80211_channel *, unsigned int);

typedef void (*btf_trace_cfg80211_ready_on_channel_expired)(void *, struct wireless_dev *, u64, struct ieee80211_channel *);

typedef void (*btf_trace_cfg80211_tx_mgmt_expired)(void *, struct wireless_dev *, u64, struct ieee80211_channel *);

typedef void (*btf_trace_cfg80211_new_sta)(void *, struct net_device *, const u8 *, struct station_info *);

typedef void (*btf_trace_cfg80211_del_sta)(void *, struct net_device *, const u8 *);

typedef void (*btf_trace_cfg80211_rx_mgmt)(void *, struct wireless_dev *, int, int);

typedef void (*btf_trace_cfg80211_mgmt_tx_status)(void *, struct wireless_dev *, u64, bool);

typedef void (*btf_trace_cfg80211_control_port_tx_status)(void *, struct wireless_dev *, u64, bool);

typedef void (*btf_trace_cfg80211_rx_control_port)(void *, struct net_device *, struct sk_buff *, bool);

typedef void (*btf_trace_cfg80211_cqm_rssi_notify)(void *, struct net_device *, enum nl80211_cqm_rssi_threshold_event, s32);

typedef void (*btf_trace_cfg80211_reg_can_beacon)(void *, struct wiphy *, struct cfg80211_chan_def *, enum nl80211_iftype, bool);

typedef void (*btf_trace_cfg80211_chandef_dfs_required)(void *, struct wiphy *, struct cfg80211_chan_def *);

typedef void (*btf_trace_cfg80211_ch_switch_notify)(void *, struct net_device *, struct cfg80211_chan_def *);

typedef void (*btf_trace_cfg80211_ch_switch_started_notify)(void *, struct net_device *, struct cfg80211_chan_def *);

typedef void (*btf_trace_cfg80211_radar_event)(void *, struct wiphy *, struct cfg80211_chan_def *);

typedef void (*btf_trace_cfg80211_cac_event)(void *, struct net_device *, enum nl80211_radar_event);

typedef void (*btf_trace_cfg80211_rx_spurious_frame)(void *, struct net_device *, const u8 *);

typedef void (*btf_trace_cfg80211_rx_unexpected_4addr_frame)(void *, struct net_device *, const u8 *);

typedef void (*btf_trace_cfg80211_ibss_joined)(void *, struct net_device *, const u8 *, struct ieee80211_channel *);

typedef void (*btf_trace_cfg80211_probe_status)(void *, struct net_device *, const u8 *, u64, bool);

typedef void (*btf_trace_cfg80211_cqm_pktloss_notify)(void *, struct net_device *, const u8 *, u32);

typedef void (*btf_trace_cfg80211_gtk_rekey_notify)(void *, struct net_device *, const u8 *);

typedef void (*btf_trace_cfg80211_pmksa_candidate_notify)(void *, struct net_device *, int, const u8 *, bool);

typedef void (*btf_trace_cfg80211_report_obss_beacon)(void *, struct wiphy *, const u8 *, size_t, int, int);

typedef void (*btf_trace_cfg80211_tdls_oper_request)(void *, struct wiphy *, struct net_device *, const u8 *, enum nl80211_tdls_operation, u16);

typedef void (*btf_trace_cfg80211_scan_done)(void *, struct cfg80211_scan_request *, struct cfg80211_scan_info *);

typedef void (*btf_trace_cfg80211_sched_scan_stopped)(void *, struct wiphy *, u64);

typedef void (*btf_trace_cfg80211_sched_scan_results)(void *, struct wiphy *, u64);

typedef void (*btf_trace_cfg80211_get_bss)(void *, struct wiphy *, struct ieee80211_channel *, const u8 *, const u8 *, size_t, enum ieee80211_bss_type, enum ieee80211_privacy);

typedef void (*btf_trace_cfg80211_inform_bss_frame)(void *, struct wiphy *, struct cfg80211_inform_bss *, struct ieee80211_mgmt *, size_t);

typedef void (*btf_trace_cfg80211_return_bss)(void *, struct cfg80211_bss *);

typedef void (*btf_trace_cfg80211_return_uint)(void *, unsigned int);

typedef void (*btf_trace_cfg80211_return_u32)(void *, u32);

typedef void (*btf_trace_cfg80211_report_wowlan_wakeup)(void *, struct wiphy *, struct wireless_dev *, struct cfg80211_wowlan_wakeup *);

typedef void (*btf_trace_cfg80211_ft_event)(void *, struct wiphy *, struct net_device *, struct cfg80211_ft_event_params *);

typedef void (*btf_trace_cfg80211_stop_iface)(void *, struct wiphy *, struct wireless_dev *);

typedef void (*btf_trace_cfg80211_pmsr_report)(void *, struct wiphy *, struct wireless_dev *, u64, const u8 *);

typedef void (*btf_trace_cfg80211_pmsr_complete)(void *, struct wiphy *, struct wireless_dev *, u64);

typedef void (*btf_trace_rdev_update_owe_info)(void *, struct wiphy *, struct net_device *, struct cfg80211_update_owe_info *);

typedef void (*btf_trace_cfg80211_update_owe_info_event)(void *, struct wiphy *, struct net_device *, struct cfg80211_update_owe_info *);

typedef void (*btf_trace_rdev_probe_mesh_link)(void *, struct wiphy *, struct net_device *, const u8 *, const u8 *, size_t);

typedef void (*btf_trace_rdev_set_tid_config)(void *, struct wiphy *, struct net_device *, struct cfg80211_tid_config *);

typedef void (*btf_trace_rdev_reset_tid_config)(void *, struct wiphy *, struct net_device *, const u8 *, u8);

enum nl80211_peer_measurement_status {
	NL80211_PMSR_STATUS_SUCCESS = 0,
	NL80211_PMSR_STATUS_REFUSED = 1,
	NL80211_PMSR_STATUS_TIMEOUT = 2,
	NL80211_PMSR_STATUS_FAILURE = 3,
};

enum nl80211_peer_measurement_resp {
	__NL80211_PMSR_RESP_ATTR_INVALID = 0,
	NL80211_PMSR_RESP_ATTR_DATA = 1,
	NL80211_PMSR_RESP_ATTR_STATUS = 2,
	NL80211_PMSR_RESP_ATTR_HOST_TIME = 3,
	NL80211_PMSR_RESP_ATTR_AP_TSF = 4,
	NL80211_PMSR_RESP_ATTR_FINAL = 5,
	NL80211_PMSR_RESP_ATTR_PAD = 6,
	NUM_NL80211_PMSR_RESP_ATTRS = 7,
	NL80211_PMSR_RESP_ATTR_MAX = 6,
};

enum nl80211_peer_measurement_ftm_failure_reasons {
	NL80211_PMSR_FTM_FAILURE_UNSPECIFIED = 0,
	NL80211_PMSR_FTM_FAILURE_NO_RESPONSE = 1,
	NL80211_PMSR_FTM_FAILURE_REJECTED = 2,
	NL80211_PMSR_FTM_FAILURE_WRONG_CHANNEL = 3,
	NL80211_PMSR_FTM_FAILURE_PEER_NOT_CAPABLE = 4,
	NL80211_PMSR_FTM_FAILURE_INVALID_TIMESTAMP = 5,
	NL80211_PMSR_FTM_FAILURE_PEER_BUSY = 6,
	NL80211_PMSR_FTM_FAILURE_BAD_CHANGED_PARAMS = 7,
};

enum nl80211_peer_measurement_ftm_resp {
	__NL80211_PMSR_FTM_RESP_ATTR_INVALID = 0,
	NL80211_PMSR_FTM_RESP_ATTR_FAIL_REASON = 1,
	NL80211_PMSR_FTM_RESP_ATTR_BURST_INDEX = 2,
	NL80211_PMSR_FTM_RESP_ATTR_NUM_FTMR_ATTEMPTS = 3,
	NL80211_PMSR_FTM_RESP_ATTR_NUM_FTMR_SUCCESSES = 4,
	NL80211_PMSR_FTM_RESP_ATTR_BUSY_RETRY_TIME = 5,
	NL80211_PMSR_FTM_RESP_ATTR_NUM_BURSTS_EXP = 6,
	NL80211_PMSR_FTM_RESP_ATTR_BURST_DURATION = 7,
	NL80211_PMSR_FTM_RESP_ATTR_FTMS_PER_BURST = 8,
	NL80211_PMSR_FTM_RESP_ATTR_RSSI_AVG = 9,
	NL80211_PMSR_FTM_RESP_ATTR_RSSI_SPREAD = 10,
	NL80211_PMSR_FTM_RESP_ATTR_TX_RATE = 11,
	NL80211_PMSR_FTM_RESP_ATTR_RX_RATE = 12,
	NL80211_PMSR_FTM_RESP_ATTR_RTT_AVG = 13,
	NL80211_PMSR_FTM_RESP_ATTR_RTT_VARIANCE = 14,
	NL80211_PMSR_FTM_RESP_ATTR_RTT_SPREAD = 15,
	NL80211_PMSR_FTM_RESP_ATTR_DIST_AVG = 16,
	NL80211_PMSR_FTM_RESP_ATTR_DIST_VARIANCE = 17,
	NL80211_PMSR_FTM_RESP_ATTR_DIST_SPREAD = 18,
	NL80211_PMSR_FTM_RESP_ATTR_LCI = 19,
	NL80211_PMSR_FTM_RESP_ATTR_CIVICLOC = 20,
	NL80211_PMSR_FTM_RESP_ATTR_PAD = 21,
	NUM_NL80211_PMSR_FTM_RESP_ATTR = 22,
	NL80211_PMSR_FTM_RESP_ATTR_MAX = 21,
};

struct cfg80211_pmsr_ftm_result {
	const u8 *lci;
	const u8 *civicloc;
	unsigned int lci_len;
	unsigned int civicloc_len;
	enum nl80211_peer_measurement_ftm_failure_reasons failure_reason;
	u32 num_ftmr_attempts;
	u32 num_ftmr_successes;
	s16 burst_index;
	u8 busy_retry_time;
	u8 num_bursts_exp;
	u8 burst_duration;
	u8 ftms_per_burst;
	s32 rssi_avg;
	s32 rssi_spread;
	struct rate_info tx_rate;
	struct rate_info rx_rate;
	s64 rtt_avg;
	s64 rtt_variance;
	s64 rtt_spread;
	s64 dist_avg;
	s64 dist_variance;
	s64 dist_spread;
	u16 num_ftmr_attempts_valid: 1;
	u16 num_ftmr_successes_valid: 1;
	u16 rssi_avg_valid: 1;
	u16 rssi_spread_valid: 1;
	u16 tx_rate_valid: 1;
	u16 rx_rate_valid: 1;
	u16 rtt_avg_valid: 1;
	u16 rtt_variance_valid: 1;
	u16 rtt_spread_valid: 1;
	u16 dist_avg_valid: 1;
	u16 dist_variance_valid: 1;
	u16 dist_spread_valid: 1;
};

struct cfg80211_pmsr_result {
	u64 host_time;
	u64 ap_tsf;
	enum nl80211_peer_measurement_status status;
	u8 addr[6];
	u8 final: 1;
	u8 ap_tsf_valid: 1;
	enum nl80211_peer_measurement_type type;
	union {
		struct cfg80211_pmsr_ftm_result ftm;
	};
};

enum rfkill_operation {
	RFKILL_OP_ADD = 0,
	RFKILL_OP_DEL = 1,
	RFKILL_OP_CHANGE = 2,
	RFKILL_OP_CHANGE_ALL = 3,
};

struct rfkill_event {
	__u32 idx;
	__u8 type;
	__u8 op;
	__u8 soft;
	__u8 hard;
};

enum rfkill_user_states {
	RFKILL_USER_STATE_SOFT_BLOCKED = 0,
	RFKILL_USER_STATE_UNBLOCKED = 1,
	RFKILL_USER_STATE_HARD_BLOCKED = 2,
};

struct rfkill {
	spinlock_t lock;
	enum rfkill_type type;
	long unsigned int state;
	u32 idx;
	bool registered;
	bool persistent;
	bool polling_paused;
	bool suspended;
	const struct rfkill_ops *ops;
	void *data;
	struct device dev;
	struct list_head node;
	struct delayed_work poll_work;
	struct work_struct uevent_work;
	struct work_struct sync_work;
	char name[0];
};

struct rfkill_int_event {
	struct list_head list;
	struct rfkill_event ev;
};

struct rfkill_data {
	struct list_head list;
	struct list_head events;
	struct mutex mtx;
	wait_queue_head_t read_wait;
	bool input_handler;
};

struct rksdmmc_iomux {
	char *name;
	int fgpio;
	int fmux;
};

struct rksdmmc_gpio {
	int io;
	char name[64];
	int enable;
	struct rksdmmc_iomux iomux;
};

struct rksdmmc_pmu {
	bool power_ctrl_by_pmu;
	char pmu_regulator[20];
	int enable;
};

struct rksdmmc_gpio_wifi_moudle {
	int sdio_vol;
	bool vref_ctrl_enble;
	bool wifi_power_remain;
	struct rksdmmc_pmu mregulator;
	struct rksdmmc_pmu ioregulator;
	struct rksdmmc_gpio vbat_n;
	struct rksdmmc_gpio power_n;
	struct rksdmmc_gpio reset_n;
	struct rksdmmc_gpio vddio;
	struct rksdmmc_gpio bgf_int_b;
	struct rksdmmc_gpio wifi_int_b;
	struct rksdmmc_gpio gps_sync;
	struct rksdmmc_gpio ANTSEL2;
	struct rksdmmc_gpio ANTSEL3;
	struct rksdmmc_gpio GPS_LAN;
	struct regmap *grf;
	struct clk *ext_clk;
};

enum {
	WIFI_RK901 = 0,
	WIFI_RK903 = 1,
	WIFI_AP6181 = 2,
	WIFI_AP6210 = 3,
	WIFI_AP6212 = 4,
	WIFI_AP6234 = 5,
	WIFI_AP6255 = 6,
	WIFI_AP6256 = 7,
	WIFI_AP6330 = 8,
	WIFI_AP6335 = 9,
	WIFI_AP6354 = 10,
	WIFI_AP6441 = 11,
	WIFI_AP6476 = 12,
	WIFI_AP6493 = 13,
	WIFI_AP6XXX_SERIES = 14,
	WIFI_RTL8188EU = 15,
	WIFI_RTL8192DU = 16,
	WIFI_RTL8723AS = 17,
	WIFI_RTL8723BS = 18,
	WIFI_RTL8723BS_VQ0 = 19,
	WIFI_RTL8723CS = 20,
	WIFI_RTL8723DS = 21,
	WIFI_RTL8723BU = 22,
	WIFI_RTL8723AU = 23,
	WIFI_RTL8189ES = 24,
	WIFI_RTL8189FS = 25,
	WIFI_RTL8812AU = 26,
	WIFI_RTL_SERIES = 27,
	WIFI_ESP8089 = 28,
	WIFI_MVL88W8977 = 29,
	WIFI_SSV6051 = 30,
	TYPE_MAX = 31,
};

struct rfkill_wlan_data {
	struct rksdmmc_gpio_wifi_moudle *pdata;
};

struct cntry_locales_custom {
	char iso_abbrev[4];
	char custom_locale[4];
	int custom_locale_rev;
};

struct rfkill_rk_gpio {
	int io;
	char name[64];
	int enable;
	struct pinctrl_state *gpio_state;
	struct pinctrl_state *default_state;
};

struct rfkill_rk_irq {
	char name[64];
	struct rfkill_rk_gpio gpio;
	int irq;
};

struct rfkill_rk_platform_data {
	char *name;
	enum rfkill_type type;
	bool power_toggle;
	struct pinctrl *pinctrl;
	struct rfkill_rk_gpio poweron_gpio;
	struct rfkill_rk_gpio reset_gpio;
	struct rfkill_rk_gpio wake_gpio;
	struct rfkill_rk_irq wake_host_irq;
	struct rfkill_rk_gpio rts_gpio;
	struct clk *ext_clk;
};

struct rfkill_rk_data {
	struct rfkill_rk_platform_data *pdata;
	struct platform_device *pdev;
	struct rfkill *rfkill_dev;
	struct delayed_work bt_sleep_delay_work;
};

enum p9_msg_t {
	P9_TLERROR = 6,
	P9_RLERROR = 7,
	P9_TSTATFS = 8,
	P9_RSTATFS = 9,
	P9_TLOPEN = 12,
	P9_RLOPEN = 13,
	P9_TLCREATE = 14,
	P9_RLCREATE = 15,
	P9_TSYMLINK = 16,
	P9_RSYMLINK = 17,
	P9_TMKNOD = 18,
	P9_RMKNOD = 19,
	P9_TRENAME = 20,
	P9_RRENAME = 21,
	P9_TREADLINK = 22,
	P9_RREADLINK = 23,
	P9_TGETATTR = 24,
	P9_RGETATTR = 25,
	P9_TSETATTR = 26,
	P9_RSETATTR = 27,
	P9_TXATTRWALK = 30,
	P9_RXATTRWALK = 31,
	P9_TXATTRCREATE = 32,
	P9_RXATTRCREATE = 33,
	P9_TREADDIR = 40,
	P9_RREADDIR = 41,
	P9_TFSYNC = 50,
	P9_RFSYNC = 51,
	P9_TLOCK = 52,
	P9_RLOCK = 53,
	P9_TGETLOCK = 54,
	P9_RGETLOCK = 55,
	P9_TLINK = 70,
	P9_RLINK = 71,
	P9_TMKDIR = 72,
	P9_RMKDIR = 73,
	P9_TRENAMEAT = 74,
	P9_RRENAMEAT = 75,
	P9_TUNLINKAT = 76,
	P9_RUNLINKAT = 77,
	P9_TVERSION = 100,
	P9_RVERSION = 101,
	P9_TAUTH = 102,
	P9_RAUTH = 103,
	P9_TATTACH = 104,
	P9_RATTACH = 105,
	P9_TERROR = 106,
	P9_RERROR = 107,
	P9_TFLUSH = 108,
	P9_RFLUSH = 109,
	P9_TWALK = 110,
	P9_RWALK = 111,
	P9_TOPEN = 112,
	P9_ROPEN = 113,
	P9_TCREATE = 114,
	P9_RCREATE = 115,
	P9_TREAD = 116,
	P9_RREAD = 117,
	P9_TWRITE = 118,
	P9_RWRITE = 119,
	P9_TCLUNK = 120,
	P9_RCLUNK = 121,
	P9_TREMOVE = 122,
	P9_RREMOVE = 123,
	P9_TSTAT = 124,
	P9_RSTAT = 125,
	P9_TWSTAT = 126,
	P9_RWSTAT = 127,
};

enum p9_proto_versions {
	p9_proto_legacy = 0,
	p9_proto_2000u = 1,
	p9_proto_2000L = 2,
};

enum p9_req_status_t {
	REQ_STATUS_ALLOC = 0,
	REQ_STATUS_UNSENT = 1,
	REQ_STATUS_SENT = 2,
	REQ_STATUS_RCVD = 3,
	REQ_STATUS_FLSHD = 4,
	REQ_STATUS_ERROR = 5,
};

struct trace_event_raw_9p_client_req {
	struct trace_entry ent;
	void *clnt;
	__u8 type;
	__u32 tag;
	char __data[0];
};

struct trace_event_raw_9p_client_res {
	struct trace_entry ent;
	void *clnt;
	__u8 type;
	__u32 tag;
	__u32 err;
	char __data[0];
};

struct trace_event_raw_9p_protocol_dump {
	struct trace_entry ent;
	void *clnt;
	__u8 type;
	__u16 tag;
	unsigned char line[32];
	char __data[0];
};

struct trace_event_data_offsets_9p_client_req {};

struct trace_event_data_offsets_9p_client_res {};

struct trace_event_data_offsets_9p_protocol_dump {};

typedef void (*btf_trace_9p_client_req)(void *, struct p9_client *, int8_t, int);

typedef void (*btf_trace_9p_client_res)(void *, struct p9_client *, int8_t, int, int);

typedef void (*btf_trace_9p_protocol_dump)(void *, struct p9_client *, struct p9_fcall *);

enum {
	Opt_msize = 0,
	Opt_trans = 1,
	Opt_legacy = 2,
	Opt_version = 3,
	Opt_err___9 = 4,
};

struct errormap {
	char *name;
	int val;
	int namelen;
	struct hlist_node list;
};

struct p9_fd_opts {
	int rfd;
	int wfd;
	u16 port;
	bool privport;
};

enum {
	Opt_port___2 = 0,
	Opt_rfdno = 1,
	Opt_wfdno = 2,
	Opt_err___10 = 3,
	Opt_privport = 4,
};

enum {
	Rworksched = 1,
	Rpending = 2,
	Wworksched = 4,
	Wpending = 8,
};

struct p9_conn;

struct p9_poll_wait {
	struct p9_conn *conn;
	wait_queue_entry_t wait;
	wait_queue_head_t *wait_addr;
};

struct p9_conn {
	struct list_head mux_list;
	struct p9_client *client;
	int err;
	struct list_head req_list;
	struct list_head unsent_req_list;
	struct p9_req_t *rreq;
	struct p9_req_t *wreq;
	char tmp_buf[7];
	struct p9_fcall rc;
	int wpos;
	int wsize;
	char *wbuf;
	struct list_head poll_pending_link;
	struct p9_poll_wait poll_wait[2];
	poll_table pt;
	struct work_struct rq;
	struct work_struct wq;
	long unsigned int wsched;
};

struct p9_trans_fd {
	struct file *rd;
	struct file *wr;
	struct p9_conn conn;
};

struct virtio_9p_config {
	__virtio16 tag_len;
	__u8 tag[0];
};

struct virtio_chan___3 {
	bool inuse;
	spinlock_t lock;
	struct p9_client *client;
	struct virtio_device *vdev;
	struct virtqueue *vq;
	int ring_bufs_avail;
	wait_queue_head_t *vc_wq;
	long unsigned int p9_max_pages;
	struct scatterlist sg[128];
	char *tag;
	struct list_head chan_list;
};

enum dns_payload_content_type {
	DNS_PAYLOAD_IS_SERVER_LIST = 0,
};

struct dns_payload_header {
	__u8 zero;
	__u8 content;
	__u8 version;
};

enum {
	dns_key_data = 0,
	dns_key_error = 1,
};

struct vsock_tap {
	struct net_device *dev;
	struct module *module;
	struct list_head list;
};

struct vsock_diag_req {
	__u8 sdiag_family;
	__u8 sdiag_protocol;
	__u16 pad;
	__u32 vdiag_states;
	__u32 vdiag_ino;
	__u32 vdiag_show;
	__u32 vdiag_cookie[2];
};

struct vsock_diag_msg {
	__u8 vdiag_family;
	__u8 vdiag_type;
	__u8 vdiag_state;
	__u8 vdiag_shutdown;
	__u32 vdiag_src_cid;
	__u32 vdiag_src_port;
	__u32 vdiag_dst_cid;
	__u32 vdiag_dst_port;
	__u32 vdiag_ino;
	__u32 vdiag_cookie[2];
};

enum virtio_vsock_event_id {
	VIRTIO_VSOCK_EVENT_TRANSPORT_RESET = 0,
};

struct virtio_vsock_event {
	__le32 id;
};

struct virtio_vsock {
	struct virtio_device *vdev;
	struct virtqueue *vqs[3];
	struct work_struct tx_work;
	struct work_struct rx_work;
	struct work_struct event_work;
	struct mutex tx_lock;
	bool tx_run;
	long: 56;
	struct work_struct send_pkt_work;
	spinlock_t send_pkt_list_lock;
	int: 32;
	struct list_head send_pkt_list;
	atomic_t queued_replies;
	int: 32;
	struct mutex rx_lock;
	bool rx_run;
	int: 24;
	int rx_buf_nr;
	int rx_buf_max_nr;
	int: 32;
	struct mutex event_lock;
	bool event_run;
	struct virtio_vsock_event event_list[8];
	int: 24;
	u32 guest_cid;
} __attribute__((packed));

enum virtio_vsock_op {
	VIRTIO_VSOCK_OP_INVALID = 0,
	VIRTIO_VSOCK_OP_REQUEST = 1,
	VIRTIO_VSOCK_OP_RESPONSE = 2,
	VIRTIO_VSOCK_OP_RST = 3,
	VIRTIO_VSOCK_OP_SHUTDOWN = 4,
	VIRTIO_VSOCK_OP_RW = 5,
	VIRTIO_VSOCK_OP_CREDIT_UPDATE = 6,
	VIRTIO_VSOCK_OP_CREDIT_REQUEST = 7,
};

enum virtio_vsock_shutdown {
	VIRTIO_VSOCK_SHUTDOWN_RCV = 1,
	VIRTIO_VSOCK_SHUTDOWN_SEND = 2,
};

struct virtio_vsock_sock {
	struct vsock_sock *vsk;
	spinlock_t tx_lock;
	spinlock_t rx_lock;
	u32 tx_cnt;
	u32 peer_fwd_cnt;
	u32 peer_buf_alloc;
	u32 fwd_cnt;
	u32 last_fwd_cnt;
	u32 rx_bytes;
	u32 buf_alloc;
	struct list_head rx_queue;
};

struct virtio_vsock_pkt_info {
	u32 remote_cid;
	u32 remote_port;
	struct vsock_sock *vsk;
	struct msghdr *msg;
	u32 pkt_len;
	u16 type;
	u16 op;
	u32 flags;
	bool reply;
};

struct af_vsockmon_hdr {
	__le64 src_cid;
	__le64 dst_cid;
	__le32 src_port;
	__le32 dst_port;
	__le16 op;
	__le16 transport;
	__le16 len;
	__u8 reserved[2];
};

enum af_vsockmon_op {
	AF_VSOCK_OP_UNKNOWN = 0,
	AF_VSOCK_OP_CONNECT = 1,
	AF_VSOCK_OP_DISCONNECT = 2,
	AF_VSOCK_OP_CONTROL = 3,
	AF_VSOCK_OP_PAYLOAD = 4,
};

enum af_vsockmon_transport {
	AF_VSOCK_TRANSPORT_UNKNOWN = 0,
	AF_VSOCK_TRANSPORT_NO_INFO = 1,
	AF_VSOCK_TRANSPORT_VIRTIO = 2,
};

struct trace_event_raw_virtio_transport_alloc_pkt {
	struct trace_entry ent;
	__u32 src_cid;
	__u32 src_port;
	__u32 dst_cid;
	__u32 dst_port;
	__u32 len;
	__u16 type;
	__u16 op;
	__u32 flags;
	char __data[0];
};

struct trace_event_raw_virtio_transport_recv_pkt {
	struct trace_entry ent;
	__u32 src_cid;
	__u32 src_port;
	__u32 dst_cid;
	__u32 dst_port;
	__u32 len;
	__u16 type;
	__u16 op;
	__u32 flags;
	__u32 buf_alloc;
	__u32 fwd_cnt;
	char __data[0];
};

struct trace_event_data_offsets_virtio_transport_alloc_pkt {};

struct trace_event_data_offsets_virtio_transport_recv_pkt {};

typedef void (*btf_trace_virtio_transport_alloc_pkt)(void *, __u32, __u32, __u32, __u32, __u32, __u16, __u16, __u32);

typedef void (*btf_trace_virtio_transport_recv_pkt)(void *, __u32, __u32, __u32, __u32, __u32, __u16, __u16, __u32, __u32, __u32);

typedef struct {
	u32 version;
	u32 length;
	u64 memory_protection_attribute;
} efi_properties_table_t;

enum efi_secureboot_mode {
	efi_secureboot_mode_unset = 0,
	efi_secureboot_mode_unknown = 1,
	efi_secureboot_mode_disabled = 2,
	efi_secureboot_mode_enabled = 3,
};

typedef union {
	struct {
		u32 revision;
		efi_handle_t parent_handle;
		efi_system_table_t *system_table;
		efi_handle_t device_handle;
		void *file_path;
		void *reserved;
		u32 load_options_size;
		void *load_options;
		void *image_base;
		__u64 image_size;
		unsigned int image_code_type;
		unsigned int image_data_type;
		efi_status_t (*unload)(efi_handle_t);
	};
	struct {
		u32 revision;
		u32 parent_handle;
		u32 system_table;
		u32 device_handle;
		u32 file_path;
		u32 reserved;
		u32 load_options_size;
		u32 load_options;
		u32 image_base;
		__u64 image_size;
		u32 image_code_type;
		u32 image_data_type;
		u32 unload;
	} mixed_mode;
} efi_loaded_image_t;

struct efi_boot_memmap {
	efi_memory_desc_t **map;
	long unsigned int *map_size;
	long unsigned int *desc_size;
	u32 *desc_ver;
	long unsigned int *key_ptr;
	long unsigned int *buff_size;
};

struct exit_boot_struct {
	efi_memory_desc_t *runtime_map;
	int *runtime_entry_count;
	void *new_fdt_addr;
};

typedef struct {
	u32 red_mask;
	u32 green_mask;
	u32 blue_mask;
	u32 reserved_mask;
} efi_pixel_bitmask_t;

typedef struct {
	u32 version;
	u32 horizontal_resolution;
	u32 vertical_resolution;
	int pixel_format;
	efi_pixel_bitmask_t pixel_information;
	u32 pixels_per_scan_line;
} efi_graphics_output_mode_info_t;

union efi_graphics_output_protocol_mode {
	struct {
		u32 max_mode;
		u32 mode;
		efi_graphics_output_mode_info_t *info;
		long unsigned int size_of_info;
		efi_physical_addr_t frame_buffer_base;
		long unsigned int frame_buffer_size;
	};
	struct {
		u32 max_mode;
		u32 mode;
		u32 info;
		u32 size_of_info;
		u64 frame_buffer_base;
		u32 frame_buffer_size;
	} mixed_mode;
};

typedef union efi_graphics_output_protocol_mode efi_graphics_output_protocol_mode_t;

union efi_graphics_output_protocol;

typedef union efi_graphics_output_protocol efi_graphics_output_protocol_t;

union efi_graphics_output_protocol {
	struct {
		efi_status_t (*query_mode)(efi_graphics_output_protocol_t *, u32, long unsigned int *, efi_graphics_output_mode_info_t **);
		efi_status_t (*set_mode)(efi_graphics_output_protocol_t *, u32);
		void *blt;
		efi_graphics_output_protocol_mode_t *mode;
	};
	struct {
		u32 query_mode;
		u32 set_mode;
		u32 blt;
		u32 mode;
	} mixed_mode;
};

enum efi_cmdline_option {
	EFI_CMDLINE_NONE = 0,
	EFI_CMDLINE_MODE_NUM = 1,
	EFI_CMDLINE_RES = 2,
	EFI_CMDLINE_AUTO = 3,
	EFI_CMDLINE_LIST = 4,
};

union efi_rng_protocol;

typedef union efi_rng_protocol efi_rng_protocol_t;

union efi_rng_protocol {
	struct {
		efi_status_t (*get_info)(efi_rng_protocol_t *, long unsigned int *, efi_guid_t *);
		efi_status_t (*get_rng)(efi_rng_protocol_t *, efi_guid_t *, long unsigned int, u8 *);
	};
	struct {
		u32 get_info;
		u32 get_rng;
	} mixed_mode;
};

typedef void (*jump_kernel_func)(unsigned int, long unsigned int);

struct tcpa_event {
	u32 pcr_index;
	u32 event_type;
	u8 pcr_value[20];
	u32 event_size;
	u8 event_data[0];
};

typedef u32 efi_tcg2_event_log_format;

union efi_tcg2_protocol {
	struct {
		void *get_capability;
		efi_status_t (*get_event_log)(efi_handle_t, efi_tcg2_event_log_format, efi_physical_addr_t *, efi_physical_addr_t *, efi_bool_t *);
		void *hash_log_extend_event;
		void *submit_command;
		void *get_active_pcr_banks;
		void *set_active_pcr_banks;
		void *get_result_of_set_active_pcr_banks;
	};
	struct {
		u32 get_capability;
		u32 get_event_log;
		u32 hash_log_extend_event;
		u32 submit_command;
		u32 get_active_pcr_banks;
		u32 set_active_pcr_banks;
		u32 get_result_of_set_active_pcr_banks;
	} mixed_mode;
};

typedef union efi_tcg2_protocol efi_tcg2_protocol_t;

struct efi_vendor_dev_path {
	struct efi_generic_dev_path header;
	efi_guid_t vendorguid;
	u8 vendordata[0];
};

union efi_load_file_protocol;

typedef union efi_load_file_protocol efi_load_file_protocol_t;

union efi_load_file_protocol {
	struct {
		efi_status_t (*load_file)(efi_load_file_protocol_t *, efi_device_path_protocol_t *, bool, long unsigned int *, void *);
	};
	struct {
		u32 load_file;
	} mixed_mode;
};

typedef union efi_load_file_protocol efi_load_file2_protocol_t;

typedef struct {
	u32 attributes;
	u16 file_path_list_length;
	u8 variable_data[0];
} __attribute__((packed)) efi_load_option_t;

typedef struct {
	u32 attributes;
	u16 file_path_list_length;
	const efi_char16_t *description;
	const efi_device_path_protocol_t *file_path_list;
	size_t optional_data_size;
	const void *optional_data;
} efi_load_option_unpacked_t;

typedef efi_status_t (*efi_exit_boot_map_processing)(struct efi_boot_memmap *, void *);

typedef enum {
	EfiPciIoWidthUint8 = 0,
	EfiPciIoWidthUint16 = 1,
	EfiPciIoWidthUint32 = 2,
	EfiPciIoWidthUint64 = 3,
	EfiPciIoWidthFifoUint8 = 4,
	EfiPciIoWidthFifoUint16 = 5,
	EfiPciIoWidthFifoUint32 = 6,
	EfiPciIoWidthFifoUint64 = 7,
	EfiPciIoWidthFillUint8 = 8,
	EfiPciIoWidthFillUint16 = 9,
	EfiPciIoWidthFillUint32 = 10,
	EfiPciIoWidthFillUint64 = 11,
	EfiPciIoWidthMaximum = 12,
} EFI_PCI_IO_PROTOCOL_WIDTH;

typedef struct {
	u32 read;
	u32 write;
} efi_pci_io_protocol_access_32_t;

typedef struct {
	void *read;
	void *write;
} efi_pci_io_protocol_access_t;

union efi_pci_io_protocol;

typedef union efi_pci_io_protocol efi_pci_io_protocol_t;

typedef efi_status_t (*efi_pci_io_protocol_cfg_t)(efi_pci_io_protocol_t *, EFI_PCI_IO_PROTOCOL_WIDTH, u32, long unsigned int, void *);

typedef struct {
	efi_pci_io_protocol_cfg_t read;
	efi_pci_io_protocol_cfg_t write;
} efi_pci_io_protocol_config_access_t;

union efi_pci_io_protocol {
	struct {
		void *poll_mem;
		void *poll_io;
		efi_pci_io_protocol_access_t mem;
		efi_pci_io_protocol_access_t io;
		efi_pci_io_protocol_config_access_t pci;
		void *copy_mem;
		void *map;
		void *unmap;
		void *allocate_buffer;
		void *free_buffer;
		void *flush;
		efi_status_t (*get_location)(efi_pci_io_protocol_t *, long unsigned int *, long unsigned int *, long unsigned int *, long unsigned int *);
		void *attributes;
		void *get_bar_attributes;
		void *set_bar_attributes;
		uint64_t romsize;
		void *romimage;
	};
	struct {
		u32 poll_mem;
		u32 poll_io;
		efi_pci_io_protocol_access_32_t mem;
		efi_pci_io_protocol_access_32_t io;
		efi_pci_io_protocol_access_32_t pci;
		u32 copy_mem;
		u32 map;
		u32 unmap;
		u32 allocate_buffer;
		u32 free_buffer;
		u32 flush;
		u32 get_location;
		u32 attributes;
		u32 get_bar_attributes;
		u32 set_bar_attributes;
		u64 romsize;
		u32 romimage;
	} mixed_mode;
};

#ifndef BPF_NO_PRESERVE_ACCESS_INDEX
#pragma clang attribute pop
#endif

#endif /* __VMLINUX_H__ */
